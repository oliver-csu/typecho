-- phpMyAdmin SQL Dump
-- version phpStudy 2014
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2020 年 04 月 12 日 19:28
-- 服务器版本: 5.5.53
-- PHP 版本: 5.4.45

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `typecho`
--

-- --------------------------------------------------------

--
-- 表的结构 `typecho_baidusubmit`
--

CREATE TABLE IF NOT EXISTS `typecho_baidusubmit` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `subject` varchar(255) DEFAULT NULL COMMENT '主体',
  `action` varchar(255) DEFAULT NULL COMMENT '动作',
  `object` varchar(255) DEFAULT NULL COMMENT '对象',
  `result` varchar(255) DEFAULT NULL COMMENT '结果',
  `more` text COMMENT '更多信息',
  `time` bigint(20) DEFAULT NULL COMMENT '时间',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=369 ;

--
-- 转存表中的数据 `typecho_baidusubmit`
--

INSERT INTO `typecho_baidusubmit` (`id`, `subject`, `action`, `object`, `result`, `more`, `time`) VALUES
(1, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1708.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1558767454),
(2, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1704.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1558767474),
(3, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1708.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1558767484),
(4, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1708.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1558767621),
(5, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1708.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1558768017),
(6, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1708.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1558768181),
(7, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1708.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1558778187),
(8, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1708.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999992,\n    ''success'' => 1,\n  ),\n)', 1558778232),
(9, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1558830278),
(10, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1558830406),
(11, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1558830865),
(12, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1558831268),
(13, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1558831542),
(14, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1558832069),
(15, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1716.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1558832090),
(16, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1716.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999992,\n    ''success'' => 1,\n  ),\n)', 1558832125),
(17, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1716.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999991,\n    ''success'' => 1,\n  ),\n)', 1558832186),
(18, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999990,\n    ''success'' => 1,\n  ),\n)', 1558874599),
(19, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999989,\n    ''success'' => 1,\n  ),\n)', 1558882975),
(20, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999988,\n    ''success'' => 1,\n  ),\n)', 1558883987),
(21, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1719.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999987,\n    ''success'' => 1,\n  ),\n)', 1558884330),
(22, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1719.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999986,\n    ''success'' => 1,\n  ),\n)', 1558884342),
(23, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1719.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999985,\n    ''success'' => 1,\n  ),\n)', 1558885794),
(24, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1558918041),
(25, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1558919727),
(26, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1558919902),
(27, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1559443085),
(28, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1559444687),
(29, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1728.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1559458622),
(30, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1728.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1559458864),
(31, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1728.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1559464212),
(32, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1559468160),
(33, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1729.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1559468187),
(34, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1729.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999992,\n    ''success'' => 1,\n  ),\n)', 1559469508),
(35, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1729.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999991,\n    ''success'' => 1,\n  ),\n)', 1559471153),
(36, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999990,\n    ''success'' => 1,\n  ),\n)', 1559472284),
(37, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1730.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999989,\n    ''success'' => 1,\n  ),\n)', 1559472507),
(38, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999988,\n    ''success'' => 1,\n  ),\n)', 1559476117),
(39, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999987,\n    ''success'' => 1,\n  ),\n)', 1559478394),
(40, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1561344938),
(41, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1561349125),
(42, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1561360361),
(43, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1561371213),
(44, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1561381696),
(45, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1749.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1561381715),
(46, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1749.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1561381754),
(47, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999992,\n    ''success'' => 1,\n  ),\n)', 1561382339),
(48, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1561418765),
(49, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1756.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1561418788),
(50, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1561419533),
(51, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1561422311),
(52, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/it/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1561436578),
(53, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1561457465),
(54, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1561465740),
(55, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1771.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999992,\n    ''success'' => 1,\n  ),\n)', 1561465759),
(56, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999991,\n    ''success'' => 1,\n  ),\n)', 1561466467),
(57, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999990,\n    ''success'' => 1,\n  ),\n)', 1561467372),
(58, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999989,\n    ''success'' => 1,\n  ),\n)', 1561467878),
(59, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999988,\n    ''success'' => 1,\n  ),\n)', 1561469000),
(60, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1403.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1561532663),
(61, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1403.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1561532732),
(62, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1561533575),
(63, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1561533860),
(64, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1781.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1561533874),
(65, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1561534563),
(66, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1783.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1561534576),
(67, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1562230662),
(68, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1562231112),
(69, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1562321945),
(70, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1562325241),
(71, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1562547273),
(72, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1562900793),
(73, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1789.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1562900811),
(74, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1562903449),
(75, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1563180672),
(76, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1563716507),
(77, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1563755738),
(78, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1563757128),
(79, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1794.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1563757160),
(80, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1793.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1563844648),
(81, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1563845027),
(82, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1563845456),
(83, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1563928828),
(84, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1563929248),
(85, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1564013961),
(86, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1564014465),
(87, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1565514537),
(88, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1801.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1565745860),
(89, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1565747144),
(90, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1565829780),
(91, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1566111636),
(92, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1566139488),
(93, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1566195475),
(94, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1566918104),
(95, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1808.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1566918733),
(96, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1808.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1566918865),
(97, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1808.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1566918914),
(98, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1808.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1566919713),
(99, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1808.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1566919995),
(100, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1566920965),
(101, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1566921817),
(102, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1811.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1566922371),
(103, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1566923470),
(104, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1567066758),
(105, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1567067906),
(106, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1814.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1567068466),
(107, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1567068737),
(108, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1567069172),
(109, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1567070548),
(110, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1567070957),
(111, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999992,\n    ''success'' => 1,\n  ),\n)', 1567071995),
(112, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999991,\n    ''success'' => 1,\n  ),\n)', 1567083961),
(113, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999990,\n    ''success'' => 1,\n  ),\n)', 1567084202),
(114, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999989,\n    ''success'' => 1,\n  ),\n)', 1567084454),
(115, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999988,\n    ''success'' => 1,\n  ),\n)', 1567084570),
(116, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1823.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999987,\n    ''success'' => 1,\n  ),\n)', 1567084817),
(117, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1568556226),
(118, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1568556558),
(119, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1826.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1568557017),
(120, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1568594688),
(121, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1827.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1568615690),
(122, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1569079676),
(123, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1569079986),
(124, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1830.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1569080013),
(125, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999999,\n    ''success'' => 1,\n  ),\n)', 1569085725),
(126, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1831.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999998,\n    ''success'' => 1,\n  ),\n)', 1569085759),
(127, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1831.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999997,\n    ''success'' => 1,\n  ),\n)', 1569085854),
(128, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999996,\n    ''success'' => 1,\n  ),\n)', 1569120883),
(129, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1836.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999995,\n    ''success'' => 1,\n  ),\n)', 1569120910),
(130, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999994,\n    ''success'' => 1,\n  ),\n)', 1569122905),
(131, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999993,\n    ''success'' => 1,\n  ),\n)', 1569163708),
(132, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/it/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999992,\n    ''success'' => 1,\n  ),\n)', 1569166146),
(133, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1842.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 4999991,\n    ''success'' => 1,\n  ),\n)', 1569166165),
(134, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1842.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499999,\n    ''success'' => 1,\n  ),\n)', 1570183862),
(135, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1842.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499998,\n    ''success'' => 1,\n  ),\n)', 1570183893),
(136, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1840.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499997,\n    ''success'' => 1,\n  ),\n)', 1570183924),
(137, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1839.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499996,\n    ''success'' => 1,\n  ),\n)', 1570183936),
(138, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1836.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499995,\n    ''success'' => 1,\n  ),\n)', 1570183948),
(139, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1831.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499994,\n    ''success'' => 1,\n  ),\n)', 1570183977),
(140, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1830.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499993,\n    ''success'' => 1,\n  ),\n)', 1570183988),
(141, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1828.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499992,\n    ''success'' => 1,\n  ),\n)', 1570184015),
(142, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1814.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499991,\n    ''success'' => 1,\n  ),\n)', 1570184042),
(143, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1801.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499990,\n    ''success'' => 1,\n  ),\n)', 1570184065),
(144, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1792.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499989,\n    ''success'' => 1,\n  ),\n)', 1570184101),
(145, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/linux/28.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499988,\n    ''success'' => 1,\n  ),\n)', 1570184428),
(146, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499987,\n    ''success'' => 1,\n  ),\n)', 1570191951),
(147, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1850.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499986,\n    ''success'' => 1,\n  ),\n)', 1570191967),
(148, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499985,\n    ''success'' => 1,\n  ),\n)', 1570194904),
(149, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499984,\n    ''success'' => 1,\n  ),\n)', 1570199891),
(150, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/it/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499983,\n    ''success'' => 1,\n  ),\n)', 1570200070),
(151, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1853.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499982,\n    ''success'' => 1,\n  ),\n)', 1570200092),
(152, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1855.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499981,\n    ''success'' => 1,\n  ),\n)', 1570200107),
(153, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1855.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499980,\n    ''success'' => 1,\n  ),\n)', 1570200119),
(154, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1857.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499979,\n    ''success'' => 1,\n  ),\n)', 1570200135),
(155, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570203978),
(156, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1862.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499977,\n    ''success'' => 1,\n  ),\n)', 1570203990),
(157, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499999,\n    ''success'' => 1,\n  ),\n)', 1570241949),
(158, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1863.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499998,\n    ''success'' => 1,\n  ),\n)', 1570241975),
(159, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1863.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499997,\n    ''success'' => 1,\n  ),\n)', 1570259392),
(160, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499996,\n    ''success'' => 1,\n  ),\n)', 1570261210),
(161, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499995,\n    ''success'' => 1,\n  ),\n)', 1570261687),
(162, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499994,\n    ''success'' => 1,\n  ),\n)', 1570262183),
(163, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1866.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499993,\n    ''success'' => 1,\n  ),\n)', 1570262334),
(164, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1866.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499992,\n    ''success'' => 1,\n  ),\n)', 1570266077),
(165, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1866.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 499991,\n    ''success'' => 1,\n  ),\n)', 1570266102),
(166, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1570538224),
(167, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570540811),
(168, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1869.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1570540836),
(169, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1570540978),
(170, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1870.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570541120),
(171, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570541534),
(172, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1570541710),
(173, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1872.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99992,\n    ''success'' => 1,\n  ),\n)', 1570541728),
(174, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99991,\n    ''success'' => 1,\n  ),\n)', 1570541897),
(175, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570542223),
(176, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1874.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99989,\n    ''success'' => 1,\n  ),\n)', 1570542271),
(177, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1874.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99988,\n    ''success'' => 1,\n  ),\n)', 1570542298),
(178, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99987,\n    ''success'' => 1,\n  ),\n)', 1570542562),
(179, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99986,\n    ''success'' => 1,\n  ),\n)', 1570542808),
(180, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1570630849),
(181, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1877.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1570630902),
(182, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1570631091),
(183, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1878.html'',\n  ),\n  ''info'' => ''Operation timed out after 3031 milliseconds with 0 bytes received'',\n)', 1570631228),
(184, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1877.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1570631401),
(185, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1878.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1570631428),
(186, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1570631663),
(187, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1879.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99992,\n    ''success'' => 1,\n  ),\n)', 1570632261),
(188, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/it/.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570634039),
(189, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1880.html'',\n  ),\n  ''info'' => ''Operation timed out after 3016 milliseconds with 0 bytes received'',\n)', 1570637170),
(190, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1880.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1570637263),
(191, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9997,\n    ''success'' => 1,\n  ),\n)', 1570688043),
(192, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570781537),
(193, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570782023),
(194, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1884.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1570782052),
(195, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1570950638),
(196, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1886.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1570950660),
(197, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1886.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9997,\n    ''success'' => 1,\n  ),\n)', 1570950855),
(198, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1886.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9996,\n    ''success'' => 1,\n  ),\n)', 1570952269),
(199, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1882.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1571465160),
(200, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1571709697),
(201, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1571713051),
(202, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => ''Operation timed out after 3000 milliseconds with 0 bytes received'',\n)', 1571729506),
(203, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1890.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9996,\n    ''success'' => 1,\n  ),\n)', 1571729564),
(204, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1889.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1572631202),
(205, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1572632372),
(206, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9997,\n    ''success'' => 1,\n  ),\n)', 1572634126),
(207, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9996,\n    ''success'' => 1,\n  ),\n)', 1572637349),
(208, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9995,\n    ''success'' => 1,\n  ),\n)', 1572651475),
(209, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1572712556),
(210, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1572713164),
(211, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9997,\n    ''success'' => 1,\n  ),\n)', 1572719271),
(212, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9996,\n    ''success'' => 1,\n  ),\n)', 1572752608),
(213, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9995,\n    ''success'' => 1,\n  ),\n)', 1572753267),
(214, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9994,\n    ''success'' => 1,\n  ),\n)', 1572764357),
(215, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1572851769),
(216, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1572852179),
(217, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1907.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9997,\n    ''success'' => 1,\n  ),\n)', 1572852417);
INSERT INTO `typecho_baidusubmit` (`id`, `subject`, `action`, `object`, `result`, `more`, `time`) VALUES
(218, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1573480999),
(219, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1908.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1573481086),
(220, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1908.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9997,\n    ''success'' => 1,\n  ),\n)', 1573481169),
(221, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1907.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9996,\n    ''success'' => 1,\n  ),\n)', 1573486319),
(222, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9995,\n    ''success'' => 1,\n  ),\n)', 1573486452),
(223, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1913.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9994,\n    ''success'' => 1,\n  ),\n)', 1573486476),
(224, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1573561492),
(225, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1915.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1573561511),
(226, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1573958792),
(227, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1573988603),
(228, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1574176886),
(229, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1574177288),
(230, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9997,\n    ''success'' => 1,\n  ),\n)', 1574177510),
(231, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9996,\n    ''success'' => 1,\n  ),\n)', 1574177614),
(232, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1575819276),
(233, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1575992401),
(234, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1576032614),
(235, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1938.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1576032832),
(236, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1576982629),
(237, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1577114303),
(238, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9999,\n    ''success'' => 1,\n  ),\n)', 1577848859),
(239, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9998,\n    ''success'' => 1,\n  ),\n)', 1577849117),
(240, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9997,\n    ''success'' => 1,\n  ),\n)', 1577849826),
(241, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9996,\n    ''success'' => 1,\n  ),\n)', 1577889822),
(242, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 9995,\n    ''success'' => 1,\n  ),\n)', 1577894404),
(243, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1579586566),
(244, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1579586918),
(245, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/it/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1579589275),
(246, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1956.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1579589296),
(247, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1579590144),
(248, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1579593766),
(249, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1579598997),
(250, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99992,\n    ''success'' => 1,\n  ),\n)', 1579604936),
(251, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99991,\n    ''success'' => 1,\n  ),\n)', 1579607454),
(252, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99990,\n    ''success'' => 1,\n  ),\n)', 1579608352),
(253, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1580047463),
(254, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1580047778),
(255, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1580047915),
(256, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1580048554),
(257, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1966.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1580048619),
(258, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1580048997),
(259, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1580050324),
(260, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1580188285),
(261, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1580189400),
(262, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1580210123),
(263, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1580221106),
(264, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/links.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1580967612),
(265, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1580968134),
(266, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1580968948),
(267, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1580969660),
(268, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1581083704),
(269, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1582369768),
(270, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1582371847),
(271, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1980.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1582371868),
(272, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/it/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1582373907),
(273, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1582374486),
(274, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1582382239),
(275, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1582429610),
(276, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1582430873),
(277, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1582431391),
(278, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1582432382),
(279, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1582462485),
(280, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1582463741),
(281, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1992.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1582463771),
(282, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1582986690),
(283, '我', '发送', 'URL', '失败', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => ''Resolving timed out after 3001 milliseconds'',\n)', 1582986699),
(284, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1995.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1583055311),
(285, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1583055338),
(286, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1999.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1583055398),
(287, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1583055651),
(288, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1999.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1583055689),
(289, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1583666070),
(290, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/1981.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1583666080),
(291, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1583670735),
(292, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1584372700),
(293, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1584374351),
(294, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1584375103),
(295, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1584629366),
(296, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2012.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1584629742),
(297, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2012.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1584629894),
(298, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2012.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1584629928),
(299, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1584630771),
(300, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2019.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1584630886),
(301, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2019.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1584630966),
(302, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2019.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99992,\n    ''success'' => 1,\n  ),\n)', 1584631096),
(303, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2012.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99991,\n    ''success'' => 1,\n  ),\n)', 1584631274),
(304, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1584633935),
(305, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1584634714),
(306, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2026.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1584634797),
(307, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2026.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1584635196),
(308, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1584843106),
(309, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2030.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1584843280),
(310, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2030.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1584844110),
(311, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2030.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1584844539),
(312, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1584846582),
(313, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2032.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1584846957),
(314, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1584847459),
(315, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2033.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99992,\n    ''success'' => 1,\n  ),\n)', 1584847546),
(316, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99991,\n    ''success'' => 1,\n  ),\n)', 1584847981),
(317, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99990,\n    ''success'' => 1,\n  ),\n)', 1584862693),
(318, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2038.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99989,\n    ''success'' => 1,\n  ),\n)', 1584862713),
(319, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2038.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99988,\n    ''success'' => 1,\n  ),\n)', 1584863252),
(320, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2038.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99987,\n    ''success'' => 1,\n  ),\n)', 1584863293),
(321, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2038.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99986,\n    ''success'' => 1,\n  ),\n)', 1584863913),
(322, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2038.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99985,\n    ''success'' => 1,\n  ),\n)', 1584883750),
(323, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2038.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99984,\n    ''success'' => 1,\n  ),\n)', 1584890103),
(324, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1585146561),
(325, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1585146977),
(326, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2041.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1585146997),
(327, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1585148987),
(328, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2042.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1585149191),
(329, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2042.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1585149207),
(330, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2042.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1585149246),
(331, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2042.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99992,\n    ''success'' => 1,\n  ),\n)', 1585149258),
(332, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2042.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99991,\n    ''success'' => 1,\n  ),\n)', 1585149789),
(333, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1585222138),
(334, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1585225376),
(335, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2045.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1585225527),
(336, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1585225714),
(337, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1585227553),
(338, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1585493096),
(339, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/it/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1585493406),
(340, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2055.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1585493418),
(341, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1585493565),
(342, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1585534887),
(343, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1585729548),
(344, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2060.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1585729578),
(345, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2060.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1585730092),
(346, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2060.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1585731560),
(347, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2060.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1585731928),
(348, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1585755580),
(349, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1585817423),
(350, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2066.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1586158008),
(351, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2066.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1586158645),
(352, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2066.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1586158774),
(353, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2066.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1586159926),
(354, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1586163108),
(355, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1586164429),
(356, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1586167363),
(357, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2073.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99992,\n    ''success'' => 1,\n  ),\n)', 1586167384),
(358, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99991,\n    ''success'' => 1,\n  ),\n)', 1586185545),
(359, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2074.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99990,\n    ''success'' => 1,\n  ),\n)', 1586185814),
(360, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99989,\n    ''success'' => 1,\n  ),\n)', 1586187083),
(361, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99988,\n    ''success'' => 1,\n  ),\n)', 1586187618),
(362, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99999,\n    ''success'' => 1,\n  ),\n)', 1586229693),
(363, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99998,\n    ''success'' => 1,\n  ),\n)', 1586230038),
(364, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/it/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99997,\n    ''success'' => 1,\n  ),\n)', 1586233571),
(365, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2079.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99996,\n    ''success'' => 1,\n  ),\n)', 1586233578),
(366, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99995,\n    ''success'' => 1,\n  ),\n)', 1586233908),
(367, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/2080.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99994,\n    ''success'' => 1,\n  ),\n)', 1586233944),
(368, '我', '发送', 'URL', '成功', 'array (\n  ''url'' => \n  array (\n    0 => ''http://www.oliver.ren/java/.html'',\n  ),\n  ''info'' => \n  array (\n    ''remain'' => 99993,\n    ''success'' => 1,\n  ),\n)', 1586234060);

-- --------------------------------------------------------

--
-- 表的结构 `typecho_comments`
--

CREATE TABLE IF NOT EXISTS `typecho_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `authorId` int(10) unsigned DEFAULT '0',
  `ownerId` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(255) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(511) DEFAULT NULL,
  `text` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;

-- --------------------------------------------------------

--
-- 表的结构 `typecho_contents`
--

CREATE TABLE IF NOT EXISTS `typecho_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `text` text,
  `order` int(10) unsigned DEFAULT '0',
  `authorId` int(10) unsigned DEFAULT '0',
  `template` varchar(32) DEFAULT NULL,
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `password` varchar(32) DEFAULT NULL,
  `commentsNum` int(10) unsigned DEFAULT '0',
  `allowComment` char(1) DEFAULT '0',
  `allowPing` char(1) DEFAULT '0',
  `allowFeed` char(1) DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  `views` int(10) NOT NULL DEFAULT '0' COMMENT '页面浏览次数',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=2083 ;

--
-- 转存表中的数据 `typecho_contents`
--

INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(4, 'Linux服务器修改为SSH密钥登录', '4', 1484546640, 1490855522, '<p>本文使用Putty作为SSH客户端，服务器采用的Cloud At Cost的机器，系统为Debian 8。</p>\r\r<!--more-->\r\r<p>1.使用Putty Gen生成秘钥对。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/01/2061684491.png" style="width: 493px; height: 477px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/01/988597851.png" style="width: 493px; height: 477px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/01/4022052090.png" style="width: 493px; height: 477px;" /></p>\r\r<p>2.将公钥上传到服务器上。</p>\r\r<pre class="brush:bash;">\r#建立秘钥的存放目录\rmkdir -p ~/.ssh\r#编辑公钥\rvi ~/.ssh/authorized_keys</pre>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/01/2442897126.png" style="width: 675px; height: 424px;" /></p>\r\r<p>3.修改公钥的权限。</p>\r\r<pre class="brush:bash;">\r#普通权限修改\rchmod -R 400 ~/.ssh/\r#SELinux权限修改，非必须\rrestorecon -Rv ~/.ssh/\r#修改sshd的配置文件\rvi /etc/ssh/sshd_config\r#修改为PasswordAuthentication no\r#重启sshd服务\rservice sshd restart</pre>\r\r<p>4.使用秘钥进行登录。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/01/3006889863.png" style="width: 466px; height: 448px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '1', '1', '1', 0, 128),
(2, '关于', 'about', 1484443920, 1554563507, '<p>经过一年的折腾，终于有了自己的博客。</p>\r\r<p>不得不说，写博客真的是一种很好的提高自己能力的方式，因为有些东西好像看上去懂了，但实际上并没有懂，只有用自己的语言写下来才知道自己并没有懂，或者懂的只是皮毛而已。</p>\r\r<p>如果对我写的文章感兴趣的话，欢迎与我交流。</p>\r\r<p><span style="line-height: 20.8px;">QQ：1184451075</span></p>\r\r<p>微信：1184451075</p>\r\r<p>CSDN：<a href="https://me.csdn.net/oliver_csu" target="_blank">oliver_csu</a></p>\r\r<p>Github：<a href="https://github.com/oliver-csu" target="_blank">oliver-csu</a></p>\r\r<p>简书：<a href="https://www.jianshu.com/u/40424eca36de" target="_blank">檀香学习笔记</a></p>\r\r<p>YouTube：<a href="https://www.youtube.com/c/OliverKingChannel" target="_blank">Oliver King</a></p>\r\r<p>Telegram：<a href="https://t.me/oliver_csu" target="_blank">oliver_csu</a></p>\r\r<p>熊掌号：<a href="https://author.baidu.com/home/1602767415797591" target="_blank">檀香学习笔记</a></p>\r\r<p>网易云音乐：<a href="http://music.163.com/#/user/home?id=315199858" target="_blank">oliver-csu</a></p>\r\r<p>邮箱：<a href="mailto:oliver.csu@gmail.com" target="_blank">oliver.csu@gmail.com</a></p>\r\r<p>认证证书：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/2355424869.png" style="width: 800px; height: 533px;" /></p>\r', 7, 1, NULL, 'page', 'publish', NULL, 0, '1', '1', '1', 0, 886),
(163, 'raid.png', 'raid-png', 1491145052, 1491145052, 'a:5:{s:4:"name";s:8:"raid.png";s:4:"path";s:35:"/usr/uploads/2017/04/1767660421.png";s:4:"size";i:44445;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 167, 0),
(164, '条带与分条.png', '条带与分条-png', 1491145289, 1491145289, 'a:5:{s:4:"name";s:19:"条带与分条.png";s:4:"path";s:35:"/usr/uploads/2017/04/3795683310.png";s:4:"size";i:24328;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 167, 0),
(165, '异或校验冗余备份.png', '异或校验冗余备份-png', 1491145530, 1491145530, 'a:5:{s:4:"name";s:28:"异或校验冗余备份.png";s:4:"path";s:35:"/usr/uploads/2017/04/1174771578.png";s:4:"size";i:15695;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 167, 0),
(166, 'RAID工作过程.png', 'RAID工作过程-png', 1491145646, 1491145646, 'a:5:{s:4:"name";s:20:"RAID工作过程.png";s:4:"path";s:35:"/usr/uploads/2017/04/2760624807.png";s:4:"size";i:34189;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 167, 0),
(167, '磁盘阵列技术简介及基本概念', '167', 1491145620, 1491145900, '<p>本文介绍磁盘阵列技术&mdash;&mdash;RAID。</p>\r<!--more-->\r\r<p>RAID（Redundant-Array-of-Independent-Disks）：独立冗余磁盘阵列，简称磁盘阵列。是指一种通过将多个较小的磁盘整合成为一个大磁盘的技术。整合后大磁盘称为磁盘阵列，不仅可以用于存储数据，还可以用于备份、迁移、容错等特定用途。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/1767660421.png" style="width: 532px; height: 123px;" /></p>\r\r<p>RAID的主要实现方式分为硬件RAID方式和软件RAID方式。</p>\r\r<p>条带：磁盘中单个或者多个连续的扇区构成一个条带。它是组成分条的元素。</p>\r\r<p>分条：同一磁盘阵列中的多个磁盘驱动器上的相同&ldquo;位置&rdquo;（或者说是相同编号）的条带。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/3795683310.png" style="width: 484px; height: 158px;" /></p>\r\r<p>XOR校验算法&mdash;&mdash;相同为假，相异为真</p>\r\r<ol>\r	<li>0+0=0</li>\r	<li>0+1=1</li>\r	<li>1+0=1</li>\r	<li>1+1=0</li>\r</ol>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/1174771578.png" style="width: 397px; height: 174px;" /></p>\r\r<p>RAID的工作过程</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/2760624807.png" style="width: 557px; height: 343px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(8, '2.png', '2-png', 1484549376, 1484549376, 'a:5:{s:4:"name";s:5:"2.png";s:4:"path";s:34:"/usr/uploads/2017/01/988597851.png";s:4:"size";i:34781;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 4, 0),
(7, '1.png', '1-png', 1484549354, 1484549354, 'a:5:{s:4:"name";s:5:"1.png";s:4:"path";s:35:"/usr/uploads/2017/01/2061684491.png";s:4:"size";i:31690;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 4, 0),
(9, '3.png', '3-png', 1484549647, 1484549647, 'a:5:{s:4:"name";s:5:"3.png";s:4:"path";s:35:"/usr/uploads/2017/01/4022052090.png";s:4:"size";i:44276;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 4, 0),
(10, '4.png', '4-png', 1484550034, 1484550034, 'a:5:{s:4:"name";s:5:"4.png";s:4:"path";s:35:"/usr/uploads/2017/01/2442897126.png";s:4:"size";i:35597;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 4, 0),
(12, '5.png', '5-png', 1484551114, 1484551114, 'a:5:{s:4:"name";s:5:"5.png";s:4:"path";s:35:"/usr/uploads/2017/01/3006889863.png";s:4:"size";i:52116;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 4, 0),
(13, '1.png', '1-png-1', 1484625102, 1484625102, 'a:5:{s:4:"name";s:5:"1.png";s:4:"path";s:35:"/usr/uploads/2017/01/1246635256.png";s:4:"size";i:31381;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 15, 0),
(14, '2.png', '2-png-1', 1484625214, 1484625214, 'a:5:{s:4:"name";s:5:"2.png";s:4:"path";s:35:"/usr/uploads/2017/01/3915229919.png";s:4:"size";i:31872;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 15, 0),
(15, 'PPK秘钥格式转OpenSSH秘钥格式', '15', 1484625180, 1490855673, '<p>本文介绍如何将PPK秘钥转换为OpenSSH秘钥，需要使用PuttyGen工具。</p>\r\r<!--more-->\r\r<p>1.加载PPK秘钥</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/01/1246635256.png" style="width: 493px; height: 477px;" /></p>\r\r<p>2.导出OpenSSH秘钥</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/01/3915229919.png" style="width: 493px; height: 477px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '1', '1', '1', 0, 143),
(16, 'Linux下Oracle的静默安装', '16', 1484626620, 1490855694, '<p>本文演示Linux操作系统下，如何使用静默方式安装Oracle数据库，虚拟机采用的是VirtualBox，Linux操作系统采用的是CentOS7，Oracle数据库的安装包采用的是Oracle11gR2.</p>\r<!--more-->\r\r<p>VirtualBox下载地址：<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank">Download</a><br />\rCentOS 7下载地址：<a href="http://mirrors.163.com/centos/">Download</a><br />\rOracle11gR2下载地址：<a href="http://dlab.csu.edu.cn/largedb2016/download/linux.x64_11gR2_database_1of2.zip">Part1</a>&nbsp;<a href="http://dlab.csu.edu.cn/largedb2016/download/linux.x64_11gR2_database_2of2.zip">Part2</a><br />\rPutty下载地址：<a href="ftp://ftp.chiark.greenend.org.uk/users/sgtatham/putty-latest/x86/putty.zip">Download</a><br />\rFilezilla下载地址：<a href="http://sourceforge.net/projects/filezilla/files/FileZilla_Client/3.24.0/FileZilla_3.24.0_win32.zip/download">Download</a></p>\r\r<p>1. 在VirtualBox下安装Centos7</p>\r\r<p><span style="line-height: 1.6em;">CPU内核数：不能少于2核</span></p>\r\r<p><span style="line-height: 1.6em;">内存：不能少于2G</span></p>\r\r<p><span style="line-height: 1.6em;">网卡连接方式：桥接</span></p>\r\r<p><span style="line-height: 1.6em;">硬盘：不能少于20G</span></p>\r\r<p><span style="line-height: 1.6em;">语言：简体中文</span></p>\r\r<p><span style="line-height: 1.6em;">软件选择：基础设施服务器</span></p>\r\r<p><span style="line-height: 1.6em;">安装位置：自动分区</span></p>\r\r<p><span style="line-height: 1.6em;">KDUMP：禁用</span></p>\r\r<p><span style="line-height: 1.6em;">网络和主机名：启用网络，主机名为oracle，记录此时的IP地址</span></p>\r\r<p><span style="line-height: 1.6em;">​</span><span style="line-height: 1.6em;">用户设置：只设置root用户的密码，不添加普通用户</span></p>\r\r<p>2.&nbsp;启动sshd服务</p>\r\r<pre class="brush:bash;ruler:true;">\rsystemctl start sshd.service\rsystemctl enable sshd.service</pre>\r\r<p>3.&nbsp;使用Putty远程连接虚拟机</p>\r\r<p><span style="line-height: 1.6em;">HostName：前面记录的IP地址</span></p>\r\r<p>4.&nbsp;修改/etc/hosts文件</p>\r\r<pre class="brush:bash;ruler:true;">\recho &lsquo;前面的IP地址 oracle oracle&rsquo; &gt;&gt; /etc/hosts</pre>\r\r<p>5.&nbsp;安装依赖库</p>\r\r<pre class="brush:bash;">\ryum -y install binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel\ryum -y install elfutils-libelf-devel-static gcc gcc-c++ glibc glibc-common glibc-devel\ryum -y install glibc-headers glibc-static kernel-headers pdksh libaio libaio-devel libgcc libgomp\ryum -y install libstdc++ libstdc++-devel libstdc++-static\ryum -y install make numactl-devel sysstat unixODBC unixODBC-devel</pre>\r\r<p>6.&nbsp;修改/etc/sysctl.conf文件</p>\r\r<pre class="brush:bash;ruler:true;">\rcat &gt;&gt; /etc/sysctl.conf &lt;&lt;EOF\rfs.aio-max-nr = 1048576\rfs.file-max = 6553600\rkernel.shmall = 2097152\rkernel.shmmax = 2147483648\rkernel.shmmni = 4096\rkernel.sem = 250 32000 100 128\rnet.ipv4.ip_local_port_range = 1024 65000\rnet.core.rmem_default = 262144\rnet.core.rmem_max = 4194304\rnet.core.wmem_default = 262144\rnet.core.wmem_max = 1048586\rnet.ipv6.conf.all.disable_ipv6 = 1\rEOF\rsysctl -p</pre>\r\r<p>7.&nbsp;创建用户和用户组</p>\r\r<pre class="brush:bash;ruler:true;">\rgroupadd oinstall\rgroupadd dba\ruseradd -g oinstall -G dba -d /home/oracle oracle\rpasswd oracle</pre>\r\r<p>8.&nbsp;修改/etc/security/limits.conf文件</p>\r\r<pre class="brush:bash;">\rcat &gt;&gt; /etc/security/limits.conf &lt;&lt;EOF\roracle soft nproc 2047\roracle hard nproc 16384\roracle soft nofile 1024\roracle hard nofile 65536\roracle soft stack 10240\rEOF</pre>\r\r<p>9.&nbsp;修改/etc/profile文件</p>\r\r<pre class="brush:bash;">\rcat &gt;&gt; /etc/profile &lt;&lt;EOF\rif [ $USER = &quot;oracle&quot; ]; then\rif [ $SHELL = &quot;/bin/ksh&quot; ]; then\rulimit -p 16384\rulimit -n 65536\relse\rulimit -u 16384 -n 65536\rfi\rfi\rEOF</pre>\r\r<p>10.&nbsp;修改/etc/pam.d/login文件</p>\r\r<pre class="brush:bash;">\rcat &gt;&gt; /etc/profile &lt;&lt;EOF\rsession required pam_limits.so\rEOF</pre>\r\r<p>11.&nbsp;修改/opt文件夹的属主和属组</p>\r\r<pre class="brush:bash;">\rchown -R oracle.oinstall /opt/</pre>\r\r<p>12.&nbsp;再打开一个Putty，用oracle用户登录</p>\r\r<p><span style="line-height: 1.6em;">HostName：前面记录的IP地址</span></p>\r\r<p>13.&nbsp;切换到opt目录，下载oracle的安装文件，并解压缩</p>\r\r<pre class="brush:bash;">\rcd /opt/\rwget http://dlab.csu.edu.cn/largedb2016/download/linux.x64_11gR2_database_1of2.zip\rwget http://dlab.csu.edu.cn/largedb2016/download/linux.x64_11gR2_database_2of2.zip\runzip linux.x64_11gR2_database_1of2.zip\runzip linux.x64_11gR2_database_2of2.zip</pre>\r\r<p>14.&nbsp;重启虚拟机</p>\r\r<pre class="brush:bash;">\r#在root用户的终端，输入reboot\rreboot</pre>\r\r<p>15.&nbsp;打开Putty，使用oracle用户登录</p>\r\r<p><span style="line-height: 1.6em;">HostName：前面记录的IP地址</span></p>\r\r<p>16.&nbsp;创建安装目录</p>\r\r<pre class="brush:bash;">\rmkdir -p /opt/oracle/product/11.2.0\rmkdir -p /home/oracle/inventory\rmkdir -p /opt/oradata\rmkdir -p /opt/oradata_back</pre>\r\r<p>17.&nbsp;修改/opt/database/response/db_install.rsp文件</p>\r\r<pre class="brush:bash;">\r#将对应行按照下面的内容进行修改\roracle.install.option=INSTALL_DB_AND_CONFIG\rORACLE_HOSTNAME=oracle\rUNIX_GROUP_NAME=oinstall\rINVENTORY_LOCATION=/home/oracle/inventory\rSELECTED_LANGUAGES=en,zh_CN\rORACLE_HOME=/opt/oracle/product/11.2.0\rORACLE_BASE=/opt/oracle\roracle.install.db.InstallEdition=EE\roracle.install.db.DBA_GROUP=dba\roracle.install.db.OPER_GROUP=dba\roracle.install.db.config.starterdb.type=GENERAL_PURPOSE\roracle.install.db.config.starterdb.globalDBName=ora11g\roracle.install.db.config.starterdb.SID=ora11g\roracle.install.db.config.starterdb.memoryLimit=512\roracle.install.db.config.starterdb.installExampleSchemas=true\roracle.install.db.config.starterdb.password.ALL=这个密码大于8位，并且包含大写字母，小写字母和数字。\roracle.install.db.config.starterdb.storageType=FILE_SYSTEM_STORAGE\roracle.install.db.config.starterdb.fileSystemStorage.dataLocation=/opt/oradata\roracle.install.db.config.starterdb.fileSystemStorage.recoveryLocation=/opt/oradata_back\rDECLINE_SECURITY_UPDATES=true</pre>\r\r<p>18.&nbsp;修改/home/oracle/.bash_profile文件</p>\r\r<pre class="brush:bash;">\r#从下面这行开始修改\r#User specific environment and startup programs\r\rPATH=$PATH:$HOME/.local/bin:$HOME/bin\r\rexport ORACLE_SID=ora11g\rexport ORACLE_BASE=/opt/oracle\rexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0\rexport LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib\rPATH=$PATH:$ORACLE_HOME/bin\r\rexport PATH</pre>\r\r<p>19.&nbsp;使上一步的修改生效</p>\r\r<pre class="brush:bash;">\rsource /home/oracle/.bash_profile</pre>\r\r<p>20.&nbsp;开始安装</p>\r\r<pre class="brush:bash;">\r/opt/database/runInstaller -silent -ignoreSysPrereqs -ignorePrereq -responseFile /opt/database/response/db_install.rsp</pre>\r\r<p>21. 安装完成</p>\r\r<p>根据提示，使用root用户运行两个脚本。</p>\r\r<p>注意事项：<br />\r1.oracle安装文件的下载地址不保证一直有效；<br />\r2.在安装过程中，可以使用top命令查看oracle用户的所有进程中是否有java这个进程，如果该进程终止，则表示安装失败，及时查看对应的日志文件进行排错，再重新运行安装命令即可；<br />\r3.如果感觉用VI编辑器修改Oracle的安装配置文件比较麻烦，可以使用Filezilla来进行修改，下载地址已经给出。</p>\r\r<p>参考内容：</p>\r\r<p><a href="http://dlab.csu.edu.cn/largedb2016/slides/oracle_install_manual.pdf" target="_blank">oracle_install_manual.pdf</a></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '1', '0', '0', 0, 201),
(19, '利用301重定向实现不带www域名跳转到带www域名', '19', 1484702220, 1490855712, '<p>本文通过利用301重定向，使不带www的域名跳转到带www的域名。</p>\r<!--more-->\r\r<p><span style="color: rgb(51, 51, 51); font-family: &quot;Microsoft Yahei&quot;, 微软雅黑, arial, 宋体, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255);">1. &nbsp;在网站根目录建立一个php文件，文件名为301.inc.php</span></p>\r\r<p><span style="color: rgb(51, 51, 51); font-family: &quot;Microsoft Yahei&quot;, 微软雅黑, arial, 宋体, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255);">2. &nbsp;在301.inc.php中输入以下代码并保存​</span></p>\r\r<pre class="brush:php;">\r&lt;?php\r//取得当前域名\r$the_host = $_SERVER[&#39;HTTP_HOST&#39;];\r//判断地址后面部分\r$the_url = isset($_SERVER[&#39;REQUEST_URI&#39;]) ? $_SERVER[&#39;REQUEST_URI&#39;] : &#39;&#39;;\r//将英文字母转成小写\r$the_url = strtolower($the_url);\r//判断是不是首页\rif($the_url==&quot;/index.php&quot;)\r{\r//如果是首页,赋值为空\r$the_url=&quot;&quot;;\r}\r//如果域名是不带www的网址那么进行下面的301跳转\rif($the_host == &#39;oliver.ren&#39;)\r{\r//发出301头部\rheader(&#39;HTTP/1.1 301 Moved Permanently&#39;);\r//跳转到带www的网址\rheader(&#39;Location:http://www.oliver.ren&#39;.$the_url);\r}\r?&gt;</pre>\r\r<p><span style="color: rgb(51, 51, 51); font-family: &quot;Microsoft Yahei&quot;, 微软雅黑, arial, 宋体, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255);">3. 在index.php头部,输入代码:include(&quot;301.inc.php&quot;);</span></p>\r\r<p style="text-align: justify; "><font face="Microsoft Yahei, 微软雅黑, arial, 宋体, sans-serif"><span style="font-size: 16px;">注意事项：</span></font></p>\r\r<p style="text-align: justify; "><span style="color: rgb(51, 51, 51); font-family: &quot;Microsoft Yahei&quot;, 微软雅黑, arial, 宋体, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255);">1.这样做有助于集中网站权重；</span></p>\r\r<p style="text-align: justify; "><span style="color: rgb(51, 51, 51); font-family: &quot;Microsoft Yahei&quot;, 微软雅黑, arial, 宋体, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255);">2.适用于所有的PHP程序的网站。</span></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '1', '0', '0', 0, 133),
(21, '常用的几个开源镜像站点', '21', 1486452300, 1552439386, '<p>本文分享几个常用的开源镜像站，推荐使用网易开源镜像站。</p>\r<!--more-->\r\r<p>网易开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirrors.163.com" target="_blank">http://mirrors.163.com</a></p>\r\r<p>阿里开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirrors.aliyun.com" target="_blank">http://mirrors.aliyun.com</a></p>\r\r<p>搜狐开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirrors.sohu.com" target="_blank">http://mirrors.sohu.com</a></p>\r\r<p>天翼开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirrors.ctyun.cn" target="_blank">http://mirrors.ctyun.cn</a></p>\r\r<p>公云开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirrors.pubyun.com" target="_blank">http://mirrors.pubyun.com</a></p>\r\r<p>东北大学开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirror.neu.edu.cn" target="_blank">http://mirror.neu.edu.cn</a></p>\r\r<p>华中科技大学开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirrors.hust.edu.cn" target="_blank">http://mirrors.hust.edu.cn</a></p>\r\r<p>中国科学大学开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirrors.ustc.edu.cn" target="_blank">http://mirrors.ustc.edu.cn</a></p>\r\r<p>东软信息学院开源镜像站：<a href="http://www.oliver.ren/go.php?url=http://mirrors.neusoft.edu.cn" target="_blank">http://mirrors.neusoft.edu.cn</a></p>\r\r<p><span style="line-height: 20.8px;">Linux运维派开源镜像站：</span><a href="http://www.oliver.ren/go.php?url=http://mirrors.skyshe.cn/" style="line-height: 20.8px;" target="_blank">http://mirrors.skyshe.cn</a></p>\r\r<p>更多：<a href="http://www.oliver.ren/go.php?url=http://www.cnblogs.com/jtlgb/p/5702713.html" target="_blank">CNBlog</a></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 127),
(20, 'Linux下安装Transmission', '20', 1484737920, 1554638024, '<p>本文介绍Linux下Transmission的安装，Transmission是一种BitTorrent客户端，特点是一个跨平台的后端和其上的简洁的用户界面。Transmission以MIT许可证和GNU通用公共许可证双许可证授权，因此是一款自由软件。</p>\r<!--more-->\r\r<p>测试环境是CentOS6 X64.</p>\r\r<p>1. 添加repo文件</p>\r\r<pre class="brush:bash;">\rwget -P /etc/yum.repos.d/ http://geekery.altervista.org/geekery-el6-x86_64.repo</pre>\r\r<p>2. 使用yum来安装Transmission</p>\r\r<pre class="brush:bash;">\r#提示导入GPG Key的时候输y同意即可\ryum -y install transmission transmission-daemon</pre>\r\r<p>3. 启动Transmission</p>\r\r<pre class="brush:bash;">\rservice transmission-daemon start</pre>\r\r<p>4. 停止Transmission，修改配置文件</p>\r\r<pre class="brush:bash;">\rservice transmission-daemon stop\r#修改/var/lib/transmission/settings.json文件\r#对应行按照下面的行修改\r&quot;rpc-authentication-required&quot;: true,\r&quot;rpc-enabled&quot;: true,\r&quot;rpc-password&quot;: &quot;管理密码密码&quot;,\r&quot;rpc-username&quot;: &quot;管理用户名&quot;,\r&quot;rpc-whitelist-enabled&quot;: false,</pre>\r\r<p>5. 启动Transmission，并设置Transmission开机自启动</p>\r\r<pre class="brush:bash;">\rservice transmission-daemon start\rchkconfig transmission-daemon on</pre>\r\r<p>6. 安装完成</p>\r\r<p>可以通过http://ip:9091访问Transmission的后台界面了。</p>\r\r<p>注意事项：</p>\r\r<p>1. CentOS5 X86的repo：http://geekery.altervista.org/geekery-el5-i386.repo<br />\r2. CentOS5 X64的repo：http://geekery.altervista.org/geekery-el5-x86_64.repo<br />\r3. CentOS6 X86的repo：http://geekery.altervista.org/geekery-el6-i686.repo<br />\r4. CentOS5的配置文件位置：/var/lib/transmission/.config/transmission-daemon/settings.json</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 154),
(1552, 'WebService简介', '1552', 1555148828, 1555148828, '<p>本文记录IT学习过程中遇到的WebService简介～</p>\r<!--more-->\r\r<p>WebService是一个平台独立的、低耦合的、自包含的并基于可编程的Web应用程序，可使用开放的XML标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p>\r\r<p>WebService技术，能使得运行在不同机器上的不同应用无需借助附加的、专门的第三方软件或硬件，就可以相互交换数据和集成。依据WebService规范实现的应用之间，无论它们所使用的语言、平台或内部协议是什么，都可以相互交换数据。WebService是自描述、自包含的可用网络模块，可以执行具体的业务功能。WebService也很容易部署，因为它们基于一些常规的产业标准以及已有的一些技术，诸如标准通用标记语言下的子集XML和HTTP协议。WebService减少了应用接口的花费，为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。</p>\r\r<p>WebService使用HTTP方式来接收和响应外部系统的请求，从而实现远程调用。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 25),
(28, 'Linux服务器禁Ping', '28', 1486725360, 1570184426, '<p>本文介绍Linux服务器如何禁止Ping探测，一共有两种方方法。一种是修改内核参数，另一种是修改防火墙配置。</p>\r<!--more-->\r\r<p>一、修改内核参数</p>\r\r<p>1.修改<span style="font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(255, 255, 255);">/proc/sys/net/ipv4/icmp_echo_ignore_all</span></p>\r\r<pre class="brush:bash;">\r#临时生效，重启之后将会失效\recho 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</pre>\r\r<p>2.在/etc/sysctl.conf中添加一行代码</p>\r\r<pre class="brush:bash;">\r#永久有效，不会在重启之后失效\recho &#39;net.ipv4.icmp_echo_ignore_all=1&#39; &gt;&gt; /etc/sysctl.conf\rsysctl -p</pre>\r\r<p>二、修改防火墙配置</p>\r\r<pre class="brush:bash;">\r#永久有效，不会在重启之后失效\riptables -A INPUT -p icmp --icmp-type8 -s 0/0 -j DROP\rservice iptables restart</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 159),
(30, 'Debian使用APT更新系统', '30', 1486726740, 1486888069, '<p>本文介绍如何使用apt命令来更新Debian系统上的所有软件包。</p>\r<!--more-->\r\r<p>由于Debian是使用apt软件包管理的，所以更新系统的方式与RHEL不同，不是直接输入yum update就能更新的。它需要先更新软件源，然后才能挨个更新每个软件包。</p>\r\r<pre class="brush:bash;">\r#更新软件源\rapt-get -y update\r#自动更新所有软件包\rapt-get -y dist-upgrade</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '1', '0', '0', 0, 142),
(1551, 'ACP证书.png', 'ACP证书-png', 1554563492, 1554563492, 'a:5:{s:4:"name";s:13:"ACP证书.png";s:4:"path";s:35:"/usr/uploads/2019/04/2355424869.png";s:4:"size";i:267585;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2, 0),
(593, '数组元素选择排序', '593', 1520781480, 1553958715, '<p>本文记录Java学习过程中遇到的选择排序～</p>\r<!--more-->\r\r<p>题目分析：</p>\r\r<p>通过观察发现，本题目要实现把数组元素{13,46,22,65,3}进行排序</p>\r\r<ol>\r	<li>提到数组排序，就要进行元素值大小的比较，通过上图发现，我们想完成排序要经过若干次的比较才能够完成。</li>\r	<li>上图中用每圈要比较的第一个元素与该元素后面的数组元素依次比较到数组的最后一个元素，把小的值放在第一个数组元素中，数组循环一圈后，则把最小元素值互换到了第一个元素中。</li>\r	<li>数组再循环一圈后，把第二小的元素值互换到了第二个元素中。按照这种方式，数组循环多圈以后，就完成了数组元素的排序。这种排序方式我们称为选择排序。</li>\r</ol>\r\r<p>如图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/256580619.png" style="width: 600px; height: 384px;" /></p>\r\r<p>解题步骤：</p>\r\r<ol>\r	<li>使用for循环（外层循环），指定数组要循环的圈数（通过图解可知，数组循环的圈数为数组长度 - 1）</li>\r	<li>在每一圈中，通过for循环（内层循环）完成数组要比较的第一个元素与该元素后面的数组元素依次比较到数组的最后一个元素，把小的值放在第一个数组元素中</li>\r	<li>在每一圈中，要参与比较的第一个元素由第几圈循环来决定。如上图所示\r	<ol style="list-style-type:lower-alpha;">\r		<li>进行第一圈元素比较时，要比较的第一个元素为数组第一个元素，即索引为0的元素</li>\r		<li>进行第二圈元素比较时，要比较的第一个元素为数组第二个元素，即索引为1的元素</li>\r		<li>依次类推，得出结论：进行第n圈元素比较时，要比较的第一个元素为数组第n个元素，即数组索引为n-1的元素</li>\r	</ol>\r	</li>\r</ol>\r\r<p>实现代码：</p>\r\r<pre class="brush:java;">\r//选择排序\rpublic static void selectSort(int[] arr) {\r	//功能\r	//外层循环用来控制数组循环的圈数\r	for (int i = 0; i &lt; arr.length-1; i++) {\r		//内层循环用来完成元素值比较，把小的元素值互换到要比较的第一个元素中\r		for (int j = i+1; j &lt; arr.length; j++) {\r			if (arr[i] &gt; arr[j]) {\r				int temp = arr[i];\r				arr[i] = arr[j];\r				arr[j] = temp;\r			}\r		}\r	}\r}</pre>\r\r<p>选择排序的时间复杂度：简单选择排序的比较次数与序列的初始排序无关。&nbsp;假设待排序的序列有&nbsp;N&nbsp;个元素，则比较次数永远都是N&nbsp;(N&nbsp;-&nbsp;1)&nbsp;/&nbsp;2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为&nbsp;0。当序列反序时，移动次数最多，为3N&nbsp;(N&nbsp;-&nbsp;1)&nbsp;/&nbsp;&nbsp;2。</p>\r\r<p>所以，综上，简单排序的时间复杂度为&nbsp;O(N2)。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(594, 'select.png', 'select-png', 1520781604, 1520781604, 'a:5:{s:4:"name";s:10:"select.png";s:4:"path";s:34:"/usr/uploads/2018/03/256580619.png";s:4:"size";i:154144;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 593, 0),
(596, '数组元素冒泡排序', '596', 1520815920, 1553959088, '<p>本文记录Java学习过程中遇到的数组元素冒泡排序～</p>\r<!--more-->\r\r<p>题目分析：</p>\r\r<p>通过观察发现，本题目要实现把数组元素{13,46,22,65,3}进行排序</p>\r\r<ol>\r	<li>提到数组排序，就要进行元素值大小的比较，通过图发现，我们想完成排序要经过若干次的比较才能够完成。</li>\r	<li>图中相邻的元素值依次比较，把大的值放后面的元素中，数组循环一圈后，则把最大元素值互换到了最后一个元素中。数组再循环一圈后，把第二大的元素值互换到了倒数第二个元素中。按照这种方式，数组循环多圈以后，就完成了数组元素的排序。这种排序方式我们称为冒泡排序。</li>\r</ol>\r\r<p>如图所示（数组元素{13,46,22,65,3}）：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/1850313610.png" style="width: 600px; height: 293px;" /></p>\r\r<p>解题步骤：</p>\r\r<ol>\r	<li>使用for循环（外层循环），指定数组要循环的圈数（通过图解可知，数组循环的圈数为数组长度 - 1）</li>\r	<li>在每一圈中，通过for循环（内层循环）完成相邻的元素值依次比较，把大的值放后面的元素中</li>\r	<li>每圈内层循环的次数，由第几圈循环来决定。如上图所示\r	<ol style="list-style-type:lower-alpha;">\r		<li>进行第一圈元素比较时，内层循环次数为数组长度 - 1</li>\r		<li>进行第二圈元素比较时，内层循环次数为数组长度 - 2</li>\r		<li>依次类推，得出结论：进行第n圈元素比较时，内层循环次数为数组长度 - n</li>\r	</ol>\r	</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//冒泡排序\rpublic static void bubbleSort(int[] arr) {\r	//功能\r	//外层循环用来控制数组循环的圈数\r	for (int i = 0; i &lt; arr.length-1; i++) {\r		//j &lt; arr.length-1 为了避免角标越界\r		//j &lt; arr.length-1-i 为了比较效率,避免重复比较\r		//内层循环用来完成元素值比较，把大的元素值互换到后面\r		for (int j = 0; j &lt; arr.length-1-i; j++) {\r			if (arr[j] &gt; arr[j+1]) {\r				int temp = arr[j];\r				arr[j] = arr[j+1];\r				arr[j+1] = temp;\r			}\r		}\r	}\r}</pre>\r\r<p>用时间复杂度来说：</p>\r\r<p>1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。</p>\r\r<p>2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1&le;i&le;n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/2181851257.jpg" style="width: 322px; height: 116px;" /></p>\r\r<p>冒泡排序的最坏时间复杂度为：O(n2)&nbsp;。</p>\r\r<p>综上所述：冒泡排序总的平均时间复杂度为：O(n2)&nbsp;。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 139),
(597, 'bubble.png', 'bubble-png', 1520816150, 1520816150, 'a:5:{s:4:"name";s:10:"bubble.png";s:4:"path";s:35:"/usr/uploads/2018/03/1850313610.png";s:4:"size";i:124839;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 596, 0),
(587, 'ASCII编码表', '587', 1520095020, 1520095210, '<p>本文记录Java学习过程中遇到的ASCII编码表～</p>\r<!--more-->\r\r<p>American Standard Code for Information Interchange，美国标准信息交换代码。</p>\r\r<p>在计算机中，所有的数据在存储和运算时都要使用二进制数表示, a、b、c、d这样的52个字母（包括大写）、以及0、1等数字还有一些常用的符号, 在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，统一规定了上述常用符号用哪些二进制数来表示。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/2672173522.png" style="width: 600px; height: 404px;" /></p>\r\r<p>数字0-9对应ASCII编码十进制为48-57, 字母a-z对应ASCII编码十进制为97-122，字母A-Z对应ASCII编码十进制为65-90。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 308),
(588, 'ascii.png', 'ascii-png', 1520095160, 1520095160, 'a:5:{s:4:"name";s:9:"ascii.png";s:4:"path";s:35:"/usr/uploads/2018/03/2672173522.png";s:4:"size";i:2599366;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 587, 0),
(590, '数组元素逆序', '590', 1520776560, 1520776760, '<p>本文记录Java学校过程中遇到的数组元素逆序～</p>\r<!--more-->\r\r<p>题目分析：</p>\r\r<p>通过观察发现，本题目要实现原数组元素倒序存放操作。即原数组存储元素为{11,22,33,44}，逆序后为原数组存储元素变为{44,33,22,11}。</p>\r\r<ol>\r	<li>通过图解发现，想完成数组元素逆序，其实就是把数组中索引为start与end的元素进行互换。</li>\r	<li>每次互换后，start索引位置后移，end索引位置前移，再进行互换</li>\r	<li>直到start位置超越了end位置，互换结束，此时，数组元素逆序完成。</li>\r</ol>\r\r<p>如图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/3907872554.png" style="width: 600px; height: 243px;" /></p>\r\r<p>解题步骤：</p>\r\r<ol>\r	<li>定义两个索引变量start值为0，变量end值为数组长度减去1（即数组最后一个元素索引）</li>\r	<li>使用循环，完成数组索引start位置元素与end位置元素值互换。</li>\r	<li>在循环换过程中，每次互换结束后，start位置后移1，end位置前移1</li>\r	<li>在循环换过程中，最先判断start位置是否超越了end位置，若已超越，则跳出循环</li>\r</ol>\r\r<p>代码实现：</p>\r\r<pre class="brush:java;">\rpublic static void receive(int[] arr){\r	for (int start = 0, end = arr.length-1; start &lt; end; start++,end--) {\r		int temp = arr[start];\r		arr[start] = arr[end];\r		arr[end] = temp;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 161),
(591, 'reverse.png', 'reverse-png', 1520776739, 1520776739, 'a:5:{s:4:"name";s:11:"reverse.png";s:4:"path";s:35:"/usr/uploads/2018/03/3907872554.png";s:4:"size";i:181315;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 590, 0),
(580, 'ArrayList集合', '580', 1519523340, 1519524230, '<p>本文记录Java学习过程中遇到的ArrayList集合～</p>\r<!--more-->\r\r<p>ArrayList集合是程序中最常见的一种集合，它属于引用数据类型（类）。在ArrayList内部封装了一个长度可变的数组，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组来存储这些元素，因此可以将ArrayList集合看作一个长度可变的数组。</p>\r\r<p><strong>集合的创建</strong></p>\r\r<p>创建集合的常用格式：</p>\r\r<ul>\r	<li style="margin-left:21.0pt;">导包：import java.util.ArrayList;</li>\r	<li style="margin-left:21.0pt;">创建对象：与其他普通的引用数据类型创建方式完全相同，但是要指定容器中存储的数据类型：</li>\r</ul>\r\r<pre class="brush:java;">\rArrayList&lt;要存储元素的数据类型&gt; 变量名 = new ArrayList&lt;要存储元素的数据类型&gt;();</pre>\r\r<p>注意：</p>\r\r<ul>\r	<li>集合中存储的元素，只能为&lt;&gt;括号中指定的数据类型元素；</li>\r	<li>&ldquo;&lt;要存储元素的数据类型&gt;&rdquo;中的数据类型必须是引用数据类型，不能是基本数据类型；</li>\r</ul>\r\r<p>8种基本数据类型所对应的引用数据类型表示形式：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/02/2284386735.png" style="width: 600px; height: 195px;" /></p>\r\r<p>我们通过举几个例子，来明确集合的创建方式：</p>\r\r<ul>\r	<li>存储String类型的元素</li>\r</ul>\r\r<pre class="brush:java;">\rArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</pre>\r\r<ul>\r	<li>存储int类型的数据</li>\r</ul>\r\r<pre class="brush:java;">\rArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</pre>\r\r<ul>\r	<li>存储Phone类型的数据</li>\r</ul>\r\r<pre class="brush:java;">\rArrayList&lt;Phone&gt; list = new ArrayList&lt;Phone&gt;();</pre>\r\r<p><strong>集合中常用方法</strong></p>\r\r<p>ArrayList集合提供的一些常用方法，如下表：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/02/1266910009.png" style="width: 600px; height: 93px;" /></p>\r\r<p>示例代码（常用方法）：</p>\r\r<pre class="brush:java;">\rimport java.util.ArrayList;\rpublic class ArrayListDemo {\r	public static void main(String[] args) {\r		// 创建ArrayList集合\r		ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();\r		// 向集合中添加元素\r		list.add(&quot;stu1&quot;);\r		list.add(&quot;stu2&quot;);\r		list.add(&quot;stu3&quot;);\r		list.add(&quot;stu4&quot;);\r		// 获取集合中元素的个数\r		System.out.println(&quot;集合的长度：&quot; + list.size());\r		// 取出并打印指定位置的元素\r		System.out.println(&quot;第1个元素是：&quot; + list.get(0));\r		System.out.println(&quot;第2个元素是：&quot; + list.get(1));\r		System.out.println(&quot;第3个元素是：&quot; + list.get(2));\r		System.out.println(&quot;第4个元素是：&quot; + list.get(3));\r	}\r}</pre>\r\r<p>强调一点，ArrayList集合相当于是一个长度可变的数组，所以访问集合中的元素也是采用索引方式访问，第一个元素存储在索引0的位置，第二个元素存储在索引1的位置，依次类推。</p>\r\r<p><strong>集合的遍历</strong></p>\r\r<p>通过集合遍历，得到集合中每个元素，这是集合中最常见的操作。集合的遍历与数组的遍历很像，都是通过索引的方式。</p>\r\r<p>示例代码（集合遍历）：</p>\r\r<pre class="brush:java;">\r import java.util.ArrayList;\r public class ArrayListDemo02 {\r 	public static void main(String[] args) {\r 		//创建ArrayList集合\r 		ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\r 		//添加元素到集合\r 		list.add(13);\r 		list.add(15);\r 		list.add(22);\r 		list.add(29);\r 		//遍历集合\r 		for (int i = 0; i &lt; list.size(); i++) {\r 			//通过索引，获取到集合中每个元素\r 			int n = list.get(i);\r 			System.out.println(n);\r 		}\r 	}\r }</pre>\r\r<p>上述代码中，第5行定义了一个可以存储int元素的集合；第7-10行，实现将int类型数值存储到集合中；第12-16行，实现遍历集合元素。这里要强调一点，get方法返回值的类型为集合中元素的类型。</p>\r\r<p><strong>集合中的常用方法补充</strong></p>\r\r<p>ArrayList集合提供的一些常用方法，如下表：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/02/3978007625.png" style="width: 600px; height: 113px;" /></p>\r\r<ul>\r	<li>boolean add（int index,&nbsp; Object obj）\r	<ul style="list-style-type:square;">\r		<li>功能：在集合中指定index位置，添加新元素obj</li>\r		<li>功能说明：假设集合list中有元素[&ldquo;java&rdquo;,&ldquo;javaEE&rdquo;]，当使用add(1，&ldquo;javaWeb&rdquo;)后，集合list中的元素为[&ldquo;java&rdquo;,&ldquo;javaWeb&rdquo;,&ldquo;JavaEE&rdquo;]。</li>\r	</ul>\r	</li>\r	<li>Object set（int index, Object obj）\r	<ul style="list-style-type:square;">\r		<li>功能：用指定元素obj替代集合中指定index位置的元素</li>\r		<li>功能说明：假设集合list中有元素[&ldquo;java&rdquo;,&ldquo;javaEE&rdquo;]，当使用set(0，&ldquo;javaWeb&rdquo;)后，集合list中的元素为[&ldquo;javaWeb&rdquo;,&ldquo;JavaEE&rdquo;]。</li>\r	</ul>\r	</li>\r	<li>Object remve（int index）\r	<ul style="list-style-type:square;">\r		<li>功能：从集合中删除指定index处的元素，返回该元素</li>\r		<li>功能说明：假设集合list中有元素[&ldquo;java&rdquo;,&ldquo;javaEE&rdquo;]，当使用remove(0)后，集合list中的元素为[&ldquo;JavaEE&rdquo;]，返回值为&ldquo;java&rdquo;。</li>\r	</ul>\r	</li>\r	<li>void clear（）\r	<ul style="list-style-type:square;">\r		<li>功能：清空集合中所有元素</li>\r		<li>功能说明：假设集合list中有元素[&ldquo;java&rdquo;,&ldquo;javaEE&rdquo;]，当使用clear()后，集合list中的元素为空[]。</li>\r	</ul>\r	</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(581, 'ArrayList01.png', 'ArrayList01-png', 1519523622, 1519523622, 'a:5:{s:4:"name";s:15:"ArrayList01.png";s:4:"path";s:35:"/usr/uploads/2018/02/2284386735.png";s:4:"size";i:78878;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 580, 0),
(583, 'ArrayList02.png', 'ArrayList02-png', 1519523861, 1519523861, 'a:5:{s:4:"name";s:15:"ArrayList02.png";s:4:"path";s:35:"/usr/uploads/2018/02/1266910009.png";s:4:"size";i:86025;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 580, 0),
(532, '选择语句if', '532', 1515831360, 1515842564, '<p>本文记录Java学习过程中遇到的选择语句if～</p>\r<!--more-->\r\r<p><strong>1.if语句</strong></p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\rif (条件语句){ \r	执行语句;\r	&hellip;&hellip;\r}</pre>\r\r<p>流程图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2412764824.png" style="width: 600px; height: 510px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class IfDemo {\r	public static void main(String[] args) {\r		int num = 19;\r		if (num % 2 == 0) {\r			// 判断条件成立，num被2整除\r			System.out.println(&quot;num是一个偶数&quot;);\r		} else {\r			System.out.println(&quot;num是一个奇数&quot;);\r		}\r	}\r}</pre>\r\r<p><strong>2.if&hellip;else语句</strong></p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\rif (判断条件){\r	执行语句1\r	&hellip;&hellip;\r}else{\r	执行语句2\r	&hellip;&hellip;\r}</pre>\r\r<p>流程图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/200151952.png" style="width: 600px; height: 440px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class IfDemo {\r	public static void main(String[] args) {\r		int num = 19;\r		if (num % 2 == 0) {\r			// 判断条件成立，num被2整除\r			System.out.println(&quot;num是一个偶数&quot;);\r		} else {\r			System.out.println(&quot;num是一个奇数&quot;);\r		}\r	}\r}</pre>\r\r<p><strong>3.if&hellip;else if&hellip;else语句</strong></p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\rif (判断条件1) {\r	执行语句1\r} else if (判断条件2) {\r	执行语句2\r}\r...\relse if (判断条件n) {\r	执行语句n\r} else {\r	执行语句n+1\r}\r</pre>\r\r<p>流程图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/838500068.png" style="width: 600px; height: 540px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class IfDemo {\r	public static void main(String[] args) {\r		int grade = 75; // 定义学生成绩\r		if (grade &gt; 80) {\r			// 满足条件 grade &gt; 80\r			System.out.println(&quot;该成绩的等级为优&quot;);\r		} else if (grade &gt; 70) {\r			// 不满足条件 grade &gt; 80 ，但满足条件 grade &gt; 70\r			System.out.println(&quot;该成绩的等级为良&quot;);\r		} else if (grade &gt; 60) {\r			// 不满足条件 grade &gt; 70 ，但满足条件 grade &gt; 60\r			System.out.println(&quot;该成绩的等级为中&quot;);\r		} else {\r			// 不满足条件 grade &gt; 60\r			System.out.println(&quot;该成绩的等级为差&quot;);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(122, '如何修改CentOS7的运行级别', '122', 1490249400, 1492407582, '<p>本文介绍如何修改CentOS7的运行级别。</p>\r<!--more-->\r\r<p>将默认的运行级别修改为&ldquo;多用户，无图形模式&rdquo;</p>\r\r<pre class="brush:bash;">\rln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target</pre>\r\r<p>将默认的运行级别修改为&ldquo;图形化模式&rdquo;</p>\r\r<pre class="brush:java;">\rln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(124, 'service与systemctl的对应关系', '124', 1490260500, 1492407575, '<p>本文分享sysvinit与systemctl的对应关系。</p>\r<!--more-->\r\r<p>1.service xxx start</p>\r\r<p>对应：systemctl start xxx.service</p>\r\r<p>作用：启动服务</p>\r\r<p>2.service xxx restart</p>\r\r<p>对应：systemctl restart xxx.service</p>\r\r<p>作用：重启服务<br />\r3.service xxx&nbsp;stop</p>\r\r<p>对应：systemctl stop xxx.service</p>\r\r<p>作用：停止服务</p>\r\r<p>4.service xxx&nbsp;reload</p>\r\r<p>对应：systemctl reload xxx.service</p>\r\r<p>作用：重新加载配置文件（不终止服务）</p>\r\r<p>5.service xxx&nbsp;status</p>\r\r<p>对应：systemctl status xxx.service</p>\r\r<p>作用：查看服务状态</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(125, 'chkconfig与systemctl的对应关系', '125', 1490260860, 1492407569, '<p>本文介绍chkconfig与systemctl的对应关系。</p>\r<!--more-->\r\r<p>1.chkconfig xxx on</p>\r\r<p>对应：systemctl enable xxx.service</p>\r\r<p>作用：开机自动启动</p>\r\r<p>2.chkconfig xxx off</p>\r\r<p>对应：systemctl disable xxx.service</p>\r\r<p>作用：开机不自动启动</p>\r\r<p>3.chkconfig xxx</p>\r\r<p>对应：systemctl is-enabled xxx.service</p>\r\r<p>作用：查看特定服务是否为开机自启动</p>\r\r<p>4.chkconfig --list</p>\r\r<p>对应：systemctl list-unit-files --type=service</p>\r\r<p>作用：查看各个级别下服务的启动与禁用情况</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(97, '工具', 'tools', 1489899000, 1531025834, '<h1>​<span style="line-height: 1.2em;">一、操作系统</span></h1>\r\r<h2>1.Windows7</h2>\r\r<p>1）32位</p>\r\r<pre class="brush:bash;">\red2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/</pre>\r\r<p>2）64位</p>\r\r<pre class="brush:bash;">\red2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</pre>\r\r<h2>2.Windows10</h2>\r\r<p>1）32位</p>\r\r<pre class="brush:bash;">\red2k://|file|cn_windows_10_multiple_editions_version_1703_updated_june_2017_x86_dvd_10725413.iso|4344467456|B3A695DA4BB0025696F168745E372BBE|/</pre>\r\r<p>2）64位</p>\r\r<pre class="brush:bash;">\red2k://|file|cn_windows_10_multiple_editions_version_1703_updated_june_2017_x64_dvd_10724850.iso|5741144064|7717C389428734009E0350A1BB8F2508|/</pre>\r\r<h2>3.Windows ThinPc</h2>\r\r<pre class="brush:java;">\red2k://|file|en_windows_thin_pc_x86_697681.iso|1576980480|2D0E6A048EB3F314F556B4F0834A95E2|/</pre>\r\r<h2>4.Ubuntu</h2>\r\r<p>1）英文版</p>\r\r<p><a href="http://releases.ubuntu.com/16.04/ubuntu-16.04.2-desktop-i386.iso" target="_blank">32位</a>&nbsp; <a href="http://releases.ubuntu.com/16.04/ubuntu-16.04.2-desktop-amd64.iso" target="_blank">64位</a></p>\r\r<p>2）中文版</p>\r\r<p><a href="http://cdimage.ubuntu.com/ubuntukylin/releases/16.04/release/ubuntukylin-16.04-desktop-i386.iso" target="_blank">32位</a>&nbsp; <a href="http://cdimage.ubuntu.com/ubuntukylin/releases/16.04/release/ubuntukylin-16.04-desktop-amd64.iso" target="_blank">64位</a></p>\r\r<h2>5.CentOS</h2>\r\r<p><a href="http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso" target="_blank">DVD</a> <a href="http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso" target="_blank">Minimal</a> <a href="http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-Everything-1611.iso" target="_blank">Everything</a> <a href="http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-NetInstall-1611.iso" target="_blank">NetInstall</a> <a href="http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-LiveGNOME-1611.iso" target="_blank">LiveGNOME</a> <a href="http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-LiveKDE-1611.iso" target="_blank">LiveKDE</a></p>\r\r<h1>二、办公软件</h1>\r\r<h2>1.Office</h2>\r\r<p>1）32位</p>\r\r<pre class="brush:bash;">\red2k://|file|SW_DVD5_Office_Professional_Plus_2016_W32_ChnSimp_MLF_X20-41351.ISO|986441728|2DE74581C10096137481873B3AD57D43|/</pre>\r\r<p>2）64位</p>\r\r<pre class="brush:bash;">\red2k://|file|SW_DVD5_Office_Professional_Plus_2016_64Bit_ChnSimp_MLF_X20-42426.ISO|1123452928|31087A00FF67D4F5B4CBF4AA07C3433B|/</pre>\r\r<p>3）Mac版</p>\r\r<pre class="brush:bash;">\red2k://|file|mu_office_home_and_business_2016_for_mac_mac_dvd_7027756.iso|1214924800|D6FA02597D30709949C4FEA6AA0F9D6B|/</pre>\r\r<h2>2.Visio</h2>\r\r<p>1）32位</p>\r\r<pre class="brush:bash;">\red2k://|file|SW_DVD5_Visio_Pro_2016_W32_ChnSimp_MLF_X20-41580.ISO|609447936|91EB248558F236AA66D234EA03FAD9A9|/</pre>\r\r<p>2）64位</p>\r\r<pre class="brush:bash;">\red2k://|file|SW_DVD5_Visio_Pro_2016_64Bit_ChnSimp_MLF_X20-42759.ISO|714913792|FC930AB97B366B3595FC2F28ABAC2A6F|/</pre>\r\r<h2>3.Project</h2>\r\r<p>1）32位</p>\r\r<pre class="brush:bash;">\red2k://|file|SW_DVD5_Project_Pro_2016_W32_ChnSimp_MLF_X20-41511.ISO|555210752|CA3BD5F8C7B3E263105B041DDD4104AB|/</pre>\r\r<p>2）64位</p>\r\r<pre class="brush:bash;">\red2k://|file|SW_DVD5_Project_Pro_2016_64Bit_ChnSimp_MLF_X20-42676.ISO|647157760|0BBBF20CA3A5F61A819586ADCE6E4DCB|/</pre>\r\r<h1><span style="line-height: 1.2em;">三、压缩软件</span></h1>\r\r<h2>1.7Zip</h2>\r\r<p>1）32位：<a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/996451" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=http://www.7-zip.org/a/7z1604.exe" target="_blank">官方</a></p>\r\r<p>2）64位：<a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/996450" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=http://www.7-zip.org/a/7z1604-x64.exe" target="_blank">官方</a></p>\r\r<h2>2.好压</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/996719" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=http://haozip.2345.com/" target="_blank">官方</a></p>\r\r<h2>3.360压缩</h2>\r\r<p><a href="https://pan.lanzou.com/1449121" target="_blank">网盘</a> <a href="http://yasuo.360.cn/" target="_blank">官方</a></p>\r\r<h2>4.WinRAR</h2>\r\r<p><a href="https://pan.lanzou.com/1449136" target="_blank">网盘</a> <a href="http://www.winrar.com.cn/" target="_blank">官方</a></p>\r\r<h1>四、SSH客户端</h1>\r\r<h2>1.Putty</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1017759" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank">官方</a></p>\r\r<h2>2.Xshell</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1017762" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=http://www.netsarang.com/" target="_blank">官方</a></p>\r\r<h2>3.SecureCRT</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1035300" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=https://www.vandyke.com/download/securecrt/download.html" target="_blank">官方</a></p>\r\r<h1>五、FTP客户端</h1>\r\r<h2>1.Filezilla</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1017757" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=https://filezilla-project.org/download.php?show_all=1" target="_blank">官方</a></p>\r\r<h2>2.Xftp</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1017761" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=http://www.netsarang.com/" target="_blank">官方</a></p>\r\r<h2>3.FlashFXP</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1086006" target="_blank">网盘</a> <a href="http://www.oliver.ren/go.php?url=https://www.flashfxp.com" target="_blank">官方</a></p>\r\r<h1>六、文本编辑器</h1>\r\r<h2>1.Sublime Text</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1017760" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=http://www.sublimetext.com/3" target="_blank">官方</a></p>\r\r<h2>2.NotePad++</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1017758" target="_blank">网盘</a>&nbsp;<a href="http://www.oliver.ren/go.php?url=https://notepad-plus-plus.org/download/v7.3.3.html" target="_blank">官方</a></p>\r\r<h1>七、截图工具</h1>\r\r<h2>1.FastStone Capture</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1017786" target="_blank">网盘</a> <a href="http://www.oliver.ren/go.php?url=https://faststone-capture.en.softonic.com/" target="_blank">官方</a></p>\r\r<h1>八、MySQL客户端</h1>\r\r<h2>1.Navicat</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1022428" target="_blank">网盘</a> <a href="http://www.oliver.ren/go.php?url=https://www.navicat.com/products/navicat-for-mysql" target="_blank">官网</a></p>\r\r<h1>九、画图软件</h1>\r\r<h2>1.亿图</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1032456" target="_blank">网盘</a> <a href="http://www.oliver.ren/go.php?url=http://www.edrawsoft.cn/" target="_blank">官网</a></p>\r\r<h1>十、视频播放器</h1>\r\r<h2>1.QQ影音</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1065501" target="_blank">网盘</a> <a href="http://www.oliver.ren/go.php?url=http://player.qq.com/" target="_blank">官网</a></p>\r\r<h2>2.小细播放器</h2>\r\r<p><a href="http://www.oliver.ren/go.php?url=https://pan.lanzou.com/1067478" target="_blank">网盘</a> <a href="http://www.oliver.ren/go.php?url=https://www.baidu.com" target="_blank">官网</a></p>\r\r<hr />\r<h2>注意事项</h2>\r\r<p>1.镜像站已经被关闭，建议使用网盘下载；</p>\r\r<p>2.有些软件为开心版，请勿用于商业用途。</p>\r', 5, 1, NULL, 'page', 'publish', NULL, 0, '0', '0', '0', 0, 654),
(99, '脚本', 'scripts', 1489899240, 1517658758, '<p><a href="https://lamp.sh/install.html" target="_blank">LAMP一键安装包</a></p>\r\r<pre class="brush:bash;">\r#for CentOS\ryum -y install wget screen git\r#for Debian/Ubuntu\r#apt-get -y install wget screen git\r\rgit clone https://github.com/teddysun/lamp.git\rcd lamp\rchmod +x *.sh\r\rscreen -S lamp\r./lamp.sh\r\r#创建虚拟主机\rlamp add\r\r#删除虚拟主机\rlamp del\r\r#列出虚拟主机\rlamp list</pre>\r\r<p><a href="https://oneinstack.com/install/" target="_blank">oneinstack一键安装</a></p>\r\r<pre class="brush:bash;">\ryum -y install wget screen curl python #for CentOS/Redhat\r# apt-get -y install wget screen curl python #for Debian/Ubuntu\rwget http://aliyun-oss.linuxeye.com/oneinstack-full.tar.gz #阿里云经典网络下载\rwget http://mirrors.linuxeye.com/oneinstack-full.tar.gz #包含源码，国内外均可下载\rwget http://mirrors.linuxeye.com/oneinstack.tar.gz #不包含源码，建议仅国外主机下载\rtar xzf oneinstack-full.tar.gz\rcd oneinstack #如果需要修改目录(安装、数据存储、Nginx日志)，请修改options.conf文件\rscreen -S oneinstack #如果网路出现中断，可以执行命令`screen -R oneinstack`重新连接安装窗口\r./install.sh #注：请勿sh install.sh或者bash install.sh这样执行</pre>\r\r<p>L2TP/IPSec一键安装</p>\r\r<pre class="brush:bash;">\rwget --no-check-certificate https://raw.githubusercontent.com/teddysun/across/master/l2tp.sh\rchmod +x l2tp.sh\r./l2tp.sh</pre>\r\r<p>Shadowsocks-Go一键安装</p>\r\r<pre class="brush:bash;">\rwget --no-check-certificate -O shadowsocks-go.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.sh\rchmod +x shadowsocks-go.sh\r./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</pre>\r\r<p>ShadowsocksR一键安装</p>\r\r<pre class="brush:bash;">\rwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh\rchmod +x shadowsocksR.sh\r./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</pre>\r\r<p>Shadowsocks-Python一键安装</p>\r\r<pre class="brush:bash;">\rwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\rchmod +x shadowsocks.sh\r./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</pre>\r', 6, 1, NULL, 'page', 'publish', NULL, 0, '0', '0', '0', 0, 687),
(552, '数组', '552', 1516081500, 1516164004, '<p>本文记录Java学习过程中遇到的数组～</p>\r<!--more-->\r\r<p>定义格式：</p>\r\r<pre class="brush:java;">\r数据类型[] 数组名 = new 数据类型[元素个数或数组长度];</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rint[] x = new int[100];</pre>\r\r<p>上述语句就相当于在内存中定义了100个int类型的变量，第一个变量的名称为x[0]，第二个变量的名称为x[1]，以此类推，第100个变量的名称为x[99]，这些变量的初始值都是0。为了更好地理解数组的这种定义方式，可以将上面的一句代码分成两句来写，具体如下：</p>\r\r<pre class="brush:java;">\r// 声明一个int[]类型的变量\rint[] x;\r// 创建一个长度为100的数组\rx = new int[100];</pre>\r\r<p>接下来，通过两张内存图来详细地说明数组在创建过程中内存的分配情况。</p>\r\r<p>第一行代码 int[] x; 声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值。内存中的状态如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/719909001.png" style="width: 200px; height: 124px;" /></p>\r\r<p>第二行代码 x = new int[100]; 创建了一个数组，将数组的地址赋值给变量x。在程序运行期间可以使用变量x来引用数组，这时内存中的状态会发生变化，如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3415026511.png" style="width: 200px; height: 123px;" /></p>\r\r<p>在上图中描述了变量x引用数组的情况。该数组中有100个元素，初始值都为0。数组中的每个元素都有一个索引(也可称为角标)，要想访问数组中的元素可以通过&ldquo;x[0]、x[1]、&hellip;&hellip;、x[98]、x[99]&rdquo;的形式。需要注意的是，数组中最小的索引是0，最大的索引是&ldquo;数组的长度-1&rdquo;。在Java中，为了方便我们获得数组的长度，提供了一个length属性，在程序中可以通过&ldquo;数组名.length&rdquo;的方式来获得数组的长度，即元素的个数。</p>\r\r<p>示例代码（定义数组以及访问数组中的元素）：</p>\r\r<pre class="brush:java;">\rpublic class ArrayDemo {\r	public static void main(String[] args) {\r		int[] arr; // 声明变量\r		arr = new int[3]; // 创建数组对象\r		System.out.println(&quot;arr[0]=&quot; + arr[0]); // 访问数组中的第一个元素\r		System.out.println(&quot;arr[1]=&quot; + arr[1]); // 访问数组中的第二个元素\r		System.out.println(&quot;arr[2]=&quot; + arr[2]); // 访问数组中的第三个元素\r		System.out.println(&quot;数组的长度是：&quot; + arr.length); // 打印数组长度\r	}\r}</pre>\r\r<p>在上述代码中声明了一个int[]类型变量arr，并将数组在内存中的地址赋值给它。在5~7行代码中通过角标来访问数组中的元素，在第8行代码中通过length属性访问数组中元素的个数。从打印结果可以看出，数组中的三个元素初始值都为0，这是因为当数组被成功创建后，数组中元素会被自动赋予一个默认值，根据元素类型的不同，默认初始化的值也是不一样的。</p>\r\r<p>注意（不同数据类型被赋予的初始值）：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2251799843.png" style="width: 600px; height: 177px;" /></p>\r\r<p>示例代码（显式为元素赋值）：</p>\r\r<pre class="brush:java;">\rpublic class ArrayDemo {\r	public static void main(String[] args) {\r		int[] arr = new int[4]; // 定义可以存储4个整数的数组\r		arr[0] = 1; // 为第1个元素赋值1\r		arr[1] = 2; // 为第2个元素赋值2\r		// 下面的代码是打印数组中每个元素的值\r		System.out.println(&quot;arr[0]=&quot; + arr[0]);\r		System.out.println(&quot;arr[1]=&quot; + arr[1]);\r		System.out.println(&quot;arr[2]=&quot; + arr[2]);\r		System.out.println(&quot;arr[3]=&quot; + arr[3]);\r	}\r}</pre>\r\r<p>在上述代码中，第3行代码定义了一个数组，此时数组中每个元素都为默认初始值0。第2、3行代码通过赋值语句将数组中的元素arr[0]和arr[1]分别赋值为1和2，而元素arr[2]和arr[3]没有赋值，其值仍为0，因此打印结果中四个元素的值依次为1、2、0、0。</p>\r\r<p>在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。</p>\r\r<p>在初始化数组时还有一种方式叫做静态初始化，就是在定义数组的同时就为数组的每个元素赋值。数组的静态初始化有两种方式，具体格式如下：</p>\r\r<pre class="brush:java;">\r类型[] 数组名 = new 类型[]{元素，元素，&hellip;&hellip;};\r类型[] 数组名 = {元素，元素，元素，&hellip;&hellip;};	</pre>\r\r<p>上面的两种方式都可以实现数组的静态初始化，但是为了简便，建议采用第二种方式。</p>\r\r<p>示例代码（数组静态初始化）：</p>\r\r<pre class="brush:java;">\rpublic class ArrayDemo03 {\r	public static void main(String[] args) {\r		int[] arr = { 1, 2, 3, 4 }; // 静态初始化\r		// 下面的代码是依次访问数组中的元素\r		System.out.println(&quot;arr[0] = &quot; + arr[0]);\r		System.out.println(&quot;arr[1] = &quot; + arr[1]);\r		System.out.println(&quot;arr[2] = &quot; + arr[2]);\r		System.out.println(&quot;arr[3] = &quot; + arr[3]);\r	}\r}\r</pre>\r\r<p>上述代码中采用静态初始化的方式为数组每个元素赋予初值，分别是1、2、3、4。需要注意的是，第3行代码千万不可写成int[] arr = new int[4]{1,2,3,4};，这样写编译器会报错。原因在于编译器会认为数组限定的元素个数[4]与实际存储的元素{1,2,3,4}个数有可能不一致，存在一定的安全隐患。</p>\r\r<p>数组的遍历：在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历。</p>\r\r<p>示例代码（数组遍历）：</p>\r\r<pre class="brush:java;">\rpublic class ArrayDemo {\r	public static void main(String[] args) {\r		int[] arr = { 1, 2, 3, 4, 5 }; // 定义数组\r		// 使用for循环遍历数组的元素\r		for (int i = 0; i &lt; arr.length; i++) {\r			System.out.println(arr[i]); // 通过索引访问元素\r		}\r	}\r}</pre>\r\r<p>上述代码中，定义一个长度为5的数组arr，数组的角标为0~4。由于for循环中定义的变量i的值在循环过程中为0~4，因此可以作为索引，依次去访问数组中的元素，并将元素的值打印出来。</p>\r\r<p>示例代码（求数组中的最大值）：</p>\r\r<pre class="brush:java;">\rpublic class ArrayDemo {\r	public static void main(String[] args) {\r		int[] arr = { 4, 1, 6, 3, 9, 8 }; // 定义一个数组\rint max = arr[0]; // 定义变量max用于记住最大数，首先假设第一个元素为最大值\r		// 下面通过一个for循环遍历数组中的元素\r		for (int x = 1; x &lt; arr.length; x++) {\r			if (arr[x] &gt; max) { // 比较 arr[x]的值是否大于max\r				max = arr[x]; // 条件成立，将arr[x]的值赋给max\r			}\r		}\r		System.out.println(&quot;max=&quot; + max); // 打印最大值\r	}\r}</pre>\r\r<p>上述代码中，定义了一个临时变量max，用于记住数组的最大值。通过for 循环获取数组中的最大值，赋值给max变量。</p>\r\r<p>首先假设数组中第一个元素arr[0]为最大值，然后使用for循环对数组进行遍历，在遍历的过程中只要遇到比max值还大的元素，就将该元素赋值给max。这样一来，变量max就能够在循环结束时记住数组中的最大值。需要注意的是，在for循环中的变量i是从1开始的，这样写的原因是程序已经假设第一个元素为最大值，for循环中只需要从第二个元素开始比较，从而提高程序的运行效率。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 125),
(530, 'Scanner类', '530', 1515806130, 1515806130, '<p>本文记录Java学习过程中遇到的Scanner类～</p>\r\r<!--more-->\r\r<p>Scanner类：</p>\r\r<ul>\r	<li>Scanner类是引用数据类型的一种，我们可以使用该类来完成用户键盘录入，获取到录入的数据。</li>\r	<li>Scanner使用步骤：</li>\r</ul>\r\r<ol>\r	<li>导包：import java.util.Scanner;</li>\r	<li>创建对象实例：Scanner sc = new Scanner(System.in);</li>\r</ol>\r\r<ul>\r	<li>调用方法：</li>\r</ul>\r\r<ol>\r	<li>int&nbsp; i = sc.nextInt(); 用来接收控制台录入的数字</li>\r	<li>String s = sc.next(); 用来接收控制台录入的字符串</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rimport java.util.Scanner;\rpublic class ScannerDemo {\r	public static void main(String[] args) {\r		//创建Scanner引用类型的变量\r		Scanner sc = new Scanner(System.in);\r		//获取数字\r		System.out.println(&quot;请输入一个数字&quot;);\r		int n = sc.nextInt();\r		System.out.println(&quot;n的值为&quot; + n);\r		//获取字符串\r		System.out.println(&quot;请输入一个字符串&quot;);\r		String str = sc.next();\r		System.out.println(&quot;str的值为&quot; + str);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(531, 'Random类', '531', 1515830353, 1515830353, '<p>本文记录Java学习过程中遇到的Random类～</p>\r\r<!--more-->\r\r<p>Random类：可以产生多种数据类型的随机数。</p>\r\r<p>方法简介：</p>\r\r<ul>\r	<li>public int nextInt(int maxValue)&nbsp; 产生[0,maxValue)范围的随机整数，包含0，不包含maxValue；</li>\r	<li>public double nextDouble()&nbsp; 产生[0,1)范围的随机小数，包含0.0，不包含1.0。</li>\r</ul>\r\r<p>Random使用方式:</p>\r\r<ul>\r	<li>import导包：所属包java.util.Random；</li>\r	<li>创建实例格式：Random 变量名 = new Random();</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rimport java.util.Random;\r\rpublic class RandomDemo {\r	public static void main(String[] args) {\r		// 创建Random类的实例\r		Random r = new Random(); \r		// 得到0-100范围内的随机整数，将产生的随机整数赋值给i变量\r		int i = r.nextInt(100); \r		//得到0.0-1.0范围内的随机小数，将产生的随机小数赋值给d变量\r		double d = r.nextDouble(); \r		System.out.println(i); \r		System.out.println(d); \r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(76, '通过刷新网页实现页面的跳转', '76', 1489655100, 1492354761, '<p>本分析如何使用刷新标签实现网页的跳转。</p>\r<!--more-->\r\r<p>在网站根目录下创建index.html文件即可，代码如下：</p>\r\r<pre class="brush:java;">\r&lt;html&gt;  \r&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.oliver.ren/&quot;&gt;  \r&lt;/html&gt;  </pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 121),
(529, '引用数据类型', '529', 1515723060, 1553955775, '<p>本文记录Java学习过程中遇到的引用数据类型～</p>\r<!--more-->\r\r<p>引用数据类型的使用：</p>\r\r<p>与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。</p>\r\r<pre class="brush:java;">\r数据类型  变量名  =  new 数据类型();</pre>\r\r<p>每种引用数据类型都有其功能，我们可以调用该类型实例的功能;</p>\r\r<pre class="brush:java;">\r变量名.方法名()</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(75, '如何通过shell脚本修改crontab', '75', 1489654740, 1492407713, '<p>本文分享如何使用shell脚本修改crontab。</p>\r<!--more-->\r\r<p>我们知道可以使用crontab -e来修改crontab，但这个修改是通过调用vi编辑器来完成的，这个是没有办法在shell脚本中调用的。</p>\r\r<p>其实，我们可以通过先导出crontab的配置文件，修该配置文件，然后再导入配置文件来实现shell脚本修改crontab。</p>\r\r<pre class="brush:bash;">\rcrontab -l &gt; /tmp/crontable\recho &#39;* * * * * some-command &gt; /dev/null 2&gt;&amp;1&#39; &gt;&gt; /tmp/crontable\rcrontab /tmp/crontable</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 131),
(527, '三元运算符', '527', 1515641340, 1515641543, '<p>本文记录Java学习过程中遇到的三元运算符～</p>\r<!--more-->\r\r<p>使用格式：</p>\r\r<ul>\r	<li>(条件表达式)？表达式1：表达式2；</li>\r</ul>\r\r<p>运算规则：</p>\r\r<ul>\r	<li>先判断条件表达式的值，若为true，运算结果为表达式1；若为false，运算结果为表达式2。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r方式一：\r	System.out.println( 3&gt;2 ? &ldquo;正确&rdquo; : &ldquo;错误&rdquo; ); \r// 三元运算符运算后的结果为true，运算结果为表达式1的值&ldquo;正确&rdquo;，然后将结果&ldquo;正确&rdquo;，在控制台输出打印\r\r方式二：\r	int a = 3;\r	int b = 4;\r	String result = (a==b) ? &ldquo;相等&rdquo; : &ldquo;不相等&rdquo;;  \r//三元运算符运算后的结果为false，运算结果为表达式2的值&ldquo;不相等&rdquo;，然后将结果赋值给了变量result\r\r方式三：\r	int n = (3&gt;2 &amp;&amp; 4&gt;6) ? 100 : 200;\r	//三元运算符运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(528, '运算符优先级', '528', 1515645991, 1515645991, '<p>本文记录Java学习过程中遇到的运算符优先级～</p>\r\r<!--more-->\r\r<p>优先级顺序如下（从高到低）：</p>\r\r<ol>\r	<li>括号 ()、[]</li>\r	<li>正负号 +、-</li>\r	<li>自增自减，非 ++、--、!</li>\r	<li>乘除，取余 *、/、%</li>\r	<li>加减 +、-</li>\r	<li>移位运算 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</li>\r	<li>大小关系 &gt;、&gt;=、&lt;、&lt;=</li>\r	<li>相等关系 ==、!=</li>\r	<li>按位与 &amp;</li>\r	<li>按位异或 ^</li>\r	<li>按位或 |</li>\r	<li>逻辑与 &amp;&amp;</li>\r	<li>逻辑或 ||</li>\r	<li>条件运算 ?:</li>\r	<li>赋值运算 =、+=、-=、*=、/=、%=</li>\r	<li>位赋值运算 &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(572, 'method.png', 'method-png-1', 1517055369, 1517055369, 'a:5:{s:4:"name";s:10:"method.png";s:4:"path";s:35:"/usr/uploads/2018/01/3576681127.png";s:4:"size";i:395348;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 571, 0),
(433, 'Shell脚本范例（八）——筛选符合长度的单词', '433', 1511963580, 1512391826, '<p>本文分享常用的一些Shell脚本的例子，这是第八篇&mdash;&mdash;筛选符合长度的单词。</p>\r<!--more-->\r\r<p>要求：利用for循环打印下面这句话中字母数不超过6的单词。</p>\r\r<pre class="brush:bash;">\rI am oliver who is learning linux shell scripts...</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rarr=(I am oliver who is learning linux shell scripts...)\r\rfor ((i=0;i&lt;${#arr[*]};i++))\rdo\r    if [${#arr[$i]} -lt 6 ]\r    then\r        echo &quot;${arr[$i]}&quot;\r    fi\rdone\r\recho -----------------------\r\rfor word in ${arr[*]}\rdo\r    if [ `expr length $word` -lt 6 ]\r    then\r        echo $word\r    fi\rdone</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rfor word in I am oliver who is learning linux shell scripts...\rdo\r    if [ `echo $word|wc -L` -lt 6 ]\r    then\r        echo $word\r    fi\rdone\r\rchars=&quot;I am oliver who is learning linux shell scripts...&quot;\r\rfor word in $chars\rdo\r    if [ `echo $word|wc -L` -lt 6 ]\r    then\r        echo $word\r    fi\rdone</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rchars=&quot;I am oliver who is learning linux shell scripts...&quot;\r\recho $chars|awk &#39;{for(i=1;i&lt;=NF;i++) if(length($i)&lt;=6) print $i}&#39;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 131),
(526, '&amp;和|与&amp;&amp;和||的区别', '526', 1515639469, 1515639469, '<p>本文简单的说下这两对符号的区别～</p>\r\r<!--more-->\r\r<p>&amp;和|：这两个符号是对两个二进制数进行位的操作，不论左右两边是什么表达式，都会先被计算出二进制的数值结果，然后再进行运算；</p>\r\r<p>&amp;&amp;和||：这两个符号是对boolean类型的两个值进行比较，为了提高运行效率，会有短路运算的操作。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(518, 'operator.png', 'operator-png', 1515582404, 1515582404, 'a:5:{s:4:"name";s:12:"operator.png";s:4:"path";s:34:"/usr/uploads/2018/01/106575422.png";s:4:"size";i:138014;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 519, 0),
(519, '算数运算符', '519', 1515582480, 1515584569, '<p>本文记录Java学过过程中遇到的算数运算符～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/106575422.png" style="width: 600px; height: 445px;" /></p>\r\r<p>注意事项：</p>\r\r<ol>\r	<li>加法运算符在连接字符串时要注意，只有直接与字符串相加才会转成字符串；</li>\r	<li>除法&ldquo;/&rdquo;当两边为整数时，取整数部分，舍余数。当其中一边为浮点型时，按正常规则相除；</li>\r	<li>&ldquo;%&rdquo;为整除取余符号，小数取余没有意义。结果符号与被取余符号相同；</li>\r	<li>整数做被除数，0不能做除数，否则报错。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class OperatorTest {\r	public static void main(String[] args) {\r		/*\r		 * 常量使用算数运算符\r		 */\r		System.out.println(10+20);\r		\r		/*\r		 * 变量使用算数运算符\r		 */\r		int x = 10;\r		int y = 20;\r		//&quot;+&quot;作为加法运算使用\r		int z = x + y; \r		//&quot;+&quot;作为连接字符串使用\r		System.out.println(&quot;x=&quot;+x);\r		System.out.println(&quot;y=&quot;+y);\r		System.out.println(&quot;z=&quot;+z);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(522, 'compare.png', 'compare-png', 1515637858, 1515637858, 'a:5:{s:4:"name";s:11:"compare.png";s:4:"path";s:35:"/usr/uploads/2018/01/2808613419.png";s:4:"size";i:100507;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 523, 0),
(523, '比较运算符', '523', 1515637980, 1515638018, '<p>本文记录Java学习过程中遇到的比较运算符～</p>\r<!--more-->\r\r<p>比较运算符，又叫关系运算符，它是用来判断两个操作数的大小关系及是否相等关系的，结果是布尔值true或者false。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2808613419.png" style="width: 600px; height: 262px;" /></p>\r\r<p>注意事项：</p>\r\r<ul>\r	<li>赋值运算符的 = 符号，是用来将 = 符号右边的值，赋值给 = 符号左边的变量；</li>\r	<li>比较运算符的 == 符号，是用来判断 == 符号 左右变量的值是否相等的。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rint a = 3;\rint b = 4;\rSystem.out.println( a=b );\rSystem.out.println( a==b );\r\r输出为：\r4\rfalse</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(524, 'logic.png', 'logic-png', 1515638165, 1515638165, 'a:5:{s:4:"name";s:9:"logic.png";s:4:"path";s:35:"/usr/uploads/2018/01/1337732155.png";s:4:"size";i:105471;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 525, 0),
(525, '逻辑运算符', '525', 1515638295, 1515638295, '<p>本文记录Java学习过程中遇到的逻辑运算符～</p>\r\r<!--more-->\r\r<p>逻辑运算符，它是用于布尔值进行运算的，运算的最终结果为布尔值true或false。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/1337732155.png" style="width: 600px; height: 262px;" /></p>\r\r<p>常见用法：</p>\r\r<ul>\r	<li>逻辑运算符通常连接两个其他表达式计算后的布尔值结果；</li>\r	<li>当使用短路与或者短路或时，只要能判断出结果则后边的部分就不再判断。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rboolean b = 100&gt;10;\rboolean b2 = false;\rSystem.out.println(b&amp;&amp;b2); // 打印结果为 false\rSystem.out.println(b||b2); //打印结果为 true\rSystem.out.println(!b2); //打印结果为 true\rSystem.out.println(b &amp;&amp; 100&gt;10); //打印结果为 true，本行结果的计算方式稍后讲解运算符优先级时解答</pre>\r\r<p>总结：</p>\r\r<ul>\r	<li>短路与&amp;&amp;:参与运算的两边数据，有false，则运算结果为false；</li>\r	<li>短路或||:参与运算的两边数据，有true，则运算结果为true；</li>\r	<li>逻辑非! : 参与运算的数据，原先是true则变成false，原先是false则变成true。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 154),
(90, '运维工程师重要的几个习惯', '90', 1489754040, 1511880540, '<p>本文分享运维工程师应该具备的几个优秀习惯。</p>\r<!--more-->\r\r<p>1.操作前备份；</p>\r\r<p>2.操作后对比检查；</p>\r\r<p>3.服务重新启动前测试语法；</p>\r\r<p>4.服务重新加载，加载后及时检查；</p>\r\r<p>5.使用find替代rm。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 115),
(497, '编写HelloWorld程序', '497', 1515300780, 1515301206, '<p>本文记录编写HelloWorld程序的过程～</p>\r<!--more-->\r\r<p>编写步骤</p>\r\r<ol>\r	<li>创建一个普通文本文件，将其修改为.java文件。</li>\r	<li>完成模板代码：</li>\r</ol>\r\r<pre class="brush:java;">\rpublic class HelloWorld{ \r    public static void main(String[] args) { \r        System.out.println(&quot;Hello World!&quot;); \r    }\r } </pre>\r\r<p>实际开发步骤</p>\r\r<ol>\r	<li>定义类</li>\r	<li>写main方法</li>\r	<li>写输出语句(注意：下面的代码是原代码，是不能运行的)</li>\r</ol>\r\r<pre class="brush:java;">\rpublic class HelloWorld { \r    public static void main(String[] args) { \r        System.out.println(&quot;HelloWorld&quot;); \r    }\r} </pre>\r\r<p>注意：</p>\r\r<ol>\r	<li>不要隐藏文件的扩展名</li>\r	<li>类名和文件名要保持一致</li>\r</ol>\r\r<p>Java代码的编写执行过程</p>\r\r<ol>\r	<li>源文件：编写Java源文件（我们也称之为源代码文件），它的扩展名为.java；</li>\r	<li>编译：然后通过编译器把源文件编译成字节码文件，字节码文件扩展名为.class(javac HelloWorld.java)；</li>\r	<li>运行：最后使用解释器来运行字节码文件(java HelloWorld)。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(498, '代码注释', '498', 1515308100, 1515308137, '<p>本文记录在Java学习过程中的代码注释～</p>\r<!--more-->\r\r<p>定义：用来解释和说明程序的文字，注释是不会被执行的 。</p>\r\r<p>分类：</p>\r\r<ol>\r	<li>单行注释 //注释内容</li>\r	<li>多行注释 /*注释内容*/</li>\r	<li>文档注释 /**注释内容*/</li>\r</ol>\r\r<p>注意：</p>\r\r<ol>\r	<li>对于单行和多行注释，被注释的文字，不会被JVM解释执行；</li>\r	<li>对于文档注释，可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档；</li>\r	<li>单行注释可以嵌套使用，多行注释不能嵌套使用</li>\r</ol>\r\r<p>案例代码</p>\r\r<ol>\r	<li>实现了一个Java的HelloWorld程序</li>\r</ol>\r\r<p>实现步骤：</p>\r\r<ol>\r	<li>定义类</li>\r	<li>定义主方法</li>\r	<li>一条命令，控制台输出了HelloWorld</li>\r</ol>\r\r<pre class="brush:java;">\rpublic class HelloWorld{ \r    //main主方法，固定格式，程序的入口点 \r    public static void main(String[] args){ \r        //系统 输出 打印 打印的内容 \r        System.out.println(&quot;HelloWorld&quot;); \r    } \r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(503, '常量', '503', 1515395760, 1515396497, '<p>本文记录Java学习过程中的常量～</p>\r<!--more-->\r\r<p>常量的定义：常量就是不变的数据量, 在程序执行的过程中其值不可以发生改变。</p>\r\r<p>常量分类：</p>\r\r<p>1.整数类型</p>\r\r<ul>\r	<li>十进制表示方式：正常数字 如 13、25等；</li>\r	<li>二进制表示方式：以0b(0B)开头，如0b1011 、0B1001；</li>\r	<li>十六进制表示方式：以0x(0X)开头 数字以0-9及A-F组成 如0x23A2、0xa、0x10 ；</li>\r	<li>八进制表示方式：以0开头 如01、07、0721 。</li>\r</ul>\r\r<p>2.小数类型</p>\r\r<ul>\r	<li>如1.0、-3.15、3.168等；</li>\r</ul>\r\r<p>3.布尔类型</p>\r\r<ul>\r	<li>如true、false；</li>\r</ul>\r\r<p>4.字符类型</p>\r\r<ul>\r	<li>如&#39;a&#39;，&#39;A&#39;, &#39;0&#39;, &#39;家&#39;；</li>\r	<li>字符必须使用&lsquo;&rsquo;包裹，并且其中只能且仅能包含一个字符；</li>\r</ul>\r\r<p>5.字符串类型</p>\r\r<ul>\r	<li>字符串String类型是一种引用类型，我们先了解作为常量类型的使用方式；</li>\r	<li>如&ldquo;我爱Java&rdquo;，&ldquo;0123&rdquo;，&ldquo;&rdquo;，&ldquo;null&rdquo;；</li>\r	<li>字符串必须使用&ldquo;&rdquo;包裹，其中可以包含0~N个字符。</li>\r</ul>\r\r<p>代码案例</p>\r\r<pre class="brush:java;">\r       /*\r	   Demo_1类，演示Java中的所有类型的常量\r	   程序当中输出：\r		 输出整数常量\r		 小数常量\r		 布尔常量\r		 字符常量\r		 字符串常量\r	*/\r	public class Demo_1{\r		public static void main(String[] args){\r			//输出整数 十进制\r			System.out.println(50);\r			\r			//输出整数，二进制, 数字开头0B\r			System.out.println(0B11);\r			\r			//输出整数，八进制，数字开头0\r			System.out.println(051);\r			\r			//输出整数，十六进制，数字开头0X  0-9 A-F\r			System.out.println(0XE);\r			\r			//输出浮点数据\r			System.out.println(5.0);\r			\r			//输出布尔数据，只有2个值，true，false 关键字\r			System.out.println(true);\r			System.out.println(false);\r			\r			//输出字符常量，单引号包裹，只能写1个字符\r			System.out.println(&#39;a&#39;);\r			\r			//输出字符串常量，双引号包裹，可以写0-n个字符\r			System.out.println(&quot;HelloWorld&quot;);\r		}\r	}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(432, 'Shell脚本范例（七）——MySQL分库分表备份', '432', 1511962260, 1512391848, '<p>本文分享常用的一些Shell脚本的例子，这是第七篇&mdash;&mdash;MySQL分库分表备份。</p>\r<!--more-->\r\r<p>要求：请用脚本实现对MySQL数据库的分库分表备份。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rPATH=&quot;/usr/local/mysql/bin:$PATH&quot;\rDBPATH=/tmp/backup\rMYUSER=root\rMYPASS=password\rSOCKET=/usr/local/mysql/data/mysql.sock\rMYCMD=&quot;mysql -u$MYUSER -p$MYPASS -S $SOCKET&quot;\rMYDUMP=&quot;mysqldump -u$MYUSER -p$MYPASS -S $SOCKET&quot;\r\r[ ! -d &quot;$DBPATH&quot; ]\r\rfor dbname in `$MYCMD -e &quot;show databases;&quot;|sed &#39;1,2d&#39;|egrep -v &quot;mysql|schema&quot;`\rdo\r    mkdir -p $DBPATH/${dbname}_$(date +%F)\r    for tbname in `$MYCMD -e &quot;show tables from $dbname;&quot;|sed &#39;1d&#39;`\r    do\r        $MYDUMP $dbname $tbname|gzip &gt; $DBPATH/${dbname}_$(date +%F)/${dbname_${tbname}.sql.gz\r    done\rdone</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 135),
(92, '服务器的电源的重要性', '92', 1489764180, 1511880560, '<p>本文介绍下电脑的电源。</p>\r<!--more-->\r\r<p>功能：保障电脑的电源供应。</p>\r\r<p>作用：一个合格的电源对电脑的作用是至关重要的。劣质的电源不仅直接影响电脑的正常的使用，对主板、显卡等其他设备造成伤害，而且这种电源所产生的的电磁辐射对人身健康也构成了潜在的威胁。在服务器领域，电源的作用更加重要，因此，服务器一般都提供双电源。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(93, '服务器IO各层次性能汇总', '93', 1489799760, 1492407654, '<p>本文分享服务器每个IO设备的延时和带宽。</p>\r<!--more-->\r\r<p>1.CPU-Cache（L1,L2,L3）</p>\r\r<p>延时：0.5-15ns</p>\r\r<p>带宽：20-60GB/s</p>\r\r<p>2.内存</p>\r\r<p>延时：30-100ns</p>\r\r<p>带宽：2-12GB/s</p>\r\r<p>3.SSSD硬盘</p>\r\r<p>延时：10us-1ms</p>\r\r<p>带宽：50MB-2GB/s</p>\r\r<p>4.普通硬盘</p>\r\r<p>延时：5-20ms</p>\r\r<p>带宽：50-200MB/s</p>\r\r<p>5.网卡</p>\r\r<p>延时：100us-1ms</p>\r\r<p>带宽：10MB-10GB/s</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(94, 'Dell服务器常见的品牌', '94', 1489801380, 1492407647, '<p>本文分享戴尔服务器常见的几个品牌。</p>\r<!--more-->\r\r<p>首先说一个基本概念，1U是4.45cm。</p>\r\r<p><strong>2010年以前</strong></p>\r\r<p>1U：1850,1950</p>\r\r<p>2U：2850,2950</p>\r\r<p><strong>2010-2013</strong></p>\r\r<p>1U：R410，R610</p>\r\r<p>2U：R710</p>\r\r<p><strong>2014-2016</strong></p>\r\r<p>1U：R420，R430，R620，R630</p>\r\r<p>2U：R720，R730</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(95, '程序和进程的区别', '95', 1489802340, 1491014347, '<p>本文分享程序和进程的区别。</p>\r<!--more-->\r\r<p>程序：c/php/java，代码文件，静态的，放在磁盘里的数据。</p>\r\r<p>进程：正在运行着的程序，进程运行就是系统把程序放在内存里执行。</p>\r\r<p>守护进程：持续保持运行着的程序。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 115),
(96, 'buffer和cache的区别', '96', 1489803480, 1492407639, '<p>本文介绍buffer和cache的区别。</p>\r<!--more-->\r\r<p>1.写入数据到内存里，这个数据的内存空间称为缓冲区（buffer）；</p>\r\r<p>2.从内存读取数据，这个存数据的内存空间称为缓存区（cache）。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(100, '001.png', '001-png', 1490010761, 1490010761, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2017/03/3681570136.png";s:4:"size";i:5125;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 106, 0),
(101, '002.png', '002-png', 1490010797, 1490010797, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2017/03/1983080691.png";s:4:"size";i:10271;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 106, 0),
(102, '003.png', '003-png', 1490010849, 1490010849, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:34:"/usr/uploads/2017/03/505036819.png";s:4:"size";i:11393;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 106, 0),
(103, '007.png', '007-png', 1490010927, 1490010927, 'a:5:{s:4:"name";s:7:"007.png";s:4:"path";s:35:"/usr/uploads/2017/03/3292249176.png";s:4:"size";i:10499;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 106, 0),
(104, '005.png', '005-png', 1490011074, 1490011074, 'a:5:{s:4:"name";s:7:"005.png";s:4:"path";s:35:"/usr/uploads/2017/03/4091315169.png";s:4:"size";i:7350;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 106, 0),
(105, '006.png', '006-png', 1490011116, 1490011116, 'a:5:{s:4:"name";s:7:"006.png";s:4:"path";s:34:"/usr/uploads/2017/03/710533344.png";s:4:"size";i:31636;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 106, 0),
(106, '如何通过grub重置CentOS7的root密码', '106', 1490011080, 1490011167, '<p>本文介绍如何通过grub进入单用户模式重置Centos7的root密码。</p>\r<!--more-->\r\r<p>1.在开机进入grub菜单的时候，选择第一项，按e进入编辑模式。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/03/3681570136.png" style="width: 730px; height: 408px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/03/1983080691.png" style="width: 732px; height: 408px;" /></p>\r\r<p>2.是用方向键向下翻，找到linux16开头的那一行。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/03/505036819.png" /></p>\r\r<p>3.将ro改为rw init=/sysroot/bin/sh。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/03/3292249176.png" style="width: 802px; height: 404px;" /></p>\r\r<p>4.现在按下Ctrl+x，使用单用户模式启动。</p>\r\r<p>5.输入chroot /sysroot，回车。</p>\r\r<p>6.使用passwd root重置root的密码为123456。</p>\r\r<p>7.使用touch /.autorelabel更新系统信息。</p>\r\r<p>8.使用exit退出chroot。</p>\r\r<p>9.使用reboot重启系统。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/03/4091315169.png" /></p>\r\r<p>10.成功使用密码123456登录root账号。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/03/710533344.png" style="width: 472px; height: 368px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 107),
(107, 'Linux常用命令——clear与reset', '107', 1490013420, 1490013698, '<p>在windows的DOS操作界面，清屏的命令是cls，那么在linux里面的清屏命令是什么呢？下面分享几种linux下清屏命令的方法。</p>\r<!--more-->\r\r<h3>1.clear</h3>\r\r<p><strong>作用：</strong></p>\r\r<p>这个命令将会刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。一般都会用这个命令。</p>\r\r<p><strong>参数：</strong></p>\r\r<p>使用快捷键Ctrl+l来替代clear</p>\r\r<p><strong>实例：</strong></p>\r\r<p>将cls变成clear的一个别名（不推荐，因为有快捷键）</p>\r\r<pre class="brush:bash;">\ralias cls=&#39;clear&#39;\rcls</pre>\r\r<h3>2.reset</h3>\r\r<p><strong>作用：</strong></p>\r\r<p>Linux reset命令其实和 tset 是一同个命令，它的用途是设定终端机的状态。一般而言，这个命令会自动的从环境变数、命令列或是其它的组态档决定目前终端机的型态。如果指定型态是 &#39;?&#39; 的话，这个程序会要求使用者输入终端机的型别。<br />\r由于这个程序会将终端机设回原始的状态，除了在 login 时使用外，当系统终端机因为程序不正常执行而进入一些奇怪的状态时，你也可以用它来重设终端机o 例如不小心把二进位档用 cat 指令进到终端机，常会有终端机不再回应键盘输入，或是回应一些奇怪字元的问题。此时就可以用 reset 将终端机回复至原始状态。</p>\r\r<p><strong>参数：</strong></p>\r\r<p>-p 将终端机类别显示在屏幕上，但不做设定的动作。这个命令可以用来取得目前终端机的类别。<br />\r-e ch 将 erase 字元设成 ch<br />\r-i ch 将中断字元设成 ch<br />\r-k ch 将删除一行的字元设成 ch<br />\r-I 不要做设定的动作，如果没有使用选项 -Q 的话，erase、中断及删除字元的目前值依然会送到屏幕上。<br />\r-Q 不要显示 erase、中断及删除字元的值到屏幕上。<br />\r-r 将终端机类别印在屏幕上。<br />\r-s 将设定 TERM 用的命令用字串的型式送到终端机中，通常在 .login 或 .profile 中用。</p>\r\r<p><strong>实例：</strong></p>\r\r<p>让使用者输入一个终端机型别并将终端机设到该型别的预设状态</p>\r\r<pre class="brush:java;">\r# reset ?</pre>\r\r<p>将 erase 字元设定 control-h</p>\r\r<pre class="brush:bash;">\r# reset -e ^B</pre>\r\r<p>将设定用的字串显示在屏幕上</p>\r\r<pre class="brush:bash;">\r# reset -s\rErase is control-B (^B).\rKill is control-U (^U).\rInterrupt is control-C (^C).\rTERM=xterm;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 133),
(108, 'Linux常用命令——pwd', '108', 1490014020, 1490014307, '<p>pwd命令用于显示工作目录，是print-working-directory的缩写。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rpwd [--help][--version]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>--help 在线帮助<br />\r--version 显示版本信息</p>\r\r<p><strong>实例</strong></p>\r\r<p>查看当前所在目录</p>\r\r<pre class="brush:bash;">\r# pwd\r/home/oliver </pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 122),
(109, 'Linux常用命令——mkdir', '109', 1490014500, 1490014643, '<p>本文介绍Linux常用命令mkdir，mkdir是make-directory的缩写。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于建立子目录。</p>\r\r<p>语法</p>\r\r<pre class="brush:bash;">\rmkdir [-p] dirName</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-p 确保目录名称存在，不存在的就建一个</p>\r\r<p>实例</p>\r\r<p>在工作目录下，建立一个名为 AAA 的子目录</p>\r\r<pre class="brush:bash;">\rmkdir AAA</pre>\r\r<p>在工作目录下的 BBB 目录中，建立一个名为 Test 的子目录。 若 BBB 目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 BBB目录不存在，则产生错误。）</p>\r\r<pre class="brush:bash;">\rmkdir -p BBB/Test</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(110, 'Linux常用命令——rmdir', '110', 1490014560, 1490014846, '<p>本文介绍rmdir命令，rmdir是remove-directory的缩写。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>删除空的目录</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rrmdir [-p] dirName</pre>\r\r<p><strong>参数</strong></p>\r\r<pre class="brush:bash;">\r-p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除</pre>\r\r<p><strong>实例</strong></p>\r\r<p>将工作目录下，名为 AAA 的子目录删除</p>\r\r<pre class="brush:bash;">\rrmdir AAA</pre>\r\r<p>在工作目录下的 BBB 目录中，删除名为 Test 的子目录。若 Test 删除后，BBB 目录成为空目录，则 BBB 亦予删除</p>\r\r<pre class="brush:bash;">\rrmdir -p BBB/Test</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(111, 'Linux常用命令——whoami', '111', 1490064217, 1490064217, '<p>本文介绍whoami命令，whoami命令用于显示自身用户名称。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>显示自身的用户名称，本指令相当于执行&quot;id -un&quot;指令。</p>\r\r<p>语法</p>\r\r<pre class="brush:bash;">\rwhoami [--help][--version]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>--help 在线帮助<br />\r--version 显示版本信息</p>\r\r<p><strong>实例</strong></p>\r\r<p>显示用户名</p>\r\r<pre class="brush:bash;">\r# whoami \roliver</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(112, 'Linux常用命令——who', '112', 1490064540, 1490065287, '<p>本文介绍who命令，该命令管理员比较常用。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rwho - [husfV] [user]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-h : 不要显示标题列<br />\r-u : 不要显示使用者的动作/工作<br />\r-s : 使用简短的格式来显示<br />\r-f : 不要显示使用者的上线位置<br />\r-V : 显示程序版本</p>\r\r<p><strong>实例</strong></p>\r\r<p>显示当前登录系统的用户</p>\r\r<pre class="brush:bash;">\r# who\rroot   tty7     2014-05-13 12:12 (:0)\rroot   pts/0    2014-05-14 17:09 (:0.0)\rroot   pts/1    2014-05-14 18:51 (192.168.1.17)\rroot   pts/2    2014-05-14 19:48 (192.168.1.17)</pre>\r\r<p>显示标题栏</p>\r\r<pre class="brush:bash;">\r# who -H\rNAME   LINE     TIME       COMMENT\rroot   tty7     2014-05-13 12:12 (:0)\rroot   pts/0    2014-05-14 17:09 (:0.0)\rroot   pts/1    2014-05-14 18:51 (192.168.1.17)\rroot   pts/2    2014-05-14 19:48 (192.168.1.17)</pre>\r\r<p>显示用户登录来源</p>\r\r<pre class="brush:bash;">\r# who -l -H\rNAME   LINE     TIME       IDLE     PID COMMENT\rLOGIN  tty4     2014-05-13 12:11        852 id=4\rLOGIN  tty5     2014-05-13 12:11        855 id=5\rLOGIN  tty2     2014-05-13 12:11        862 id=2\rLOGIN  tty3     2014-05-13 12:11        864 id=3\rLOGIN  tty6     2014-05-13 12:11        867 id=6\rLOGIN  tty1     2014-05-13 12:11       1021 id=1</pre>\r\r<p>显示终端属性</p>\r\r<pre class="brush:bash;">\r# who -T -H\rNAME    LINE     TIME       COMMENT\rroot   + tty7     2014-05-13 12:12 (:0)\rroot   + pts/0    2014-05-14 17:09 (:0.0)\rroot   - pts/1    2014-05-14 18:51 (192.168.1.17)\rroot   - pts/2    2014-05-14 19:48 (192.168.1.17)</pre>\r\r<p>只显示当前用户</p>\r\r<pre class="brush:bash;">\r# who -m -H\rNAME   LINE     TIME       COMMENT\rroot   pts/1    2014-05-14 18:51 (192.168.1.17)</pre>\r\r<p>精简模式显示</p>\r\r<pre class="brush:bash;">\r# who -q\rroot root root root\r# users=4</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(113, 'Linux常用命令——w', '113', 1490064840, 1502676228, '<p>本文介绍w命令，该命令管理员比较常用。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rwho - [husfV] [user]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-h : 不要显示标题列<br />\r-u : 不要显示使用者的动作/工作<br />\r-s : 使用简短的格式来显示<br />\r-f : 不要显示使用者的上线位置<br />\r-V : 显示程序版本</p>\r\r<p><strong>实例</strong></p>\r\r<p>显示当前登录系统的用户</p>\r\r<p>#who<br />\rroot &nbsp; tty7 &nbsp; &nbsp; 2014-05-13 12:12 (:0)<br />\rroot &nbsp; pts/0 &nbsp; &nbsp;2014-05-14 17:09 (:0.0)<br />\rroot &nbsp; pts/1 &nbsp; &nbsp;2014-05-14 18:51 (192.168.1.17)<br />\rroot &nbsp; pts/2 &nbsp; &nbsp;2014-05-14 19:48 (192.168.1.17)</p>\r\r<p>显示标题栏</p>\r\r<pre class="brush:bash;">\r# who -H\rNAME   LINE     TIME       COMMENT\rroot   tty7     2014-05-13 12:12 (:0)\rroot   pts/0    2014-05-14 17:09 (:0.0)\rroot   pts/1    2014-05-14 18:51 (192.168.1.17)\rroot   pts/2    2014-05-14 19:48 (192.168.1.17)</pre>\r\r<p>显示用户登录来源</p>\r\r<pre class="brush:bash;">\r# who -l -H\rNAME   LINE     TIME       IDLE     PID COMMENT\rLOGIN  tty4     2014-05-13 12:11        852 id=4\rLOGIN  tty5     2014-05-13 12:11        855 id=5\rLOGIN  tty2     2014-05-13 12:11        862 id=2\rLOGIN  tty3     2014-05-13 12:11        864 id=3\rLOGIN  tty6     2014-05-13 12:11        867 id=6\rLOGIN  tty1     2014-05-13 12:11       1021 id=1</pre>\r\r<p>显示终端属性</p>\r\r<pre class="brush:bash;">\r# who -T -H\rNAME    LINE     TIME       COMMENT\rroot   + tty7     2014-05-13 12:12 (:0)\rroot   + pts/0    2014-05-14 17:09 (:0.0)\rroot   - pts/1    2014-05-14 18:51 (192.168.1.17)\rroot   - pts/2    2014-05-14 19:48 (192.168.1.17)</pre>\r\r<p>只显示当前用户</p>\r\r<pre class="brush:bash;">\r# who -m -H\rNAME   LINE     TIME       COMMENT\rroot   pts/1    2014-05-14 18:51 (192.168.1.17)</pre>\r\r<p>精简模式显示</p>\r\r<pre class="brush:bash;">\r# who -q\rroot root root root\r# users=4</pre>\r\r<p><strong>备注：每一列的含义</strong></p>\r\r<p>USER &nbsp; &nbsp; &nbsp;显示登陆用户帐号名(用户重复登陆，该帐号也会重复出现)。<br />\rTTY &nbsp; &nbsp; &nbsp; &nbsp; 用户登陆所用的终端。<br />\rFROM &nbsp; &nbsp; 显示用户在何处登陆系统。<br />\rLOGIN@ 是LOGIN AT的意思，表示登陆进入系统的时间。<br />\rIDLE &nbsp; &nbsp; &nbsp; &nbsp;用户空闲时间，从用户上一次任务结束后，开会记时。<br />\rJCPU &nbsp; &nbsp; &nbsp; 以终端代号来区分，表示在某段时间内，所有与该终端相关的进程任务所耗费的CPU时间。<br />\rPCPU &nbsp; &nbsp; &nbsp;指WHAT域的任务执行后耗费的CPU时间。<br />\rWHAT &nbsp; &nbsp; &nbsp;表示当前执行的任务。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(114, 'Linux常用命令——cd', '114', 1490065500, 1490065562, '<p>本文介绍cd命令，cd是change-directory的缩写。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于切换当前工作目录至目标目录。</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rcd [dirName]</pre>\r\r<p><strong>实例</strong></p>\r\r<p>跳到 /usr/bin/</p>\r\r<pre class="brush:bash;">\rcd /usr/bin/</pre>\r\r<p>跳到自己的家目录</p>\r\r<pre class="brush:bash;">\rcd ~</pre>\r\r<p>跳到目前目录的上上两层</p>\r\r<pre class="brush:bash;">\rcd ../../</pre>\r\r<p>调到上次访问的目录</p>\r\r<pre class="brush:bash;">\rcd -</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(115, '常用的几个开源协议', '115', 1490242329, 1490242329, '<p>本文介绍几个常用的开源协议。</p>\r<!--more-->\r\r<h2>1.GPL许可协议(GNU General Public License)</h2>\r\r<p>只要软件中包含有其他GPL协议的产品或代码，那么该软件就必须也采用GPL许可协议且开源及免费，因此这个协议并不适合商用软件，但包括Linux系统在内的大多数的开源软件都是基于了这个协议，拥有极大的开源软件数量，具有以下特点：</p>\r\r<p><strong>复制自由</strong>：允许将软件复制到任何人的电脑中，并且不限制复制的数量。</p>\r\r<p><strong>传播自由</strong>：允许以各种形式进行传播。</p>\r\r<p><strong>收费传播</strong>：允许在各种媒介上出售该软件，但必需提前让买家知道这个软件是可以免费获得的，并解释收费的理由（一般来讲都是能够为用户提供某种服务，以技术服务的形式来收费）。</p>\r\r<p><strong>修改自由</strong>：允许开发人员增加或删除软件的功能，但必须依然基于GPL许可协议授权。</p>\r\r<h2>2.BSD许可协议(Berkeley Software Distribution)</h2>\r\r<p>使用该许可后将允许使用者使用、修改和重新发布代码，并且可以作为商业软件发布和销售，但需要满足下面的三个条件：</p>\r\r<p>1：如果再发布的软件中包含源代码，则源代码必需使用BSD许可协议。</p>\r\r<p>2：如果再发布的软件中只有二进制程序，则需要在相关文档或版权中声明原始代码中使用了BSD协议。</p>\r\r<p>3：不允许用原始软件的名字、作者或机构名称做市场推广。</p>\r\r<h2>3.Apache许可协议（Apache Licence Version）</h2>\r\r<p>同时为开发人员提供版权及专利许可，允许修改代码及再发布的自由，适合于商业软件，现在热门的Hadoop、apache(httpserver)、MongoDB等项目都是基于该许可，程序开发者要严格遵守下面的四个条件：</p>\r\r<p>1：该软件及其衍生品必须基于Apache许可协议。</p>\r\r<p>2：如果修改了源代码，需要在文档中声明。</p>\r\r<p>3：若软件是基于他人的源代码，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容。</p>\r\r<p>4：如果再发布的软件中有声明文件，则需在此文件中标注Apache许可协议及其他许可协议。</p>\r\r<h2>4.MPL许可协议（The Mozilla Public License）</h2>\r\r<p>相较于GPL许可协议，更加注重平衡的开发者对源代码的需求和收益。</p>\r\r<h2>5.MIT许可协议（Massachusetts Institute of Technology）</h2>\r\r<p>目前限制最少的开源许可协议之一，只需要程序的开发者在修改后的源代码中保留原作者的许可信息，所以比较适合于商业软件。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(116, '常用的几个rpm命令', '116', 1490243220, 1492407625, '<p>本文介绍几个常用的rpm命令。</p>\r<!--more-->\r\r<p>1.安装软件的命令格式:rpm -ivh filename.rpm</p>\r\r<p>2.升级软件的命令格式:rpm -Uvh filename.rpm</p>\r\r<p>3.卸载软件的命令格式:rpm -e filename.rpm</p>\r\r<p>4.查询软件的描述信息的命令格式:rpm -qpi filename.rpm</p>\r\r<p>5.列出软件的文件信息的命令格式:rpm -qpl filename.rpm</p>\r\r<p>6.查询文件属于那个RPM的命令格式:rpm -qf filename</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 117),
(117, 'yum的repo详解', '117', 1490243400, 1492407604, '<p>本文介绍repo文件中每行的意义。</p>\r<!--more-->\r\r<p>[rhel-media]: yum仓库唯一标识符，避免与其他仓库冲突。<br />\rname=oliver : yum仓库的名称描述，易于识别仓库用处。<br />\rbaseurl=file:///media/cdrom :提供方式包括FTP（ftp://..）、HTTP（http://..）、本地（file:///..）<br />\renabled=1 : 设置此源是否可用，1为可用，0为禁用。<br />\rgpgcheck=1 : 设置此源是否校验文件，1为校验，0为不校验。<br />\rgpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release :若为校验请指定公钥文件地址。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 143),
(118, '常用的几个yum命令', '118', 1490243700, 1492407597, '<p>本文分享几个常用的yum命令。</p>\r<!--more-->\r\r<p>1.yum repolist all</p>\r\r<p>列出所有仓库。</p>\r\r<p>2.yum list all</p>\r\r<p>列出仓库中所有软件包</p>\r\r<p>3.yum info 软件包名称</p>\r\r<p>查看软件包信息</p>\r\r<p>4.yum install 软件包名称</p>\r\r<p>安装软件包</p>\r\r<p>5.yum reinstall 软件包名称</p>\r\r<p>重新安装软件包</p>\r\r<p>6.yum update 软件包名称</p>\r\r<p>升级软件包</p>\r\r<p>7.yum remove 软件包</p>\r\r<p>移除软件包</p>\r\r<p>8.yum clean all</p>\r\r<p>清除所有仓库缓存</p>\r\r<p>9.yum check-update</p>\r\r<p>检查可更新的软件包</p>\r\r<p>10.yum grouplist</p>\r\r<p>查看系统中已经安装的软件包组</p>\r\r<p>11.yum groupinstall 软件包组</p>\r\r<p>安装指定的软件包组</p>\r\r<p>12.yum groupremove 软件包组</p>\r\r<p>移除指定的软件包组</p>\r\r<p>13.yum groupinfo 软件包组</p>\r\r<p>查询指定的软件包组信息</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(119, 'sysvinit与systemd的对应关系', '119', 1490244720, 1492407589, '<p>应该第一次使用CentOS7的时候，看到这个东西变了，就全懵逼了吧。</p>\r<!--more-->\r\r<p><strong>0级别</strong></p>\r\r<p>目标：runlevel0.target, poweroff.target</p>\r\r<p>作用：关机</p>\r\r<p><strong>1级别</strong></p>\r\r<p>目标：runlevel1.target, rescue.target</p>\r\r<p>作用：单用户模式</p>\r\r<p><strong>2级别</strong></p>\r\r<p>目标：runlevel2.target, multi-user.target</p>\r\r<p>作用：<span style="line-height: 20.8px;">多用户的文本界面</span></p>\r\r<p><strong>3级别</strong></p>\r\r<p>目标：runlevel3.target, multi-user.target</p>\r\r<p>作用：多用户的文本界面</p>\r\r<p><strong>4级别</strong></p>\r\r<p>目标：runlevel4.target, multi-user.target</p>\r\r<p>作用：<span style="line-height: 20.8px;">多用户的文本界面</span></p>\r\r<p><strong>5级别</strong></p>\r\r<p>目标：runlevel5.target, graphical.target</p>\r\r<p>作用：多用户的图形界面</p>\r\r<p><strong>6级别</strong></p>\r\r<p>目标：runlevel6.target, reboot.target</p>\r\r<p>作用：重启系统</p>\r\r<p><strong>emergency级别</strong></p>\r\r<p>目标：emergency.target</p>\r\r<p>作用：紧急Shell，用于系统紧急修复</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(121, '虚拟机常用的三个网络模式', '121', 1490245500, 1496909306, '<p>本文分享虚拟机常用的三个网络模式。</p>\r<!--more-->\r\r<p>1.NAT</p>\r\r<p>NAT（Network Address Translation，网络地址转换），NAT模式是比较简单的实现虚拟机上网的方式。简单地理解，NAT模式的虚拟机就是通过宿主机（物理计算机）上网和交换数据的。<br />\r在NAT模式下，虚拟机的网卡连接到宿主机的VMnet8上。此时系统的VMware-NAT-Service服务就充当了路由器，负责将虚拟机发送到VMnet8的包进行地址转换之后发送到实际的网络上，再将实际网络上返回的包进行地址转换后通过VMnet8发送给虚拟机。VMware-DHCP-Service负责为虚拟机分配IP地址。NAT网络类型的原理逻辑图如图1-18所示。<br />\rNAT网络特别适合家庭或学校里计算机直接连接网线的情况，当然办公室的局域网环境也是适合的，其优势是不会与其他物理主机IP冲突，且在没有路由器的环境下也可以通过SSH-NAT连接虚拟机学习，换了网络环境虚拟机IP等不受影响，推荐使用这种模式。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/06/3970595453.png" style="width: 600px; height: 385px;" /></p>\r\r<p>2.Bridged（网桥模式）</p>\r\r<p>网桥模式可以简单理解为通过物理主机网卡架设一座桥，从而连入实际的网络中。因此，虚拟机可以被分配与物理主机相同网段的独立IP，所有网络功能和网络中的真实机器几乎完全一样。网桥模式下的虚拟机和网内真实计算机所处的位置是一样的。<br />\r在Bridged模式下，计算机设备创建的虚拟机就像一台真正的计算机一样，它会直接连接到实际的网络上，逻辑上上网与宿主机（计算机设备）没有联系。<br />\rBridged网络类型特别适合于局域网环境，其优势是虚拟机像一台真正的主机一样，缺点是可能会与其他物理主机IP冲突，并且在与宿主机交换数据时，都会经过实际的路由器，当不考虑NAT模式的时候，就选择这个桥接模式，在桥接模式下换了网络环境后所有虚拟机的IP都会受影响。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/06/1499739776.png" style="width: 600px; height: 355px;" /></p>\r\r<p>3.Host-only（仅主机）</p>\r\r<p>在Host-only模式下，虚拟机的网卡会连接到宿主的VMnet1上，但宿主系统并不为虚拟机提供任何路由服务，因此虚拟机只能与宿主机进行通信，不能连接到实际网络上，即无法上网。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/06/849122180.png" style="width: 600px; height: 373px;" />​</p>\r\r<p>&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(129, 'man命令的常用操作按键', '129', 1490265120, 1492407549, '<p>本文介绍man命令的常用按键。</p>\r<!--more-->\r\r<p>1.空格键</p>\r\r<p>向下翻一页</p>\r\r<p>2.[Page Down]</p>\r\r<p><span style="line-height: 1.6em;">向下翻一页</span></p>\r\r<p><span style="line-height: 1.6em;">3.</span><span style="line-height: 1.6em;">[Page Up]</span></p>\r\r<p><span style="line-height: 1.6em;">向上翻一页</span></p>\r\r<p><span style="line-height: 1.6em;">4.</span><span style="line-height: 1.6em;">[HOME]</span></p>\r\r<p><span style="line-height: 1.6em;">直接前往首页</span></p>\r\r<p><span style="line-height: 1.6em;">5.[END]</span></p>\r\r<p><span style="line-height: 1.6em;">直接前往尾页</span></p>\r\r<p><span style="line-height: 1.6em;">6./关键词</span></p>\r\r<p><span style="line-height: 1.6em;">从上至下搜索某个关键词,如&quot;/linux&quot;</span></p>\r\r<p><span style="line-height: 1.6em;">7.?关键词</span></p>\r\r<p><span style="line-height: 1.6em;">从下至上搜索某个关键词,如&quot;?linux&quot;</span></p>\r\r<p><span style="line-height: 1.6em;">8.</span><span style="line-height: 1.6em;">n</span></p>\r\r<p><span style="line-height: 1.6em;">定位到下一个搜索到的关键词</span></p>\r\r<p><span style="line-height: 1.6em;">9.N</span></p>\r\r<p><span style="line-height: 1.6em;">定位到上一个搜索到的关键词</span></p>\r\r<p><span style="line-height: 1.6em;">10.q</span></p>\r\r<p><span style="line-height: 1.6em;">退出帮助文档</span></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 181),
(128, 'bash的四大优势', '128', 1490262060, 1492407560, '<p>本文介绍bash的四大优势。</p>\r<!--more-->\r\r<p>1.通过上下方向键来调取过往执行过的命令。</p>\r\r<p>2.命令或参数仅需输入前几位就可以用tab键补全。</p>\r\r<p>3.强大的批处理脚本。</p>\r\r<p>4.实用的环境变量。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(130, 'man帮助文档各个部分的解释', '130', 1490265360, 1492407541, '<p>本文分享man的帮助文档各个部分的意义解释。</p>\r<!--more-->\r\r<p>1.NAME</p>\r\r<p>命令的名称</p>\r\r<p>2.SYNOPSIS</p>\r\r<p>参数的大致使用方法</p>\r\r<p>3.DESCRIPTION</p>\r\r<p>介绍说明</p>\r\r<p>4.EXAMPLES</p>\r\r<p>演示（附带简单说明）</p>\r\r<p>5.OVERVIEW</p>\r\r<p>概述</p>\r\r<p>6.DEFAULTS</p>\r\r<p>默认的功能</p>\r\r<p>7.OPTIONS</p>\r\r<p>具体的可用选项（带介绍）</p>\r\r<p>8.ENVIRONMENT</p>\r\r<p>环境变量</p>\r\r<p>9.FILES</p>\r\r<p>用到的文件</p>\r\r<p>10.SEE ALSO</p>\r\r<p>相关的资料</p>\r\r<p>11.HISTORY</p>\r\r<p>维护历史与联系方式</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(131, 'Linux常用命令——date', '131', 1490266500, 1490267663, '<p>本文介绍date命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>显示或设置系统时间与日期</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\r#可用来显示系统日期或时间，以%为开头的参数为格式参数，可指定日期或时间的显示格式\rdate [-d &lt;字符串&gt;][-u][+%H%I%K%l%M%P%r%s%S%T%X%Z%a%A%b%B%c%d%D%j%m%U%w%x%y%Y%n%t] \r#可用来设置系统日期与时间，只有管理员才有设置日期与时间的权限\rdate [-s &lt;字符串&gt;][-u][MMDDhhmmCCYYss]\r#查看date命令的帮助与版本\rdate [--help][--version]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>%H 小时(以00-23来表示)<br />\r%I 小时(以01-12来表示)<br />\r%K 小时(以0-23来表示)<br />\r%l 小时(以0-12来表示)<br />\r%M 分钟(以00-59来表示)<br />\r%P AM或PM<br />\r%r 时间(含时分秒，小时以12小时AM/PM来表示)<br />\r%s 总秒数。起算时间为1970-01-01 00:00:00 UTC<br />\r%S 秒(以本地的惯用法来表示)<br />\r%T 时间(含时分秒，小时以24小时制来表示)<br />\r%X 时间(以本地的惯用法来表示)<br />\r%Z 市区<br />\r%a 星期的缩写<br />\r%A 星期的完整名称<br />\r%b 月份英文名的缩写<br />\r%B 月份的完整英文名称<br />\r%c 日期与时间。只输入date指令也会显示同样的结果<br />\r%d 日期(以01-31来表示)<br />\r%D 日期(含年月日)<br />\r%j 该年中的第几天<br />\r%m 月份(以01-12来表示)<br />\r%U 该年中的周数<br />\r%w 该周的天数，0代表周日，1代表周一，异词类推<br />\r%x 日期(以本地的惯用法来表示)<br />\r%y 年份(以00-99来表示)<br />\r%Y 年份(以四位数来表示)<br />\r%n 在显示时，插入新的一行<br />\r%t 在显示时，插入tab<br />\rMM 月份(必要)<br />\rDD 日期(必要)<br />\rhh 小时(必要)<br />\rmm 分钟(必要)<br />\rCC 年份的前两位数(选择性)<br />\rYY 年份的后两位数(选择性)<br />\rss 秒(选择性)<br />\r-d&lt;字符串&gt; 显示字符串所指的日期与时间。字符串前后必须加上双引号<br />\r-s&lt;字符串&gt; 根据字符串来设置日期与时间。字符串前后必须加上双引号<br />\r-u 显示GMT<br />\r--help 在线帮助<br />\r--version 显示版本信息</p>\r\r<p><strong>实例</strong></p>\r\r<p>设置日期时间</p>\r\r<pre class="brush:bash;">\r#设置成20170323，这样会把具体时间设置成空00:00:00\rdate -s 20170323\r#设置具体时间，不会对日期做更改\rdate -s 01:01:01\r#这样可以设置全部时间\rdate -s &ldquo;01:01:01 2008-05-23&Prime;\r#这样可以设置全部时间\rdate -s &ldquo;01:01:01 20080523&Prime; \r#这样可以设置全部时间\rdate -s &ldquo;2008-05-23 01:01:01&Prime;\r#这样可以设置全部时间\rdate -s &ldquo;20080523 01:01:01&Prime; </pre>\r\r<p>显示日期时间</p>\r\r<pre class="brush:bash;">\r#显示前一天的日期\rdate +%Y%m%d --date=&quot;+1 day&quot;\r#显示后一天的日期\rdate +%Y%m%d --date=&quot;-1 day&quot;\r#显示上一月的日期\rdate +%Y%m%d --date=&quot;-1 month&quot;\r#显示下一月的日期\rdate +%Y%m%d --date=&quot;+1 month&quot;\r#显示前一年的日期\rdate +%Y%m%d --date=&quot;-1 year&quot; \r#显示后一年的日期\rdate +%Y%m%d --date=&quot;+1 year&quot;</pre>\r\r<p>显示当前时间</p>\r\r<pre class="brush:bash;">\rdate\r2012年 12月 08日 星期六 08:31:35 CST\r\r date &#39;+%c&#39;\r2012年12月08日 星期六 08时34分44秒\r\rdate &#39;+%D&#39;\r12/08/12\r\rdate &#39;+%x&#39;\r2012年12月08日\r\rdate &#39;+%T&#39;\r08:35:36\r\rdate &#39;+%X&#39;\r08时35分54秒</pre>\r\r<p>显示日期和设定时间</p>\r\r<pre class="brush:bash;">\rdate &#39;+%c&#39;\r2012年12月08日 星期六 08时41分37秒\r\rdate --date 08:42:00\r2012年 12月 08日 星期六 08:42:00 CST\r\rdate &#39;+%c&#39; --date 08:45:00\r2012年12月08日 星期六 08时45分00秒</pre>\r\r<p>date -d参数使用</p>\r\r<pre class="brush:bash;">\rdate -d &quot;nov 22&quot;\r2012年 11月 22日 星期四 00:00:00 CST\r\rdate -d &#39;2 weeks&#39;\r2012年 12月 22日 星期六 08:50:21 CST\r\rdate -d &#39;next monday&#39;\r2012年 12月 10日 星期一 00:00:00 CST\r\rdate -d next-day +%Y%m%d\r20121209\r\rdate -d tomorrow +%Y%m%d\r20121209\r\rdate -d last-day +%Y%m%d\r20121207\r\rdate -d yesterday +%Y%m%d\r20121207\r\rdate -d last-month +%Y%m\r201211\r\rdate -d next-month +%Y%m\r201301\r\rdate -d &#39;30 days ago&#39;\r2012年 11月 08日 星期四 08:51:37 CST\r\rdate -d &#39;-100 days&#39;\r2012年 08月 30日 星期四 08:52:03 CST\r\rdate -d &#39;dec 14 -2 weeks&#39;\r2012年 11月 30日 星期五 00:00:00 CST\r\rdate -d &#39;50 days&#39;\r2013年 01月 27日 星期日 08:52:27 CST</pre>\r\r<p>显示月份和日数</p>\r\r<pre class="brush:bash;">\rdate  &#39;+%B %d&#39;\r十二月 08</pre>\r\r<p>显示时间后跳行，再显示目前日期</p>\r\r<pre class="brush:bash;">\rdate &#39;+%T%n%D&#39;\r14:10:35\r12/13/12</pre>\r\r<p>参考资料：<a href="http://www.linuxeye.com/command/date.html" target="_blank">LinuxEye</a></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 131),
(132, 'Linux常用命令——reboot', '132', 1490318931, 1490318931, '<p>本文介绍reboot命令。</p>\r<!--more-->\r\r<p>作用</p>\r\r<p>重新开机</p>\r\r<p>语法</p>\r\r<pre class="brush:bash;">\rreboot [-dfinw]</pre>\r\r<p>参数</p>\r\r<p>-d 重新开机时不把数据写入记录文件/var/tmp/wtmp。本参数具有&quot;-n&quot;参数的效果<br />\r-f 强制重新开机，不调用shutdown指令的功能<br />\r-i 在重开机之前，先关闭所有网络界面<br />\r-n 重开机之前不检查是否有未结束的程序<br />\r-w 仅做测试，并不真的将系统重新开机，只会把重开机的数据写入/var/log目录下的wtmp记录文件</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(133, 'Linux常用命令——poweroff', '133', 1490353200, 1490353258, '<p>本文介绍poweroff命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用来关闭计算机操作系统并且切断系统电源。</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rpoweroff [-nwdfih]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-n：关闭操作系统时不执行sync操作<br />\r-w：不真正关闭操作系统，仅在日志文件&ldquo;/var/log/wtmp&rdquo;中<br />\r-d：关闭操作系统时，不将操作写入日志文件&ldquo;/var/log/wtmp&rdquo;中添加相应的记录<br />\r-f：强制关闭操作系统<br />\r-i：关闭操作系统之前关闭所有的网络接口<br />\r-h：关闭操作系统之前将系统中所有的硬件设置为备用模式</p>\r\r<p><strong>实例</strong></p>\r\r<p><span style="color: rgb(45, 55, 75); font-family: Verdana, Geneva, sans-serif; font-size: 12px; line-height: 18px;">使用poweroff立即关闭系统</span></p>\r\r<pre class="brush:bash;">\rpoweroff</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(134, 'Linux常用命令——wget', '134', 1490354487, 1490354487, '<p>本文介绍wget命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于在终端中下载网络文件</p>\r\r<p><strong>语法</strong></p>\r\r<p>wget [参数] 下载地址</p>\r\r<p><strong>参数</strong></p>\r\r<p>-b&nbsp;&nbsp; &nbsp;后台下载模式<br />\r-O&nbsp;&nbsp; &nbsp;下载到指定目录<br />\r-t&nbsp;&nbsp; &nbsp;最大尝试次数<br />\r-c&nbsp;&nbsp; &nbsp;断点续传<br />\r-p&nbsp;&nbsp; &nbsp;下载页面内所有资源,包括图片、视频等<br />\r-r&nbsp;&nbsp; &nbsp;递归下载</p>\r\r<p><strong>实例</strong></p>\r\r<p>下载红帽的镜像文件</p>\r\r<pre class="brush:bash;">\rwget http://down.linuxprobe.com/Tools/RHEL-server-7.0-x86_64-LinuxProbe.Com.iso\r--2016-08-24 18:25:24-- http://down.linuxprobe.com/Tools/RHEL-server-7.0-x86_64-LinuxProbe.Com.iso\rResolving www.linuxprobe.com... 106.185.25.197\rConnecting to www.linuxprobe.com|106.185.25.197|:80... connected.\rHTTP request sent, awaiting response... 200 OK\rLength: 3743416320 (3.5G) [application/octet-stream]\rSaving to: &#39;RHEL-server-7.0-x86_64-LinuxProbe.Com.iso&#39;\r100%[====================================&amp;gt;] 3,743,416,320 1.82M/s in 32m 27s\r2016-08-24 18:57:51 (1.83 MB/s) - &#39;RHEL-server-7.0-x86_64-LinuxProbe.Com.iso&#39; saved [3743416320/3743416320]</pre>\r\r<p>递归下载《Linux就该这么学》的整站页面与所有资料，下载完成后会自动保存到当前目录中名字为&quot;www.linuxprobe.com&quot;的目录中</p>\r\r<pre class="brush:bash;">\rwget -r -p http://www.linuxprobe.com\r--2016-08-24 19:31:41-- http://www.linuxprobe.com/\rResolving www.linuxprobe.com... 106.185.25.197\rConnecting to www.linuxprobe.com|106.185.25.197|:80... connected.\rHTTP request sent, awaiting response... 200 OK\rLength: unspecified [text/html]\rSaving to: `www.linuxprobe.com/index.html&#39;\r&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;省略下载过程&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130),
(135, 'Linux常用命令——ps', '135', 1490354640, 1490591355, '<p>本文介绍ps命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于查看系统中的进程状态。</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rps [参数]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-a&nbsp;&nbsp; &nbsp;显示所有的进程（包括其他用户的）<br />\r-u&nbsp;&nbsp; &nbsp;用户以及其他详细信息<br />\r-x&nbsp;&nbsp; &nbsp;显示没有控制终端的进程</p>\r\r<p><strong>实例</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/03/849394236.png" style="width: 723px; height: 323px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 89),
(136, 'Linux系统中进程的5种不同的状态', '136', 1490354700, 1492407530, '<p>本文介绍Linux系统中进程的5种状态。</p>\r<!--more-->\r\r<p>R(运行):正在运行或在运行队列中等待。</p>\r\r<p>S(中断):休眠中, 在等待某个条件的形成或接收到信号。</p>\r\r<p>D(不可中断):收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。</p>\r\r<p>Z:(僵死):进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。</p>\r\r<p>T:(停止):进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130),
(137, 'ps.png', 'ps-png', 1490355010, 1490355010, 'a:5:{s:4:"name";s:6:"ps.png";s:4:"path";s:34:"/usr/uploads/2017/03/849394236.png";s:4:"size";i:27424;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 135, 0),
(140, 'top.png', 'top-png', 1490355633, 1490355633, 'a:5:{s:4:"name";s:7:"top.png";s:4:"path";s:34:"/usr/uploads/2017/03/387942434.png";s:4:"size";i:281603;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 141, 0),
(141, 'top命令前5行的意义', '141', 1490355600, 1492407525, '<p>本文介绍top命令的前5行的意义。</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/03/387942434.png" style="width: 701px; height: 422px;" />​</p>\r\r<p>第1行:系统时间，运行时间，登录用户数，系统负载（分别为1分钟、5分钟、15分钟的平均值）。</p>\r\r<p>第2行:进程总数，运行中的，睡眠中的，停止的，僵死的。</p>\r\r<p>第3行:用户占用资源，系统内核占用资源，改变过优先级的进程，空闲的资源，等待输入输出的时间。<span style="line-height: 1.6em;">此行数据均为CPU数据并以百分比格式显示，例如&quot;99.2 id&quot;意味着有99.2%的CPU资源正在空闲中。</span></p>\r\r<p>第4行:物理内存总量，使用量，空闲量，作为内核缓存的内存量。</p>\r\r<p>第5行:虚拟内存总量，使用量，空闲量，已被提前加载的内存数据。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 132),
(142, 'Linux常用命令——wc', '142', 1490356380, 1490357112, '<p>本文介绍wc命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于统计指定文本的行数、字数、字节数。</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rwc [参数] 文本</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-l&nbsp;&nbsp; &nbsp;只显示行数<br />\r-w&nbsp;&nbsp; &nbsp;只显示单词数<br />\r-c&nbsp;&nbsp; &nbsp;只显示字节数</p>\r\r<p><strong>实例</strong></p>\r\r<p>统计当前系统中有多少个用户</p>\r\r<pre class="brush:bash;">\rwc -l /etc/passwd\r38 /etc/passwd</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(143, 'Linux常用命令——touch', '143', 1490356800, 1490357094, '<p>本文介绍touch命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于创建空白文件与设置文件的各种时间</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rtouch [选项] [文件]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-a&nbsp;&nbsp; &nbsp;仅修改&ldquo;访问时间&rdquo;（atime）<br />\r-m&nbsp;&nbsp; &nbsp;仅修改&ldquo;更改时间&rdquo;（mtime）<br />\r-d&nbsp;&nbsp; &nbsp;同时修改atime与mtime</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(144, 'Linux常用命令——cp', '144', 1490357040, 1490357127, '<p>本文介绍cp命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于复制文件或目录</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rcp [选项] 源文件 目标文件</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-p&nbsp;&nbsp; &nbsp;保留原始文件的属性<br />\r-d&nbsp;&nbsp; &nbsp;若对象为&quot;链接文件&quot;，则保留该&quot;链接文件&quot;的属性<br />\r-r&nbsp;&nbsp; &nbsp;递归持续复制（用于目录）<br />\r-i&nbsp;&nbsp; &nbsp;若目标文件存在则询问是否覆盖<br />\r-a&nbsp;&nbsp; &nbsp;相当于-pdr（p,d,r为上述的参数）</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 121),
(145, 'Linux常用命令——dd', '145', 1490357880, 1490357994, '<p>本文介绍dd命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于指定大小的拷贝文件或指定转换文件</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rdd [参数]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>if&nbsp;&nbsp; &nbsp;输入的文件名称<br />\rof&nbsp;&nbsp; &nbsp;输出的文件名称<br />\rbs&nbsp;&nbsp; &nbsp;设置每个&ldquo;块&rdquo;的大小<br />\rcount&nbsp;&nbsp;设置要拷贝&ldquo;块&rdquo;的个数</p>\r\r<p><strong>实例</strong></p>\r\r<p>创建一个560M的文件</p>\r\r<pre class="brush:bash;">\rdd if=/dev/zero of=560_file count=1 bs=560M\r1+0 records in\r1+0 records out\r587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s</pre>\r\r<p>制作光盘镜像</p>\r\r<pre class="brush:bash;">\rdd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso\r7311360+0 records in\r7311360+0 records out\r3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 115),
(146, 'Linux常用命令——find', '146', 1490405400, 1491274190, '<p>本文介绍find命令。</p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>用于查找文件</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rfind [查找路径] 寻找条件 操作</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;匹配名称<br />\r-perm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;匹配权限（mode为完全匹配，-mode为包含即可）<br />\r-user &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;匹配所有者<br />\r-group &nbsp; &nbsp; &nbsp; &nbsp; 匹配所有组<br />\r-mtime -n +n&nbsp;&nbsp; &nbsp;匹配修改内容的时间（-n指n天以内，+n指n天以前）<br />\r-atime -n +n&nbsp;&nbsp; &nbsp;匹配访问文件的时间（<span style="line-height: 20.8px;">-n指n天以内，+n指n天以前</span>）<br />\r-ctime -n +n&nbsp;&nbsp; &nbsp;匹配修改权限的时间（<span style="line-height: 20.8px;">-n指n天以内，+n指n天以前</span>）<br />\r-nouser &nbsp; &nbsp; &nbsp; &nbsp;匹配无所有者的文件<br />\r-nogroup &nbsp; &nbsp; &nbsp; &nbsp;匹配无所有组的文件<br />\r-newer f1 !f2&nbsp;&nbsp; &nbsp;匹配比文件f1新却比f2旧的文件<br />\r--type b/d/c/p/l/f&nbsp;匹配文件类型（块设备、目录、字符设备、管道、链接文件、文件文件）<br />\r-size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 匹配文件的大小（+50k查找超过50k的文件,而-50k则代表查找小于50k的文件）<br />\r-prune &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;忽略某个目录<br />\r-exec {} \\; &nbsp; &nbsp; &nbsp;后面可接对搜索到结果进一步处理的命令<br />\r！取反<br />\r-a并且 and<br />\r-o或者 or<br />\r&amp;&amp;并且 and</p>\r\r<p><strong>实例</strong></p>\r\r<p>获取/etc/中所有以host开头的文件</p>\r\r<pre class="brush:bash;">\rfind /etc -name &quot;host*&quot; -print\r/etc/avahi/hosts\r/etc/host.conf\r/etc/hosts\r/etc/hosts.allow\r/etc/hosts.deny\r/etc/selinux/targeted/modules/active/modules/hostname.pp\r/etc/hostname</pre>\r\r<p>在整个系统中搜索所有权限中包括SUID权限的文件</p>\r\r<pre class="brush:bash;">\rfind / -perm -4000 -print\r/usr/bin/fusermount\r/usr/bin/su\r/usr/bin/umount\r/usr/bin/passwd\r/usr/sbin/userhelper\r/usr/sbin/usernetctl\r&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;省略部分输出信息&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</pre>\r\r<p>&quot;-exec {} \\;&quot;其中的{}代表find命令搜索出的逐个文件，并且记得命令的结尾必须是\\;</p>\r\r<pre class="brush:bash;">\rfind / -user oliver -exec cp -a {} /root/findresults/ \\;</pre>\r\r<p>删除一个目录下的所有文件，但保留一个指定文件</p>\r\r<pre class="brush:bash;">\r#假设这个目录是/xx/，里面有file1,file2,file3..file10  十个文件\r[root@oldboy xx]# touch file{1..10}\r[root@oldboy xx]# ls\rfile1  file10  file2  file3  file4  file5  file6  file7  file8  file9\r[root@oldboy xx]# ls\rfile1  file10  file2  file3  file4  file5  file6  file7  file8  file9\r#方法一，通过xargs传参\r[root@oldboy xx]# find /xx -type f ! -name &quot;file10&quot;|xargs rm -f \r[root@oldboy xx]# ls\rfile10\r#方法二，通过find的-exec执行命令参数\r [root@oldboy xx]# find /xx -type f ! -name &quot;file10&quot; -exec rm -f {} \\;     \r[root@oldboy xx]# ls\rfile10</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 126),
(571, '方法中参数的传递', '571', 1517055000, 1517055407, '<p>本文记录Java学习过程中遇到的参数的传递～</p>\r<!--more-->\r\r<p>参数传递，可以理解当我们要调用一个方法时，我们会把指定的数值，传递给方法中的参数，这样方法中的参数就拥有了这个指定的值，可以使用该值，在方法中运算了。这种传递方式，我们称为参数传递。</p>\r\r<ul>\r	<li>在这里，定义方法时，参数列表中的变量，我们称为形式参数</li>\r	<li>调用方法时，传入给方法的数值，我们称为实际参数</li>\r</ul>\r\r<p>示例代码（普通数据类型，不改变值）：</p>\r\r<pre class="brush:java;">\rpublic class ArgumentsDemo {\r	public static void main(String[] args) {\r		int a=5;\r		int b=10;\r		change(a, b);//调用方法时，传入的数值称为实际参数\r		System.out.println(&quot;a=&quot; + a);\r		System.out.println(&quot;b=&quot; + b);\r	}\r\r	public static void change(int a, int b){//方法中指定的多个参数称为形式参数\r		a=200;\r		b=500;\r	}\r}</pre>\r\r<p>示例代码（引用数据类型，改变值）：</p>\r\r<pre class="brush:java;">\rpublic class ArgumentsDemo {\r	public static void main(String[] args) {\r		int[] arr = { 1, 2, 3 };\r		change(arr);// 调用方法时，传入的数值称为实际参数\r		\r		for (int i = 0; i &lt; arr.length; i++) {\r			System.out.println(arr[i]);\r		}\r	}\r\r	public static void change(int[] arr) {// 方法中指定的多个参数称为形式参数\r		for (int i = 0; i &lt; arr.length; i++) {\r			arr[i] *= 2;\r		}\r	}\r}</pre>\r\r<p>参数传递图解：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3576681127.png" style="width: 600px; height: 346px;" /></p>\r\r<p>通过上面的两段程序可以得出如下结论：</p>\r\r<ul>\r	<li>当调用方法时，如果传入的数值为基本数据类型（包含String类型），形式参数的改变对实际参数不影响</li>\r	<li>当调用方法时，如果传入的数值为引用数据类型（String类型除外），形式参数的改变对实际参数有影响</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 122),
(577, '类的定义与使用', '577', 1519311360, 1553958010, '<p>本文记录Java学习过程中遇到的类的定义与使用～</p>\r<!--more-->\r\r<p>Java代码映射成现实事物的过程就是定义类的过程。</p>\r\r<p>我们就拿一部手机进行分析，它能用来做什么呢？它可以打电话，上网，聊微信等，这些就是手机所提供的功能，也就是方法；手机也有它的特征，如颜色、尺寸大小、品牌型号等，这些就是手机的特征，也就是属性。</p>\r\r<p>目前，我们只关注类中的属性，类中的方法在面向对象部分再进行学习。</p>\r\r<p><strong>类的定义格式</strong></p>\r\r<pre class="brush:java;">\r//创建java文件，与类名相同\rpublic class 类名{\r	数据类型  属性名称1；\r	数据类型  属性名称2；\r	&hellip;\r}</pre>\r\r<p>通过类的定义格式，来进行手机类的描述，如下所示：</p>\r\r<pre class="brush:java;">\rpublic class Phone {\r	/*\r	 * 属性\r	 */\r	String brand;// 品牌型号\r	String color;// 颜色\r	double size; // 尺寸大小\r}</pre>\r\r<p>上述代码，就是创建一个类的的过程，类的名称我们给起名为Phone，类中包含了三个属性（brand品牌型号、color颜色、size尺寸大小）。</p>\r\r<p>注意：类中定义的属性没有个数要求。</p>\r\r<p><strong>类的使用格式</strong></p>\r\r<p>Phone类定义好后，我们就可以使用这个类了，使用方式和使用引用数据类型Scanner类相似。</p>\r\r<p>格式如下：</p>\r\r<ol>\r	<li>导包：我们将所有的类放到同一个文件夹下，可以避免导包。</li>\r	<li>创建对象：数据类型&nbsp; 变量名 = new 数据类型();</li>\r	<li>调用方法：目前我们定义的自定义类不涉及方法，只是属性（自定义类中的方法部分在面向对象部分讲解）；</li>\r	<li>访问属性：变量名.属性 (这是当前的方式，后期会采取调用方法的方式替代掉直接访问的方式来完成对属性的访问。)</li>\r</ol>\r\r<p>当有了Phone数据类型的变量后，我们就可以使用Phone类中的属性了。对属性的访问我们来演示一下，如下所示：</p>\r\r<pre class="brush:java;">\rpublic class TestPhone {\r	public static void main(String[] args) {\r		//定义了一个Phone类型的变量p\r		Phone p = new Phone();\r		/*\r		 * 通过p,使用Phone中的属性\r		 */\r		//访问p中的brand品牌属性\rp.brand = &quot;苹果6s&quot;;\r//访问p中的color颜色属性\r		p.color = &quot;白色&quot;;\r//访问p中的size尺寸大小属性\rp.size = 5.5;\r\rSystem.out.println(&quot;手机品牌为&quot; + p.brand);\rSystem.out.println(&quot;手机颜色为&quot; + p.color);\rSystem.out.println(&quot;手机尺寸大小为&quot; + p.size);\r	}\r}</pre>\r\r<p><strong>自定义类型注意事项与内存图</strong></p>\r\r<p>上述代码中，通过类Phone创建出来的变量p，它相当于我们生活中的盒子，里面包含了它能够使用的属性。</p>\r\r<ul>\r	<li>通过 p.属性名 就可以对属性进行操作</li>\r	<li>与引用类型数组类似，引用类型的自定义类型的变量，直接变量时，结果为对象地址值，这里可以通过内存图简单解释。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/02/2181335884.jpg" style="width: 600px; height: 278px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(567, '方法调用过程', '567', 1517042760, 1517042952, '<p>本文记录Java学习过程中遇到的方法调用过程图～</p>\r<!--more-->\r\r<p>实力代码（求矩形面积）：</p>\r\r<pre class="brush:java;">\rpublic class MethodDemo {\r	public static void main(String[] args) {\r		int area = getArea(3, 5); // 调用 getArea方法\r		System.out.println(&quot; The area is &quot; + area);\r	}\r\r	// 下面定义了一个求矩形面积的方法，接收两个参数，其中x为高，y为宽\r	public static int getArea(int x, int y) {\r		int temp = x * y; // 使用变量temp记住运算结果\r		return temp; // 将变量temp的值返回\r	}\r}</pre>\r\r<p>接下来通过一个图例演示getArea()方法的整个调用过程，如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/197460163.png" style="width: 600px; height: 315px;" /></p>\r\r<p>从上图中可以看出，在程序运行期间，参数x和y相当于在内存中定义的两个变量。当调用getArea()方法时，传入的参数3和5分别赋值给变量x和y，并将x*y的结果通过return语句返回，整个方法的调用过程结束，变量x和y被释放。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130),
(568, 'method.png', 'method-png', 1517042915, 1517042915, 'a:5:{s:4:"name";s:10:"method.png";s:4:"path";s:34:"/usr/uploads/2018/01/197460163.png";s:4:"size";i:102305;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 567, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(570, '方法的重载', '570', 1517043060, 1517043864, '<p>本文记录Java学习过程中遇到的方法的重载～</p>\r<!--more-->\r\r<p>假设要在程序中实现一个对数字求和的方法，由于参与求和数字的个数和类型都不确定，因此要针对不同的情况去设计不同的方法。接下来通过一个案例来实现对两个整数相加、对三个整数相加以及对两个小数相加的功能，具体实现如下所示：</p>\r\r<pre class="brush:java;">\rpublic class MethodDemo {\r	public static void main(String[] args) {\r		// 下面是针对求和方法的调用\r		int sum1 = add01(1, 2);\r		int sum2 = add02(1, 2, 3);\r		double sum3 = add03(1.2, 2.3);\r		// 下面的代码是打印求和的结果\r		System.out.println(&quot;sum1=&quot; + sum1);\r		System.out.println(&quot;sum2=&quot; + sum2);\r		System.out.println(&quot;sum3=&quot; + sum3);\r	}\r\r	// 下面的方法实现了两个整数相加\r	public static int add01(int x, int y) {\r		return x + y;\r	}\r	// 下面的方法实现了三个整数相加\r	public static int add02(int x, int y, int z) {\r		return x + y + z;\r	}\r	// 下面的方法实现了两个小数相加\r	public static double add03(double x, double y) {\r		return x + y;\r	}\r}</pre>\r\r<p>从上述代码不难看出，程序需要针对每一种求和的情况都定义一个方法，如果每个方法的名称都不相同，在调用时就很难分清哪种情况该调用哪个方法。</p>\r\r<p>为了解决这个问题，Java允许在一个类中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。</p>\r\r<p>下面的三个方法互为重载关系：</p>\r\r<ul>\r	<li>public static int add(int x,int y) {逻辑} //两个整数加法</li>\r	<li>public static int add(int x,int y,int z) {逻辑} //三个整数加法</li>\r	<li>public static int add(double x,double y) {逻辑} //两个小数加法</li>\r</ul>\r\r<p>接下来通过方法重载的方式进行修改，如下所示：</p>\r\r<pre class="brush:java;">\rpublic class MethodDemo {\r	public static void main(String[] args) {\r		// 下面是针对求和方法的调用\r		int sum1 = add(1, 2);\r		int sum2 = add(1, 2, 3);\r		double sum3 = add(1.2, 2.3);\r		// 下面的代码是打印求和的结果\r		System.out.println(&quot;sum1=&quot; + sum1);\r		System.out.println(&quot;sum2=&quot; + sum2);\r		System.out.println(&quot;sum3=&quot; + sum3);\r	}\r\r	// 下面的方法实现了两个整数相加\r	public static int add(int x, int y) {\r		return x + y;\r	}\r	// 下面的方法实现了三个整数相加\r	public static int add(int x, int y, int z) {\r		return x + y + z;\r	}\r	// 下面的方法实现了两个小数相加\r	public static double add(double x, double y) {\r		return x + y;\r	}\r}</pre>\r\r<p>上述代码中定义了三个同名的add()方法，它们的参数个数或类型不同，从而形成了方法的重载。</p>\r\r<p>在main()方法中调用add()方法时，通过传入不同的参数便可以确定调用哪个重载的方法，如add(1,2)调用的是两个整数求和的方法。值得注意的是，方法的重载与返回值类型无关，它只有两个条件，一是方法名相同，二是参数个数或参数类型不相同。</p>\r\r<p>重载的注意事项：</p>\r\r<ul>\r	<li>重载方法参数必须不同：</li>\r</ul>\r\r<p style="margin-left:42.0pt;">参数个数不同，如method(int x)与method(int x,int y)不同</p>\r\r<p style="margin-left:42.0pt;">参数类型不同，如method(int x)与method(double x)不同g</p>\r\r<p style="margin-left:42.0pt;">参数顺序不同，如method(int x,double y)与method(double x,int y)不同</p>\r\r<ul>\r	<li>重载只与方法名与参数类型相关，与返回值无关</li>\r</ul>\r\r<p style="margin-left: 40px;">&nbsp; &nbsp; 如void method(int x)与int method(int y)不是方法重载，不能同时存在</p>\r\r<ul>\r	<li>重载与具体的变量标识符无关</li>\r</ul>\r\r<p style="margin-left: 40px;">&nbsp; &nbsp; 如method(int x)与method(int y)不是方法重载，不能同时存在</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(155, '目录', 'catalog', 1490802120, 1490802318, NULL, 2, 1, 'page-article.php', 'page', 'publish', NULL, 0, '0', '0', '0', 0, 1042),
(157, '导航', 'links', 1490802180, 1580967612, '<h2>搜索引擎</h2>\r\r<p><a href="https://www.google.com" target="_blank">谷歌</a>&nbsp;<a href="https://www.baidu.com" target="_blank">百度</a>&nbsp;<a href="https://cn.bing.com" target="_blank">必应</a></p>\r\r<h2>云服务器</h2>\r\r<p><a href="http://aliyun.oliver.ren/" target="_blank">阿里云</a> <a href="https://www.qcloud.com" target="_blank">腾讯云</a> <a href="http://www.hwclouds.com" target="_blank">华为云</a> <a href="https://www.vultr.com/?ref=7708123" target="_blank">Vultr</a> <a href="https://m.do.co/c/b441f55e3605" target="_blank">DigitalOcean</a>&nbsp;<a href="https://bwh1.net/aff.php?aff=10100" target="_blank">搬瓦工</a>&nbsp;<a href="https://www.sentris.net/billing/aff.php?aff=523" target="_blank">Sentris</a></p>\r\r<h2>虚拟主机</h2>\r\r<p><a href="http://api.hostinger.com.hk/redir/21071474" target="_blank">Hostinger</a>&nbsp;<a href="https://9xvps.com/shared-hosting.php" target="_blank">9xvps</a>&nbsp;<a href="https://billing.virmach.com/aff.php?aff=2268" target="_blank">VPSCraft</a></p>\r\r<h2>域名注册</h2>\r\r<p><a href="https://wanwang.aliyun.com" target="_blank">万网</a>&nbsp;<a href="http://www.xinnet.com" target="_blank">新网</a></p>\r\r<h2>安全加速</h2>\r\r<p><a href="https://www.yunaq.com/" target="_blank">知道创宇</a>&nbsp;<a href="https://su.baidu.com/?ic=7GRhn1" target="_blank">百度云加速</a>&nbsp;<a href="https://www.cloudflare.com/" target="_blank">CloudFlare</a></p>\r\r<h2>站长工具</h2>\r\r<p><a href="http://ce.cloud.360.cn/" target="_blank">奇云测</a>&nbsp;<a href="http://jk.cloud.360.cn/" target="_blank">网站监控</a>&nbsp;<a href="http://zz.baidu.com/" target="_blank">百度站长</a>&nbsp;<a href="https://www.bt.cn/" target="_blank">宝塔面板</a>&nbsp;<a href="https://oneinstack.com/" target="_blank">OneinStack</a></p>\r\r<h2><span style="line-height: 20.8px;">存储</span>网盘</h2>\r\r<p><a href="http://www.lanzou.com/account.php?action=register&amp;B3ZeNQYwAzJUZwNgDGJSO1U0V2w=" target="_blank">蓝奏网盘</a>&nbsp;<a href="https://pan.baidu.com" target="_blank">百度网盘</a></p>\r\r<h2>视频网站</h2>\r\r<p><a href="https://www.youtube.com/" target="_blank">YouTube</a>&nbsp;<a href="http://www.iqiyi.com/" target="_blank">爱奇艺</a>&nbsp;<a href="http://www.bilibili.com/" target="_blank">哔哩哔哩</a>&nbsp;<a href="http://www.pptv.com/" target="_blank">PPTV</a></p>\r\r<h2>开源工具</h2>\r\r<p><a href="https://www.kernel.org/" target="_blank">Linux</a>&nbsp;<a href="http://docs.linbit.com/" target="_blank">DRBD</a>&nbsp;<a href="http://www.mycat.io/" target="_blank">Mycat</a>&nbsp;<a href="http://mango.jfaster.org/" target="_blank">mango</a>&nbsp;<a href="https://sourceforge.net/projects/amoeba/" target="_blank">Amoeba</a>&nbsp;<a href="https://logback.qos.ch/" target="_blank">Logback</a>&nbsp;<a href="https://www.elastic.co/" target="_blank">Elasticsearch</a>&nbsp;<a href="https://brew.sh" target="_blank">Homebrew</a>&nbsp;<a href="http://www.treejs.cn" target="_blank">zTree</a></p>\r\r<h2>牛P博客</h2>\r\r<p>&nbsp;<a href="http://www.blogjava.net/BlueDavy/" target="_blank">毕玄</a>&nbsp;<a href="http://blog.csdn.net/cenwenchu79" target="_blank">放翁</a>&nbsp;<a href="http://cloudate.net/" target="_blank">云博</a>&nbsp;<a href="https://blog.csdn.net/lovelion" target="_blank">Sunny</a>&nbsp;<a href="http://shengxinjing.cn/" target="_blank">蜗牛老湿</a></p>\r\r<h2>友情链接</h2>\r\r<p><a href="http://51.ruyo.net/" target="_blank">如有乐享</a>&nbsp;<a href="https://liyuans.com/" target="_blank">Leonn</a>&nbsp;<a href="https://lai.yuweining.cn/" target="_blank">不死鸟</a>&nbsp;<a href="https://bookfere.com" target="_blank">书伴</a>&nbsp;<a href="http://www.tiantianbianma.com/" target="_blank">天天编码</a>&nbsp;<a href="http://www.newbiefly.com" target="_blank">编程资源库</a>&nbsp;<a href="https://www.lthack.com" target="_blank">龙天论坛</a>&nbsp;<a href="http://www.365cmd.com" target="_blank">三六五网络学院</a>&nbsp;<a href="http://www.itresource.org" target="_blank">IT资源网</a>&nbsp;<a href="https://itbook.download/" target="_blank">ITBook</a></p>\r', 3, 1, NULL, 'page', 'publish', NULL, 0, '0', '0', '0', 0, 879),
(1974, 'Gradle生命周期', '1974', 1580968134, 1580968134, '<p>本文记录Java学习过程中遇到的Gradle生命周期～</p>\r<!--more-->\r\r<p>Gradle生命周期主要包括：</p>\r\r<ol>\r	<li>Initialization初始化阶段：解析整个工程中所有Project，构建所有Project对应的Project对象；</li>\r	<li>Configuration配置阶段：解析所有的Project对象中的Task，构建好所有的Task的拓扑图；</li>\r	<li>Execution执行阶段：执行具体的Task和其依赖的Tasks。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(650, '构造方法', '650', 1525067520, 1525067881, '<p>本文记录Java学习过程中遇到的构造方法～</p>\r<!--more-->\r\r<p>我们对封装已经有了基本的了解，接下来我们来看一个新的问题，依然以Person为例，由于Person中的属性都被private了，外界无法直接访问属性，必须对外提供相应的set和get方法。当创建人对象的时候，人对象一创建就要明确其姓名和年龄，那该怎么做呢？</p>\r\r<p>在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年龄等属性信息。</p>\r\r<p>那么，创建对象就要明确属性值，那怎么解决呢？也就是在创建对象的时候就要做的事情，当使用new关键字创建对象时，怎么给对象的属性初始化值呢？这就要学习Java另外一门小技术&mdash;&mdash;构造方法。</p>\r\r<p>那什么是构造方法呢？从字面上理解即为构建创造时用的方法，即就是对象创建时要执行的方法。既然是对象创建时要执行的方法，那么只要在new对象时，知道其执行的构造方法是什么，就可以在执行这个方法的时候给对象进行属性赋值。</p>\r\r<p>构造方法的格式：</p>\r\r<pre class="brush:java;">\r修饰符 构造方法名(参数列表)\r{\r}</pre>\r\r<p>构造方法的特点：</p>\r\r<ul style="list-style-type:square;">\r	<li>构造方法没有返回值类型，也不需要写返回值。因为它是为构建对象的，对象创建完，方法就执行结束。</li>\r	<li>构造方法名称必须和类名保持一致。</li>\r	<li>构造方法没有具体的返回值。</li>\r</ul>\r\r<p>示例代码（构造方法）：</p>\r\r<pre class="brush:java;">\rclass Person {\r	// Person的成员属性age和name\r	private int age;\r	private String name;\r\r	// Person的构造方法，拥有参数列表\r	Person(int a, String nm) {\r		// 接受到创建对象时传递进来的值，将值赋给成员属性\r		age = a;\r		name = nm;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 107),
(407, '《分布式数据库架构及企业实践 基于Mycat中间件》PDF完整版下载', '407', 1508573400, 1555579947, '<p>本文分享一本书&mdash;&mdash;《分布式数据库架构及企业实践 基于Mycat中间件》。</p>\r<!--more-->\r\r<p>第 1 章 数据库中间件与分布式数据库的实现<br />\r1.1 什么是分布式系统<br />\r1.2 为什么需要分布式数据库<br />\r1.3 分布式数据库的实现原理&nbsp;<br />\r1.4 Mycat 数据库中间件简介<br />\r1.4.1 Mycat 的历史与未来规划<br />\r1.4.2 Mycat 与其他中间件的区别<br />\r1.4.3 Mycat 的优势<br />\r1.4.4 Mycat 的适用场合&nbsp;<br />\r第 2 章 Mycat 入门<br />\r2.1 环境搭建&nbsp;<br />\r2.1.1 Windows 环境搭建&nbsp;<br />\r2.1.2 Linux 环境搭建<br />\r2.2 Mycat 核心概念详解&nbsp;<br />\r2.2.1 逻辑库（schema）&nbsp;<br />\r2.2.2 逻辑表（table）&nbsp;<br />\r2.2.3 分片节点（dataNode）&nbsp;<br />\r2.2.4 节点主机（dataHost）&nbsp;<br />\r2.3 Mycat 原理介绍&nbsp;<br />\r2.4 参与 Mycat 源码开发&nbsp;<br />\r2.4.1 Mycat 源码环境搭建&nbsp;<br />\r2.4.2 Mycat 源码调试&nbsp;<br />\r第 3 章 Mycat 进阶&nbsp;<br />\r3.1 Mycat 配置详解&nbsp;<br />\r3.1.1 Mycat 支持的两种配置方式&nbsp;<br />\r3.1.2 server.xml 配置文件&nbsp;<br />\r3.1.3 schema.xml 配置文件&nbsp;<br />\r3.1.4 sequence 配置文件&nbsp;<br />\r3.1.5 zk-create.yaml 配置文件&nbsp;<br />\r3.1.6 其他配置文件&nbsp;<br />\r3.2 Mycat 分片规则详解&nbsp;<br />\r3.2.1 分片表与分片表&nbsp;<br />\r3.2.2 ER 关系分片表&nbsp;<br />\r3.2.3 分片规则 rule.xml 文件详解&nbsp;<br />\r3.2.4 取模分片&nbsp;<br />\r3.2.5 枚举分片&nbsp;<br />\r3.2.6 范围分片&nbsp;<br />\r3.2.7 范围求模算法&nbsp;<br />\r3.2.8 固定分片 hash 算法&nbsp;<br />\r3.2.9 取模范围算法&nbsp;<br />\r3.2. 字符串 hash 求模范围算法&nbsp;<br />\r3.2.11 应用指定的算法&nbsp;<br />\r3.2.12 字符串 hash 解析算法&nbsp;<br />\r3.2.13 一致性 hash 算法&nbsp;<br />\r3.2.14 按日期（天）分片算法&nbsp;<br />\r3.2.15 按单月小时算法&nbsp;<br />\r3.2.16 自然月分片算法&nbsp;<br />\r3.2.17 日期范围 hash 算法&nbsp;<br />\r3.3 Mycat 管理命令详解&nbsp;<br />\r3.3.1 Reload 命令&nbsp;<br />\r3.3.2 Show 命令<br />\r第 4 章 Mycat 高级技术实战<br />\r4.1 用 Mycat 搭建读写分离&nbsp;<br />\r4.1.1 MySQL 读写分离&nbsp;<br />\r4.1.2 MySQL Galera Cluster 读写分离&nbsp;<br />\r4.1.3 SQL Server 读写分离&nbsp;<br />\r4.2 Mycat 故障切换&nbsp;<br />\r4.2.1 Mycat 主从切换&nbsp;<br />\r4.2.2 MySQL Galera 节点切换&nbsp;<br />\r4.3 Mycat Percona HAProxy Keepalived<br />\r4.3.1 Mycat&nbsp;<br />\r4.3.2 Percona 集群&nbsp;<br />\r4.3.3 HAProxy&nbsp;</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1jI69OBc" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2729),
(1556, '权限控制', '1556', 1555632060, 1555632078, '<p>本文记录IT学习过程中遇到的权限控制～</p>\r<!--more-->\r\r<p>系统中提供了很多功能，但并不是所有的用户都能操作这些功能，需要对这些功能进行访问控制。</p>\r\r<p>访问控制一般包括两方面：</p>\r\r<p>认证：系统提供的用于识别用户身份的功能，即让系统知道你是谁，通常登录功能就是认证；<br />\r授权：系统授予登录用户可以操作那些功能，即让系统知道你能做什么。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24),
(169, 'RAID-0.png', 'RAID-0-png', 1491146101, 1491146101, 'a:5:{s:4:"name";s:10:"RAID-0.png";s:4:"path";s:35:"/usr/uploads/2017/04/3383989475.png";s:4:"size";i:48877;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 172, 0),
(170, 'RAID-1.png', 'RAID-1-png', 1491146299, 1491146299, 'a:5:{s:4:"name";s:10:"RAID-1.png";s:4:"path";s:35:"/usr/uploads/2017/04/2074425495.png";s:4:"size";i:38728;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 172, 0),
(171, 'RAID-3.png', 'RAID-3-png', 1491146457, 1491146457, 'a:5:{s:4:"name";s:10:"RAID-3.png";s:4:"path";s:35:"/usr/uploads/2017/04/4055339047.png";s:4:"size";i:35275;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 172, 0),
(172, '常见的几个RAID级别', '172', 1491146460, 1491229033, '<p>本文介绍常见的几个RAID级别。</p>\r<!--more-->\r\r<p><strong>RAID-0：数据条带化，无校验</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/3383989475.png" style="width: 553px; height: 348px;" /></p>\r\r<p>RAID0硬盘组技术虽然很大程度上提高了存储设备的IO读写速度，但通过图中所描述的数据存放结构就会不难发现数据是被分开存放的，也就是说假设任何其中的一块硬盘出现了问题都会破坏数据的完整性。</p>\r\r<p><strong>RAID-1：数据镜像，无校验</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/2074425495.png" style="width: 544px; height: 357px;" /></p>\r\r<p>RAID1硬盘组技术是将两块以上的存储设备进行绑定，目的是让数据被多块硬盘同时写入，类似于把数据再制作出多份备份的镜像，当有某一块硬盘损坏后一般可以立即通过热交换方式来恢复数据的正常使用，RAID1硬盘组技术虽然十分注重数据的安全性，但因为是将多块硬盘中写入相同的数据，也就是说理论上硬盘空间的真实可用率只有50%，因此会明显的提高硬盘组整体的成本，同时因为需要将数据同时写入到两块以上的硬盘设备中，这无疑也会增加一定系统计算功能的负载。</p>\r\r<p><strong>RAID-3：数据条带化读写，校验信息存放于专用磁盘</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/4055339047.png" style="width: 541px; height: 346px;" /></p>\r\r<p>RAID 3是把数据分成多个&ldquo;块&rdquo;，按照一定的容错算法，存放在N+1个硬盘上，实际数据占用的有效空间为N个硬盘的空间总和，而第N+1个硬盘上存储的数据是校验容错信息，当这N+1个硬盘中的其中一个硬盘出现故障时，从其它N个硬盘中的数据也可以恢复原始数据，这样，仅使用这N个硬盘也可以带伤继续工作（如采集和回放素材），当更换一个新硬盘后，系统可以重新恢复完整的校验容错信息。由于在一个硬盘阵列中，多于一个硬盘同时出现故障率的几率很小，所以一般情况下，使用RAID3，安全性是可以得到保障的。</p>\r\r<p>但是，在使用RAID3的过程中还有其它一些性能上的问题需要引起注意。RAID3存在的最大的一个不足，同时也是导致RAID3很少被人们采用的原因就是校验盘很容易成为整个系统的瓶颈。我们已经知道，RAID3会把数据写入操作分散到多个硬盘上进行，然而不管是向哪一个数据盘写入数据，都需要同时重写校验盘中的相关信息。因此，对于那些经常需要执行大量写入操作的应用来说，校验盘的负载将会很大，无法满足程序的运行速度，从而导致整个RAID系统性能的下降。鉴于这种原因，RAID3更加适合应用于那些写入操作较少，读取操作较多的应用环境，如数据库和web服务器等。与RAID0相比，RAID3在读写速度方面相对较慢。使用的容错算法和分块大小决定RAID使用的应用场合，在通常情况下，RAID3比较适合大文件类型且安全性要求较高的应用，如视频编辑、硬盘播出机、大型数据库等。</p>\r\r<p><strong>RAID-4：数据块化读写，校验信息存放于专用磁盘</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/4055339047.png" style="width: 541px; height: 346px;" /></p>\r\r<p>与RAID3类似，但RAID4是按块(扇区)存取。无须像RAID3那样，哪怕每一次小I/O操作也要涉 及全组，只需涉及组中两块硬盘（一块数据盘，一块校验盘）即可，从而提高了小量数据 I/O速度。</p>\r\r<p><strong>RAID-5：数据条带化，校验信息分布式存放</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/72290260.png" style="width: 567px; height: 349px;" /></p>\r\r<p>RAID5硬盘组技术是将其它存储设备中的数据奇偶校验信息互相保存到硬盘设备中。RAID5硬盘组阵列有两项技术特色，第一，数据的奇偶校验信息并不是单独保存到某一块硬盘设备中的，而是分别互相存储到其它每一块硬盘设备上，这样的好处就是当其中任何一设备损坏后不至于出现致命缺陷。第二，RAID5硬盘组并不是备份真正的硬盘实际数据信息，而是当设备出现问题后通过奇偶校验信息来尝试重建损坏的数据，这样的技术特性&ldquo;妥协&rdquo;的兼顾了存储设备性能、数据安全性与存储成本问题。</p>\r\r<p><strong>RAID-6：带有两种校验的独立磁盘</strong></p>\r\r<p>它采用两种奇偶校验方法，至少需要N+2（N&gt;2）个磁盘来构成阵列，一般用在数据可靠性、可用性要求极高的应用场合。</p>\r\r<p>常用的两种RAID-6技术：</p>\r\r<p>①RAID-6 P+Q<span style="line-height: 1.6em;">:需要计算出两个校验数据P和Q，当有两个数据丢失时，根据P和Q恢复出丢失的数据。校验数据P和Q是由以下公式计算得来的：</span></p>\r\r<p><span style="line-height: 1.6em;">P=D0+D1+D2</span></p>\r\r<p><span style="line-height: 1.6em;">Q=（</span>&alpha;&times;D0<span style="line-height: 1.6em;">）+（</span>&beta;&times;D1<span style="line-height: 1.6em;">）+（</span>&gamma;&times;D2<span style="line-height: 1.6em;">）</span></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/2002261277.png" style="width: 579px; height: 193px;" /></p>\r\r<p><span style="line-height: 20.8px;">②RAID-6 DP（Double Parity）：就是在RAID4所使用的一个行XOR校验磁盘的基础上又增加了一个磁盘用于存放斜向的XOR校验信息</span></p>\r\r<ul>\r	<li>横向校验盘中P0-P3为各个数据盘中横向数据的校验信息</li>\r</ul>\r\r<p style="margin-left: 40px;">例如：P0=D0 <strong>XOR</strong> D1 <strong>XOR</strong> D2 <strong>XOR</strong> D3</p>\r\r<ul>\r	<li>斜向校验盘中DP0-DP3为各个数据盘及横向校验盘的斜向数据校验信息</li>\r</ul>\r\r<p style="margin-left: 40px;">例如：DP0=D0 <strong>XOR</strong> D5 <strong>XOR</strong> D10 <strong>XOR</strong> D15</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/1901722733.png" style="width: 573px; height: 157px;" /></p>\r\r<p><strong>RAID-10：镜像和条带的组合</strong></p>\r\r<p>它是将镜像和条带进行组合的RAID级别，先进行RAID1镜像然后再做RAID0。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/4239903963.png" style="width: 477px; height: 296px;" /></p>\r\r<p><strong>RAID-50：RAID5和RAID0的组合</strong></p>\r\r<p>它是将RAID5和RAID0进行两级组合的RAID级别，第一级是RAID5，第二级是RAID0。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/2641098467.png" style="width: 596px; height: 280px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(175, 'RAID-5.png', 'RAID-5-png', 1491147016, 1491147016, 'a:5:{s:4:"name";s:10:"RAID-5.png";s:4:"path";s:33:"/usr/uploads/2017/04/72290260.png";s:4:"size";i:37293;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 172, 0),
(176, 'P+Q.png', 'P-Q-png', 1491227503, 1491227503, 'a:5:{s:4:"name";s:7:"P+Q.png";s:4:"path";s:35:"/usr/uploads/2017/04/2002261277.png";s:4:"size";i:34011;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 172, 0),
(181, 'RAID比较.png', 'RAID比较-png', 1491229254, 1491229254, 'a:5:{s:4:"name";s:14:"RAID比较.png";s:4:"path";s:35:"/usr/uploads/2017/04/2462068848.png";s:4:"size";i:33630;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 182, 0),
(182, '几种常见RAID技术的比较', '182', 1491229260, 1492407491, '<p>本文将常见的几种RAID技术用表格的形式进行了比较。</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/2462068848.png" style="width: 571px; height: 319px;" /></p>\r\r<p><span style="line-height: 1.6em;">从可靠性、性能和成本简单比较各RAID级别的优劣</span><span style="line-height: 1.6em;">（相对而言），供在实际项目中选择时参考。</span></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/2924623941.png" style="width: 560px; height: 151px;" /></p>\r\r<p><strong>空间利用率</strong>：RAID5明显优于RAID10</p>\r\r<p><strong>可靠性</strong>：RAID5低于RAID10</p>\r\r<p><strong>性能</strong>：业务是一些大文件的读写操作时，RAID5的性能会明显好于RAID10；业务以随机的小数据块读写为主的时候，RAID10是最优的选择。</p>\r\r<p>RAID5和RAID10下分条深度变化随机写性能规律</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/140597298.png" style="width: 582px; height: 181px;" /></p>\r\r<p><strong>RAID5规律</strong>：随着分条深度的增加，随机写IOPS先会不断的增加，达到一定程度之后，随机写IOPS会不断的递减；</p>\r\r<p><strong>RAID10规律</strong>：随着分条深度的增加，随机写IOPS不断的增长，当分条深度增大到一定程度后，随机写IOPS保持一个较为稳定的状态。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(184, '应用场景.png', '应用场景-png', 1491229560, 1491229560, 'a:5:{s:4:"name";s:16:"应用场景.png";s:4:"path";s:35:"/usr/uploads/2017/04/2462611491.png";s:4:"size";i:46878;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 182, 0),
(185, '比较.png', '比较-png', 1491229735, 1491229735, 'a:5:{s:4:"name";s:10:"比较.png";s:4:"path";s:35:"/usr/uploads/2017/04/2924623941.png";s:4:"size";i:12279;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 182, 0),
(186, '随机写性能.png', '随机写性能-png', 1491229970, 1491229970, 'a:5:{s:4:"name";s:19:"随机写性能.png";s:4:"path";s:34:"/usr/uploads/2017/04/140597298.png";s:4:"size";i:15914;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 182, 0),
(178, 'DP.png', 'DP-png', 1491228574, 1491228574, 'a:5:{s:4:"name";s:6:"DP.png";s:4:"path";s:35:"/usr/uploads/2017/04/1901722733.png";s:4:"size";i:32429;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 172, 0),
(179, 'RAID10.png', 'RAID10-png', 1491228802, 1491228802, 'a:5:{s:4:"name";s:10:"RAID10.png";s:4:"path";s:35:"/usr/uploads/2017/04/4239903963.png";s:4:"size";i:28711;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 172, 0),
(180, 'RAID50.png', 'RAID50-png', 1491228943, 1491228943, 'a:5:{s:4:"name";s:10:"RAID50.png";s:4:"path";s:35:"/usr/uploads/2017/04/2641098467.png";s:4:"size";i:36138;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 8, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 172, 0),
(190, '磁盘的IOPS的计算步骤', '190', 1491231180, 1492407474, '<p>本文分享物理磁盘的IOPS的计算步骤，并给出一个简单的例子。</p>\r<!--more-->\r\r<p>在实际存储方案设计的过程中，计算实际可用IOPS的过程中必须纳入RAID的写惩罚计算。</p>\r\r<p>计算的公式如下：</p>\r\r<ul>\r	<li>物理磁盘总的IOPS=物理磁盘的IOPS&times;磁盘数目</li>\r	<li>可用的IOPS=（物理磁盘总的IOPS&times;写百分比&divide;RAID写惩罚）+（物理磁盘总的IOPS&times;读百分比）</li>\r</ul>\r\r<p>假设组成RAID5的物理磁盘总共可以提供500的IOPS，使用该存储的应用程序读写比例是50%/50%，那么对于前端主机而言，实际可用的IOPS是：</p>\r\r<p>（500&times;50%&divide;4）+（500&times;50%）=312.5IOPS</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 150),
(191, 'Linux中的常见特殊符号', '191', 1491272700, 1491272716, '<p>本文介绍Linux中常见的一些特殊符号。</p>\r<!--more-->\r\r<p>1.&gt;：对应符号1，输出重定向符号，重定向内容到文件，清除已有的内容，然后加入新内容，如果文件不存在还会创建文件。</p>\r\r<p>2.&gt;&gt;：对应符号1，追加输出重定向符号，追加内容到文件（中间无空格）。</p>\r\r<p>3.&lt;：对应符号2，输入重定向。</p>\r\r<p>4.|：管道，将前面命令的输出转为后面命令的输入。</p>\r\r<p>5.点和点斜线：当前目录。</p>\r\r<p>6.点点：上一层目录。</p>\r\r<p>7.斜线：根目录。</p>\r\r<p>8.分号：命令分隔符，用于分割两条命令。</p>\r\r<p>9.{}：生成一个序列，但在find中表示结果。</p>\r\r<p>10.！：</p>\r\r<p>①！加命令：可以调用最近使用的命令；</p>\r\r<p>②！！：重复上一条命令；</p>\r\r<p>③！+数字：调用历史的第几条命令。</p>\r\r<p>④取反</p>\r\r<p>11.~：当前用户的家目录。</p>\r\r<p>12.-：上一次访问的目录。</p>\r\r<p>13.\\：转义字符。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 115),
(188, '写惩罚计算.png', '写惩罚计算-png', 1491230407, 1491230407, 'a:5:{s:4:"name";s:19:"写惩罚计算.png";s:4:"path";s:35:"/usr/uploads/2017/04/1896368834.png";s:4:"size";i:4979;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 189, 0),
(189, 'RAID中写惩罚的计算步骤', '189', 1491230820, 1492407481, '<p>本文介绍RAID中写惩罚的计算过程，并给出几种常见的RAID技术的写惩罚值。</p>\r<!--more-->\r\r<p>假设由5块硬盘组成的RAID5，每块盘同一条带数据如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/04/1896368834.png" style="width: 511px; height: 89px;" /></p>\r\r<p>如果有一个数据要写入，假设在第1个磁盘上写入的数据为0111。那么整个RAID5需要完成写入的过程分为：</p>\r\r<ol>\r	<li>读取原数据，然后与新数据0111做XOR操作：1010 <strong>XOR</strong> 0111 = 1101</li>\r	<li>读取原有的校验位1111</li>\r	<li>用第一步算出的数值与原校验再做一次XOR操作：1101 XOR 1111=0010</li>\r	<li>然后将0111新数据写入到数据磁盘，将第三步计算出来的新的校验位写入校验盘。</li>\r</ol>\r\r<p>由上述几个步骤可见：对于任何一次写入，在存储端，需要分别进行两次读和两次写，所以说RAID5的写惩罚值为4。</p>\r\r<p>常见的RAID级别的写惩罚值：</p>\r\r<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">\r	<tbody>\r		<tr>\r			<td>RAID</td>\r			<td>写惩罚值</td>\r		</tr>\r		<tr>\r			<td>0</td>\r			<td>1</td>\r		</tr>\r		<tr>\r			<td>1</td>\r			<td>2</td>\r		</tr>\r		<tr>\r			<td>5</td>\r			<td>4</td>\r		</tr>\r		<tr>\r			<td>6</td>\r			<td>6</td>\r		</tr>\r		<tr>\r			<td>10</td>\r			<td>2</td>\r		</tr>\r	</tbody>\r</table>\r\r<p>&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 556),
(192, 'Linux中去掉命令提示的两个办法', '192', 1491273420, 1492407466, '<p>本文分享Linux命令行中去掉命令提示的两个办法。</p>\r<!--more-->\r\r<ol>\r	<li>\r	<p>加\\</p>\r\r	<p>\\c == c<br />\r	故\\cp == cp<br />\r	一般情况下是一样的<br />\r	但是，有时候会出现这种情况 有人这样使用了alias命令<br />\r	alias cp=&quot;cp -i&quot;<br />\r	你再用cp a b时就会被翻译成 cp -i a b<br />\r	但是用\\cp就不会了</p>\r	</li>\r	<li>\r	<p>使用命令的全路径。</p>\r	</li>\r</ol>\r\r<p>至此，alias解读成功。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(193, 'Linux命令中的三种重定向', '193', 1491274320, 1492407459, '<p>本文分享Linux中的三种重定向，整理的不是很详细。</p>\r<!--more-->\r\r<p>&gt;或者1&gt;<br />\r输出重定向：把前面输出的东西输入到后面的文件中，会清除文件原有内容。</p>\r\r<p>&gt;&gt;或者1&gt;&gt;<br />\r追加输出重定向：把前面输出的东西追加到后面的文件中，不会清除文件原有内容。</p>\r\r<p>0&lt;或&lt;<br />\r输入重定向：输入重定向用户改变命令的输入，后面制定输入内容，前面跟文件名。</p>\r\r<p>0&lt;&lt;或&lt;&lt;<br />\r追加输入重定向：后跟字符串，用来表示&ldquo;输入结束&rdquo;，也可以用Ctrl+D来结束输入。</p>\r\r<p>2&gt;<br />\r错误重定向：把错误信息输入到后边的文件中，会删除文件原有内容。</p>\r\r<p>2&gt;&gt;<br />\r错误追加重定向：把错误信息追加到后边的文件中，不会删除文件原有内容。</p>\r\r<p>说明：<br />\r1、箭头的指向就是数据的流向；<br />\r2、数字说明：<br />\r1.标准输入（stdin）：代码为0，使用&lt;或&lt;&lt;。数据从右向左。<br />\r2.标准正常输出（stdout)：代码为1，使用&gt;或&gt;&gt;。数据流向从左向右。<br />\r3.标准错误输出（stderr）：代码为2，使用2&gt;或2&gt;&gt;。<br />\r4.2&gt;&amp;1标准正常输出和标准错误输出一样。</p>\r\r<p>举例：<br />\rxxx 1&gt; /dev/null 2&gt;&amp;1<br />\rxxx &amp;&gt; /dev/null</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(194, 'Linux命令行中的快捷键', '194', 1491274920, 1492407452, '<p>在命令终端中通过它们或者方向键可以实现对历史命令的快速查找，是快速输入命令的好方法。</p>\r<!--more-->\r\r<p>Ctrl+a：光标回到命令行首（ahead）</p>\r\r<p>Ctrl+e：光标回到命令行尾（end）</p>\r\r<p>Ctrl+b：光标向行首移动一个字符（backwards）</p>\r\r<p>Ctrl+f：光标向行尾移动一个字符（forwards）</p>\r\r<p>Ctrl+w: 删除光标处到行首的字符</p>\r\r<p>Ctrl+k：删除光标处到行尾的字符</p>\r\r<p>Ctrl+u：删除整个命令行文本字符</p>\r\r<p>Ctrl+h：向行首删除一个字符</p>\r\r<p>Ctrl+d：向行尾删除一个字符</p>\r\r<p>Ctrl+y: 粘贴u，k，w删除的文本</p>\r\r<p>Ctrl+p: 上一个使用的历史命令（previous）</p>\r\r<p>Ctrl+n：下一个使用的历史命令（next ）</p>\r\r<p>Ctrl+r：快速检索历史命令（retrieve）</p>\r\r<p>Ctrl+t： 交换光标所在字符和其前的字符</p>\r\r<p>Ctrl+i：相当于Tab键</p>\r\r<p>Ctrl+o：相当于Ctrl+m</p>\r\r<p>Ctrl+m：相当Enter键</p>\r\r<p>Ctrl+s:使终端发呆，静止，可以使快速输出的终端屏幕停下来</p>\r\r<p>Ctrl+q：退出Ctrl+s引起的发呆</p>\r\r<p>Ctrl+z：使正在运行在终端的任务，运行于后台（可用fg恢复）</p>\r\r<p>Ctrl+c：中断终端中正在执行的任务</p>\r\r<p>Ctrl+d: 在空命令行的情况下可以退出终端</p>\r\r<p>Ctrl+[ ：相当于Esc键</p>\r\r<p>Esc键：连续按3次显示所有的支持的终端命令</p>\r\r<p>Tab键：命令、文件名等自动补全功能</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 122),
(195, '32位系统与64位系统的区别', '195', 1491276180, 1491276229, '<p>本文介绍32位系统与64位系统的区别。</p>\r\r<!--more-->\r\r<p>1.当初设计时的定位不同：64位操作系统的设计定位是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域，这些应用领域的共同特点就是需要有大量的系统内存和浮点性能。简单地说，64位操作系统是为高科技人员使用本行业特殊软件的运行品台而设计的。而32位操作系统是为普通用户设计的。</p>\r\r<p>2.安装要求配置不同：64位操作系统只能安装在64位电脑上（CPU必须是64位的），并且只在针对64位的软件时才能发挥其最佳性能。32位操作系统既可以安装在32位电脑上，也可以安装在64位电脑上。当然，此时32位的操作系统是无法发挥64位硬件性能的。</p>\r\r<p>3.运算速度不同：64位CPU-GPRs（General-Purpose-Registers，通用寄存器）的数据宽度为64位，64位指令集可以运行64位数据指令，也就是说处理器一次可存取64位数据（只要两个指令，一次提取8个字节的数据），比32位提高了一倍（32位需要四个指令，一次只能提取4个字节的数据），性能会相应提升。</p>\r\r<p>4.寻址能力不同：64位处理器的优势还体现在操作系统对内存的控制上。由于地址使用的是特殊整数，因此一个ALU（算数逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。比如，Windows7X64支持多达128GB的物理内存和16TB的虚拟内存，而32位的CPU和操作系统理论上最大只可支持4GB的内存，实际上也就是3.2G左右的内存，当然32位系统是可以通过扩展来支持大内存的，扩展所采用的是PAE技术。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(196, '如何查看Linux操作系统的位数', '196', 1491276720, 1492407443, '<p>方法应该有很多，这里只介绍两种。</p>\r<!--more-->\r\r<p>uname -m<br />\r如果输出为i386，则为32位；如果输出为X86_64，则为64位。</p>\r\r<p>ll -d /lib64<br />\r如果该目录不存在，则为32位；如果该目录存在，则为64位。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(198, '将Centos的yum源更换为阿里云', '198', 1492347840, 1492406450, '<p>阿里云是最近新出的一个镜像源。得益与阿里云的高速发展，这么大的需求，肯定会推出自己的镜像源。</p>\r<!--more-->\r\r<p>阿里云Linux安装镜像源地址：http://mirrors.aliyun.com/</p>\r\r<p>CentOS系统更换软件安装源</p>\r\r<p>第一步：备份你的原镜像文件，以免出错后可以恢复。</p>\r\r<pre class="brush:bash;">\rmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</pre>\r\r<p>第二步：下载新的CentOS-Base.repo 到/etc/yum.repos.d/</p>\r\r<pre class="brush:bash;">\r#CentOS 5\rwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo\r#CentOS 6\rwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</pre>\r\r<p>第三步：运行yum makecache生成缓存</p>\r\r<pre class="brush:bash;">\ryum clean all\ryum makecache</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 143),
(471, 'Java语言概述', '471', 1515285540, 1515286373, '<p>本文简单的记录下Java语言的概述～</p>\r<!--more-->\r\r<p>Java是SUN公司开发的一门编程语言，目前被Oracle公司收购，编程语言就是用来编写软件的。</p>\r\r<p>Java的应用</p>\r\r<ol>\r	<li>开发QQ、迅雷程序(桌面应用软件)；</li>\r	<li>淘宝、京东(互联网应用软件)。</li>\r</ol>\r\r<p>Java的擅长</p>\r\r<ol>\r	<li>互联网：电商、P2P等等；</li>\r	<li>企业级应用：ERP、CRM、BOSS、OA等等。</li>\r</ol>\r\r<p>Java语言平台</p>\r\r<ol>\r	<li>JavaSE（标准版）部分：JavaSE并不能开发大型项目；</li>\r	<li>JavaEE（企业版）部分：学习完JavaEE部分就可以开发各种大型项目了。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(472, '常用的DOS命令', '472', 1515286824, 1515286824, '<p>本文记录在学习Java语言的过程中常用的DOS命令～</p>\r\r<!--more-->\r\r<p>打开Dos控制台</p>\r\r<ol>\r	<li>win+r--输入cmd--回车</li>\r</ol>\r\r<p>常用dos命令</p>\r\r<ol>\r	<li>cd .. : 退回到上一级目录</li>\r	<li>cd \\ : 退回到根目录</li>\r	<li>cd tools: 进入tools文件夹</li>\r	<li>d: : 回车 盘符切换</li>\r	<li>cd d:\\234 :进入d盘的234文件夹（先切换盘符(d:)才能进入d:\\234）</li>\r	<li>dir : 列出当前目录下的文件以及文件夹</li>\r	<li>cls : 清除屏幕</li>\r	<li>ipconfig: 查看本机的相关网络配置</li>\r</ol>\r\r<p>dos控制台运行记事本程序</p>\r\r<ol>\r	<li>D:\\&gt;C:\\windows\\notepad.exe</li>\r	<li>还可以省略&ldquo;.exe&rdquo;后缀，例如：D:\\&gt;C:\\windows\\notepad</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 147),
(473, 'JDK和JRE的区别和联系', '473', 1515291112, 1515291112, '<p>本文记录在学习Java的过程中遇到的JDK与JRE的区别和联系～</p>\r\r<!--more-->\r\r<p>JDK：它是Java开发运行环境，在程序员的电脑上当然要安装JDK。</p>\r\r<p>JRE：Java Runtime Environment它是Java运行环境，如果你不需要开发只需要运行Java程序，那么你可以安装JRE。例如程序员开发出的程序最终卖给了用户，用户不用开发，只需要运行程序，所以用户在电脑上安装JRE即可。</p>\r\r<p>注意：JDK包含了JRE。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(474, '虚拟机跨平台.png', '虚拟机跨平台-png', 1515291459, 1515291459, 'a:5:{s:4:"name";s:22:"虚拟机跨平台.png";s:4:"path";s:35:"/usr/uploads/2018/01/2988949739.png";s:4:"size";i:17076;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 475, 0),
(475, 'Java的跨平台特性', '475', 1515291499, 1515291499, '<p>本文记录在学习Java的过程中的Java的跨平台特性～</p>\r\r<!--more-->\r\r<ol>\r	<li>平台指的是操作系统 （Windows，Linux，Mac）；</li>\r	<li>Java程序可以在任意操作系统上运行，一次编写到处运行 ；</li>\r	<li>实现跨平台需要依赖Java的虚拟机 JVM （Java Virtual Machine）。</li>\r</ol>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2988949739.png" style="width: 600px; height: 250px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 128),
(320, '0028Bridged.png', '0028Bridged-png', 1496909250, 1496909250, 'a:5:{s:4:"name";s:15:"0028Bridged.png";s:4:"path";s:35:"/usr/uploads/2017/06/1499739776.png";s:4:"size";i:209511;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 121, 0),
(321, '0028Host-only.png', '0028Host-only-png', 1496909251, 1496909251, 'a:5:{s:4:"name";s:17:"0028Host-only.png";s:4:"path";s:34:"/usr/uploads/2017/06/849122180.png";s:4:"size";i:222183;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 121, 0),
(322, '0028NAT.png', '0028NAT-png', 1496909251, 1496909251, 'a:5:{s:4:"name";s:11:"0028NAT.png";s:4:"path";s:35:"/usr/uploads/2017/06/3970595453.png";s:4:"size";i:229429;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 121, 0),
(324, '001.png', '001-png-1', 1496909915, 1496909915, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2017/06/2535076202.png";s:4:"size";i:69746;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 17, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(325, '002.jpg', '002-jpg', 1496909972, 1496909972, 'a:5:{s:4:"name";s:7:"002.jpg";s:4:"path";s:35:"/usr/uploads/2017/06/3983956886.jpg";s:4:"size";i:56297;s:4:"type";s:3:"jpg";s:4:"mime";s:10:"image/jpeg";}', 18, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(484, '006.png', '006-png-1', 1515297098, 1515297098, 'a:5:{s:4:"name";s:7:"006.png";s:4:"path";s:35:"/usr/uploads/2018/01/3362692956.png";s:4:"size";i:62898;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(485, '007.png', '007-png-1', 1515297098, 1515297098, 'a:5:{s:4:"name";s:7:"007.png";s:4:"path";s:35:"/usr/uploads/2018/01/4129276484.png";s:4:"size";i:57981;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(486, '008.png', '008-png', 1515297098, 1515297098, 'a:5:{s:4:"name";s:7:"008.png";s:4:"path";s:35:"/usr/uploads/2018/01/3383332572.png";s:4:"size";i:3567;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(487, '009.png', '009-png', 1515297098, 1515297098, 'a:5:{s:4:"name";s:7:"009.png";s:4:"path";s:35:"/usr/uploads/2018/01/1709912593.png";s:4:"size";i:9289;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(488, '010.png', '010-png', 1515297099, 1515297099, 'a:5:{s:4:"name";s:7:"010.png";s:4:"path";s:35:"/usr/uploads/2018/01/2268273077.png";s:4:"size";i:46776;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 10, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(489, '011.png', '011-png', 1515297099, 1515297099, 'a:5:{s:4:"name";s:7:"011.png";s:4:"path";s:35:"/usr/uploads/2018/01/1720716446.png";s:4:"size";i:55866;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 11, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(490, '012.png', '012-png', 1515297099, 1515297099, 'a:5:{s:4:"name";s:7:"012.png";s:4:"path";s:35:"/usr/uploads/2018/01/2482140266.png";s:4:"size";i:41644;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 12, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(491, '013.png', '013-png', 1515297099, 1515297099, 'a:5:{s:4:"name";s:7:"013.png";s:4:"path";s:35:"/usr/uploads/2018/01/1601548463.png";s:4:"size";i:52451;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 13, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(492, '014.png', '014-png', 1515297099, 1515297099, 'a:5:{s:4:"name";s:7:"014.png";s:4:"path";s:35:"/usr/uploads/2018/01/3061516794.png";s:4:"size";i:42442;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 14, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(493, '015.png', '015-png', 1515297099, 1515297099, 'a:5:{s:4:"name";s:7:"015.png";s:4:"path";s:35:"/usr/uploads/2018/01/2346839076.png";s:4:"size";i:11293;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 15, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(494, '016.png', '016-png', 1515297099, 1515297099, 'a:5:{s:4:"name";s:7:"016.png";s:4:"path";s:35:"/usr/uploads/2018/01/3405261777.png";s:4:"size";i:9599;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 16, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(207, '206-01.png', '206-01-png', 1495013947, 1495013947, 'a:5:{s:4:"name";s:10:"206-01.png";s:4:"path";s:35:"/usr/uploads/2017/05/3724908202.png";s:4:"size";i:30932;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(211, '206-04.png', '206-04-png', 1495019364, 1495019364, 'a:5:{s:4:"name";s:10:"206-04.png";s:4:"path";s:35:"/usr/uploads/2017/05/1199465580.png";s:4:"size";i:40595;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(209, '206-02.png', '206-02-png', 1495014045, 1495014045, 'a:5:{s:4:"name";s:10:"206-02.png";s:4:"path";s:34:"/usr/uploads/2017/05/204186605.png";s:4:"size";i:29007;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(210, '206-03.png', '206-03-png', 1495014100, 1495014100, 'a:5:{s:4:"name";s:10:"206-03.png";s:4:"path";s:35:"/usr/uploads/2017/05/2320312392.png";s:4:"size";i:31056;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(213, '206-05.png', '206-05-png', 1495019417, 1495019417, 'a:5:{s:4:"name";s:10:"206-05.png";s:4:"path";s:35:"/usr/uploads/2017/05/3438938055.png";s:4:"size";i:114721;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(214, '206-06.png', '206-06-png', 1495019463, 1495019463, 'a:5:{s:4:"name";s:10:"206-06.png";s:4:"path";s:34:"/usr/uploads/2017/05/630227989.png";s:4:"size";i:47932;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(215, '206-07.png', '206-07-png', 1495019513, 1495019513, 'a:5:{s:4:"name";s:10:"206-07.png";s:4:"path";s:35:"/usr/uploads/2017/05/2914515002.png";s:4:"size";i:35924;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(216, '206-08.png', '206-08-png', 1495019557, 1495019557, 'a:5:{s:4:"name";s:10:"206-08.png";s:4:"path";s:35:"/usr/uploads/2017/05/3997435712.png";s:4:"size";i:25793;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 8, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(217, '206-09.png', '206-09-png', 1495019599, 1495019599, 'a:5:{s:4:"name";s:10:"206-09.png";s:4:"path";s:35:"/usr/uploads/2017/05/1900728441.png";s:4:"size";i:36323;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 9, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(476, '如何下载和安装JDK7', '476', 1515293460, 1515298090, '<p>本文记录如何下载和安装JDK7，学会这个，Java应该就算入门了～</p>\r<!--more-->\r\r<p>JDK的全称是JavaSE Development Kit，即java开发工具包，是sun公司提供的一套用于开发java应用程序的开发包，它提供了编译、运行java程序所需的各种工具和资源，包括java编译器、java运行时环境，以及常用的java类库等。</p>\r\r<p><strong>1. JDK的下载</strong></p>\r\r<p>第一步：登录<a href="http://www.oracle.com/cn/index.html" target="_blank">http://www.oracle.com/cn/index.html</a>，点击导航栏上&ldquo;下载&rdquo;，我们可以看到下图所示的页面。&nbsp; &nbsp;&nbsp;</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/1898077596.png" style="width: 600px; height: 238px;" /></p>\r\r<p>第二步：点击图1-1中&ldquo;Java开发资源&rdquo;可以进入到JDK的下载页面，如下图所示。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3468550428.png" style="width: 600px; height: 300px;" /></p>\r\r<p>第三步：在JDK的下载页面中首先看到的是目前JDK最新版本JDK8。此时只需在如图所示的页面中向下看，在页面的最后有&ldquo;Java存档&rdquo;，点击&ldquo;java存档&rdquo;右侧的&ldquo;DOWNLOAD&rdquo;按钮即可进入JDK的历史版本页面见下图。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2899194692.png" style="width: 600px; height: 227px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/806210183.png" style="width: 600px; height: 296px;" /></p>\r\r<p>第四步：在JDK历史版本页面中，找到JDK7，点击&ldquo;Java SE7&rdquo;，进入JDK7的历史更新包位置。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3654222899.png" style="width: 600px; height: 418px;" /></p>\r\r<p>第五步：在JDK7历是更新包页面中找到JDK7.51，点击&ldquo;Java SE Development Kit 7u51&rdquo;进入下载页面。进入下载页面，点击&ldquo;Accent Lincense Agreement&rdquo;接受协议。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3362692956.png" style="width: 600px; height: 330px;" /></p>\r\r<p>第六步：接受协议之后，既可以根据自己的系统的版本下载对应的JDK图1-7示。下载完成之后可以看到下图所示的一个压缩包。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/4129276484.png" style="width: 600px; height: 348px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3383332572.png" style="width: 600px; height: 23px;" /></p>\r\r<p>到此JDK的下载工作已经完成。</p>\r\r<p><strong>2. JDK的安装</strong></p>\r\r<p>第一步：解压下载好的JDK7.51，如下图所示。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/1709912593.png" style="width: 600px; height: 34px;" /></p>\r\r<p>第二步：双击打开安装文件，注意安装与操作系统对应版本；在此我安装的是64的JDK。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2268273077.png" style="width: 600px; height: 469px;" /></p>\r\r<p>第三步:选择&ldquo;下一步&rdquo;，进入安装路径选择页面。选择安装路径时，注意：不要选择带中文及特殊符号的路径，也尽量不要安装到C盘。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/1720716446.png" style="width: 600px; height: 459px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2482140266.png" style="width: 600px; height: 456px;" /></p>\r\r<p>第四步:在第三步基础上选择&ldquo;下一步&rdquo;，选择是否安装JRE，这里我们选择安装(当然也可以不安装，开发中我们只装jdk就行)。选择好JRE的安装路径后点击&ldquo;下一步&rdquo;，下图为JRE安装完成后的界面，点击&ldquo;关闭&rdquo;，JRE安装成功。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/1601548463.png" style="width: 600px; height: 460px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3061516794.png" style="width: 600px; height: 456px;" /></p>\r\r<p>第五步：JDK和JRE安装成功之后的目录结构如下图示。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2346839076.png" style="width: 600px; height: 630px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3405261777.png" style="width: 600px; height: 477px;" /></p>\r\r<p>第六步：验证jdk是否安装安装成功。</p>\r\r<ol>\r	<li>win+r运行cmd，打开dos窗口；</li>\r	<li>进入jdk安装目录下的bin目录；</li>\r	<li>输入javac屏幕输出帮助信息即安装成功。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 174),
(483, '005.png', '005-png-1', 1515297098, 1515297098, 'a:5:{s:4:"name";s:7:"005.png";s:4:"path";s:35:"/usr/uploads/2018/01/3654222899.png";s:4:"size";i:54537;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(478, '001.png', '001-png-4', 1515297090, 1515297090, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2018/01/1898077596.png";s:4:"size";i:98597;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(479, '002.png', '002-png-1', 1515297090, 1515297090, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/01/3468550428.png";s:4:"size";i:104865;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(481, '003.png', '003-png-1', 1515297098, 1515297098, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:35:"/usr/uploads/2018/01/2899194692.png";s:4:"size";i:61121;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 8, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(482, '004.png', '004-png', 1515297098, 1515297098, 'a:5:{s:4:"name";s:7:"004.png";s:4:"path";s:34:"/usr/uploads/2018/01/806210183.png";s:4:"size";i:113815;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 9, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 476, 0),
(220, '218-01.png', '218-01-png', 1495020052, 1495020052, 'a:5:{s:4:"name";s:10:"218-01.png";s:4:"path";s:35:"/usr/uploads/2017/05/2777422448.png";s:4:"size";i:34007;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 10, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(222, '218-02.png', '218-02-png', 1495020108, 1495020108, 'a:5:{s:4:"name";s:10:"218-02.png";s:4:"path";s:35:"/usr/uploads/2017/05/2477719911.png";s:4:"size";i:56164;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 11, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(223, '218-03.png', '218-03-png', 1495020149, 1495020149, 'a:5:{s:4:"name";s:10:"218-03.png";s:4:"path";s:35:"/usr/uploads/2017/05/3969583676.png";s:4:"size";i:70527;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 12, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(224, '218-04.png', '218-04-png', 1495020194, 1495020194, 'a:5:{s:4:"name";s:10:"218-04.png";s:4:"path";s:35:"/usr/uploads/2017/05/4045416721.png";s:4:"size";i:50071;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 13, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(225, '218-05.png', '218-05-png', 1495020246, 1495020246, 'a:5:{s:4:"name";s:10:"218-05.png";s:4:"path";s:35:"/usr/uploads/2017/05/3253157914.png";s:4:"size";i:57762;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 14, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(226, '218-06.png', '218-06-png', 1495020289, 1495020289, 'a:5:{s:4:"name";s:10:"218-06.png";s:4:"path";s:35:"/usr/uploads/2017/05/4056875878.png";s:4:"size";i:35777;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 15, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(227, '218-07.png', '218-07-png', 1495020355, 1495020355, 'a:5:{s:4:"name";s:10:"218-07.png";s:4:"path";s:35:"/usr/uploads/2017/05/1644908109.png";s:4:"size";i:59026;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 16, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(404, '001.png', '001-png-3', 1507996161, 1507996161, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2017/10/4157280056.png";s:4:"size";i:108274;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 405, 0),
(405, '什么是Shell？', '405', 1507996204, 1507996204, '<p>本文简单的介绍下什么是Shell。</p>\r\r<!--more-->\r\r<p>Shell是一个命令解释器，它在操作系统的最外层，负责直接与用户对话，把用户的输入解释给操作系统，并处理各种各样的操作系统的输出结果，输出到屏幕返回给用户。这种对话方式可以是交互的方式(从键盘输入命令，可以立即得到Shell的回应)，或非交互(执行脚本程序)的方式。</p>\r\r<p>下图的黄色部分就是命令解释器Shell处于的操作系统中的位置形象图解。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/10/4157280056.png" style="width: 600px; height: 316px;" /></p>\r\r<p>提示：Shell英文是贝壳的意思，从上图我们可以看出，命令解释器Shell就像一个贝壳一样包住了系统核心。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 137),
(406, '《跟老男孩学Linux运维 Shell编程实战》PDF完整版下载', '406', 1507996680, 1526793433, '<p>本文分享一本Linux运维必备书籍&mdash;&mdash;《跟老男孩学Linux运维 Web集群实战》。</p>\r<!--more-->\r\r<p>书籍目录</p>\r\r<p>前言<br />\r第1章 如何才能学好Shell编程 / 1<br />\r1.1 为什么要学习Shell编程 / 1<br />\r1.2 学好Shell编程所需的基础知识 / 1<br />\r1.3 如何才能学好Shell编程之&ldquo;老鸟&rdquo;经验谈 / 3<br />\r1.4 学完本书后可以达到何种Shell编程高度 / 5<br />\r第2章 Shell脚本初步入门 / 6<br />\r2.1 什么是Shell / 6<br />\r2.2 什么是Shell脚本 / 7<br />\r2.3 Shell脚本在Linux运维工作中的地位 / 8<br />\r2.4 脚本语言的种类 / 9<br />\r2.4.1 Shell脚本语言的种类 / 9<br />\r2.4.2 其他常用的脚本语言种类 / 10<br />\r2.4.3 Shell脚本语言的优势 / 11<br />\r2.5 常用操作系统默认的Shell / 11<br />\r2.6 Shell脚本的建立和执行 / 12<br />\r2.6.1 Shell脚本的建立 / 12<br />\r2.6.2 Shell脚本的执行 / 15<br />\r2.6.3 Shell脚本开发的基本规范及习惯 / 19<br />\r第3章 Shell变量的核心基础知识与实践 / 22<br />\r3.1 什么是Shell变量 / 22<br />\r3.2 环境变量 / 23<br />\r3.2.1 自定义环境变量 / 26<br />\r3.2.2 显示与取消环境变量 / 28<br />\r3.2.3 环境变量初始化与对应文件的生效顺序 / 30<br />\r3.3 普通变量 / 31<br />\r3.3.1 定义本地变量 / 31<br />\r3.3.2 变量定义及变量输出说明 / 35<br />\r3.4 变量定义技巧总结 / 40<br />\r第4章 Shell变量知识进阶与实践 / 41<br />\r4.1 Shell中特殊且重要的变量 / 41<br />\r4.1.1 Shell中的特殊位置参数变量 / 41<br />\r4.1.2 Shell进程中的特殊状态变量 / 47<br />\r4.2 bash Shell内置变量命令 / 52<br />\r4.3 Shell变量子串知识及实践 / 55<br />\r4.3.1 Shell变量子串介绍 / 55<br />\r4.3.2 Shell变量子串的实践 / 56<br />\r4.3.3 变量子串的生产场景应用案例 / 59<br />\r4.4 Shell特殊扩展变量的知识与实践 / 60<br />\r4.4.1 Shell特殊扩展变量介绍 / 60<br />\r4.4.2 Shell特殊扩展变量的实践 / 61<br />\r4.4.3 Shell特殊扩展变量的生产场景应用案例 / 63<br />\r第5章 变量的数值计算实践 / 65<br />\r5.1 算术运算符 / 65<br />\r5.2 双小括号&ldquo;(())&rdquo;数值运算命令 / 66<br />\r5.2.1 双小括号&ldquo;(())&rdquo;数值运算的基础语法 / 66<br />\r5.2.2 双小括号&ldquo;(())&rdquo;数值运算实践 / 66<br />\r5.3 let运算命令的用法 / 73<br />\r5.4 expr命令的用法 / 75<br />\r5.4.1 expr命令的基本用法示例 / 75<br />\r5.4.2 expr的企业级实战案例详解 / 76<br />\r5.5 bc命令的用法 / 81<br />\r5.6 awk实现计算 / 83<br />\r5.7 declare（同typeset）命令的用法 / 83<br />\r5.8 $[]符号的运算示例 / 83<br />\r5.9 基于Shell变量输入read命令的运算实践 / 84<br />\r5.9.1 read命令基础 / 84<br />\r5.9.2 以read命令读入及传参的综合企业案例 / 87<br />\r第6章 Shell脚本的条件测试与比较 / 92<br />\r6.1 Shell脚本的条件测试 / 92<br />\r6.1.1 条件测试方法综述 / 92<br />\r6.1.2 test条件测试的简单语法及示例 / 93<br />\r6.1.3 []（中括号）条件测试语法及示例 / 94<br />\r6.1.4 [[]]条件测试语法及示例 / 95<br />\r6.2 文件测试表达式 / 97<br />\r6.2.1 文件测试表达式的用法 / 97<br />\r6.2.2 文件测试表达式举例 / 97<br />\r6.2.3 特殊条件测试表达式案例 / 101<br />\r6.3 字符串测试表达式 / 102<br />\r6.3.1 字符串测试操作符 / 102<br />\r6.3.2 字符串测试生产案例 / 104<br />\r6.4 整数二元比较操作符 / 105<br />\r6.4.1 整数二元比较操作符介绍 / 105<br />\r6.4.2 整数变量测试实践示例 / 107<br />\r6.5 逻辑操作符 / 108<br />\r6.5.1 逻辑操作符介绍 / 108<br />\r6.5.2 逻辑操作符实践示例 / 110<br />\r6.5.3 逻辑操作符企业案例 / 112<br />\r6.6 测试表达式test、[]、[[]]、(())的区别总结 / 120<br />\r第7章 if条件语句的知识与实践 / 121<br />\r7.1 if条件语句 / 121<br />\r7.1.1 if条件语句的语法 / 121<br />\r7.1.2 if条件语句多种条件表达式语法 / 125<br />\r7.1.3 单分支if条件语句实践 / 126<br />\r7.1.4 if条件语句的深入实践 / 130<br />\r7.2 if条件语句企业案例精讲 / 132<br />\r7.2.1 监控Web和数据库的企业案例 / 132<br />\r7.2.2 比较大小的经典拓展案例 / 142<br />\r7.2.3 判断字符串是否为数字的多种思路 / 143<br />\r7.2.4 判断字符串长度是否为0的多种思路 / 145<br />\r7.2.5 更多的生产场景实战案例 / 145<br />\r第8章 Shell函数的知识与实践 / 151<br />\r8.1 Shell函数的概念与作用介绍 / 151<br />\r8.2 Shell函数的语法 / 152<br />\r8.3 Shell函数的执行 / 152<br />\r8.4 Shell函数的基础实践 / 153<br />\r8.5 利用Shell函数开发企业级URL检测脚本 / 155<br />\r8.6 利用Shell函数开发一键优化系统脚本 / 158<br />\r8.7 利用Shell函数开发rsync服务启动脚本 / 166<br />\r第9章 case条件语句的应用实践 / 169<br />\r9.1 case条件语句的语法 / 169<br />\r9.2 case条件语句实践 / 171<br />\r9.3 实践：给输出的字符串加颜色 / 176<br />\r9.3.1 给输出的字符串加颜色的基础知识 / 176<br />\r9.3.2 结合case语句给输出的字符串加颜色 / 177<br />\r9.3.3 给输出的字符串加背景颜色 / 180<br />\r9.4 case语句企业级生产案例 / 181<br />\r9.5 case条件语句的Linux系统脚本范例 / 187<br />\r9.6 本章小结 / 191<br />\r第10章 while循环和until循环的应用实践 / 192<br />\r10.1 当型和直到型循环语法 / 192<br />\r10.1.1 while循环语句 / 192<br />\r10.1.2 until循环语句 / 193<br />\r10.2 当型和直到型循环的基本范例 / 194<br />\r10.3 让Shell脚本在后台运行的知识 / 195<br />\r10.4 企业生产实战：while循环语句实践 / 206<br />\r10.5 while循环按行读文件的方式总结 / 210<br />\r10.6 企业级生产高级实战案例 / 211<br />\r10.7 本章小结 / 215<br />\r第11章 for和select循环语句的应用实践 / 217<br />\r11.1 for循环语法结构 / 217<br />\r11.2 for循环语句的基础实践 / 219<br />\r11.3 for循环语句的企业级案例 / 222<br />\r11.4 for循环语句的企业高级实战案例 / 230<br />\r11.5 Linux系统产生随机数的6种方法 / 239<br />\r11.6 select循环语句介绍及语法 / 241<br />\r11.7 select循环语句案例 / 242<br />\r第12章 循环控制及状态返回值的应用实践 / 249<br />\r12.1 break、continue、exit、return的区别和对比 / 249<br />\r12.2 break、continue、exit功能执行流程图 / 249<br />\r12.3 break、continue、exit、return命令的基础示例 / 251<br />\r12.4 循环控制及状态返回值的企业级案例 / 253<br />\r第13章 Shell数组的应用实践 / 260<br />\r13.1 Shell数组介绍 / 260<br />\r13.1.1 为什么会产生Shell数组 / 260<br />\r13.1.2 什么是Shell数组 / 260<br />\r13.2 Shell数组的定义与增删改查 / 261<br />\r13.2.1 Shell数组的定义 / 261<br />\r13.2.2 Shell数组的打印及输出 / 262<br />\r13.3 Shell数组脚本开发实践 / 265<br />\r13.4 Shell数组的重要命令 / 267<br />\r13.5 Shell数组相关面试题及高级实战案例 / 268<br />\r13.6 合格运维人员必会的脚本列表 / 277<br />\r第14章 Shell脚本开发规范 / 279<br />\r14.1 Shell脚本基本规范 / 279<br />\r14.2 Shell脚本变量命名及引用变量规范 / 281<br />\r14.3 Shell函数的命名及函数定义规范 / 282<br />\r14.4 Shell脚本（模块）高级命名规范 / 283<br />\r14.5 Shell脚本的代码风格 / 283<br />\r14.5.1 代码框架 / 283<br />\r14.5.2 缩进规范 / 284<br />\r14.6 Shell脚本的变量及文件检查规范 / 285<br />\r第15章 Shell脚本的调试 / 286<br />\r15.1 常见Shell脚本错误范例 / 286<br />\r15.1.1 if条件语句缺少结尾关键字 / 286<br />\r15.1.2 循环语句缺少关键字 / 287<br />\r15.1.3 成对的符号落了单 / 287<br />\r15.1.4 中括号两端没空格 / 288<br />\r15.1.5 Shell语法调试小结 / 289<br />\r15.2 Shell脚本调试技巧 / 289<br />\r15.2.1 使用dos2unix命令处理在Windows下开发的脚本 / 289<br />\r15.2.2 使用echo命令调试 / 290<br />\r15.2.3 使用bash命令参数调试 / 291<br />\r15.2.4 使用set命令调试部分脚本内容 / 294<br />\r15.2.5 其他调试Shell脚本的工具 / 296<br />\r15.3 本章小结 / 296<br />\r第16章 Shell脚本开发环境的配置和优化实践 / 297<br />\r16.1 使用vim而不是vi编辑器 / 297<br />\r16.2 配置文件.vimrc的重要参数介绍 / 298<br />\r16.3 让配置文件.vimrc生效 / 304<br />\r16.4 使用vim编辑器进行编码测试 / 304<br />\r16.4.1 代码自动缩进功能 / 304<br />\r16.4.2 代码颜色高亮显示功能说明 / 304<br />\r16.5 vim配置文件的自动增加版权功能 / 305<br />\r16.6 vim配置文件的代码折叠功能 / 305<br />\r16.7 vim编辑器批量缩进及缩进调整技巧 / 305<br />\r16.8 其他vim配置文件功能说明 / 307<br />\r16.9 vim编辑器常用操作技巧 / 307<br />\r第17章 Linux信号及trap命令的企业应用实践 / 310<br />\r17.1 信号知识 / 310<br />\r17.1.1 信号介绍 / 310<br />\r17.1.2 信号列表 / 310<br />\r17.2 使用trap控制信号 / 311<br />\r17.3 Linux信号及trap命令的生产应用案例 / 313<br />\r第18章 Expect自动化交互式程序应用实践 / 317<br />\r18.1 Expect介绍 / 317<br />\r18.1.1 什么是Expect / 317<br />\r18.1.2 为什么要使用Expect / 317<br />\r18.2 安装Expect软件 / 318<br />\r18.3 小试牛刀：实现Expect自动交互功能 / 318<br />\r18.4 Expect程序自动交互的重要命令及实践 / 319<br />\r18.4.1 spawn命令 / 320<br />\r18.4.2 expect命令 / 320<br />\r18.4.3 send命令 / 323<br />\r18.4.4 exp_continue命令 / 324<br />\r18.4.5 send_user命令 / 324<br />\r18.4.6 exit命令 / 325<br />\r18.4.7 Expect常用命令总结 / 325<br />\r18.5 Expect程序变量 / 326<br />\r18.5.1 普通变量 / 326<br />\r18.5.2 特殊参数变量 / 326<br />\r18.6 Expect程序中的if条件语句 / 327<br />\r18.7 Expect中的关键字 / 329<br />\r18.7.1 eof关键字 / 329<br />\r18.7.2 timeout关键字 / 329<br />\r18.8 企业生产场景下的Expect案例 / 330<br />\r18.8.1 批量执行命令 / 330<br />\r18.8.2 批量发送文件 / 332<br />\r18.8.3 批量执行Shell脚本 / 334<br />\r18.8.4 自动化部署SSH密钥认证+ansible的项目实战 / 337<br />\r18.9 本章小节 / 339<br />\r第19章 企业Shell面试题及企业运维实战案例 / 340<br />\r19.1 企业Shell面试题案例 / 340<br />\r19.1.1 面试题1：批量生成随机字符文件名 / 340<br />\r19.1.2 面试题2：批量改名 / 341<br />\r19.1.3 面试题3：批量创建特殊要求用户 / 342<br />\r19.1.4 面试题4：扫描网络内存活主机 / 342<br />\r19.1.5 面试题5：解决DOS攻击 / 343<br />\r19.1.6 面试题6：MySQL数据库分库备份 / 344<br />\r19.1.7 面试题7：MySQL数据库分库分表备份 / 344<br />\r19.1.8 面试题8：筛选符合长度的单词 / 344<br />\r19.1.9 面试题9：MySQL主从复制异常监控 / 344<br />\r19.1.10 面试题10：比较整数大小 / 344<br />\r19.1.11 面试题11：菜单自动化软件部署 / 344<br />\r19.1.12 面试题12：Web及MySQL服务异常监测 / 345<br />\r19.1.13 面试题13：监控Memcached缓存服务 / 345<br />\r19.1.14 面试题14：开发脚本实现入侵检测与报警 / 346<br />\r19.1.15 面试题15：开发Rsync服务启动脚本 / 349<br />\r19.1.16 面试题16：开发MySQL多实例启动脚本 / 349<br />\r19.1.17 面试题17：开发学生实践抓阄脚本 / 351<br />\r19.1.18 面试题18：破解RANDOM随机数 / 353<br />\r19.1.19 面试题19：批量检查多个网站地址是否正常 / 354<br />\r19.1.20 面试题20：单词及字母去重排序 / 355<br />\r19.1.21 面试题21：开发脚本管理服务端LVS / 357<br />\r19.1.22 面试题22：LVS节点健康检查及管理脚本 / 359<br />\r19.1.23 面试题23：LVS客户端配置脚本 / 360<br />\r19.1.24 面试题24：模拟keepalived软件高可用 / 361<br />\r19.1.25 面试题25：编写正（或长）方形图形 / 362<br />\r19.1.26 面试题26：编写等腰三角形图形字符 / 363<br />\r19.1.27 面试题27：编写直角梯形图形字符 / 364<br />\r19.1.28 面试题28：51CTO博文爬虫脚本 / 365<br />\r19.1.29 面试题29：Nginx负载节点状态监测 / 366<br />\r19.2 Shell经典程序案例：哄老婆和女孩的神器 / 369<br />\r19.2.1 功能简介 / 369<br />\r19.2.2 使用方法 / 369<br />\r19.2.3 girlLove工具内容模板 / 370<br />\r19.2.4 girlLove工具的Shell源码注释 / 371<br />\r19.2.5 girlLove最终结果展示 / 376<br />\r第20章 子Shell及Shell嵌套模式知识应用 / 377<br />\r20.1 子Shell的知识及实践说明 / 377<br />\r20.1.1 什么是子Shell / 377<br />\r20.1.2 子Shell的常见产生途径及特点 / 378<br />\r20.2 子Shell在企业应用中的&ldquo;坑&rdquo; / 383<br />\r20.2.1 使用管道与while循环时遭遇的&ldquo;坑&rdquo; / 383<br />\r20.2.2 解决while循环遭遇的&ldquo;坑&rdquo; / 385<br />\r20.3 Shell调用脚本的模式说明 / 386<br />\r20.3.1 fork模式调用脚本知识 / 386<br />\r21.3.2 exec模式调用脚本 / 386<br />\r21.3.3 source模式调用脚本 / 387<br />\r20.4 Shell调用脚本的3种不同实践方法 / 387<br />\r20.4.1 开发测试不同模式区别的Shell脚本 / 387<br />\r20.4.2 对比fork模式与source模式的区别 / 390<br />\r20.4.3 对比exec模式与source模式的区别 / 391<br />\r20.5 Shell调用脚本3种不同模式的应用场景 / 391<br />\r附 录 Linux重要命令汇总 / 393</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1bo670dx" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 581),
(461, '《白帽子讲Web安全》PDF完整版下载', '461', 1513992060, 1555515894, '<p>本文分享一本安全方面的书&mdash;&mdash;《白帽子讲Web安全》，道哥力作。</p>\r<!--more-->\r\r<p>图书目录：</p>\r\r<p>第一篇 世界观安全<br />\r第1章 我的安全世界观<br />\r1.1Web安全简史<br />\r1.1.1中国黑客简史<br />\r1.1.2黑客技术的发展历程<br />\r1.1.3Web安全的兴起<br />\r1.2黑帽子，白帽子<br />\r1.3返璞归真，揭秘安全的本质<br />\r1.4破除迷信，没有银弹<br />\r1.5安全三要素<br />\r1.6如何实施安全评估<br />\r1.6.1资产等级划分<br />\r1.6.2威胁分析<br />\r1.6.3风险分析<br />\r1.6.4设计安全方案<br />\r1.7白帽子兵法<br />\r1.7.1SecureByDefault原则<br />\r1.7.2纵深防御原则<br />\r1.7.3数据与代码分离原则<br />\r1.7.4不可预测性原则<br />\r1.8小结<br />\r（附）谁来为漏洞买单？<br />\r第二篇 客户端脚本安全<br />\r第2章 浏览器安全<br />\r2.1同源策略<br />\r2.2浏览器沙箱<br />\r2.3恶意网址拦截<br />\r2.4高速发展的浏览器安全<br />\r2.5小结<br />\r第3章 跨站脚本攻击（XSS）<br />\r3.1XSS简介<br />\r3.2XSS攻击进阶<br />\r3.2.1初探XSSPayload<br />\r3.2.2强大的XSSPayload<br />\r3.2.3XSS攻击平台<br />\r3.2.4终极武器：XSSWorm<br />\r3.2.5调试JavaScript<br />\r3.2.6XSS构造技巧<br />\r3.2.7变废为宝：MissionImpossible<br />\r3.2.8容易被忽视的角落：FlashXSS<br />\r3.2.9真的高枕无忧吗：JavaScript开发框架<br />\r3.3XSS的防御<br />\r3.3.1四两拨千斤：HttpOnly<br />\r3.3.2输入检查<br />\r3.3.3输出检查<br />\r3.3.4正确地防御XSS<br />\r3.3.5处理富文本<br />\r3.3.6防御DOMBasedXSS<br />\r3.3.7换个角度看XSS的风险<br />\r3.4小结<br />\r第4章 跨站点请求伪造（CSRF）<br />\r4.1CSRF简介<br />\r4.2CSRF进阶<br />\r4.2.1浏览器的Cookie策略<br />\r4.2.2P3P头的副作用<br />\r4.2.3GET?POST?<br />\r4.2.4FlashCSRF<br />\r4.2.5CSRFWorm<br />\r4.3CSRF的防御<br />\r4.3.1验证码<br />\r4.3.2RefererCheck<br />\r4.3.3AntiCSRFToken<br />\r4.4小结<br />\r第5章 点击劫持（ClickJacking）<br />\r5.1什么是点击劫持<br />\r&hellip;&hellip;<br />\r第6章 HTML5安全<br />\r第三篇 服务器端应用安全<br />\r第7章 注入攻击<br />\r第8章 文件上传漏洞<br />\r第9章 认证与会话管理<br />\r第10章 访问控制<br />\r第11章 加密算法与随机数<br />\r第12章 Web框架安全<br />\r第13章 应用层拒绝服务攻击<br />\r第14章 PHP安全<br />\r第15章 WebServer配置安全<br />\r第四篇 互联网公司安全运营<br />\r第16章 互联网业务安全<br />\r第17章 安全开发流程（SDL）<br />\r第18章 安全运营</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1PSoOXa2XxdRYvdtjlv8hbw" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4194),
(562, '001.png', '001-png-6', 1516279680, 1516279680, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:34:"/usr/uploads/2018/01/279104980.png";s:4:"size";i:182134;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 561, 0),
(564, '002.png', '002-png-3', 1516279835, 1516279835, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/01/2538120519.png";s:4:"size";i:120858;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 561, 0),
(565, '003.png', '003-png-3', 1516280009, 1516280009, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:35:"/usr/uploads/2018/01/3121825939.png";s:4:"size";i:96106;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 561, 0),
(408, '《微服务架构与实践》PDF完整版下载', '408', 1508575920, 1526793392, '<p>本文分享一本书&mdash;&mdash;《微服务架构与实践》。</p>\r<!--more-->\r\r<p>第 1部分 基础篇<br />\r第 1章 单块架构及其面临的挑战<br />\r1.1三层应用架构<br />\r1.1.1三层应用架构的发展<br />\r1.1.2什么是三层架构<br />\r1.1.3三层架构的优势<br />\r1.2单块架构<br />\r1.2.1什么是单块架构<br />\r1.2.2单块架构的优势<br />\r1.2.3单块架构面临的挑战<br />\r1.3 小结<br />\r第 2章 微服务架构综述<br />\r2.1什么是微服务架构<br />\r2.1.1多微才够微&nbsp;<br />\r2.1.2 单一职责&nbsp;<br />\r2.1.3 轻量级通信&nbsp;<br />\r2.1.4 独立性&nbsp;<br />\r2.1.5 进程隔离<br />\r2.2 微服务的诞生背景<br />\r2.2.1 互联网行业的快速发展<br />\r2.2.2 敏捷、精益方法论的深入人心&nbsp;<br />\r2.2.3 单块架构系统面临的挑战<br />\r2.2.4 容器虚拟化技术<br />\r2.3 微服务架构与 SOA&nbsp;<br />\r2.3.1 SOA概述<br />\r2.3.2 微服务与 SOA&nbsp;<br />\r2.4 微服务的本质&nbsp;<br />\r2.4.1服务作为组件<br />\r2.4.2 围绕业务组织团队<br />\r2.4.3 关注产品而非项目&nbsp;<br />\r2.4.4 技术多样性&nbsp;<br />\r2.4.5 业务数据独立&nbsp;<br />\r2.4.6 基础设施自动化&nbsp;<br />\r2.4.7 演进式架构&nbsp;<br />\r2.5 微服务不是银弹&nbsp;<br />\r2.5.1 分布式系统的复杂度&nbsp;<br />\r2.5.2 运维成本&nbsp;<br />\r2.5.3 部署自动化<br />\r2.5.4 DevOps与组织架构 &nbsp;<br />\r2.5.5 服务间的依赖测试 &nbsp;<br />\r2.5.6 服务间的依赖管理&nbsp;<br />\r2.6 小结&nbsp;<br />\r第 2部分 实践篇<br />\r第 3章 构建个服务<br />\r3.1场景分析<br />\r3.2任务拆分<br />\r第 4章 Hello World API<br />\r4.1 API实现<br />\r4.1.1 开发语言 &mdash;&mdash;Ruby<br />\r4.1.2 Web框架&mdash;&mdash;Grape&nbsp;<br />\r4.1.3 API的具体实现<br />\r4.2代码测试与静态检查<br />\r4.2.1代码测试<br />\r4.2.2测试覆盖率统计<br />\r4.2.3静态检查<br />\r4.2.4代码复杂度检查<br />\r第 5章 构建 Docker映像<br />\r5.1 定义 Dockerfile<br />\r5.2 配置 Docker主机&nbsp;<br />\r5.3 构建 Docker映像&nbsp;<br />\r5.4 运行 Docker容器&nbsp;<br />\r5.5 发布 Docker映像&nbsp;<br />\r5.6 小结&nbsp;<br />\r第 6章 部署 Docker映像&nbsp;<br />\r6.1基础设施 AWS<br />\r6.2基础设施自动化<br />\r6.3 部署 Docker映像<br />\r6.4自动化部署&nbsp;<br />\r6.5 小结&nbsp;<br />\r第 7章 持续交付流水线&nbsp;<br />\r7.1持续集成环境&nbsp;<br />\r7.2提交阶段&nbsp;<br />\r7.3验证阶段&nbsp;<br />\r7.4构建阶段&nbsp;<br />\r7.5发布阶段&nbsp;<br />\r7.6 小结&nbsp;<br />\r第 8章 日志聚合<br />\r8.1 日志聚合工具简介&nbsp;<br />\r8.2 Splunk的核心&nbsp;<br />\r8.3 安装 Splunk索引器&nbsp;<br />\r8.4 安装 Splunk转发器&nbsp;<br />\r8.5日志查找&nbsp;<br />\r8.6告警设置&nbsp;<br />\r8.7 小结&nbsp;<br />\r第 9章 监控与告警<br />\r9.1 Nagios简介<br />\r9.2 Nagios的工作原理&nbsp;<br />\r9.3 Nagios安装<br />\r9.4 Nagios的配置&nbsp;<br />\r9.5 监控 products-service&nbsp;<br />\r9.6 告警&nbsp;<br />\r9.7 小结&nbsp;<br />\r第 10章 功能迭代&nbsp;<br />\r10.1定义模型&nbsp;<br />\r10.2持久化模型&nbsp;<br />\r10.3定义表现形式&nbsp;<br />\r10.4 实现 API&nbsp;<br />\r10.5服务描述文件<br />\r10.6 小结&nbsp;<br />\r第 3部分 进阶篇<br />\r第 11章 微服务与持续交付<br />\r11.1持续交付的核心<br />\r11.2微服务架构与持续交付&nbsp;<br />\r11.2.1 开发&nbsp;<br />\r11.2.2 测试<br />\r11.2.3持续集成<br />\r11.2.4 构建&nbsp;<br />\r11.2.5 部署&nbsp;<br />\r11.2.6 运维&nbsp;<br />\r11.3 小结</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1geIAXTx" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 304),
(288, '《跟老男孩学Linux运维 Web集群实战》PDF完整版下载', '288', 1495203300, 1555390123, '<p>本文分享一本Linux运维必备书籍&mdash;&mdash;《跟老男孩学Linux运维 Web集群实战》。</p>\r<!--more-->\r\r<p>一、书籍简介</p>\r\r<p>《跟老男孩学Linux运维 Web集群实战》针对中小规模网站集群的搭建、部署、优化进行了详细讲解。全书可分为三大部分，其中第一部分讲的是Linux相关的基础且重要的知识，第二部分针对当下流行的Web环境架构（LNMP）的搭建及企业级Web优化等进行了讲解，第三部分讲的是Web集群后端的数据存储和Web集群前端的负载均衡高可用。</p>\r\r<p>如果你是一名经验丰富的资深Linux用户，可以直接阅读第二部分内容。但如果你是一名Linux初学者，请一定从第1章的基础知识开始学习。</p>\r\r<p>第一部分为基础篇（第1~4章），简单地介绍了Linux的历史沿革、Linux的企业级选型、学习环境的搭建、Linux的企业级系统安装、Linux系统的基础优化，以及远程连接Linux及客户端SSH的设置等，最后比较深入地讲解了HTTP协议和www服务相关知识，为读者搭建企业级Web集群环境做好了准备。</p>\r\r<p>第二部分为Web服务篇（第5~8章），着重讲解了Linux、Nginx、MySQL、PHP（LNMP）等当下流行的Web环境架构的搭建、开源blog网站产品的安装部署、Web优化等知识。为读者搭建企业级完整的网站Web集群架构做好了准备。</p>\r\r<p>第三部分为集群篇（第9~15章），着重讲解了Web集群后端的MySQL数据库、Web集群共享存储NFS、Nginx反向代理负载均衡、Keepalived高可用、Memcached缓存及session共享、Nagios企业级监控等技术实战，最后为读者规划了一个中等规模的网站集群架构解决方案。</p>\r\r<p>二、书籍信息</p>\r\r<p>作者：老男孩<br />\r出版社： 机械工业出版社<br />\rISBN：9787111529835<br />\r版次：1<br />\r开本：16开<br />\r出版时间：2016-04-01</p>\r\r<p>三、书籍目录</p>\r\r<p>第1章 Linux系统介绍与环境搭建准备 / 1<br />\r1.1 Linux简介 / 1<br />\r1.1.1 什么是操作系统 / 1<br />\r1.1.2 什么是Linux / 2<br />\r1.2 Linux的起源 / 3<br />\r1.2.1 UNIX的历史 / 3<br />\r1.2.2 UNIX的5大优秀特性 / 4<br />\r1.2.3 UNIX操作系统的革命 / 4<br />\r1.2.4 Linux的诞生 / 5<br />\r1.2.5 Linux的发展历程 / 5<br />\r1.3 Linux核心概念知识 / 6<br />\r1.3.1 自由软件与FSF / 6<br />\r1.3.2 GNU知识 / 7<br />\r1.3.3 GPL知识 / 8<br />\r1.3.4 Linux系统组成 / 8<br />\r1.4 Linux的特点 / 8<br />\r1.4.1 Linux为什么受欢迎 / 8<br />\r1.4.2 Linux更多特点介绍 / 9<br />\r1.5 Linux的应用领域 / 9<br />\r1.5.1 IT服务器Linux系统应用领域 / 9<br />\r1.5.2 嵌入式Linux系统应用领域 / 10<br />\r1.5.3 个人桌面Linux应用领域 / 11<br />\r1.5.4 本书讲解的Linux领域说明 / 11<br />\r1.6 如何选择Linux的发行版 / 11<br />\r1.6.1 Linux的发行版本介绍 / 11<br />\r1.6.2 选择适合的Linux系统学习 / 12<br />\r1.7 搭建学习Linux的运维环境 / 14<br />\r1.7.1 虚拟机软件介绍 / 14<br />\r1.7.2 通过虚拟机软件学习Linux运维 / 15<br />\r1.7.3 选择适合自己的虚拟机软件 / 16<br />\r1.7.4 安装与使用VMware虚拟机软件 / 17<br />\r1.7.5 创建一个虚拟机的实践 / 17<br />\r1.8 本章重点回顾 / 26<br />\r1.9 本章知识相关考试题 / 27<br />\r1.10 本章参考资料 / 27<br />\r第2章 企业级CentOS 6.6操作系统安装 / 28<br />\r2.1 下载CentOS系统ISO镜像 / 28<br />\r2.1.1 下载CentOS系统ISO镜像的说明 / 28<br />\r2.1.2 下载后有关ISO镜像的使用说明 / 29<br />\r2.1.3 为什么企业环境要选择64位操作系统 / 30<br />\r2.1.4 如何区分已安装的系统是32位还是64位 / 31<br />\r2.1.5 在学习与工作中如何选择操作系统 / 31<br />\r2.2 CentOS 6.6操作系统安装准备 / 32<br />\r2.2.1 单台物理服务器安装系统准备 / 32<br />\r2.2.2 虚拟机学习安装系统准备 / 32<br />\r2.3 开始安装CentOS 6.6操作系统 / 33<br />\r2.3.1 安装CentOS 6.6操作系统的过程 / 33<br />\r2.3.2 磁盘分区类型选择与磁盘分区配置过程 / 39<br />\r2.3.3 CentOS 6.6系统安装包组的选择与配置过程 / 47<br />\r2.4 系统安装后的基本配置 / 50<br />\r2.4.1 重启系统过程中的引导过程介绍 / 50<br />\r2.4.2 登录系统 / 51<br />\r2.4.3 配置网卡和设置网络联网 / 52<br />\r2.4.4 更新系统，打补丁到最新 / 58<br />\r2.4.5 额外安装一些有用的软件包 / 59<br />\r2.5 本章重点回顾 / 59<br />\r2.6 本章知识相关考试题 / 60<br />\r第3章 CentOS 6.6连接管理及优化 / 61<br />\r3.1 远程连接Linux系统管理 / 61<br />\r3.1.1 为什么要远程连接Linux系统 / 61<br />\r3.1.2 远程连接Linux的原理 / 61<br />\r3.1.3 远程连接Linux的客户端工具介绍 / 65<br />\r3.1.4 如何选择远程连接Linux的工具 / 65<br />\r3.2 SSH客户端常用工具SecureCRT / 66<br />\r3.2.1 SecureCRT工具介绍 / 66<br />\r3.2.2 SecureCRT工具安装说明 / 66<br />\r3.2.3 配置SecureCRT连接Linux主机 / 66<br />\r3.2.4 通过SSH工具连接Linux主机的常见问题 / 67<br />\r3.2.5 调整SecureCRT终端显示和回滚缓冲区大小 / 69<br />\r3.2.6 调整字体及光标颜色 / 70<br />\r3.2.7 配置记录SSH操作的日志及输出 / 70<br />\r3.2.8 配置本地机器上传和下载的目录 / 71<br />\r3.2.9 实现批量部署和管理功能 / 73<br />\r3.2.10 配置SecureCRT标签路径 / 75<br />\r3.2.11 配置标签模板 / 75<br />\r3.2.12 调整命令行颜色方案（目录和注释） / 76<br />\r3.3 Linux系统应用管理 / 77<br />\r3.3.1 添加普通用户账号 / 77<br />\r3.3.2 基本的Linux命令操作示例 / 79<br />\r3.4 安装Linux系统后调优及安全设置 / 83<br />\r3.4.1 关闭SELinux功能 / 83<br />\r3.4.2 设定运行级别为3（文本模式） / 84<br />\r3.4.3 精简开机系统自启动 / 84<br />\r3.4.4 关闭iptables防火墙 / 88<br />\r3.4.5 Linux系统安全最小原则说明 / 88<br />\r3.4.6 更改SSH服务器端远程登录的配置 / 89<br />\r3.4.7 利用sudo控制用户对系统命令的使用权限 / 91<br />\r3.4.8 Linux中文显示设置 / 95<br />\r3.4.9 设置Linux服务器时间同步 / 96<br />\r3.4.10 历史记录数及登录超时环境变量设置 / 98<br />\r3.4.11 调整Linux系统文件描述符数量 / 99<br />\r3.4.12 Linux服务器内核参数优化 / 100<br />\r3.4.13 定时清理邮件服务临时目录垃圾文件 / 103<br />\r3.4.14 隐藏Linux版本信息显示 / 104<br />\r3.4.15 锁定关键系统文件，防止被提权篡改 / 104<br />\r3.4.16 清除多余的系统虚拟账号 / 105<br />\r3.4.17 为grub菜单加密码 / 105<br />\r3.4.18 禁止Linux系统被ping / 106<br />\r3.4.19 升级具有典型漏洞的软件版本 / 107<br />\r3.5 Linux基础优化与安全重点小结 / 107<br />\r3.6 有关VMware虚拟机的使用问题 / 108<br />\r3.7 本章重点回顾 / 109<br />\r3.8 本章知识相关考试题 / 109<br />\r第4章 Web服务基础 / 110<br />\r4.1 HTTP服务的重要基础 / 110<br />\r4.2 HTTP协议 / 115<br />\r4.3 HTTP资源 / 123<br />\r4.4 网站流量度量术语 / 129<br />\r4.5 WWW服务软件介绍 / 135<br />\r4.6 本章重点回顾 / 138<br />\r4.7 本章知识相关面试考试题 / 138<br />\r4.8 本章参考资料 / 139<br />\r第5章 Nginx Web服务应用 / 140<br />\r5.1 Nginx介绍 / 140<br />\r5.2 Nginx Web服务 / 144<br />\r5.3 编译安装Nginx / 147<br />\r5.4 Nginx技术的深入剖析 / 156<br />\r5.5 Nginx虚拟主机配置实战 / 162<br />\r5.6 Nginx常用功能配置实战 / 174<br />\r5.7 Nginx访问日志（access_log） / 184<br />\r5.8 Nginx location / 190<br />\r5.9 Nginx rewrite / 194<br />\r5.10 Nginx访问认证 / 198<br />\r5.11 Nginx相关问题的解答 / 201<br />\r5.12 本章重点回顾 / 204<br />\r第6章 企业级LNMP环境应用实践 / 205<br />\r6.1 LNMP应用环境 / 205<br />\r6.2 LNMP之MySQL数据库 / 206<br />\r6.3 FastCGI介绍 / 217<br />\r6.4 LNMP之PHP（FastCGI方式）服务的安装准备 / 218<br />\r6.5 开始安装PHP（FastCGI方式）服务 / 222<br />\r6.6 配置Nginx支持PHP程序请求访问 / 227<br />\r6.7 部署一个blog程序服务 / 230<br />\r6.8 有关使用高版本PHP 5.5的说明 / 240<br />\r6.9 本章重点回顾 / 241<br />\r6.10 本章参考资料 / 241<br />\r第7章 PHP服务缓存加速优化实战 / 242<br />\r7.1 PHP缓存加速器介绍与环境准备 / 242<br />\r7.2 安装PHP缓存加速器扩展 / 247<br />\r7.3 安装数据库缓存及其他PHP扩展插件 / 252<br />\r7.4 安装其他的PHP扩展插件模块 / 256<br />\r7.5 配置PHP加速与缓存相关的扩展插件模块 / 261<br />\r7.6 生产环境PHP扩展插件的安装建议 / 278<br />\r7.7 补充知识 / 279<br />\r7.8 PHP缓存加速压力测试练习 / 280<br />\r7.9 本章参考资料 / 281<br />\r第8章 企业级Nginx Web服务优化实战 / 282<br />\r8.1 Nginx基本安全优化 / 282<br />\r8.2 根据参数优化Nginx服务性能 / 288<br />\r8.3 Nginx日志相关优化与安全 / 311<br />\r8.4 Nginx站点目录及文件URL访问控制 / 313<br />\r8.5 Nginx图片及目录防盗链解决方案 / 317<br />\r8.6 Nginx错误页面的优雅显示 / 324<br />\r8.7 Nginx站点目录文件及目录权限优化 / 327<br />\r8.8 Nginx防爬虫优化 / 329<br />\r8.9 利用Nginx限制HTTP的请求方法 / 331<br />\r8.10 使用CDN做网站内容加速 / 331<br />\r8.11 Nginx程序架构优化 / 333<br />\r8.12 使用普通用户启动Nginx（监牢模式） / 334<br />\r8.13 控制Nginx并发连接数量 / 338<br />\r8.14 控制客户端请求Nginx的速率 / 342<br />\r8.15 本章重点回顾 / 344<br />\r第9章 MySQL数据库企业级应用实践 / 345<br />\r9.1 概述 / 345<br />\r9.2 MySQL多实例介绍 / 346<br />\r9.3 MySQL多实例的生产应用场景 / 347<br />\r9.4 MySQL多实例常见的配置方案 / 348<br />\r9.5 安装并配置多实例MySQL数据库 / 350<br />\r9.6 配置及管理MySQL多实例数据库 / 363<br />\r9.7 MySQL主从复制介绍 / 367<br />\r9.8 MySQL主从复制实践 / 373<br />\r9.9 MySQL主从复制更多应用技巧实践 / 389<br />\r9.10 本章重点回顾 / 395<br />\r9.11 本章参考资料 / 395<br />\r第10章 企业级NFS网络文件共享服务 / 396<br />\r10.1 NFS介绍 / 396<br />\r10.2 NFS系统原理介绍 / 399<br />\r10.3 NFS服务器端部署环境准备 / 403<br />\r10.4 NFS服务器端的设置 / 404<br />\r10.5 实战配置NFS服务器端 / 410<br />\r10.6 NFS配置参数权限 / 411<br />\r10.7 NFS服务企业案例配置实践 / 413<br />\r10.8 NFS服务的重点知识梳理 / 417<br />\r10.9 NFS客户端挂载命令 / 418<br />\r10.10 生产环境高级案例配置实战 / 422<br />\r10.11 NFS客户端挂载深入 / 424<br />\r10.12 NFS系统应用的优缺点说明 / 429<br />\r10.13 本章涉及的相关知识 / 430<br />\r10.14 本章重点回顾 / 435<br />\r10.15 本章参考资料 / 435<br />\r第11章 Nginx反向代理与负载均衡应用实践 / 436<br />\r11.1 集群简介 / 436<br />\r11.2 为什么要使用集群 / 436<br />\r11.3 集群的分类 / 439<br />\r11.4 常用的集群软硬件介绍及选型 / 441<br />\r11.5 Nginx负载均衡集群介绍 / 442<br />\r11.6 快速实践Nginx负载均衡环境准备 / 443<br />\r11.7 Nginx负载均衡核心组件介绍 / 449<br />\r11.8 Nginx负载均衡配置实战 / 456<br />\r11.9 Nginx负载均衡监测节点状态 / 475<br />\r11.10 proxy_next_upstream参数补充 / 478<br />\r11.11 本章重点回顾 / 478<br />\r第12章 Keepalived高可用集群应用实践 / 479<br />\r12.1 Keepalived高可用软件 / 479<br />\r12.2 Keepalived高可用服务搭建准备 / 482<br />\r12.3 Keepalived高可用服务单实例实战 / 486<br />\r12.4 Keepalived高可用服务器的&ldquo;裂脑&rdquo;问题 / 491<br />\r12.5 Keepalived双实例双主模式配置 / 492<br />\r12.6 Nginx负载均衡配合Keepalived服务案例实战 / 498<br />\r12.7 解决服务监听的网卡上不存在IP地址问题 / 502<br />\r12.8 解决高可用服务只针对物理服务器的问题 / 502<br />\r12.9 解决多组Keepalived服务器在一个局域网的冲突问题 / 505<br />\r12.10 配置指定文件接收Keepalived服务日志 / 505<br />\r12.11 开发监测Keepalived裂脑的脚本 / 507<br />\r12.12 本章重点回顾 / 508<br />\r第13章 企业级Memcached服务应用实践 / 509<br />\r13.1 Memcached介绍 / 509<br />\r13.2 Memcached的用途与应用场景 / 511<br />\r13.3 Memcached的特点与工作机制 / 514<br />\r13.4 Memcached内存管理 / 517<br />\r13.5 Memcached服务安装 / 521<br />\r13.6 Memcached服务的基本管理 / 522<br />\r13.7 安装Memcached客户端 / 527<br />\r13.8 Memcached应用管理 / 530<br />\r13.9 Memcached服务应用的优化 / 538<br />\r13.10 Memcached在集群中session共享案例 / 546<br />\r13.11 Memcached兼容持久化工具介绍 / 547<br />\r13.12 本章重点回顾 / 549<br />\r第14章 企业级监控Nagios实践 / 550<br />\r14.1 Nagios监控简介 / 550<br />\r14.2 Nagios监控工具及原理介绍 / 551<br />\r14.3 Nagios服务器端安装 / 555<br />\r14.4 Nagios客户端安装 / 571<br />\r14.5 Nagios服务器端监控 / 578<br />\r14.6 服务器端Nagios图形监控显示和管理 / 604<br />\r14.7 实现将Nagios故障报警给管理员 / 616<br />\r14.8 Nagios插件开发 / 622<br />\r14.9 常见故障问题总结 / 631<br />\r14.10 本章重点回顾 / 631<br />\r第15章 企业级网站集群搭建综合解决方案 / 632<br />\r15.1 企业级中小规模网站集群项目规划 / 632<br />\r15.2 集群服务搭建详细规划设计说明 / 641<br />\r15.3 中小规模网站集群架构综合说明 / 662<br />\r15.3.1 概述 / 662<br />\r15.3.2 运维人员的两大核心工作主题 / 664</p>\r\r<p>四、下载地址</p>\r\r<p><a href="https://pan.baidu.com/s/1Ig50Yfy0PnXTKk63mtgbGQ" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1607),
(308, 'Linux系统优化（一）——关闭SELinux功能', '308', 1495415400, 1497430481, '<p>本文分享Linux系统优化的第一部分&mdash;&mdash;关闭SELinux功能。</p>\r<!--more-->\r\r<p>SELinux（Security-Enhanced Linux）是美国国家安全局（NSA）对于强制访问控制的实现，这个功能让系统管理员又爱又恨，这里我们还是把它关闭了吧，至于安全问题，后面通过其他手段来解决，这也是大多数生产环境的做法，如果非要开启也是可以的。关闭方式如下。</p>\r\r<p>1.修改配置文件，是SELinux永久关闭：</p>\r\r<pre class="brush:bash;">\rsed -i &#39;s#SELINUX=enforcing#SELINUX=disabled#&#39; /etc/selinux/config\rgrep SELINUX=disabled /etc/selinux/config</pre>\r\r<p>2.临时关闭SELinux，可在命令行执行如下命令：</p>\r\r<pre class="brush:bash;">\rsetenforce 0\rgetenforce</pre>\r\r<hr />\r<p>注意事项：</p>\r\r<p>修改配置SELinux后，要想使其生效，必须要重启系统。因此，可配合使用setenforce 0这个临时使其关闭的命令，这样在重启前后都可以使SELinux关闭生效，也就是说无须立刻重启服务器了，在生产场景下Linux机器是不能随意重启的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 131),
(309, 'Linux系统优化（二）——设定运行级别为3（文字模式）', '309', 1495416420, 1497430474, '<p>本文分享Linux系统优化的第二部分&mdash;&mdash;设定运行级别为3（文字模式）。</p>\r<!--more-->\r\r<p>设定运行级别（runlevel）为3，即表示使用文本命令行模式管理Linux。</p>\r\r<pre class="brush:bash;">\rsed -i &#39;s#id:3:initdefault:#id:5:initdefault:#&#39; /etc/inittab\rgrep id:3:initdefault: /etc/inittab</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(310, 'Linux系统优化（三）——精简开机系统自启动', '310', 1495419120, 1497430467, '<p>本文介绍Linux系统优化的第三部分&mdash;&mdash;精简开机系统自启动。</p>\r<!--more-->\r\r<p>与Windows系统一样，在Linux服务器运行的过程中，也会有很多无用的软件服务默认运行，这些服务占用了很多系统资源，而且也带来了安全隐患，因此要关闭。</p>\r\r<p>1.重要的开机自启动服务</p>\r\r<p>企业环境新装Linux系统之后有必要保留的开机自启动服务有5个，具体如下。</p>\r\r<p>sshd：远程连接Linux服务器时需要用到这个服务程序，所以必须要开启，否则Linux服务器就无法提供远程连接服务了。<br />\rrsyslog：日志相关软件，这是操作系统提供的一种机制，系统的守护程序通常会使用rsyslog程序将各种信息写到各个系统日志文件中，在CentOS6以前此服务的名字为syslog。<br />\rnetwork：系统启动时，若想开启各个网络接口，则必须开启此服务。<br />\rcrond：该服务用于周期性地执行系统及用户配置的任务计划。有要周期性执行的任务时，就要开启，此服务几乎是生产场景必须要用的一个软件。<br />\rsysstat：包含监测系统性能及效率的一组工具，这些工具对于我们收集系统性能数据很有帮助，比如CPU使用率、硬盘和网络吞吐数据等，对这些数据的收集和分析，有利于判断系统运行是否正常，所以它是提高系统运行效率、安全运行服务器的得力助手。</p>\r\r<p>2.设置开机自启动服务的常见方法</p>\r\r<p>1）执行命令，然后手动选择处理的方法</p>\r\r<p>方法1：执行ntsysv命令，然后在弹出的窗口中进行设置。<br />\r方法2：执行setup命令，然后在system-service中设置。</p>\r\r<p>2）通过一行命令或shell脚本进行设置</p>\r\r<pre class="brush:bash;">\rLANG=en\rchkconfig --list | grep 3:on | grep -vE &quot;crond|sshd|network|rsyslog|sysstat&quot; | awk &#39;{print &quot;chkconfig &quot; $1 &quot; off&quot;}&#39; | bash</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(314, '图书', 'books', 1495709940, 1555826027, '<h2>技术类</h2>\r\r<ol>\r	<li>《跟老男孩学Linux运维 Web集群实战》 <a href="/it/288.html">点我下载</a></li>\r	<li>《Redis实战》 <a href="/it/330.html">点我下载</a></li>\r	<li>《Linux运维之道》 <a href="/it/331.html">点我下载</a></li>\r	<li>《TCP-IP详解卷一 协议》 <a href="/it/332.html">点我下载</a></li>\r	<li>《Go语言编程》 <a href="/it/333.html">点我下载</a></li>\r	<li>《Maven实战》 <a href="/it/340.html">点我下载</a></li>\r	<li>《图解HTTP》 <a href="/it/343.html">点我下载</a></li>\r	<li>《细说PHP》 <a href="/it/369.html" target="_blank">点我下载</a></li>\r	<li>《跟老男孩学Linux运维 Shell编程实战》&nbsp;<a href="/it/406.html">点我下载</a></li>\r	<li>《分布式数据库架构及企业实践 基于Mycat中间件》 <a href="/it/407.html">点我下载</a></li>\r	<li>《微服务架构与实践》 <a href="/it/408.html">点我下载</a></li>\r	<li>《淘宝技术这十年》 <a href="/it/410.html">点我下载</a></li>\r	<li>《MYSQL 5.5从零开始学》 <a href="/it/411.html">点我下载</a></li>\r	<li>《HTTP权威指南》 <a href="/it/420.html">点我下载</a></li>\r	<li>《白帽子讲Web安全》 <a href="/it/461.html">点我下载</a></li>\r	<li>《分布式服务架构：原理、设计与实战》 <a href="https://item.jd.com/12222782.html" target="_blank">点我购买</a></li>\r	<li>《测试架构师修炼之道：从测试工程师到测试架构师》<a href="/it/726.html">点我下载</a></li>\r	<li>《SpringBoot实战》&nbsp;<a href="/it/1323.html">点我下载</a></li>\r	<li>《互联网轻量级SSM框架解密：Spring、SpringMVC、MyBatis源码深度剖析》&nbsp;<a href="/it/1565.html">点我下载</a></li>\r	<li>《JUnit实战（第二版）》&nbsp;<a href="/it/1566.html">点我下载</a></li>\r</ol>\r\r<h2>非技术类</h2>\r\r<ol>\r	<li>《人月神话》&nbsp;<a href="/it/371.html">点我下载</a></li>\r	<li>《基督山伯爵》&nbsp;<a href="/it/421.html">点我下载</a></li>\r	<li>《技术之瞳 阿里巴巴技术笔试心得》&nbsp;<a href="https://item.jd.com/11995757.html" target="_blank">点我购买</a></li>\r</ol>\r', 4, 1, NULL, 'page', 'publish', NULL, 0, '0', '0', '0', 0, 979),
(326, '003.jpg', '003-jpg', 1496910017, 1496910017, 'a:5:{s:4:"name";s:7:"003.jpg";s:4:"path";s:35:"/usr/uploads/2017/06/1362513345.jpg";s:4:"size";i:135401;s:4:"type";s:3:"jpg";s:4:"mime";s:10:"image/jpeg";}', 19, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(327, '004.jpg', '004-jpg', 1496910114, 1496910114, 'a:5:{s:4:"name";s:7:"004.jpg";s:4:"path";s:35:"/usr/uploads/2017/06/3646299870.jpg";s:4:"size";i:116923;s:4:"type";s:3:"jpg";s:4:"mime";s:10:"image/jpeg";}', 20, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 471, 0),
(500, '关键字', '500', 1515308825, 1515308825, '<p>本文记录在Java学习中遇到的关键字～</p>\r\r<!--more-->\r\r<p>定义</p>\r\r<p>是被Java语言赋予特殊含义，具有专门用途的单词，比如之前接触的class，int，double均为Java已经预设好的。</p>\r\r<p>特点</p>\r\r<p>组成关键字的字母全部小写(代码中的蓝色部分) ，注意String不是关键字。</p>\r\r<p>常见关键字</p>\r\r<p>abstract,assert,boolean,break,byte,case,catch,char,class,const,continue,default,do,double,else,enum,extends,final,finally,float,for,goto,if,implements,import,instanceof,int,interface,long,native,new,package,private,protected,public,return,strictfp,short,static,super,switch,synchronized,this,throw,throws,transient,try,void,volatile,while等。</p>\r\r<p>注意事项</p>\r\r<p>goto与const是Java中的保留字，即没有赋予特殊含义却仍被Java占用的单词。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(501, '标识符', '501', 1515393780, 1515394422, '<p>本文记录Java学习中的标识符～</p>\r<!--more-->\r\r<p>定义：就是给类,接口,方法,变量等起名字时使用的字符序列。</p>\r\r<p>组成规则(只能包含下面的内容,不能有其它内容)：</p>\r\r<ol>\r	<li>英文大小写字母；</li>\r	<li>数字字符；</li>\r	<li>$和_。</li>\r</ol>\r\r<p>注意事项：</p>\r\r<ol>\r	<li>数字不能开头；</li>\r	<li>不可以使用关键字；</li>\r	<li>严格区分大小写，不限制长度；</li>\r	<li>起名时，尽量达到见名知意。</li>\r</ol>\r\r<p>标识符中常见的命名规则(这些规定是不受语法约束的) :</p>\r\r<ol>\r	<li>包名：多单词组成时所有字母均小写，使用.连接 aaa.bbb.ccc</li>\r	<li>类名&amp;接口名：大驼峰式 AaaBbbCcc</li>\r	<li>变量名&amp;方法名：小驼峰式 aaaBbbCcc</li>\r	<li>常量名：多单词组成是所有字母均大写，使用_连接AAA_BBB_CCC</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(502, '数据类型', '502', 1515395160, 1515395362, '<p>本文记录Java学习过程中遇到的数据类型～</p>\r\r<!--more-->\r\r<p>为什么有数据类型：Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型&nbsp;</p>\r\r<p>Java中数据类型的分类</p>\r\r<ol>\r	<li>基本数据类型: 基本数据类型是Java语言中内置的类型，分别是整数类型、小数类型、字符类型、布尔类型。 这四类基本类型是最简单、最基础的类型。整数(byte、short、int、long)、小数(float、double)、字符类型(char)、布尔类型(boolean) 。</li>\r	<li>引用数据类型: 是强大的数据类型，它是基于基本数据类型创建的。JavaSE中提供了一个超级类库，类库中包含了近万种引用数据类型。&nbsp;</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(329, 'Linux分区简介', '329', 1496911800, 1497430459, '<p>本文简单介绍下Linux磁盘分区相关知识。</p>\r<!--more-->\r\r<p>1.磁盘在使用之前一般要先分区；</p>\r\r<p>2.磁盘分区有主分区、扩展分区和逻辑分区之分。一块磁盘最多可以有4个主分区，其中一个主分区的位置可以用一个扩展分区替代，在这个扩展分区内可以划分多个逻辑分区；</p>\r\r<p>3.如果规划的分区数量超过4个，则分区组合为3P+1E或2P+1E或1P+1E；</p>\r\r<p>4.一个磁盘最多只能有一个扩展分区，扩展分区不能直接使用，必须在扩展分区上划分逻辑分区，然后格式化（创建文件系统），之后才能存取数据或安装系统。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 124),
(330, '《Redis实战》PDF完整版下载', '330', 1497429900, 1555390148, '<p>本文分享一本Redis工程师必备书籍&mdash;&mdash;《Redis实战》。</p>\r<!--more-->\r\r<p>第一部分 入门</p>\r\r<p>第1章 初识Redis 2</p>\r\r<p>1.1 Redis简介 3</p>\r\r<p>1.1.1 Redis与其他数据库和软件的对比 3</p>\r\r<p>1.1.2 附加特性 4</p>\r\r<p>1.1.3 使用Redis的理由 5</p>\r\r<p>1.2 Redis数据结构简介 6</p>\r\r<p>1.2.1 Redis中的字符串 7</p>\r\r<p>1.2.2 Redis中的列表 9</p>\r\r<p>1.2.3 Redis的集合 10</p>\r\r<p>1.2.4 Redis的散列 11</p>\r\r<p>1.2.5 Redis的有序集合 12</p>\r\r<p>1.3 你好Redis 13</p>\r\r<p>1.3.1 对文章进行投票 15</p>\r\r<p>1.3.2 发布并获取文章 17</p>\r\r<p>1.3.3 对文章进行分组 19</p>\r\r<p>1.4 寻求帮助 21</p>\r\r<p>1.5 小结 21</p>\r\r<p>第2章 使用Redis构建Web应用 23</p>\r\r<p>2.1 登录和cookie缓存 24</p>\r\r<p>2.2 使用Redis实现购物车 28</p>\r\r<p>2.3 网页缓存 29</p>\r\r<p>2.4 数据行缓存 30</p>\r\r<p>2.5 网页分析 33</p>\r\r<p>2.6 小结 34</p>\r\r<p>第二部分 核心概念</p>\r\r<p>第3章 Redis命令 38</p>\r\r<p>3.1 字符串 39</p>\r\r<p>3.2 列表 42</p>\r\r<p>3.3 集合 44</p>\r\r<p>3.4 散列 46</p>\r\r<p>3.5 有序集合 48</p>\r\r<p>3.6 发布与订阅 52</p>\r\r<p>3.7 其他命令 54</p>\r\r<p>3.7.1 排序 54</p>\r\r<p>3.7.2 基本的Redis事务 56</p>\r\r<p>3.7.3 键的过期时间 58</p>\r\r<p>3.8 小结 60</p>\r\r<p>第4章 数据安全与性能保障 61</p>\r\r<p>4.1 持久化选项 61</p>\r\r<p>4.1.1 快照持久化 62</p>\r\r<p>4.1.2 AOF持久化 66</p>\r\r<p>4.1.3 重写/压缩AOF文件 67</p>\r\r<p>4.2 复制 68</p>\r\r<p>4.2.1 配置Redis的配置选项 69</p>\r\r<p>4.2.2 Redis复制的启动过程 70</p>\r\r<p>4.2.3 主从链 71</p>\r\r<p>4.2.4 检验磁盘写入 72</p>\r\r<p>4.3 处理系统故障 73</p>\r\r<p>4.3.1 验证快照文件和AOF文件 74</p>\r\r<p>4.3.2 更换故障主服务器 75</p>\r\r<p>4.4 Redis事务 76</p>\r\r<p>4.4.1 定义用户信息和用户包裹 77</p>\r\r<p>4.4.2 将物品放到市场上销售 78</p>\r\r<p>4.4.3 购买物品 80</p>\r\r<p>4.5 非事务型流水线 82</p>\r\r<p>4.6 关于性能方面的注意事项 85</p>\r\r<p>4.7 小结 87</p>\r\r<p>第5章 使用Redis构建支持程序 88</p>\r\r<p>5.1 使用Redis来记录日志 88</p>\r\r<p>5.1.1 **日志 89</p>\r\r<p>5.1.2 常见日志 90</p>\r\r<p>5.2 计数器和统计数据 91</p>\r\r<p>5.2.1 将计数器存储到Redis里面 91</p>\r\r<p>5.2.2 使用Redis存储统计数据 96</p>\r\r<p>5.2.3 简化统计数据的记录与发现 98</p>\r\r<p>5.3 查找IP所属城市以及国家 100</p>\r\r<p>5.3.1 载入位置表格 100</p>\r\r<p>5.3.2 查找IP所属城市 102</p>\r\r<p>5.4 服务的发现与配置 103</p>\r\r<p>5.4.1 使用Redis存储配置信息 103</p>\r\r<p>5.4.2 为每个应用程序组件分别配置一个Redis服务器 104</p>\r\r<p>5.4.3 自动Redis连接管理 106</p>\r\r<p>5.5 小结 107</p>\r\r<p>第6章 使用Redis构建应用程序组件 109</p>\r\r<p>6.1 自动补全 109</p>\r\r<p>6.1.1 自动补全*近联系人 110</p>\r\r<p>6.1.2 通讯录自动补全 112</p>\r\r<p>6.2 分布式锁 115</p>\r\r<p>6.2.1 锁的重要性 116</p>\r\r<p>6.2.2 简易锁 118</p>\r\r<p>6.2.3 使用Redis构建锁 119</p>\r\r<p>6.2.4 细粒度锁 122</p>\r\r<p>6.2.5 带有超时限制特性的锁 124</p>\r\r<p>6.3 计数信号量 126</p>\r\r<p>6.3.1 构建基本的计数信号量 126</p>\r\r<p>6.3.2 公平信号量 128</p>\r\r<p>6.3.3 刷新信号量 131</p>\r\r<p>6.3.4 消除竞争条件 132</p>\r\r<p>6.4 任务队列 133</p>\r\r<p>6.4.1 先进先出队列 133</p>\r\r<p>6.4.2 延迟任务 136</p>\r\r<p>6.5 消息拉取 139</p>\r\r<p>6.5.1 单接收者消息的发送与订阅替代品 140</p>\r\r<p>6.5.2 多接收者消息的发送与订阅替代品 141</p>\r\r<p>6.6 使用Redis进行文件分发 145</p>\r\r<p>6.6.1 根据地理位置聚合用户数据 146</p>\r\r<p>6.6.2 发送日志文件 148</p>\r\r<p>6.6.3 接收日志文件 149</p>\r\r<p>6.6.4 处理日志文件 150</p>\r\r<p>6.7 小结 152</p>\r\r<p>第7章 基于搜索的应用程序 153</p>\r\r<p>7.1 使用Redis进行搜索 153</p>\r\r<p>7.1.1 基本搜索原理 154</p>\r\r<p>7.1.2 对搜索结果进行排序 160</p>\r\r<p>7.2 有序索引 162</p>\r\r<p>7.2.1 使用有序集合对搜索结果进行排序 162</p>\r\r<p>7.2.2 使用有序集合实现非数值排序 164</p>\r\r<p>7.3 广告定向 166</p>\r\r<p>7.3.1 什么是广告服务器？ 167</p>\r\r<p>7.3.2 对广告进行索引 167</p>\r\r<p>7.3.3 执行广告定向操作 170</p>\r\r<p>7.3.4 从用户行为中学习 174</p>\r\r<p>7.4 职位搜索 180</p>\r\r<p>7.4.1 逐个查找合适的职位 180</p>\r\r<p>7.4.2 以搜索方式查找合适的职位 181</p>\r\r<p>7.5 小结 182</p>\r\r<p>第8章 构建简单的社交网站 184</p>\r\r<p>8.1 用户和状态 185</p>\r\r<p>8.1.1 用户信息 185</p>\r\r<p>8.1.2 状态消息 186</p>\r\r<p>8.2 主页时间线 187</p>\r\r<p>8.3 关注者列表和正在关注列表 188</p>\r\r<p>8.4 状态消息的发布与删除 191</p>\r\r<p>8.5 流API 194</p>\r\r<p>8.5.1 流API提供的数据 195</p>\r\r<p>8.5.2 提供数据 196</p>\r\r<p>8.5.3 对流消息进行过滤 199</p>\r\r<p>8.6 小结 205</p>\r\r<p>第三部分 进阶内容</p>\r\r<p>第9章 降低内存占用 208</p>\r\r<p>9.1 短结构 208</p>\r\r<p>9.1.1 压缩列表表示 209</p>\r\r<p>9.1.2 集合的整数集合编码 211</p>\r\r<p>9.1.3 长压缩列表和大整数集合带来的性能问题 212</p>\r\r<p>9.2 分片结构 214</p>\r\r<p>9.2.1 分片式散列 215</p>\r\r<p>9.2.2 分片集合 218</p>\r\r<p>9.3 打包存储二进制位和字节 221</p>\r\r<p>9.3.1 决定被存储位置信息的格式 221</p>\r\r<p>9.3.2 存储打包后的数据 223</p>\r\r<p>9.3.3 对分片字符串进行聚合计算 224</p>\r\r<p>9.4 小结 226</p>\r\r<p>第10章 扩展Redis 227</p>\r\r<p>10.1 扩展读性能 227</p>\r\r<p>10.2 扩展写性能和内存容量 230</p>\r\r<p>10.2.1 处理分片配置信息 232</p>\r\r<p>10.2.2 创建分片服务器连接装饰器 233</p>\r\r<p>10.3 扩展复杂的查询 234</p>\r\r<p>10.3.1 扩展搜索查询量 235</p>\r\r<p>10.3.2 扩展搜索索引大小 235</p>\r\r<p>10.3.3 对社交网站进行扩展 240</p>\r\r<p>10.4 小结 247</p>\r\r<p>第11章 Redis的Lua脚本编程 248</p>\r\r<p>11.1 在不编写C代码的情况下添加新功能 248</p>\r\r<p>11.1.1 将Lua脚本载入Redis 249</p>\r\r<p>11.1.2 创建新的状态消息 251</p>\r\r<p>11.2 使用Lua重写锁和信号量 254</p>\r\r<p>11.2.1 使用Lua实现锁的原因 254</p>\r\r<p>11.2.2 重写锁实现 255</p>\r\r<p>11.2.3 使用Lua实现计数信号量 257</p>\r\r<p>11.3 移除WATCH/MULTI/EXEC事务 258</p>\r\r<p>11.3.1 回顾群组自动补全程序 259</p>\r\r<p>11.3.2 再次对物品买卖市场进行改进 261</p>\r\r<p>11.4 使用Lua对列表进行分片 263</p>\r\r<p>11.4.1 分片列表的构成 263</p>\r\r<p>11.4.2 将元素推入分片列表 265</p>\r\r<p>11.4.3 从分片里面里面弹出元素 266</p>\r\r<p>11.4.4 对分片列表执行阻塞弹出操作 267</p>\r\r<p>11.5 小结 270</p>\r\r<p>附录A 快速安装指南 271</p>\r\r<p>附录B 其他资源和参考资料 279</p>\r\r<p>下载地址：<a href="https://pan.lanzou.com/1258397" target="_blank">网盘</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 393),
(331, '《Linux运维之道》PDF完整版下载', '331', 1499663140, 1499663140, '<p>本文分享一本Linux相关学习书籍&mdash;&mdash;《Linux运维之道》。</p>\r<!--more-->\r\r<p>第1篇 基 础 知 识<br />\r第1章 部署操作系统 2<br />\r1．1 光盘安装Linux操作系统 2<br />\r1．1．1 操作系统版本的选择 2<br />\r1．1．2 光盘安装Linux系统案例 2<br />\r1．2 无人职守自动安装Linux操作系统 11<br />\r1．2．1 大规模部署案例 11<br />\r1．2．2 PXE简介 13<br />\r1．2．3 Kickstart技术 13<br />\r1．2．4 配置安装服务器 14<br />\r1．2．5 自动化安装案例 16<br />\r1．3 常见问题分析 26<br />\r第2章 命令工具 29<br />\r2．1 基本命令 30<br />\r2．1．1 目录及文件的基本操作 30<br />\r2．1．2 查看文件内容 34<br />\r2．1．3 链接文件 37<br />\r2．1．4 压缩及解压 37<br />\r2．1．5 命令使用技巧 38<br />\r2．1．6 帮助 39<br />\r2．2 Vim文档编辑 41<br />\r2．2．1 Vim工作模式 41<br />\r2．2．2 Vim光标操作 42<br />\r2．2．3 Vim编辑文档 43<br />\r2．2．4 Vim查找与替换 43<br />\r2．2．5 Vim保存与退出 44<br />\r2．2．6 Vim小技巧 45<br />\r2．3 账户与安全 46<br />\r2．3．1 账户及组的概念 46<br />\r2．3．2 创建账户及组 46<br />\r2．3．3 修改账户及组 47<br />\r2．3．4 删除账户及组 48<br />\r2．3．5 账户与组文件解析 49<br />\r2．3．6 文件及目录权限 51<br />\r2．3．7 账户管理案例 53<br />\r2．3．8 ACL访问控制权限 54<br />\r2．4 存储管理 55<br />\r2．4．1 磁盘分区 55<br />\r2．4．2 格式化与挂载文件系统 59<br />\r2．4．3 LVM逻辑卷概述 61<br />\r2．4．4 创建LVM分区实例 63<br />\r2．4．5 修改LVM分区容量 67<br />\r2．4．6 删除LVM分区 68<br />\r2．4．7 RAID磁盘阵列概述 69<br />\r2．4．8 RAID级别 69<br />\r2．4．9 创建与管理软RAID实例 73<br />\r2．4．10 RAID性能测试 76<br />\r2．4．11 RAID故障模拟 77<br />\r2．5 软件管理 78<br />\r2．5．1 Linux常用软件包类型 78<br />\r2．5．2 RPM软件包管理 78<br />\r2．5．3 使用YUM安装软件包 80<br />\r2．5．4 YUM使用技巧 82<br />\r2．5．5 源码编译安装软件 83<br />\r2．5．6 常见问题分析 84<br />\r2．5．7 服务管理 85<br />\r2．6 计划任务 87<br />\r2．6．1 at一次性计划任务 87<br />\r2．6．2 cron周期性计划任务 88<br />\r2．6．3 计划任务权限 89<br />\r2．7 性能监控 89<br />\r2．7．1 监控CPU使用情况――uptime命令 89<br />\r2．7．2 监控内存及交换分区使用情况――free命令 89<br />\r2．7．3 监控磁盘使用情况――df命令 90<br />\r2．7．4 监控网络使用情况――ip和netstat命令 91<br />\r2．7．5 监控进程使用情况――ps和top命令 93<br />\r2．8 网络配置 94<br />\r2．8．1 命令行设置网络参数 94<br />\r2．8．2 文件修改网络参数 96<br />\r2．8．3 网络故障排错 98<br />\r2．9 内核模块 100<br />\r2．9．1 内核模块存放位置 100<br />\r2．9．2 查看已加载内核模块 100<br />\r2．9．3 加载与卸载内核模块 101<br />\r2．9．4 修改内核参数 101<br />\r第3章 自动化运维 103<br />\r3．1 Shell简介 103<br />\r3．2 Bash功能介绍 104<br />\r3．2．1 命令历史 104<br />\r3．2．2 命令别名 104<br />\r3．2．3 管道与重定向 105<br />\r3．2．4 快捷键 106<br />\r3．3 Bash使用技巧 106<br />\r3．3．1 重定向技巧 106<br />\r3．3．2 命令序列使用技巧 107<br />\r3．3．3 作业控制技巧 107<br />\r3．3．4 花括号{}的使用技巧 108<br />\r3．4 变量 108<br />\r3．4．1 自定义变量 108<br />\r3．4．2 变量的使用范围 109<br />\r3．4．3 环境变量 109<br />\r3．4．4 位置变量 111<br />\r3．4．5 变量的展开替换 111<br />\r3．4．6 数组 112<br />\r3．4．7 算术运算与测试 113<br />\r3．5 Shell引号 115<br />\r3．5．1 反斜线 115<br />\r3．5．2 单引号 116<br />\r3．5．3 双引号 116<br />\r3．5．4 反引号 116<br />\r3．6 正则表达式 117<br />\r3．6．1 基本正则表达式（Regular Expression） 117<br />\r3．6．2 扩展正则表达式（Extended Regular Expression） 120<br />\r3．6．3 POSIX规范 121<br />\r3．6．4 GNU规范 122<br />\r3．7 Sed 122<br />\r3．7．1 Sed简介 122<br />\r3．7．2 Sed基本语法格式 123<br />\r3．7．3 Sed入门范例 124<br />\r3．7．4 Sed指令与脚本 126<br />\r3．7．5 Sed高级应用 131<br />\r3．8 Awk 134<br />\r3．8．1 Awk简介 134<br />\r3．8．2 Awk工作流程 135<br />\r3．8．3 Awk基本语法格式 135<br />\r3．8．4 Awk操作指令 137<br />\r3．8．5 Awk高级应用 141<br />\r3．9 Shell脚本 143<br />\r3．9．1 脚本格式范例 144<br />\r3．9．2 运行脚本的方式 145<br />\r3．9．3 Shell脚本简单案例 145<br />\r3．9．4 判断语句应用 148<br />\r3．9．5 循环语句应用 152<br />\r3．9．6 控制语句应用 155<br />\r3．9．7 Shell函数应用 157<br />\r3．9．8 综合案例 159<br />\r3．9．9 图形脚本 163<br />\r第2篇 网 络 服 务<br />\r第4章 搭建网络服务 168<br />\r4．1 NFS文件共享 168<br />\r4．1．1 NFS服务器配置 169<br />\r4．1．2 客户端访问NFS共享 171<br />\r4．1．3 NFS高级设置 172<br />\r4．1．4 常见问题分析 175<br />\r4．2 Samba文件共享 176<br />\r4．2．1 快速配置Samba服务器 176<br />\r4．2．2 访问Samba共享 178<br />\r4．2．3 配置文件详解 180<br />\r4．2．4 Samba应用案例 181<br />\r4．2．5 常见问题分析 184<br />\r4．3 vsftpd文件共享 185<br />\r4．3．1 FTP工作模式 185<br />\r4．3．2 安装与管理vsftpd 186<br />\r4．3．3 配置文件解析 187<br />\r4．3．4 账户权限 188<br />\r4．3．5 vsftpd应用案例 189<br />\r4．3．6 常见问题分析 192<br />\r4．4 ProFTPD文件共享 193<br />\r4．4．1 安装ProFTPD软件 194<br />\r4．4．2 配置文件解析 194<br />\r4．4．3 ProFTPD权限设置 195<br />\r4．4．4 虚拟用户应用案例 196<br />\r4．4．5 常见问题分析 199<br />\r4．5 Subversion版本控制 200<br />\r4．5．1 Subversion简介 200<br />\r4．5．2 Subversion服务器对比 202<br />\r4．5．3 安装Subversion软件 203<br />\r4．5．4 svnserve服务器搭建 203<br />\r4．5．5 svnserve+SSH服务器搭建 208<br />\r4．5．6 Apache+SVN服务器搭建 209<br />\r4．5．7 对人协同编辑案例 211<br />\r4．5．8 常见问题 215<br />\r4．6 网络存储服务器 216<br />\r4．6．1 iSCSI网络存储 217<br />\r4．6．2 Rsync文件同步 220<br />\r4．6．3 Rsync+Inotify实现文件自动同步 225<br />\r4．7 DHCP服务器 231<br />\r4．7．1 安装软件 231<br />\r4．7．2 配置文件解析 232<br />\r4．7．3 DHCP应用案例 233<br />\r4．7．4 常见问题分析 234<br />\r4．8 DNS域名服务器 235<br />\r4．8．1 DNS简介 235<br />\r4．8．2 安装DNS软件 237<br />\r4．8．3 配置文件解析 237<br />\r4．8．4 部署主域名服务器 241<br />\r4．8．5 部署从域名服务器 245<br />\r4．8．6 DNS视图应用案例 247<br />\r4．8．7 常见问题分析 249<br />\r4．9 Apache网站服务器 250<br />\r4．9．1 Apache简介 250<br />\r4．9．2 安装Apache软件 250<br />\r4．9．3 配置文件解析 252<br />\r4．9．4 虚拟主机应用案例 257<br />\r4．9．5 网站安全应用案例 258<br />\r4．9．6 常见问题分析 260<br />\r4．10 Nginx网站服务器 261<br />\r4．10．1 Nginx简介 261<br />\r4．10．2 安装Nginx软件 261<br />\r4．10．3 配置文件解析 264<br />\r4．10．4 虚拟主机应用案例 266<br />\r4．10．5 SSL网站应用案例 268<br />\r4．10．6 HTTP响应状态码 270<br />\r4．11 数据库基础 271<br />\r4．11．1 MySQL数据库简介 271<br />\r4．11．2 安装MySQL软件 272<br />\r4．11．3 MySQL管理工具 273<br />\r4．11．4 数据库定义语言 278<br />\r4．11．5 数据库操作语言 282<br />\r4．11．6 数据库查询语言 284<br />\r4．11．7 MySQL与安全 285<br />\r4．11．8 MySQL数据库备份与还原 288<br />\r4．12 动态网站架构案例 289<br />\r4．12．1 论坛系统应用案例 290<br />\r4．12．2 博客系统应用案例 296<br />\r第5章 系统监控 300<br />\r5．1 Cacti监控系统 300<br />\r5．1．1 简介 300<br />\r5．1．2 Cacti监控应用案例 301<br />\r5．2 Nagios监控系统 309<br />\r5．2．1 简介 309<br />\r5．2．2 Nagios监控应用案例 310<br />\r第6章 网络安全 322<br />\r6．1 防火墙 322<br />\r6．1．1 iptables防火墙语法格式 323<br />\r6．1．2 iptables防火墙应用案例 326<br />\r6．1．3 防火墙备份与还原 329<br />\r6．1．4 firewalld简介 330<br />\r6．1．5 firewalld-cmd命令 331<br />\r6．2 SELinux简介 334<br />\r6．2．1 SELinux配置文件 335<br />\r6．2．2 SELinux软件包 336<br />\r6．2．3 SELinux安全上下文 336<br />\r6．2．4 SELinux排错 337<br />\r6．2．5 修改安全上下文 339<br />\r6．2．6 查看与修改布尔值 341<br />\r6．2．7 SELinux应用案例 342<br />\r6．2．8 httpd相关的SELinux安全策略 342<br />\r6．2．9 FTP相关的SELinux安全策略 344<br />\r6．2．10 MySQL相关的SELinux安全策略 345<br />\r6．2．11 NFS相关的SELinux安全策略 345<br />\r6．2．12 Samba相关的SELinux安全策略 346<br />\r6．3 OpenVPN 347<br />\r6．3．1 OpenVPN简介 347<br />\r6．3．2 安装OpenVPN服务 348<br />\r6．3．3 OpenVPN客户端 351<br />\r第3篇 高 级 应 用<br />\r第7章 虚拟化技术 354<br />\r7．1 虚拟化产品对比 354<br />\r7．1．1 VMware虚拟化技术 355<br />\r7．1．2 Xen虚拟化技术 355<br />\r7．1．3 KVM虚拟化技术 356<br />\r7．2 KVM虚拟化应用案例 356<br />\r7．2．1 安装KVM组件 356<br />\r7．2．2 创建虚拟机操作系统 357<br />\r7．2．3 监控虚拟机操作系统 362<br />\r7．2．4 命令工具使用技巧 364<br />\r7．2．5 虚拟存储与虚拟网络 369<br />\r第8章 集群及高可用 379<br />\r8．1 集群 379<br />\r8．1．1 LVS负载均衡简介 379<br />\r8．1．2 基于NAT的LVS负载均衡 380<br />\r8．1．3 基于TUN的LVS负载均衡 381<br />\r8．1．4 基于DR的LVS负载均衡 382<br />\r8．1．5 LVS负载均衡调度算法 383<br />\r8．1．6 部署LVS服务 384<br />\r8．1．7 LVS负载均衡应用案例 387<br />\r8．1．8 常见问题分析 394<br />\r8．2 Keepalived双机热备 395<br />\r8．2．1 Keepalived简介 395<br />\r8．2．2 VRRP协议简介 395<br />\r8．2．3 安装Keepalived服务 395<br />\r8．2．4 配置文件解析 396<br />\r8．2．5 Keepalived+LVS应用案例 398<br />\r8．2．6 常见问题分析 405<br />\r8．3 Squid代理服务器 406<br />\r8．3．1 Squid简介 406<br />\r8．3．2 安装Squid服务 406<br />\r8．3．3 常见代理服务器类型 406<br />\r8．3．4 配置文件解析 408<br />\r8．3．5 Squid应用案例 409<br />\r8．4 HAProxy负载均衡 413<br />\r8．4．1 HAProxy简介 413<br />\r8．4．2 配置文件解析 413<br />\r8．4．3 HAProxy应用案例 416<br />\r8．5 Nginx高级应用 420<br />\r8．5．1 Nginx负载均衡 420<br />\r8．5．2 Nginx负载均衡案例 422<br />\r8．5．3 Nginx rewrite规则 425<br />\r8．6 MySQL高可用 429<br />\r8．6．1 MySQL复制 429<br />\r8．6．2 一步一步操作MySQL复制 430</p>\r\r<p>下载地址：<a href="https://pan.lanzou.com/1360997" target="_blank">点我下载</a></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 254),
(332, '《TCP-IP详解卷一 协议》PDF完整版下载', '332', 1499681760, 1528759163, '<p>本文分享一本网工必备书籍&mdash;&mdash;《TCP-IP详解卷一 协议》。</p>\r<!--more-->\r\r<p>出版者的话<br />\r译者序<br />\r本书评语<br />\r序<br />\r第2版前言<br />\r第1版前言（改编）<br />\r第1章 概述 1<br />\r1.1 体系结构原则 2<br />\r1.1.1 分组、连接和数据报 2<br />\r1.1.2 端到端论点和命运共享 3<br />\r1.1.3 差错控制和流量控制 4<br />\r1.2 设计和实现 5<br />\r1.2.1 分层 5<br />\r1.2.2 分层实现中的复用、分解和封装 6<br />\r1.3 TCP/IP协议族结构和协议 9<br />\r1.3.1 ARPANET参考模型 9<br />\r1.3.2 TCP/IP中的复用、分解和封装 11<br />\r1.3.3 端口号 12<br />\r1.3.4 名称、地址和DNS 12<br />\r1.4 Internet、内联网和外联网 13<br />\r1.5 设计应用 13<br />\r1.5.1 客户机/服务器 14<br />\r1.5.2 对等 14<br />\r1.5.3 应用程序编程接口 14<br />\r1.6 标准化进程 15<br />\r1.6.1 RFC 15<br />\r1.6.2 其他标准 15<br />\r1.7 实现和软件分发 16<br />\r1.8 与Internet体系结构相关的攻击 17<br />\r1.9 总结 17<br />\r1.10 参考文献 18<br />\r第2章 Internet地址结构 21<br />\r2.1 引言 21<br />\r2.2 表示IP地址 21<br />\r2.3 基本的IP地址结构 23<br />\r2.3.1 分类寻址 23<br />\r2.3.2 子网寻址 24<br />\r2.3.3 子网掩码 26<br />\r2.3.4 可变长度子网掩码 27<br />\r2.3.5 广播地址 28<br />\r2.3.6 IPv6地址和接口标识符 29<br />\r2.4 CIDR和聚合 31<br />\r2.4.1 前缀 31<br />\r2.4.2 聚合 32<br />\r2.5 特殊用途地址 34<br />\r2.5.1 IPv4/IPv6地址转换 35<br />\r2.5.2 组播地址 36<br />\r2.5.3 IPv4组播地址 36<br />\r2.5.4 IPv6组播地址 38<br />\r2.5.5 任播地址 41<br />\r2.6 分配 42<br />\r2.6.1 单播 42<br />\r2.6.2 组播 44<br />\r2.7 单播地址分配 44<br />\r2.7.1 单个供应商/无网络/单个地址 44<br />\r2.7.2 单个供应商/单个网络/单个地址 45<br />\r2.7.3 单个供应商/多个网络/多个地址 45<br />\r2.7.4 多个供应商/多个网络/多个地址（多宿主） 46<br />\r2.8 与IP地址相关的攻击 48<br />\r2.9 总结 48<br />\r2.10 参考文献 49<br />\r第3章 链路层 54<br />\r3.1 引言 54<br />\r3.2 以太网和IEEE 802局域网/城域网标准 54<br />\r3.2.1 IEEE 802局域网/城域网标准 56<br />\r3.2.2 以太网帧格式 57<br />\r3.2.3 802.1p/q：虚拟局域网和QoS标签 60<br />\r3.2.4 802.1AX：链路聚合（以前的802.3ad） 62<br />\r3.3 全双工、省电、自动协商和802.1X流量控制 64<br />\r3.3.1 双工不匹配 65<br />\r3.3.2 局域网唤醒（WoL）、省电和魔术分组 65<br />\r3.3.3 链路层流量控制 66<br />\r3.4 网桥和交换机 67<br />\r3.4.1 生成树协议 70<br />\r3.4.2 802.1ak：多注册协议 76<br />\r3.5 无线局域网&mdash;&mdash;IEEE 802.11（Wi-Fi） 76<br />\r3.5.1 802.11帧 77<br />\r3.5.2 省电模式和时间同步功能 81<br />\r3.5.3 802.11介质访问控制 82<br />\r3.5.4 物理层的细节：速率、信道和频率 84<br />\r3.5.5 Wi-Fi安全 88<br />\r3.5.6 Wi-Fi网状网（802.11s） 89<br />\r3.6 点到点协议 89<br />\r3.6.1 链路控制协议 89<br />\r3.6.2 多链路PPP 93<br />\r3.6.3 压缩控制协议 95<br />\r3.6.4 PPP认证 95<br />\r3.6.5 网络控制协议 96<br />\r3.6.6 头部压缩 96<br />\r3.6.7 例子 97<br />\r3.7 环回 99<br />\r3.8 MTU和路径MTU 101<br />\r3.9 隧道基础 102<br />\r3.9.1 单向链路 105<br />\r3.10 与链路层相关的攻击 106<br />\r3.11 总结 107<br />\r3.12 参考文献 108<br />\r第4章 地址解析协议 113<br />\r4.1 引言 113<br />\r4.2 一个例子 113<br />\r4.2.1 直接交付和ARP 114<br />\r4.3 ARP缓存 115<br />\r4.4 ARP帧格式 116<br />\r4.5 ARP例子 117<br />\r4.5.1 正常的例子 117<br />\r4.5.2 对一个不存在主机的ARP请求 118<br />\r4.6 ARP缓存超时 119<br />\r4.7 代理ARP 119<br />\r4.8 免费ARP和地址冲突检测 120<br />\r4.9 arp命令 121<br />\r4.10 使用ARP设置一台嵌入式设备的IPv4地址 121<br />\r4.11 与ARP相关的攻击 122<br />\r4.12 总结 122<br />\r4.13 参考文献 123<br />\r第5章 Internet协议 124<br />\r5.1 引言 124<br />\r5.2 IPv4头部和IPv6头部 125<br />\r5.2.1 IP头部字段 125<br />\r5.2.2 Internet校验和 127<br />\r5.2.3 DS字段和ECN（以前称为ToS字节或IPv6流量类别） 129<br />\r5.2.4 IP选项 131<br />\r5.3 IPv6扩展头部 133<br />\r5.3.1 IPv6选项 134<br />\r5.3.2 路由头部 137<br />\r5.3.3 分片头部 139<br />\r5.4 IP转发 143<br />\r5.4.1 转发表 144<br />\r5.4.2 IP转发行动 144<br />\r5.4.3 例子 145<br />\r5.4.4 讨论 148<br />\r5.5 移动IP 149<br />\r5.5.1 基本模型：双向隧道 149<br />\r5.5.2 路由优化 150<br />\r5.5.3 讨论 152<br />\r5.6 IP数据报的主机处理 152<br />\r5.6.1 主机模式 152<br />\r5.6.2 地址选择 153<br />\r5.7 与IP相关的攻击 156<br />\r5.8 总结 156<br />\r5.9 参考文献 157<br />\r第6章 系统配置：DHCP和自动配置 161<br />\r6.1 引言 161<br />\r6.2 动态主机配置协议 161<br />\r6.2.1 地址池和租用 162<br />\r6.2.2 DHCP和BOOTP消息格式 163<br />\r6.2.3 DHCP和BOOTP选项 164<br />\r6.2.4 DHCP协议操作 165<br />\r6.2.5 DHCPv6 174<br />\r6.2.6 使用DHCP中继 185<br />\r6.2.7 DHCP认证 188<br />\r6.2.8 重新配置扩展 189<br />\r6.2.9 快速确认 189<br />\r6.2.10 位置信息（LCI和LoST） 190<br />\r6.2.11 移动和切换信息（MoS和ANDSF） 190<br />\r6.2.12 DHCP嗅探 191<br />\r6.3 无状态地址自动配置 191<br />\r6.3.1 IPv4链路本地地址的动态配置 191<br />\r6.3.2 链路本地地址的IPv6 SLAAC 192<br />\r6.4 DHCP和DNS交互 198<br />\r6.5 以太网上的PPP 199<br />\r6.6 与系统配置相关的攻击 201<br />\r6.7 总结 203<br />\r6.8 参考文献 204<br />\r第7章 防火墙和网络地址转换 209<br />\r7.1 引言 209<br />\r7.2 防火墙 209<br />\r7.2.1 包过滤防火墙 209<br />\r7.2.2 代理防火墙 210<br />\r7.3 网络地址转换 212<br />\r7.3.1 传统的NAT：基本NAT和NAPT 213<br />\r7.3.2 地址和端口转换行为 217<br />\r7.3.3 过滤行为 219<br />\r7.3.4 位于NAT之后的服务器 219<br />\r7.3.5 发夹和NAT环回 220<br />\r7.3.6 NAT编辑器 220<br />\r7.3.7 服务提供者NAT和服务提供者IPv6转换 220<br />\r7.4 NAT穿越 221<br />\r7.4.1 针孔和打孔 221<br />\r7.4.2 单边的自地址确定 222<br />\r7.4.3 NAT的会话穿越工具 223<br />\r7.4.4 利用NAT中继的穿越 228<br />\r7.4.5 交互连接建立 233<br />\r7.5 配置包过滤防火墙和NAT 235<br />\r7.5.1 防火墙规则 235<br />\r7.5.2 NAT规则 236<br />\r7.5.3 与NAT和防火墙的直接交互：UPnP、NAT-PMP和PCP 237<br />\r7.6 IPv4/IPv6共存和过渡中的NAT 238<br />\r7.6.1 双协议栈精简版 239<br />\r7.6.2 使用NAT和ALG的IPv4/IPv6转换 239<br />\r7.7 与防火墙和NAT相关的攻击 243<br />\r7.8 总结 243<br />\r7.9 参考文献 244<br />\r第8章 ICMPv4和ICMPv6：Internet控制报文协议 248<br />\r8.1 引言 248<br />\r8.1.1 在IPv4和IPv6中的封装 248<br />\r8.2 ICMP报文 249<br />\r8.2.1 ICMPv4报文 250<br />\r8.2.2 ICMPv6报文 251<br />\r8.2.3 处理ICMP报文 253<br />\r8.3 ICMP差错报文 253<br />\r8.3.1 扩展的ICMP和多部报文 254<br />\r8.3.2 目的不可达（ICMPv4类型3，ICMPv6类型1）和数据包太大（ICMPv6类型2） 255<br />\r8.3.3 重定向（ICMPv4类型5，ICMPv6类型137） 261<br />\r8.3.4 ICMP超时（ICMPv4类型11，ICMPv6类型3） 263<br />\r8.3.5 参数问题（ICMPv4类型12，ICMPv6类型4） 266<br />\r8.4 ICMP查询/信息类报文 267<br />\r8.4.1 回显请求/应答（ping）（ICMPv4类型0/8，ICMPv6类型129/128） 268<br />\r8.4.2 路由器发现：路由器请求和通告（ICMPv4类型9，10） 269<br />\r8.4.3 本地代理地址发现请求/应答（ICMPv6类型144/145） 271<br />\r8.4.4 移动前缀请求/通告（ICMPv6类型146/147） 272<br />\r8.4.5 移动IPv6快速切换报文（ICMPv6类型154） 273<br />\r8.4.6 组播侦听查询/报告/完成（ICMPv6类型130/131/132） 273<br />\r8.4.7 版本2组播侦听发现（ICMPv6类型143） 274<br />\r8.4.8 组播路由器发现（IGMP类型48/49/50，ICMPv6类型151/152/153） 278<br />\r8.5 IPv6中的邻居发现 278<br />\r8.5.1 ICMPv6路由器请求和通告（ICMPv6类型133，134） 279<br />\r8.5.2 ICMPv6邻居请求和通告（ICMPv6类型135，136） 280<br />\r8.5.3 ICMPv6反向邻居发现请求/通告（ICMPv6类型141/142） 283<br />\r8.5.4 邻居不可达检测 283<br />\r8.5.5 安全邻居发现 284<br />\r8.5.6 ICMPv6邻居发现选项 287<br />\r8.6 ICMPv4和ICMPv6转换 298<br />\r8.6.1 从ICMPv4转换到ICMPv6 299<br />\r8.6.2 从ICMPv6转换到ICMPv4 300<br />\r8.7 与ICMP相关的攻击 301<br />\r8.8 总结 303<br />\r8.9 参考文献 303<br />\r第9章 广播和本地组播（IGMP和MLD） 307<br />\r9.1 引言 307<br />\r9.2 广播 308<br />\r9.2.1 使用广播地址 308<br />\r9.2.2 发送广播数据报 310<br />\r9.3 组播 311<br />\r9.3.1 将IP组播地址转换为802 MAC/以太网地址 312<br />\r9.3.2 例子 313<br />\r9.3.3 发送组播数据报 314<br />\r9.3.4 接收组播数据报 316<br />\r9.3.5 主机地址过滤 317<br />\r9.4 互联网组管理协议和组播侦听发现协议 318<br />\r9.4.1 组成员的IGMP和MLD处理（&ldquo;组成员部分&rdquo;） 321<br />\r9.4.2 组播路由器的IGMP和MLD处理（&ldquo;组播路由器部分&rdquo;） 323<br />\r9.4.3 例子 324<br />\r9.4.4 轻量级IGMPv3和MLDv2 328<br />\r9.4.5 IGMP和MLD健壮性 329<br />\r9.4.6 IGMP和MLD计数器和变量 330<br />\r9.4.7 IGMP和MLD探听 331<br />\r9.5 与IGMP和MLD相关的攻击 332<br />\r9.6 总结 332<br />\r9.7 参考文献 333<br />\r第10章 用户数据报协议和IP分片 335<br />\r10.1 引言 335<br />\r10.2 UDP头部 335<br />\r10.3 UDP校验和 336<br />\r10.4 例子 338<br />\r10.5 UDP和IPv6 340<br />\r10.5.1 Teredo：通过IPv4网络隧道传输IPv6 341<br />\r10.6 UDP-Lite 345<br />\r10.7 IP分片 345<br />\r10.7.1 例子：UDP/IPv4分片 346<br />\r10.7.2 重组超时 348<br />\r10.8 采用UDP的路径MTU发现 349<br />\r10.8.1 例子 349<br />\r10.9 IP分片和ARP/ND之间的交互 351<br />\r10.10 最大UDP数据报长度 352<br />\r10.10.1 实现限制 352<br />\r10.10.2 数据报截断 353<br />\r10.11 UDP服务器的设计 353<br />\r10.11.1 IP地址和UDP端口号 353<br />\r10.11.2 限制本地IP地址 354<br />\r10.11.3 使用多地址 355<br />\r10.11.4 限制远端IP地址 356<br />\r10.11.5 每端口多服务器的使用 357<br />\r10.11.6 跨越地址族：IPv4和IPv6 357<br />\r10.11.7 流量和拥塞控制的缺失 357<br />\r10.12 UDP/IPv4和UDP/IPv6数据报的转换 358<br />\r10.13 互联网中的UDP 358<br />\r10.14 与UDP和IP分片相关的攻击 359<br />\r10.15 总结 360<br />\r10.16 参考文献 360<br />\r第11章 名称解析和域名系统 362<br />\r11.1 引言 362<br />\r11.2 DNS名称空间 362<br />\r11.2.1 DNS命名语法 365<br />\r11.3 名称服务器和区域 366<br />\r11.4 缓存 366<br />\r11.5 DNS协议 367<br />\r11.5.1 DNS消息格式 369<br />\r11.5.2 DNS扩展格式（EDNS0） 372<br />\r11.5.3 UDP或TCP 372<br />\r11.5.4 问题（查询）和区域区段格式 373<br />\r11.5.5 回答、授权和额外信息区段格式 373<br />\r11.5.6 资源记录类型 374<br />\r11.5.7 动态更新（DNS UPDATE） 394<br />\r11.5.8 区域传输和DNS通知 397<br />\r11.6 排序列表、循环和分离DNS 402<br />\r11.7 开放DNS服务器和DynDNS 403<br />\r11.8 透明度和扩展性 404<br />\r11.9 从IPv4向IPv6转换DNS 404<br />\r11.10 LLMNR和mDNS 405<br />\r11.11 LDAP 406<br />\r11.12 与DNS相关的攻击 406<br />\r11.13 总结 407<br />\r11.14 参考文献 408<br />\r第12章 TCP：传输控制协议（初步） 412<br />\r12.1 引言 412<br />\r12.1.1 ARQ和重传 412<br />\r12.1.2 分组窗口和滑动窗口 413<br />\r12.1.3 变量窗口：流量控制和拥塞控制 414<br />\r12.1.4 设置重传超时 415<br />\r12.2 TCP的引入 415<br />\r12.2.1 TCP服务模型 416<br />\r12.2.2 TCP中的可靠性 416<br />\r12.3 TCP头部和封装 418<br />\r12.4 总结 420<br />\r12.5 参考文献 421<br />\r第13章 TCP连接管理 423<br />\r13.1 引言 423<br />\r13.2 TCP连接的建立与终止 423<br />\r13.2.1 TCP半关闭 425<br />\r13.2.2 同时打开与关闭 426<br />\r13.2.3 初始序列号 427<br />\r13.2.4 例子 428<br />\r13.2.5 连接建立超时 429<br />\r13.2.6 连接与转换器 430<br />\r13.3 TCP选项 431<br />\r13.3.1 最大段大小选项 431<br />\r13.3.2 选择确认选项 432<br />\r13.3.3 窗口缩放选项 433<br />\r13.3.4 时间戳选项与防回绕序列号 433<br />\r13.3.5 用户超时选项 435<br />\r13.3.6 认证选项 436<br />\r13.4 TCP的路径最大传输单元发现 436<br />\r13.4.1 例子 437<br />\r13.5 TCP状态转换 439<br />\r13.5.1 TCP状态转换图 440<br />\r13.5.2 TIME_WAIT状态 442<br />\r13.5.3 静默时间的概念 446<br />\r13.5.4 FIN_WAIT_2状态 446<br />\r13.5.5 同时打开与关闭的转换 446<br />\r13.6 重置报文段 447<br />\r13.6.1 针对不存在端口的连接请求 447<br />\r13.6.2 终止一条连接 447<br />\r13.6.3 半开连接 449<br />\r13.6.4 时间等待错误 451<br />\r13.7 TCP服务器选项 451<br />\r13.7.1 TCP端口号 452<br />\r13.7.2 限制本地IP地址 453<br />\r13.7.3 限制外部节点 454<br />\r13.7.4 进入连接队列 455<br />\r13.8 与TCP连接管理相关的攻击 458<br />\r13.9 总结 459<br />\r13.10 参考文献 460<br />\r第14章 TCP超时与重传 462<br />\r14.1 引言 462<br />\r14.2 简单的超时与重传举例 462<br />\r14.3 设置重传超时 464<br />\r14.3.1 经典方法 465<br />\r14.3.2 标准方法 465<br />\r14.3.3 Linux采用的方法 468<br />\r14.3.4 RTT估计器行为 471<br />\r14.3.5 RTTM对丢包和失序的鲁棒性 472<br />\r14.4 基于计时器的重传 473<br />\r14.4.1 例子 473<br />\r14.5 快速重传 475<br />\r14.5.1 例子 475<br />\r14.6 带选择确认的重传 478<br />\r14.6.1 SACK接收端行为 479<br />\r14.6.2 SACK发送端行为 479<br />\r14.6.3 例子 480<br />\r14.7 伪超时与重传 482<br />\r14.7.1 重复SACK（DSACK）扩展 482<br />\r14.7.2 Eifel检测算法 483<br />\r14.7.3 前移RTO恢复（F-RTO） 484<br />\r14.7.4 Eifel响应算法 484<br />\r14.8 包失序与包重复 485<br />\r14.8.1 失序 486<br />\r14.8.2 重复 487<br />\r14.9 目的度量 487<br />\r14.10 重新组包 488<br />\r14.11 与TCP重传相关的攻击 489<br />\r14.12 总结 489<br />\r14.13 参考文献 490<br />\r第15章 TCP数据流与窗口管理 492<br />\r15.1 引言 492<br />\r15.2 交互式通信 492<br />\r15.3 延时确认 494<br />\r15.4 Nagle算法 495<br />\r15.4.1 延时ACK与Nagle算法结合 497<br />\r15.4.2 禁用Nagle算法 498<br />\r15.5 流量控制与窗口管理 498<br />\r15.5.1 滑动窗口 499<br />\r15.5.2 零窗口与TCP持续计时器 501<br />\r15.5.3 糊涂窗口综合征 503<br />\r15.5.4 大容量缓存与自动调优 509<br />\r15.6 紧急机制 512<br />\r15.6.1 例子 512<br />\r15.7 与窗口管理相关的攻击 514<br />\r15.8 总结 515<br />\r15.9 参考文献 515<br />\r第16章 TCP拥塞控制 517<br />\r16.1 引言 517<br />\r16.1.1 TCP拥塞检测 517<br />\r16.1.2 减缓TCP发送 518<br />\r16.2 一些经典算法 519<br />\r16.2.1 慢启动 520<br />\r16.2.2 拥塞避免 521<br />\r16.2.3 慢启动和拥塞避免的选择 523<br />\r16.2.4 Tahoe、Reno以及快速恢复算法 523<br />\r16.2.5 标准TCP 524<br />\r16.3 对标准算法的改进 524<br />\r16.3.1 NewReno 525<br />\r16.3.2 采用选择确认机制的TCP拥塞控制 525<br />\r16.3.3 转发确认（FACK）和速率减半 526<br />\r16.3.4 限制传输 527<br />\r16.3.5 拥塞窗口校验 527<br />\r16.4 伪RTO处理&mdash;&mdash;Eifel响应算法 528<br />\r16.5 扩展举例 528<br />\r16.5.1 慢启动行为 531<br />\r16.5.2 发送暂停和本地拥塞（事件1） 532<br />\r16.5.3 延伸ACK和本地拥塞恢复 535<br />\r16.5.4 快速重传和SACK恢复（事件2） 538<br />\r16.5.5 其他本地拥塞和快速重传事件 539<br />\r16.5.6 超时、重传和撤销cwnd修改 542<br />\r16.5.7 连接结束 545<br />\r16.6 共享拥塞状态信息 545<br />\r16.7 TCP友好性 546<br />\r16.8 高速环境下的TCP 547<br />\r16.8.1 高速TCP与受限的慢启动 547<br />\r16.8.2 二进制增长拥塞控制（BIC和CUBIC） 549<br />\r16.9 基于延迟的拥塞控制算法 552<br />\r16.9.1 Vegas算法 552<br />\r16.9.2 FAST算法 553<br />\r16.9.3 TCP Westwood算法和Westwood+算法 553<br />\r16.9.4 复合TCP 553<br />\r16.10 缓冲区膨胀 555<br />\r16.11 积极队列管理和ECN 556<br />\r16.12 与TCP拥塞控制相关的攻击 557<br />\r16.13 总结 558<br />\r16.14 参考文献 560<br />\r第17章 TCP保活机制 563<br />\r17.1 引言 563<br />\r17.2 描述 564<br />\r17.2.1 保活功能举例 565<br />\r17.3 与TCP保活机制相关的攻击 569<br />\r17.4 总结 570<br />\r17.5 参考文献 570<br />\r第18章 安全：可扩展身份认证协议、IP安全协议、传输层安全、DNS安全、域名密钥识别邮件 571<br />\r18.1 引言 571<br />\r18.2 信息安全的基本原则 572<br />\r18.3 网络通信的威胁 572<br />\r18.4 基础的加密与安全机制 573<br />\r18.4.1 密码系统 573<br />\r18.4.2 RSA公钥密码算法 575<br />\r18.4.3 Diffie-Hellman-Merkle密钥协商协议 576<br />\r18.4.4 签密与椭圆曲线密码 577<br />\r18.4.5 密钥派生与完全正向保密 577<br />\r18.4.6 伪随机数、生成器与函数族 578<br />\r18.4.7 随机数与混淆值 578<br />\r18.4.8 加密散列函数与消息摘要 578<br />\r18.4.9 消息认证码 579<br />\r18.4.10 加密套件与密码套件 580<br />\r18.5 证书、证书颁发机构与公钥基础设施 582<br />\r18.5.1 公钥证书、证书颁发机构与X.509标准 583<br />\r18.5.2 验证与撤销证书 587<br />\r18.5.3 属性证书 589<br />\r18.6 TCP/IP安全协议与分层 590<br />\r18.7 网络访问控制：802.1X, 802.1AE,EAP, PANA 591<br />\r18.7.1 EAP方法与密钥派生 594<br />\r18.7.2 EAP重新认证协议 595<br />\r18.7.3 网络接入认证信息承载协议 595<br />\r18.8 第3层IP安全（IPsec） 596<br />\r18.8.1 Internet密钥交换协议（IKEv2） 597<br />\r18.8.2 认证头部 606<br />\r18.8.3 封装安全负载 609<br />\r18.8.4 组播 612<br />\r18.8.5 L2TP/IPsec 613<br />\r18.8.6 IPsec NAT穿越 613<br />\r18.8.7 例子 614<br />\r18.9 传输层安全（TLS和DTLS） 622<br />\r18.9.1 TLS 1.2 623<br />\r18.9.2 DTLS 633<br />\r18.10 DNS安全（DNSSEC） 636<br />\r18.10.1 DNSSEC资源记录 637<br />\r18.10.2 DNSSEC运行 642<br />\r18.10.3 事务认证（TSIG, TKEY,SIG(0)） 648<br />\r18.10.4 带有DNS64的DNSSEC 652<br />\r18.11 域名密钥识别邮件 652<br />\r18.11.1 DKIM签名 652<br />\r18.11.2 例子 653<br />\r18.12 与安全协议相关的攻击 654<br />\r18.13 总结 655<br />\r18.14 参考文献 657<br />\r缩略语 666</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/17lMQ7bLq3EjXsBxEaYo0Ng" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 308);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(333, '《Go语言编程》PDF完整版下载', '333', 1499682000, 1555390200, '<p>​<span style="line-height: 1.6em;">本文分享一门新语言的学习用书&mdash;&mdash;《Go语言编程》。</span></p>\r<!--more-->\r\r<p>第1章 初识Go语言 1<br />\r1.1 语言简史 1<br />\r1.2 语言特性 2<br />\r1.2.1 自动垃圾回收 3<br />\r1.2.2 更丰富的内置类型 4<br />\r1.2.3 函数多返回值 5<br />\r1.2.4 错误处理 6<br />\r1.2.5 匿名函数和闭包 6<br />\r1.2.6 类型和接口 7<br />\r1.2.7 并发编程 8<br />\r1.2.8 反射 9<br />\r1.2.9 语言交互性 10<br />\r1.3 第一个Go程序 11<br />\r1.3.1 代码解读 11<br />\r1.3.2 编译环境准备 12<br />\r1.3.3 编译程序 12<br />\r1.4 开发工具选择 13<br />\r1.5 工程管理 13<br />\r1.6 问题追踪和调试 18<br />\r1.6.1 打印日志 18<br />\r1.6.2 GDB调试 18<br />\r1.7 如何寻求帮助 18<br />\r1.7.1 邮件列表 19<br />\r1.7.2 网站资源 19<br />\r1.8 小结 19<br />\r第2章 顺序编程 20<br />\r2.1 变量 20<br />\r2.1.1 变量声明 20<br />\r2.1.2 变量初始化 21<br />\r2.1.3 变量赋值 21<br />\r2.1.4 匿名变量 22<br />\r2.2 常量 22<br />\r2.2.1 字面常量 22<br />\r2.2.2 常量定义 23<br />\r2.2.3 预定义常量 23<br />\r2.2.4 枚举 24<br />\r2.3 类型 24<br />\r2.3.1 布尔类型 25<br />\r2.3.2 整型 25<br />\r2.3.3 浮点型 27<br />\r2.3.4 复数类型 28<br />\r2.3.5 字符串 28<br />\r2.3.6 字符类型 30<br />\r2.3.7 数组 31<br />\r2.3.8 数组切片 32<br />\r2.3.9 map 36<br />\r2.4 流程控制 38<br />\r2.4.1 条件语句 38<br />\r2.4.2 选择语句 39<br />\r2.4.3 循环语句 40<br />\r2.4.4 跳转语句 41<br />\r2.5 函数 41<br />\r2.5.1 函数定义 42<br />\r2.5.2 函数调用 42<br />\r2.5.3 不定参数 43<br />\r2.5.4 多返回值 45<br />\r2.5.5 匿名函数与闭包 45<br />\r2.6 错误处理 47<br />\r2.6.1 error接口 47<br />\r2.6.2 defer 48<br />\r2.6.3 panic()和recover() 49<br />\r2.7 完整示例 50<br />\r2.7.1 程序结构 51<br />\r2.7.2 主程序 51<br />\r2.7.3 算法实现 54<br />\r2.7.4 主程序 57<br />\r2.7.5 构建与执行 59<br />\r2.8 小结 61<br />\r第3章 面向对象编程 62<br />\r3.1 类型系统 62<br />\r3.1.1 为类型添加方法 63<br />\r3.1.2 值语义和引用语义 66<br />\r3.1.3 结构体 67<br />\r3.2 初始化 68<br />\r3.3 匿名组合 68<br />\r3.4 可见性 71<br />\r3.5 接口 71<br />\r3.5.1 其他语言的接口 71<br />\r3.5.2 非侵入式接口 73<br />\r3.5.3 接口赋值 74<br />\r3.5.4 接口查询 76<br />\r3.5.5 类型查询 78<br />\r3.5.6 接口组合 78<br />\r3.5.7 Any类型 79<br />\r3.6 完整示例 79<br />\r3.6.1 音乐库 80<br />\r3.6.2 音乐播放 82<br />\r3.6.3 主程序 84<br />\r3.6.4 构建运行 86<br />\r3.6.5 遗留问题 86<br />\r3.7 小结 87<br />\r第4章 并发编程 88<br />\r4.1 并发基础 88<br />\r4.2 协程 90<br />\r4.3 goroutine 90<br />\r4.4 并发通信 91<br />\r4.5 channel 94<br />\r4.5.1 基本语法 95<br />\r4.5.2 select 95<br />\r4.5.3 缓冲机制 96<br />\r4.5.4 超时机制 97<br />\r4.5.5 channel的传递 98<br />\r4.5.6 单向channel 98<br />\r4.5.7 关闭channel 99<br />\r4.6 多核并行化 100<br />\r4.7 出让时间片 101<br />\r4.8 同步 101<br />\r4.8.1 同步锁 101<br />\r4.8.2 全局唯一性操作 102<br />\r4.9 完整示例 103<br />\r4.9.1 简单IPC框架 105<br />\r4.9.2 中央服务器 108<br />\r4.9.3 主程序 113<br />\r4.9.4 运行程序 116<br />\r4.10 小结 117<br />\r第5章 网络编程 118<br />\r5.1 Socket编程 118<br />\r5.1.1 Dial()函数 118<br />\r5.1.2 ICMP示例程序 119<br />\r5.1.3 TCP示例程序 121<br />\r5.1.4 更丰富的网络通信 122<br />\r5.2 HTTP编程 124<br />\r5.2.1 HTTP客户端 124<br />\r5.2.2 HTTP服务端 130<br />\r5.3 RPC编程 132<br />\r5.3.1 Go语言中的RPC支持与<br />\r处理 132<br />\r5.3.2 Gob简介 134<br />\r5.3.3 设计优雅的RPC接口 134<br />\r5.4 JSON处理 135<br />\r5.4.1 编码为JSON格式 136<br />\r5.4.2 解码JSON数据 137<br />\r5.4.3 解码未知结构的JSON数据 138<br />\r5.4.4 JSON的流式读写 140<br />\r5.5 网站开发 140<br />\r5.5.1 最简单的网站程序 141<br />\r5.5.2 net/http包简介 141<br />\r5.5.3 开发一个简单的相册网站 142<br />\r5.6 小结 157<br />\r第6章 安全编程 158<br />\r6.1 数据加密 158<br />\r6.2 数字签名 158<br />\r6.3 数字证书 159<br />\r6.4 PKI体系 159<br />\r6.5 Go语言的哈希函数 159<br />\r6.6 加密通信 160<br />\r6.6.1 加密通信流程 161<br />\r6.6.2 支持HTTPS的Web服务器 162<br />\r6.6.3 支持HTTPS的文件服务器 165<br />\r6.6.4 基于SSL/TLS的ECHO程序 166<br />\r6.7 小结 169<br />\r第7章 工程管理 170<br />\r7.1 Go命令行工具 170<br />\r7.2 代码风格 172<br />\r7.2.1 强制性编码规范 172<br />\r7.2.2 非强制性编码风格建议 173<br />\r7.3 远程import支持 175<br />\r7.4 工程组织 175<br />\r7.4.1 GOPATH 176<br />\r7.4.2 目录结构 176<br />\r7.5 文档管理 177<br />\r7.6 工程构建 180<br />\r7.7 跨平台开发 180<br />\r7.7.1 交叉编译 181<br />\r7.7.2 Android支持 182<br />\r7.8 单元测试 183<br />\r7.9 打包分发 184<br />\r7.10 小结 184<br />\r第8章 开发工具 186<br />\r8.1 选择开发工具 186<br />\r8.2 gedit 187<br />\r8.2.1 语法高亮 187<br />\r8.2.2 编译环境 187<br />\r8.3 Vim 188<br />\r8.4 Eclipse 189<br />\r8.5 Notepad++ 192<br />\r8.5.1 语法高亮 192<br />\r8.5.2 编译环境 192<br />\r8.6 LiteIDE 193<br />\r8.7 小结 195<br />\r第9章 进阶话题 196<br />\r9.1 反射 196<br />\r9.1.1 基本概念 196<br />\r9.1.2 基本用法 197<br />\r9.1.3 对结构的反射操作 199<br />\r9.2 语言交互性 199<br />\r9.2.1 类型映射 200<br />\r9.2.2 字符串映射 201<br />\r9.2.3 C程序 201<br />\r9.2.4 函数调用 202<br />\r9.2.5 编译Cgo 203<br />\r9.3 链接符号 203<br />\r9.4 goroutine机理 204<br />\r9.4.1 协程 204<br />\r9.4.2 协程的C语言实现 205<br />\r9.4.3 协程库概述 205<br />\r9.4.4 任务 208<br />\r9.4.5 任务调度 210<br />\r9.4.6 上下文切换 211<br />\r9.4.7 通信机制 215<br />\r9.5 接口机理 216<br />\r9.5.1 类型赋值给接口 217<br />\r9.5.2 接口查询 223<br />\r9.5.3 接口赋值 224<br />\r附录A 225</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1wyN3SynWKlj2_YNFzBEO_w" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 183),
(334, '常见的弱口令', '334', 1499689140, 1499689267, '<p>本文分享各种渠道收集来的弱口令，希望大家引以为戒。</p>\r\r<!--more-->\r\r<ol>\r	<li>123qwe!@#</li>\r	<li>123@root</li>\r	<li>1qaz2wsx</li>\r	<li>1qaz2wsx!@#</li>\r	<li>1qaz@wsx</li>\r	<li>1qaz@WSX</li>\r	<li>1qazXSW@</li>\r	<li>1qazxsw2</li>\r	<li>Admin@123</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(335, '服务器虚拟化技术结构分析', '335', 1499690580, 1502203035, '<p>本文介绍服务器虚拟化技术结构分析。</p>\r\r<!--more-->\r\r<p>云计算的根本是服务器，服务器可简单分为硬件资源、操作系统和应用程序三个层面。服务器虚拟化技术粗略的可分为一虚多和多虚一两大类。一虚多技术主要面对硬件层面与操作系统层面，就是在一台物理服务器上虚拟出多套逻辑资源来运行多套操作系统。需注意物理资源虚拟化只是手段不是重点，真正的目的是要虚拟出多套能够同时运行且互不干扰的操作系统，这部分技术是当前云计算IaaS层的基础。</p>\r\r<p>多虚一技术主要针对应用程序层面，操作系统层面也有如Cluster和Load Balance等技术手段，但其重点是要在应用层面上将底层资源整合，达到对外统一服务的目的。用户在使用搜索引擎或浏览新闻的时候，实际的任务是由后端成千上万台服务器完成，但对我们这些使用者来说，看到的就是那几个应用页面。</p>\r\r<p>当我们想要在尽量少改动甚至不改动原有对象的条件下，对整体结构做调整时，可以在其中间插入新的一个对象，专门来处理结构调整与任务调度。虚拟化技术很好的阐述了这种设计思路，通过下图梳理下一虚多与多虚一两类技术的方向，如图中Plat位置对应的Hadoop、GFS、HBASE等产品技术以及Hypervisor位置对应的VMware ESX/ECSi、Xen、Linux KVM、Microsoft Hyper-V等产品技术。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/08/1677966143.png" style="width: 600px; height: 187px;" /></p>\r\r<p>相对来说，底层的一虚多技术更加收敛一些，上层的多虚一技术则要更加开放，毕竟主流的硬件和操作系统数量有限，而应用软件数不胜数。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(337, 'Linux常用命令——iperf', '337', 1500087120, 1500089711, '<p>​<span style="line-height: 1.6em;">本文解释Linux的一个常用命令&mdash;&mdash;iperf，iperf是一款网络性能测试工具。</span></p>\r<!--more-->\r\r<p>一、iperf的安装</p>\r\r<p>1.通过源码安装</p>\r\r<pre class="brush:bash;">\rwget https://github.com/esnet/iperf/archive/3.2.tar.gz\rtar -zxvf 3.2.tar.gz\rcd iperf-3.2\r./configure\rmake\rmake install</pre>\r\r<p>2.通过rpm安装</p>\r\r<pre class="brush:bash;">\r32位系统：\rwget https://iperf.fr/download/fedora/iperf3-3.1.3-1.fc24.i686.rpm\rrpm -ivh iperf3-3.1.3-1.fc24.i686.rpm\r64位系统：\rwget https://iperf.fr/download/fedora/iperf3-3.1.3-1.fc24.x86_64.rpm\rrpm -ivh iperf3-3.1.3-1.fc24.x86_64.rpm</pre>\r\r<p>二、iperf的通用参数</p>\r\r<p>1.-f, --format [bkmaBKMA]</p>\r\r<pre class="brush:bash;">\r格式化带宽数输出。\r支持的格式有： \r&#39;b&#39; = bits/sec \r&#39;B&#39; = Bytes/sec \r&#39;k&#39; = Kbits/sec \r&#39;K&#39; = KBytes/sec \r&#39;m&#39; = Mbits/sec \r&#39;M&#39; = MBytes/sec \r&#39;g&#39; = Gbits/sec \r&#39;G&#39; = GBytes/sec \r&#39;a&#39; = adaptive bits/sec \r&#39;A&#39; = adaptive Bytes/sec \r自适应格式是kilo-和mega-二者之一。\r除了带宽之外的字段都输出为字节，除非指定输出的格式，默认的参数是a。 \r注意：在计算字节byte时，Kilo = 1024， Mega = 1024^2，Giga = 1024^3。\r通常，在网络中，Kilo = 1000， Mega = 1000^2， and Giga = 1000^3，所以，Iperf也按此来计算比特（位）。\r如果这些困扰了你，那么请使用-f b参数，然后亲自计算一下。 </pre>\r\r<p>2.-i, --interval</p>\r\r<pre class="brush:bash;">\r设置每次报告之间的时间间隔，单位为秒。\r如果设置为非零值，就会按照此时间间隔输出测试报告。\r默认值为零。</pre>\r\r<p>3.-l, --len [KM]</p>\r\r<pre class="brush:bash;">\r设置读写缓冲区的长度。\rTCP方式默认为8KB，UDP方式默认为1470字节。 </pre>\r\r<p>4.-m, --print_mss</p>\r\r<pre class="brush:bash;">\r输出TCP MSS值（通过TCP_MAXSEG支持）。MSS值一般比MTU值小40字节。</pre>\r\r<p>5.-p, --port</p>\r\r<pre class="brush:bash;">\r设置端口，与服务器端的监听端口一致。\r默认是5201端口，与ttcp的一样。 </pre>\r\r<p>6.-u, --udp</p>\r\r<pre class="brush:bash;">\r使用UDP方式而不是TCP方式。\r参看-b选项。</pre>\r\r<p>7.-w, --window [KM]</p>\r\r<pre class="brush:bash;">\r设置套接字缓冲区为指定大小。对于TCP方式，此设置为TCP窗口大小。\r对于UDP方式，此设置为接受UDP数据包的缓冲区大小，限制可以接受数据包的最大值。</pre>\r\r<p>8.-B, --bind host</p>\r\r<pre class="brush:bash;">\r绑定到主机的多个地址中的一个。\r对于客户端来说，这个参数设置了出栈接口。\r对于服务器端来说，这个参数设置入栈接口。\r这个参数只用于具有多网络接口的主机。\r在Iperf的UDP模式下，此参数用于绑定和加入一个多播组。\r使用范围在224.0.0.0至239.255.255.255的多播地址。\r参考-T参数。</pre>\r\r<p>9.-C, --compatibility</p>\r\r<pre class="brush:bash;">\r与低版本的Iperf使用时，可以使用兼容模式。\r不需要两端同时使用兼容模式，但是强烈推荐两端同时使用兼容模式。\r某些情况下，使用某些数据流可以引起1.7版本的服务器端崩溃或引起非预期的连接尝试。</pre>\r\r<p>10.-M, --mss [KM]</p>\r\r<pre class="brush:bash;">\r通过TCP_MAXSEG选项尝试设置TCP最大信息段的值。\rMSS值的大小通常是TCP/ip头减去40字节。\r在以太网中，MSS值为1460字节（MTU1500字节）。\r许多操作系统不支持此选项。</pre>\r\r<p>11.-N, --nodelay</p>\r\r<pre class="brush:bash;">\r设置TCP无延迟选项，禁用Nagle&#39;s运算法则。\r通常情况此选项对于交互程序，例如telnet，是禁用的。</pre>\r\r<p>12.-V</p>\r\r<pre class="brush:bash;">\r绑定一个IPv6地址。\r服务端：$ iperf -s &ndash;V \r客户端：$ iperf -c -V \r注意：在1.6.3或更高版本中，指定IPv6地址不需要使用-B参数绑定，在1.6之前的版本则需要。\r在大多数操作系统中，将响应IPv4客户端映射的IPv4地址。</pre>\r\r<p>13.-h, --help</p>\r\r<pre class="brush:bash;">\r显示命令行参考并退出。</pre>\r\r<p>14.-v, --version</p>\r\r<pre class="brush:bash;">\r显示版本信息和编译信息并退出。</pre>\r\r<p>三、iperf的服务端专用参数</p>\r\r<p>1.-s, --server</p>\r\r<pre class="brush:bash;">\rIperf服务器模式</pre>\r\r<p>2.-D</p>\r\r<pre class="brush:bash;">\rUnix平台下Iperf作为后台守护进程运行。\r在Win32平台下，Iperf将作为服务运行。</pre>\r\r<p>3.-R</p>\r\r<pre class="brush:bash;">\r仅用于Windows。\r卸载Iperf服务（如果它在运行）。</pre>\r\r<p>4.-o</p>\r\r<pre class="brush:bash;">\r仅用于Windows。\r重定向输出到指定文件。</pre>\r\r<p>5.-c, --client host</p>\r\r<pre class="brush:bash;">\r如果Iperf运行在服务器模式，并且用-c参数指定一个主机，那么Iperf将只接受指定主机的连接。\r此参数不能工作于UDP模式。</pre>\r\r<p>6.-P, --parallel</p>\r\r<pre class="brush:bash;">\r服务器关闭之前保持的连接数。\r默认是0，这意味着永远接受连接。</pre>\r\r<p>四、iperf的客户端专用参数</p>\r\r<p>1.-b, --bandwidth [KM]</p>\r\r<pre class="brush:bash;">\rUDP模式使用的带宽，单位bits/sec。\r此选项与-u选项相关。默认值是1 Mbit/sec。</pre>\r\r<p>2.-c, --client host</p>\r\r<pre class="brush:bash;">\r运行Iperf的客户端模式，连接到指定的Iperf服务器端。</pre>\r\r<p>3.-d, --dualtest</p>\r\r<pre class="brush:bash;">\r运行双测试模式。\r这将使服务器端反向连接到客户端，使用-L参数中指定的端口（或默认使用客户端连接到服务器端的端口）。\r这些在操作的同时就立即完成了。\r如果你想要一个交互的测试，请尝试-r参数。</pre>\r\r<p>4.-n, --num [KM]</p>\r\r<pre class="brush:bash;">\r传送的缓冲器数量。\r通常情况，Iperf按照10秒钟发送数据。\r-n参数跨越此限制，按照指定次数发送指定长度的数据，而不论该操作耗费多少时间。\r参考-l与-t选项。</pre>\r\r<p>5.-r, --tradeoff</p>\r\r<pre class="brush:bash;">\r往复测试模式。\r当客户端到服务器端的测试结束时，服务器端通过-l选项指定的端口（或默认为客户端连接到服务器端的端口），反向连接至客户端。\r当客户端连接终止时，反向连接随即开始。\r如果需要同时进行双向测试，请尝试-d参数。</pre>\r\r<p>6.-t, --time</p>\r\r<pre class="brush:bash;">\r设置传输的总时间。\rIperf在指定的时间内，重复的发送指定长度的数据包。\r默认是10秒钟。\r参考-l与-n选项。</pre>\r\r<p>7.-L, --listenport</p>\r\r<pre class="brush:bash;">\r指定服务端反向连接到客户端时使用的端口。\r默认使用客户端连接至服务端的端口。</pre>\r\r<p>8.-P, --parallel</p>\r\r<pre class="brush:bash;">\r线程数。\r指定客户端与服务端之间使用的线程数。\r默认是1线程。需要客户端与服务器端同时使用此参数。</pre>\r\r<p>9.-S, --tos</p>\r\r<pre class="brush:bash;">\r出栈数据包的服务类型。\r许多路由器忽略TOS字段。\r你可以指定这个值，使用以&quot;0x&quot;开始的16进制数，或以&quot;0&quot;开始的8进制数或10进制数。 \r例如，16进制&#39;0x10&#39; = 8进制&#39;020&#39; = 十进制&#39;16&#39;。\rTOS值1349就是： IPTOS_LOWDELAY minimize delay 0x10 IPTOS_THROUGHPUT maximize throughput 0x08 IPTOS_RELIABILITY maximize reliability 0x04 IPTOS_LOWCOST minimize cost 0x02</pre>\r\r<p>10.-T, --ttl</p>\r\r<pre class="brush:bash;">\r出栈多播数据包的TTL值。\r这本质上就是数据通过路由器的跳数。\r默认是1，链接本地。</pre>\r\r<p>11.-F</p>\r\r<pre class="brush:bash;">\r使用特定的数据流测量带宽，例如指定的文件。\r$ iperf -c -F \r-I与-F一样，由标准输入输出文件输入数据。</pre>\r\r<p>五、常用示例参考</p>\r\r<p>带宽测试通常采用UDP模式，因为能测出极限带宽、时延抖动、丢包率。在进行测试时，首先以链路理论带宽作为数据发送速率进行测试，例如，从客户端到服务器之间的链路的理论带宽为100Mbps，先用-b 100M进行测试，然后根据测试结果（包括实际带宽，时延抖动和丢包率），再以实际带宽作为数据发送速率进行测试，会发现时延抖动和丢包率比第一次好很多，重复测试几次，就能得出稳定的实际带宽。</p>\r\r<p>1.TCP模式</p>\r\r<pre class="brush:bash;">\r服务器端：\riperf -s\r客户端：\riperf -c 192.168.1.1 -t 60\r在tcp模式下，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒。\riperf -c 192.168.1.1 -P 30 -t 60\r客户端同时向服务器端发起30个连接线程。\riperf -c 192.168.1.1 -d -t 60\r进行上下行带宽测试。</pre>\r\r<p>2.UDP模式</p>\r\r<pre class="brush:bash;">\r服务器端：\riperf -u -s\r客户端：\riperf -u -c 192.168.1.1 -b 100M -t 60\r在udp模式下，以100Mbps为数据发送速率，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒。 \riperf -u -c 192.168.1.1 -b 5M -P 30 -t 60\r客户端同时向服务器端发起30个连接线程，以5Mbps为数据发送速率。\riperf -u -c 192.168.1.1 -b 100M -d -t 60\r以100M为数据发送速率，进行上下行带宽测试。</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 188),
(520, 'count.png', 'count-png', 1515584123, 1515584123, 'a:5:{s:4:"name";s:9:"count.png";s:4:"path";s:35:"/usr/uploads/2018/01/3632602918.png";s:4:"size";i:124141;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 521, 0),
(521, '赋值运算符', '521', 1515584160, 1515584579, '<p>本文记录Java学习过程中遇到的赋值运算符～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3632602918.png" style="width: 600px; height: 265px;" /></p>\r\r<p>注意事项：</p>\r\r<ul>\r	<li>诸如+=这样形式的赋值运算符，会将结果自动强转成等号左边的数据类型。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class OperatorTest {\r	public static void main(String[] args) {\r		byte x = 10;\r		x += 20;// 相当于 x = (byte)(x+20);\r		System.out.println(x);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(340, '《Maven实战》PDF完整版下载', '340', 1500268440, 1555390174, '<p>本文分享一本书&mdash;&mdash;《Maven实战》。</p>\r<!--more-->\r\r<p>前言<br />\r致谢<br />\r第1章 Maven简介<br />\r1.1 何为Maven<br />\r1.1.1 何为构建<br />\r1.1.2 Maven是***的构建工具<br />\r1.1.3 Maven不仅仅是构建工具乃<br />\r1.2 为什么需要Maven<br />\r1.2.1 组装PC和品牌PC<br />\r1.2.2 IDE不是***的<br />\r1.2.3 Make<br />\r1.2.4 Ant<br />\r1.2.5 不重复发明轮子<br />\r1.3 Maven与极限编程<br />\r1.4 被误解的Maven<br />\r1.5 小结<br />\r第2章 Maven的安装和配置<br />\r2.1 在Windows上安装Maven<br />\r2.1.1 检查JDK安装<br />\r2.1.2 下载Maven<br />\r2.1.3 本地安装<br />\r2.1.4 升级Maven<br />\r2.2 在基于UNIX的系统上安装Maven<br />\r2.2.1 下载和安装<br />\r2.2.2 井级Maven<br />\r2.3 安装目录分析<br />\r2.3.1 M2－HOME<br />\r2.4 设置HTTP代理<br />\r2.5 安装m2eclipse<br />\r2.6 安装NetBeansMaven插件<br />\r2.7 Maven安装***佳实践<br />\r2.7.1 设置MAVEN-OPTS环境变量<br />\r2.7.2 配置用户范围settings.xmL<br />\r2.7.3 不要使用IDE內嵌的Maven<br />\r2.8 小结<br />\r第3章 Maven使用入门<br />\r3.1 编写POM<br />\r3.2 编写主代码<br />\r3.3 编写测试代码<br />\r3.4 打包和运行<br />\r3.5 使用Archetype生成项目骨架<br />\r3.6 m2eclipse简单使用<br />\r3.6.1 导入Maven项目<br />\r3.6.2 创建Maven项目<br />\r3.6.3 运行mvn命令<br />\r3.7 NetBeansMaven插件简单使用<br />\r3.7.1 打开Maven项目<br />\r3.7.2 创建Maven项目<br />\r3.7.3 运行mvn命令<br />\r3.8 小结<br />\r第4章 背景案例<br />\r4.1 简单的账户注册服务<br />\r4.2 需求阐述<br />\r4.2.1 需求用例<br />\r4.2.2 界面原型<br />\r4.3 简要设计<br />\r4.3.1 接口<br />\r4.3.2 模块结构<br />\r4.4 小结<br />\r第5章 坐标和依赖<br />\r5.1 何为Maven坐标<br />\r5.2 坐标详解<br />\r5.3 account－email<br />\r5.3.1 account－email的POM<br />\r5.3.2 account－email的主代码<br />\r5.3.3 account－email的测试代码<br />\r5.3.4 构建account－emaiL<br />\r5.4 依赖的配置<br />\r5.5 依赖范围<br />\r5.6 传递性依赖<br />\r5.6.1 何为传递性依赖<br />\r5.6.2 传递性依赖和依赖范围<br />\r5.7 依赖调解<br />\r5.8 可选依赖<br />\r5.9 ***佳实践<br />\r5.9.1 排除依赖<br />\r5.9.2 归类依赖<br />\r5.9.3 优化依赖<br />\r5.10 小结<br />\r第6章 仓库<br />\r6.1 何为Maven仓库<br />\r6.2 仓库的布局<br />\r6.3 仓库的分类<br />\r6.3.1 本地仓库<br />\r6.3.2 远程仓库<br />\r6.3.3 中央仓库<br />\r6.3.4 私服<br />\r6.4 远程仓库的配置<br />\r6.4.1 远程仓库的认证<br />\r6.4.2 部署至远程仓库<br />\r6.5 快照版本<br />\r6.6 从仓库解析依赖的机制<br />\r6.7 镜像<br />\r6.8 仓库搜索服务<br />\r6.8.1 SonatypeNexus<br />\r6.8.2 Jarvana<br />\r6.8.3 MVNbrowser<br />\r6.8.4 MVNrepository<br />\r6.8.5 选择合适的仓库搜索服务<br />\r6.9 小结<br />\r第7章 生命周期和插件<br />\r7.1 何为生命周期<br />\r&hellip;&hellip;<br />\r第8章 聚合与继承<br />\r第9章 Nexus创建私服<br />\r下载地址：<a href="https://pan.baidu.com/s/1zU6uXAs6EF9Mnq-RftSgLg" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 354),
(342, '常用Windows快捷键', '342', 1500444366, 1500444366, '<p>本文分享一些Windows的常用快捷键，有需要的千万要收藏好。</p>\r\r<!--more-->\r\r<ol>\r	<li><span style="line-height: 1.6em;">F1 显示当前程序或者windows的帮助内容</span></li>\r	<li><span style="line-height: 1.6em;">F2 当你选中一个文件的话，这意味着&ldquo;重命名&rdquo;</span></li>\r	<li><span style="line-height: 1.6em;">F5 刷新</span></li>\r	<li><span style="line-height: 1.6em;">F10 或ALT 激活当前程序的菜单栏（word中Shift+F10会出现右键快捷菜单）</span></li>\r	<li><span style="line-height: 1.6em;">F11 当你在打开网页时，是隐藏侧边栏，也就是浏览器&ldquo;全屏模式&rdquo;</span></li>\r	<li>F12 在编辑好Excel 或Word文档，可&ldquo;另存为&rdquo;</li>\r	<li>Backspace 如果在&ldquo;另存为&rdquo;或&ldquo;打开&rdquo;对话框中选中了某个文件夹，则打开上一级文件夹</li>\r	<li>Enter 对于许多选定命令代替单击鼠标</li>\r	<li>空格键 如果活动选项是复选框，则选中或清除该复选框</li>\r	<li>箭头键 如果活动选项是一组选项按钮，则选择某个按钮</li>\r	<li>windows键或CTRL+ESC 打开开始菜单</li>\r	<li>CTRL+SHIFT+ESC 或 CTRL+ALT+DELETE 打开任务管理器</li>\r	<li>DELETE 删除被选中的项目，如果是文件，将被放入回收站</li>\r	<li>SHIFT+DELETE 删除被选中的项目，如果是文件，将被直接删除而不是放入回收站</li>\r	<li>CTRL+SHIFT+N 新建一个新的文件夹</li>\r	<li>CTRL+A 全选文件夹内的文件</li>\r	<li>CTRL+O 打开&ldquo;打开文件&rdquo;对话框（适用于WORD）</li>\r	<li>CTRL+P 打开&ldquo;打印&rdquo;对话框</li>\r	<li>CTRL+S 保存当前操作的文件</li>\r	<li>CTRL+W 关闭当前的窗口</li>\r	<li>CTRL+ X 剪切被选择的项目到剪贴板</li>\r	<li>CTRL+INSERT 或 CTRL+C 复制被选择的项目到剪贴板（笔记本：FN+CTRL+INSERT=CTRL+INSERT）</li>\r	<li>CTRL+Shift 切换中英文输入法和（CTRL+空格的作用一样）</li>\r	<li>CTRL+F4 关闭当前应用程序中的当前文本（如word中）</li>\r	<li>CTRL+F6 切换到当前应用程序中的下一个文本</li>\r	<li>Ctrl+Tab 在选项卡上向前移动</li>\r	<li>Ctrl+Shift+Tab 在选项卡上向后移动</li>\r	<li>CTRL+ALT+方向键或CTRL+方向键 可以滚动屏幕</li>\r	<li>SHIFT+INSERT 或 CTRL+V 粘贴剪贴板中的内容到当前位置(笔记本：FN+SHIFT+INSERT=SHIFT+INSERT）</li>\r	<li>Shift+Tab 在选项上向后移动</li>\r	<li>ALT+BACKSPACE 或 CTRL+Z 撤销上一步的操作</li>\r	<li>ALT+SHIFT+BACKSPACE 或CTRL+Y 重做上一步被撤销的操作</li>\r	<li>Alt+加下划线的字母 执行与该字母匹配的命令（或选择选项）</li>\r	<li>SHIFT+F10或鼠标右击 打开当前活动项目的快捷菜单</li>\r	<li>SHIFT 在放入CD的时候按下不放，可以跳过自动播放CD。在打开word的时候按下不放，可以跳过自启动的宏</li>\r	<li>ALT+F4关闭当前应用程序</li>\r	<li>ALT+SPACEBAR 打开程序最左上角的菜单</li>\r	<li>ALT+TAB 切换当前程序 （加SHIFT反向）</li>\r	<li>ALT+ESC 切换当前程序 （加SHIFT反向）</li>\r	<li>ALT+ENTER 将windows下运行的MSDOS窗口在窗口和全屏幕状态间切换</li>\r	<li>PRINT SCREEN 将当前屏幕以图像方式拷贝到剪贴板(笔记本上是PrtScSysRq)</li>\r	<li>ALT+PRINT SCREEN 将当前活动程序窗口以图像方式拷贝到剪贴板（加shift 可以跳到前一个窗口）</li>\r	<li>Windows键+B 选中桌面右下方工具栏</li>\r	<li>Windows键+D 显示桌面</li>\r	<li>Windows键+E 打开我的电脑</li>\r	<li>Windows键+F 打开&ldquo;查找：所有文件&rdquo;对话框</li>\r	<li>Windows键+L 锁定计算机或切换用户</li>\r	<li>Windows键+M 最小化所有窗口</li>\r	<li>Windows键+SHIFT+M 将最小化的窗口还原到桌面</li>\r	<li>Windows键+R 打开&ldquo;运行&rdquo;对话框</li>\r	<li>Windows键+U 打开辅助工具管理器</li>\r	<li>Windows键+BREAK 打开&ldquo;系统属性&rdquo;对话框</li>\r	<li>Windows键+CTRL+F 搜索计算机（如果已连接到网络）</li>\r	<li>Windows键+ Pause 显示&ldquo;系统属性&rdquo;对话框</li>\r	<li>Windows键+ T 循环切换任务栏上的程序</li>\r	<li>Windows键+ 数字 启动锁定到任务栏中的由该数字所表示位置处的程序。如果该程序已在运行，则切换到该程序，（主键盘区上的数字）</li>\r	<li>Shift+Windows键+数字 启动锁定到任务栏中的由该数字所表示位置处的程序的新实例，（主键盘区上的数字）</li>\r	<li>Alt+Windows键+数字 打开锁定到任务栏中的由该数字所表示位置处的程序的跳转列表 (Jump List) （主键盘区上的数字）</li>\r	<li>Windows键+Tab 使用Aero Flip&nbsp;3-D循环切换任务栏上的程序</li>\r	<li>Ctrl+Windows键+Tab 通过 Aero Flip 3-D 使用箭头键循环切换任务栏上的程序</li>\r	<li>Windows键+空格键 预览桌面 （在win10此项是小界面切换输入法）</li>\r	<li>Windows键+向上键 最大化窗口</li>\r	<li>Windows键+向左键 将窗口最大化到屏幕的左侧</li>\r	<li>Windows键+向右键 将窗口最大化到屏幕的右侧</li>\r	<li>Windows键+向下键 最小化窗口（win10）（windowsXP不适用）</li>\r	<li>Windows键+Home 最小化除活动窗口之外的所有窗口</li>\r	<li>Windows键+Shift+向上键 将窗口拉伸到屏幕的顶部和底部</li>\r	<li>Windows键+Shift+向左键或向右键 将窗口从一个监视器移动到另一个监视器</li>\r	<li>Windows键+P 选择演示显示模式（win10），一些办公人士专用，按住windows+p就可以把笔记本的屏幕投影到投影仪上了</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 145),
(343, '《图解HTTP》PDF完整版下载', '343', 1500537540, 1540985784, '<p>本文分享一本关于http的入门书籍&mdash;&mdash;《图解HTTP》。</p>\r<!--more-->\r\r<p>第1章 了解Web及网络基础<br />\r1.1 使用HTTP协议访问Web<br />\r1.2 HTTP的诞生<br />\r1.2.1 为知识共享而规划Web<br />\r1.2.2 Web成长时代<br />\r1.2.3 驻足不前的HTTP<br />\r1.3 网络基础TCP/IP<br />\r1.3.1 TCP/IP协议族<br />\r1.3.2 TCP/IP的分层管理<br />\r1.3.3 TCP/IP通信传输流<br />\r1.4 与HTTP关系密切的协议：IP、TCP和DNS<br />\r1.4.1 负责传输的IP协议<br />\r1.4.2 确保可靠性的TCP协议<br />\r1.5 负责域名解析的DNS服务<br />\r1.6 各种协议与HTTP协议的关系<br />\r1.7 URI和URL<br />\r1.7.1 统一资源标识符<br />\r1.7.2 URI格式<br />\r第2章 简单的HTTP协议<br />\r2.1 HTTP协议用于客户端和服务器端之间的通信<br />\r2.2 通过请求和响应的交换达成通信<br />\r2.3 HTTP是不保存状态的协议<br />\r2.4 请求URI定位资源<br />\r2.5 告知服务器意图的HTTP方法<br />\r2.6 使用方法下达命令<br />\r2.7 持久连接节省通信量<br />\r2.7.1 持久连接<br />\r2.7.2 管线化<br />\r2.8 使用Cookie的状态管理<br />\r第3章 HTTP报文内的HTTP信息<br />\r3.1 HTTP报文<br />\r3.2 请求报文及响应报文的结构<br />\r3.3 编码提升传输速率<br />\r3.3.1 报文主体和实体主体的差异<br />\r3.3.2 压缩传输的内容编码<br />\r3.3.3 分割发送的分块传输编码<br />\r3.4 发送多种数据的多部分对象集合<br />\r3.5 获取部分内容的范围请求<br />\r3.6 内容协商返回最合适的内容<br />\r第4章 返回结果的HTTP状态码<br />\r4.1 状态码告知从服务器端返回的请求结果<br />\r4.2 2XX成功<br />\r4.2.1 200 OK<br />\r4.2.2 204 No Content<br />\r4.2.3 206 Partial Content<br />\r4.3 3XX重定向<br />\r4.3.1 301 Moved Permanently<br />\r4.3.2 302 Found<br />\r4.3.3 303 See Other<br />\r4.3.4 304 Not Modified<br />\r4.3.5 307 Temporary Redirect<br />\r4.4 4XX客户端错误<br />\r4.4.1 400 Bad Request<br />\r4.4.2 401 Unauthorized<br />\r4.4.3 403 Forbidden<br />\r4.4.4 404 Not Found<br />\r4.5 5XX服务器错误<br />\r4.5.1 500 Internal Server Error<br />\r4.5.2 503 Service Unavailable<br />\r第5章 与HTTP协作的Web服务器<br />\r5.1 用单台虚拟主机实现多个域名<br />\r5.2 通信数据转发程序：代理、网关、隧道<br />\r5.2.1 代理<br />\r5.2.2 网关<br />\r5.2.3 隧道<br />\r5.3 保存资源的缓存<br />\r5.3.1 缓存的有效期限<br />\r5.3.2 客户端的缓存<br />\r第6章 HTTP首部<br />\r6.1 HTTP报文首部<br />\r6.2 HTTP首部字段<br />\r6.2.1 HTTP首部字段传递重要信息<br />\r6.2.2 HTTP首部字段结构<br />\r6.2.3 4种HTTP首部字段类型<br />\r6.2.4 HTTP/1.1首部字段一览<br />\r6.2.5 非HTTP/1.1首部字段<br />\r6.2.6 End-to-end首部和Hop-by-hop首部<br />\r6.3 HTTP/1.1通用首部字段<br />\r6.3.1 Cache-Control<br />\r6.3.2 Connection<br />\r6.3.3 Date<br />\r6.3.4 Pragma<br />\r6.3.5 Trailer<br />\r6.3.6 Transfer-Encoding<br />\r6.3.7 Upgrade<br />\r6.3.8 Via<br />\r6.3.9 Warning<br />\r6.4 请求首部字段<br />\r6.4.1 Accept<br />\r6.4.2 Accept-Charset<br />\r6.4.3 Accept-Encoding<br />\r6.4.4 Accept-Language<br />\r6.4.5 Authorization<br />\r6.4.6 Expect<br />\r6.4.7 From<br />\r6.4.8 Host<br />\r6.4.9 If-Match<br />\r6.4.10 If-Modified-Since<br />\r6.4.11 If-None-Match<br />\r6.4.12 If-Range<br />\r6.4.13 If-Unmodified-Since<br />\r6.4.14 Max-Forwards<br />\r6.4.15 Proxy-Authorization<br />\r6.4.16 Range<br />\r6.4.17 Referer<br />\r6.4.18 TE<br />\r6.4.19 User-Agent<br />\r6.5 响应首部字段<br />\r6.5.1 Accept-Ranges<br />\r6.5.2 Age<br />\r6.5.3 ETag<br />\r6.5.4 Location<br />\r6.5.5 Proxy-Authenticate<br />\r6.5.6 Retry-After<br />\r6.5.7 Server<br />\r6.5.8 Vary<br />\r6.5.9 WWW-Authenticate<br />\r6.6 实体首部字段<br />\r6.6.1 Allow<br />\r6.6.2 Content-Encoding<br />\r6.6.3 Content-Language<br />\r6.6.4 Content-Length<br />\r6.6.5 Content-Location<br />\r6.6.6 Content-MD5<br />\r6.6.7 Content-Range<br />\r6.6.8 Content-Type<br />\r6.6.9 Expires<br />\r6.6.10 Last-Modified<br />\r6.7 为Cookie服务的首部字段<br />\r6.7.1 Set-Cookie<br />\r6.7.2 Cookie<br />\r6.8 其他首部字段<br />\r6.8.1 X-Frame-Options<br />\r6.8.2 X-XSS-Protection<br />\r6.8.3 DNT<br />\r6.8.4 P3P<br />\r第7章 确保Web安全的HTTPS<br />\r7.1 HTTP的缺点<br />\r7.1.1 通信使用明文可能会被窃听<br />\r7.1.2 不验证通信方的身份就可能遭遇伪装<br />\r7.1.3 无法证明报文完整性，可能已遭篡改<br />\r7.2 HTTP+加密+认证+完整性保护=HTTPS<br />\r7.2.1 HTTP加上加密处理和认证以及完整性保护后即是HTTPS<br />\r7.2.2 HTTPS是身披SSL外壳的HTTP<br />\r7.2.3 相互交换密钥的公开密钥加密技术<br />\r7.2.4 证明公开密钥正确性的证书<br />\r7.2.5 HTTPS的安全通信机制<br />\r第8章 确认访问用户身份的认证<br />\r8.1 何为认证<br />\r8.2 BASIC认证<br />\r8.3 DIGEST认证<br />\r8.4 SSL客户端认证<br />\r8.4.1 SSL客户端认证的认证步骤<br />\r8.4.2 SSL客户端认证采用双因素认证<br />\r8.4.3 SSL客户端认证必要的费用<br />\r8.5 基于表单认证<br />\r8.5.1 认证多半为基于表单认证<br />\r8.5.2 Session管理及Cookie应用<br />\r第9章 基于HTTP的功能追加协议<br />\r9.1 基于HTTP的协议<br />\r9.2 消除HTTP瓶颈的SPDY<br />\r9.2.1 HTTP的瓶颈<br />\r9.2.2 SPDY的设计与功能<br />\r9.2.3 SPDY消除Web瓶颈了吗<br />\r9.3 使用浏览器进行全双工通信的WebSocket<br />\r9.3.1 WebSocket的设计与功能<br />\r9.3.2 WebSocket协议<br />\r9.4 期盼已久的HTTP/2.0<br />\r9.5 Web服务器管理文件的WebDAV<br />\r9.5.1 扩展HTTP/1.1的WebDAV<br />\r9.5.2 WebDAV内新增的方法及状态码<br />\r第10章 构建Web内容的技术<br />\r10.1 HTML<br />\r10.1.1 Web页面几乎全由HTML构建<br />\r10.1.2 HTML的版本<br />\r10.1.3 设计应用CSS<br />\r10.2 动态HTML<br />\r10.2.1 让Web页面动起来的动态HTML<br />\r10.2.2 更易控制HTML的DOM<br />\r10.3 Web应用<br />\r10.3.1 通过Web提供功能的Web应用<br />\r10.3.2 与Web服务器及程序协作的CGI<br />\r10.3.3 因Java而普及的Servlet<br />\r10.4 数据发布的格式及语言<br />\r10.4.1 可扩展标记语言<br />\r10.4.2 发布更新信息的RSS/Atom<br />\r10.4.3 JavaScript衍生的轻量级易用JSON<br />\r第11章 Web的攻击技术<br />\r11.1 针对Web的攻击技术<br />\r11.1.1 HTTP不具备必要的安全功能<br />\r11.1.2 在客户端即可篡改请求<br />\r11.1.3 针对Web应用的攻击模式<br />\r11.2 因输出值转义不完全引发的安全漏洞<br />\r11.2.1 跨站脚本攻击<br />\r11.2.2 SQL注入攻击<br />\r11.2.3 OS命令注入攻击<br />\r11.2.4 HTTP首部注入攻击<br />\r11.2.5 邮件首部注入攻击<br />\r11.2.6 目录遍历攻击<br />\r11.2.7 远程文件包含漏洞<br />\r11.3 因设置或设计上的缺陷引发的安全漏洞<br />\r11.3.1 强制浏览<br />\r11.3.2 不正确的错误消息处理<br />\r11.3.3 开放重定向<br />\r11.4 因会话管理疏忽引发的安全漏洞<br />\r11.4.1 会话劫持<br />\r11.4.2 会话固定攻击<br />\r11.4.3 跨站点请求伪造<br />\r11.5 其他安全漏洞<br />\r11.5.1 密码破解<br />\r11.5.2 点击劫持<br />\r11.5.3 DoS攻击<br />\r11.5.4 后门程序</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1dYh8HpPYfD5uSeZ6hRJt9w" target="_blank">图片版</a>&nbsp;<a href="https://pan.baidu.com/s/1pBT33pL2wKEIFrHap3gguw" target="_blank">文字版</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 157),
(344, '如何添加自定义CA根证书到操作系统获得信任', '344', 1500597982, 1500597982, '<p>现在很多网站和服务都使用了HTTPS进行链路加密、防止信息在传输中间节点被窃听和篡改。HTTPS的启用都需要一个CA证书，以保证加密过程是可信的。</p>\r<!--more-->\r\r<p>我们可以申请和获得一个CA机构颁发的证书，在软件调试过程中或者机构内部网可以创建自签名的CA证书，在使用openssl创建nginx自签名证书有关于自签名CA证书制作和使用的描述。</p>\r\r<p>所谓&ldquo;自签名&rdquo;就是把自己当成一个CA证书颁发机构，只不过未得到公共证书机构的认可。这样的CA证书在部分操作系统下，可以直接配置在应用系统里使用，在浏览器里往往会进行提示，如果加入&ldquo;例外&rdquo;白名单中，就可以继续使用。</p>\r\r<p>但在有的操作系统和一些版本中，需要将根证书配置为系统级的证书，才允许继续使用，系统就像个看大门的，需得首先过了这一关才行。尤其是因为出现证书机构颁发虚假证书问题，最近很多操作系统都加强了安全措施，对证书都加强了验证，必须进行ca证书配置才能继续访问了。</p>\r\r<p>Mac OS X</p>\r\r<pre class="brush:bash;">\r添加证书：\rsudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ~/new-root-certificate.crt\r移除证书：\rsudo security delete-certificate -c &quot;&quot;</pre>\r\r<p>Windows</p>\r\r<pre class="brush:bash;">\r添加证书：\rcertutil -addstore -f &quot;ROOT&quot; new-root-certificate.crt\r移除证书：\rcertutil -delstore &quot;ROOT&quot; serial-number-hex</pre>\r\r<p>Linux (Ubuntu, Debian)</p>\r\r<pre class="brush:bash;">\r添加证书：\r1.复制 CA 文件到目录： /usr/local/share/ca-certificates/\r2.执行:\rsudo cp foo.crt /usr/local/share/ca-certificates/foo.crt\r3.更新 CA 证书库:\rsudo update-ca-certificates\r移除证书：\r1.Remove your CA.\r2.Update the CA store:\rsudo update-ca-certificates --fresh\rRestart Kerio Connect to reload the certificates in the 32-bit versions or Debian 7.</pre>\r\r<p>Linux (CentOs 6)</p>\r\r<pre class="brush:bash;">\r添加证书：\r1.安装 ca-certificates package:\ryum install ca-certificates\r2.启用dynamic CA configuration feature:\rupdate-ca-trust force-enable\r3.Add it as a new file to /etc/pki/ca-trust/source/anchors/:\rcp foo.crt /etc/pki/ca-trust/source/anchors/\r4.执行:\rupdate-ca-trust extract\rRestart Kerio Connect to reload the certificates in the 32-bit version.</pre>\r\r<p>Linux (CentOs 5)</p>\r\r<pre class="brush:bash;">\r添加证书：\rAppend your trusted certificate to file /etc/pki/tls/certs/ca-bundle.crt\rcat foo.crt &gt;&gt; /etc/pki/tls/certs/ca-bundle.crt</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 255),
(345, '什么是数据库', '345', 1500903660, 1501909502, '<p>​本文介绍什么是数据库。</p>\r<!--more-->\r\r<p>简单的说，数据库就是一个存放数据的仓库，这个仓库是按照一定的数据结构（数据结构是指数据的组织形式或数据之间的联系）来组织、存储的，我们可以通过数据库提供的多种方法来管理数据库里的数据。</p>\r\r<p>更简单的形象描述，数据库和我们生活中存放杂物的储物间仓库性质一样，区别只是存放的东西不同，杂物间存放实物的物件，而数据库里存储的是数据，这样我们就对数据库有一个初步的了解了。</p>\r\r<p>数据库诞生于距现在大概六十多年前，随着信息技术的发展和人类社会的不断进步，特别是2000年以后，数据库不在仅仅是存储和管理数据了，而转变成用户所需要的各种数据管理的方式。数据库有很多种类和功能，从最简单的存储有各种数据的表格到能够进行海量数据存储的大型数据库都在各个方面得到了广泛的应用。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(346, '数据库的种类', '346', 1500904140, 1503198469, '<p>本文介绍数据库的种类。</p>\r<!--more-->\r\r<p>按照早起的数据库理论，比较流行的数据库模型有三种，分别为层次式数据库、网络式数据库和关系型数据库。</p>\r\r<p>而在当今的互联网中，最常用的数据库模型主要是两种，即关系型数据库和非关系型数据库。</p>\r\r<p>我们不是写教科书，更不是研究数据库理论，因此，我们主要讲解关系型数据库和非关系型数据库NoSQL这两类最重要的也是目前实际使用最多的数据库种类。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(347, '非关系型数据库种类', '347', 1500904620, 1503198439, '<p>本文介绍非关系型数据库的分类。</p>\r<!--more-->\r\r<p><strong>（1）健值存储数据库</strong></p>\r\r<p>健值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据，因为使用key主键访问，所以会获得很高的性能及扩展性。</p>\r\r<p>健值（key-value）数据库主要是使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。key-value模型对于IT系统来说的优势在于简单、易部署、高并发。</p>\r\r<p>典型产品：Memcached、Redis、MemcacheDB、BerkeleyDB</p>\r\r<p><strong>（2）列存储（Column-oriented）数据库</strong></p>\r\r<p>列存储数据库将数据存储在列族（column-family）中，一个列族存储经常被一起查询的相关数据。举个例子，如果我们有一个Person类，我们通常会一起查询他们的姓名和年龄而不是薪资。这种情况下，姓名和年龄就会被放入一个列族中，而薪资则在另一个列族中。</p>\r\r<p>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。</p>\r\r<p>典型产品：Cassandra，HBase</p>\r\r<p><strong>（3）面向文档（Document-Oriented）数据库</strong></p>\r\r<p>文档性数据库的灵感是来自于Lotus-Notes办公软件的，而且它同第一种健值存储相类似。该类型的数据模型是版本话的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是健值数据库的升级版，允许之间嵌套健值。而且文档型数据库比健值数据库的查询效率更高。</p>\r\r<p>面向文档数据库会将数据以文档的形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名词与相应的值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或者JSONB等多种形式存储。</p>\r\r<p>典型产品：MongoDB、CouchDB</p>\r\r<p><strong>（4）图形（Graph）数据库</strong></p>\r\r<p>图形数据库允许我们将数据以图的方式存储。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve-Jobs、Apple和Next，则会有两个&ldquo;Founded bv&rdquo;的边将Apple和Next连接到Steve-Jobs。</p>\r\r<p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言（SQL），因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。</p>\r\r<p>典型产品：Neo4J、InfoGrid</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(348, '关系型数据库介绍', '348', 1500908760, 1503198460, '<p>本文介绍关系型数据库，从关系型数据库的由来说起。</p>\r<!--more-->\r\r<p><strong>（1）关系型数据库由来</strong></p>\r\r<p>碎岩网状数据库和层次数据库已经很好地解决了数据的集中和共享问题，但是在数据独立性和抽象级别上仍有很大欠缺。用户在对这两种数据库进行存取时，仍然需要明确数据的存储结构，指出存取路径。而关系型数据库就可以较好地解决这些问题。</p>\r\r<p><strong>（2）关系型数据库介绍</strong></p>\r\r<p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据的管理。</p>\r\r<p>关系型数据库诞生距今已有40多年了，从理论产生发展到现实产品，例如：大家最常见的MySQL和Oracle数据库，Oracle在数据库领域里上升到了霸主地位，形成每年高达数百亿美金的庞大产业市场，而MySQL也是不容忽视的数据库，以至于被Oracle重金收购了。</p>\r\r<p><strong>（3）关系型数据库表格之间的关系举例</strong></p>\r\r<p>Access、Excel或者PowerBuilder</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/07/3266322497.png" style="width: 215px; height: 130px;" /><img alt="" src="http://www.oliver.ren/usr/uploads/2017/07/921242697.png" /><img alt="" src="http://www.oliver.ren/usr/uploads/2017/07/835865192.png" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(349, 'table01.png', 'table01-png', 1500909006, 1500909006, 'a:5:{s:4:"name";s:11:"table01.png";s:4:"path";s:35:"/usr/uploads/2017/07/3266322497.png";s:4:"size";i:15362;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 348, 0),
(350, 'table02.png', 'table02-png', 1500909007, 1500909007, 'a:5:{s:4:"name";s:11:"table02.png";s:4:"path";s:34:"/usr/uploads/2017/07/921242697.png";s:4:"size";i:20756;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 348, 0),
(351, 'table03.png', 'table03-png', 1500909007, 1500909007, 'a:5:{s:4:"name";s:11:"table03.png";s:4:"path";s:34:"/usr/uploads/2017/07/835865192.png";s:4:"size";i:16699;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 348, 0),
(353, '非关系型数据库诞生背景', '353', 1500910380, 1503198454, '<p>本文介绍非关系型数据库诞生的背景，非关系型数据库也被称为NoSQL数据库。</p>\r<!--more-->\r\r<p>NoSQL的本意是&ldquo;Not Only SQL&rdquo;，指的是非关系型数据库，而不是&ldquo;No SQL&rdquo;的意思（没有SQL语句？），因此，NoSQL的产生并不是要彻底地否定关系型数据库，而是作为传统关系型数据库的一个有效的补充。NoSQL数据库在特定的场景下可以发挥出难以想象的高效率和高性能。</p>\r\r<p>随着互联网web2.0网站的兴起，传统的关系型数据库在应付web2.0网站，特别是对于规模日益扩大的海量数据，超大规模和高并发的微博、微信、SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如：传统的关系型数据库IO瓶颈、性能瓶颈都难以有效突破，于是开始出现了大批针对特定场景，以高性能和使用便利为目的功能特异化的数据库产品，NoSQL（非关系型）类的数据库就是在这样的情景中诞生并得到了非常迅速的发展。</p>\r\r<p>NoSQL是非关系型数据库的广义定义。它打破了长久以来关系型数据库与ACID理论大统一的局面。NoSQL数据存储不需要固定的表结构，通常也不存在连接操作。在大数据存取上具备关系型数据库无法比拟的性能优势。该术语（NoSQL）在2009年初得到了广泛认同。</p>\r\r<p>当今的应用体系结构需要数据存储在横向伸缩性上能够满足需求。而NoSQL存储就是为了实现这个需求而诞生的。Google的Bigtable与Amazon的Dynamo是非常成功的商业NoSQL实现。一些开源的NoSQL体系，如Facebook的Cassandra，Apache的HBase，也得到了广泛认同，Redis，mongoDB也逐渐的越来越受到各类大中小型公司的欢迎和追捧。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(354, '常用关系型数据库产品介绍', '354', 1500999120, 1503198447, '<p>本文介绍几种常用的关系型数据库产品。</p>\r<!--more-->\r\r<p><strong>Oracle数据库</strong></p>\r\r<p>Oracle前身叫SDL，由Larry Ellison和另两个编程人员在1977创办，他们开发了自己的拳头产品，在市场上大量销售，1979年，Oracle公司引入了第一个商用SQL关系数据库管理系统，Oracle公司是最早开发关系型数据库的厂商之一，其产品支持最广泛的操作系统平台。目前Oracle关系数据库产品的市场占有率数一数二。</p>\r\r<p>Oracle公司是目前全球最大的数据库软件公司，也是近年业务增长极为迅速的软件提供与服务商。</p>\r\r<p>2007年7月12日，甲骨文公司在美国纽约宣布推出数据库Oracle 11g，这是Oracle数据库的最新版本。Oracle介绍说，Oracle 11g有400多项功能，经过了1500万个小时的测试，开发工作量达到了3.6万人/月。Oracle 11g在安全，XML DB，备份等方面得到了很大提升。</p>\r\r<p>主要应用范围：传统大企业，大公司，政府，金融，证券等等。</p>\r\r<p>版本升级：Oracle 8i，Oracle 9i，Oracle 10g，Oracle 11g，Oracle 12c</p>\r\r<p><strong>MySQL数据库</strong></p>\r\r<p>MySQL数据库是一个中小型的关系型数据库管理系统，软件开发者为瑞典MySQL AB公司。在2008年1月16号被Sun公司收购。</p>\r\r<p>目前MySQL被广泛地应用在Internet上的大中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源代码这一特点，许多大中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库，甚至国内知名的淘宝网也选择弃用了Oracle而更换为更开放的MySQL。</p>\r\r<p>MySQL数据库主要应用范围：互联网领域，大中小型网站，游戏公司，电商平台等等。</p>\r\r<p><strong>MariaDB数据库</strong></p>\r\r<p>MariaDB数据库管理系统是MySQL数据库的一个分支，主要由开源社区维护，采用GPL授权许可。开发这个MariaDB数据库分支的可能原因之一是：Oracle收购了MySQL后，有将MySQL闭源的潜在风险，因此MySQL开源社区采用分支的方式来避开这个风险。</p>\r\r<p>开发MariaDB数据库的目的是完全兼容MySQL数据库，包括API和命令行，使之能轻松的称为MySQL的替代品。在存储引擎方面，使用XtraDB来代替MySQL的InnoDB。MariaDB由MySQL的创始人Michael Widenius主导开发，他是前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了Sun，此后，随着Sun被Oracle收购，MySQL的所有权也落入Oracle的手中。MariaDB数据库的名称来自MySQL的创始人Michael Widenius的女儿Maria的名字。</p>\r\r<p>MariaDB基于事务的Maria存储引擎，替换了MySQL的MyISAM存储引擎，它使用了Percona的XtraDB（InNoDB的变体）。这个版本还包括了PrimeBase XT（PBXT）和FederatedX存储引擎。</p>\r\r<p>MariaDB数据库直到5.5版本，均依照MySQL的版本发行。因此，使用MariaDB 5.5的人会从MySQL 5.5中了解到MariaDB的所有功能。</p>\r\r<p><strong>SQL Server数据库</strong></p>\r\r<p>Microsoft SQL Server是微软公司开发的大型关系型数据库系统。SQL Server的功能比较全面，效率高，可以作为中型企业或单位的数据库平台。SQL Server可以与Windows操作系统紧密集成，无论是应用程序开发速度还是系统事务处理运行速度，都能得到较大的提升。对于在Windows平台上开发的各种企业级信息管理系统来说，无论是C/S（客户机/服务器）架构还是B/S（浏览器/服务器）架构，SQL Server都是一个很好的选择。SQL Server的缺点是只能在Windows系统下运行。</p>\r\r<p>1987年，微软和IBM合作开发完成OS/2，IBM在其销售的OS/2 ExtendedEdition系统中绑定了OS/2 Database Manager，而微软产品线中尚缺少数据库产品。为此，微软将目光投向Sybase，同Sybase签订了合作协议，使用Sybase的技术开发基于OS/2平台的关系型数据库。1989年，微软发布了SQL Server 1.0版本。Microsoft在与Sybase分道扬镳后，随后在其6.05和7.0版本中重写了核心数据库系统，如今SQL Server 2016已经发布。</p>\r\r<p>主要应用范围：部分企业电商（央视购物），使用Windows服务器平台的企业。</p>\r\r<p><strong>Access数据库</strong></p>\r\r<p>美国Microsoft公司与1994年推出的微机数据库管理系统。它具有界面友好、易学易用、开发简单、接口灵活等特点，是典型的新一代桌面关系型数据库管理系统。它结合了Microsoft Jet Database Engine和图形用户界面两项特点，是Microsoft Office的成员之一。</p>\r\r<p>Access能够存取Access/Jet、Microsoft SQL Server、Oracle，或者任何ODBC兼容数据库的资料。Access界面友好而且易学易用，作为Office套件的一部分，可以与Office集成，实现无缝连接Access提供了表（Table）、查询（Query）、窗体（Form）、报表（Report）、宏（Macro）、模块（Module）等用来建立数据库系统的对象。提供了多种向导、生成器、模板，把数据存储、数据查询、界面设计、报表生成等操作规范化。</p>\r\r<p>Access是入门级小型桌面数据库，性能安全性都很一般。可供个人管理或小型网站之用。Access不是数据库语言，只是一个数据库程序。目前最新版本为Office 2016。其主要特点如下：</p>\r\r<p>（1）完善地管理各种数据库对象，具有强大的数据组织、用户管理、安全检查等功能；<br />\r（2）强大的数据处理功能，在一个工作组级别的网络环境中，使用Access开发的多用户数据库管理系统具有传统的XBASE（DBASE、FoxBASE的统称）数据库系统所无法实现的客户服务器（Client/Server）结构和相应的数据库安全机制，Access具备了许多先进的大型数据库管理系统所具备的特征，如事务处理/出错回滚能力等。<br />\r（3）可以方便地生成各种数据对象，利用存储的数据建立窗体和报表，可视性好。<br />\r（4）作为Office套件的一部分，可以与Office集成，实现无缝连接。<br />\r（5）能够利用Web检索和发布数据，实现与Internet的连接。Access主要适用于中小型应用系统，或作为客户机/服务器系统中的客户端数据库。</p>\r\r<p>早期应用领域：小型程序系统asp+access系统，留言板，校友录等。</p>\r\r<p><strong>其他不常用关系型数据库</strong></p>\r\r<p>DB2，PostgreSQL，Informix，Sybase等。这些关系型数据库逐步的淡出了普通运维的视线，特别是互联网公司几乎见不到，因此我们这里就不介绍了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97),
(356, '常用非关系型数据库产品介绍', '356', 1501084260, 1503198427, '<p>本文介绍几种常用的非关系型数据库产品。</p>\r<!--more-->\r\r<p><strong>Memcached(key-value)</strong></p>\r\r<p>Memcached是一个开源的、高性能的、具有分布式内存对象的缓存系统。通过它可以减轻数据库负载，加速动态的Web应用，最初版本由LiveJournal的Brad Fitzpatrick在2003年开发完成。目前全球有非常多的用户都在使用它来构建自己的大负载网站或提高自己的高访问网站的响应速度。注意：Memcache是这个项目的名称，而Memcached是服务器端的主程序文件名。</p>\r\r<p>缓存一般用来保存一些经常被存取的对象或数据（例如，浏览器会把经常访问的网页缓存起来），通过缓存来存取对象或数据要比在磁盘上存取快很多，前者是内存，后者是磁盘。Memcached是一种纯内存缓存系统，把经常存取的对象或数据缓存在memcached的内存中，这些被缓存的数据被程序通过API的方式存取，Memcached里面的数据就像一张巨大的HASH表，数据以key-value对的方式存在。Memcached通过缓存经常被存取的对象或数据，从而减轻频繁读取数据库的压力，提高网站的响应速度，构建出速度更快的可扩展的Web应用。</p>\r\r<p>由于Memcached为纯内存缓存软件，一旦重启所有数据都会丢失，因此，新浪网基于Memcached开发了一个开源项目Memcached。通过为Memcached增加Berkeley DB的持久化存储机制和异步主辅复制机制，是Memcached具备了事务恢复能力、持久化数据存储能力和分布式复制能力，Memcached非常适合需要超高性能读写速度、持久化保存的应用场景，但是最近几年逐渐被其他的持久化产品替代，例如，Redis。</p>\r\r<p><strong>redis(key-value)</strong></p>\r\r<p>和Memcached类似，redis也是一个key-value型存储系统。但redis支持的存储value类型相对更多，包括string（字符串）、list（链表）、set（集合）和zset（有序集合）等。这些数据类型都支持push/pop、add/remove及取交集、并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与Memcached一样，为了保证效率，redis的数据都是缓存在内存中。区别是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>\r\r<p>redis是一个高性能的key-value数据库。redis的出现，很大程度补偿了Memcached这类key-value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。</p>\r\r<p>redis的特点：</p>\r\r<p>1.支持内存缓存，这个功能相当于Memcached；<br />\r2.支持持久化，这个功能相当于MemcachedDB，ttserver；<br />\r3.数据类型更丰富，比其他key-value库功能更强；<br />\r4.支持集群，分布式；<br />\r5.支持队列等特殊功能。</p>\r\r<p>应用：缓存从存取Memcached更改存取redis。</p>\r\r<p><strong>MongoDB(Document-oriented)</strong></p>\r\r<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是费关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，类似json的bjson格式，因此可以存储比较复杂的数据类型。MongoDB最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它的特点是高性能、易部署、易使用，存储数据非常方便。</p>\r\r<p>主要功能特性：</p>\r\r<p>1.面向集合存储，易存储对象类型的数据<br />\r&ldquo;面向集合&rdquo;（Collenction&mdash;Oriented），意思是数据被分组存储在数据集中，被称为一个集合（Collection）。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限书目的文档。集合的概念类似关系型数据库（RDBMS）里的表（table），不同的是它不需要定义任何模式（schema）。<br />\r2.模式自由<br />\r模式自由（schema-free），意味着对于存储在MongoDB数据库中的文件，我们不需要知道它的任何结构定义。如果需要，你完全可以把不同结构的问阿金存储在同一个数据库里。<br />\r3.支持动态查询<br />\r4.支持完全索引，包含内部对象<br />\r5.支持查询<br />\r6.支持复制和故障恢复<br />\r7.使用高效的二进制数据存储，包括大型对象（如视频等）<br />\r8.自动处理碎片，以支持云计算层次的扩展性<br />\r9.支持Ruby，Python，Java，C++，PHP等多种语言<br />\r10.文件存储格式为BSON（一种JSON的扩展）<br />\rBSON（Binary Serizlized Document Format）存储形式是指：存储在集合中的文档，被存储为key-value对的形式。键用唯一标识一个文档，为字符串类型，而值则可以是各种复杂的文件类型。<br />\r11.可通过网络访问</p>\r\r<p>MongoDB服务端可运行在Linux、Windows或OS X平台，支持32位或64位应用，默认端口为27017.推荐运行在64位平台。</p>\r\r<p>MongoDB把数据存储在文件中（默认路径为：/data/db），为提高效率使用内存映射文件进行管理。</p>\r\r<p><strong>Cassandra(Column-Oriented)</strong></p>\r\r<p>Apache Cassandra是一套开源分布式key-value存储系统。它最初由Facebook开发，用于存储特别大的数据。Facebook目前在使用此系统。</p>\r\r<p>主要特性：</p>\r\r<p>1.分布式；<br />\r2.基于column的结构化；<br />\r3.高伸展性。</p>\r\r<p>Cassandra的主要特点就是它不是一个数据库，而是由一堆数据库节点共同构成的一个分布式网络服务，对Cassandra的一个写操作，会被复制到其他节点上去，对Cassandra的读操作，也会被路由到某个节点上面去读取。对于一个Cassandra集群来说，扩展性能是比较简单的事情，只管在集群里面添加节点就可以了。</p>\r\r<p>Cassandra是一个混合型的非关系的数据库，类似于Google的BigTable。其主要功能比Dynomite（分布式的key-value存储系统）更丰富，Cassandra最初由Facebook开发，后转变成了开源项目。它是一个网络社交云计算方面理想的数据库。以Amazon专有的完全分布式的Dynamo为基础，结合了Google BigTable基于列族（Column Family）的数据模型。P2P去中心化的存储。很多方面都可以称之为Dynamo 2.0。</p>\r\r<p><strong>其他不常用非关系型数据库</strong></p>\r\r<p>HBase，MemcachedDB，BerkeleyDB，Tokyo Cabinet\\Tokyo Tyrant(ttserver)</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 189),
(394, 'MySQL存储引擎简介', '394', 1505808060, 1506166169, '<p>本文简单介绍下MySQL的存储引擎。</p>\r<!--more-->\r\r<p>在讲清楚什么是存储引擎之前，我们先来个比喻，我们都知道录制一个视频文件，可以转成不同的格式如mp4,avi,wmv等，而存在我们电脑的磁盘上也会存在不同类型的文件系统中，如windows里面常见的ntfs,fat32，存在Linux里常见的ext3,ext4,nfs。但是，给我们用户看到实际视频内容都是一样的。直观区别是，占用系统的空间大小与清晰程度可能不一样。</p>\r\r<p>那么，数据库表里的数据存储在数据库里及磁盘上和上述的视频格式以及存储磁盘文件系统格式特征类似，也有很多存储方式。</p>\r\r<p>但是，对于用户和应用程序来说同样一张表的数据，无论用什么引擎来存储，用户看到的数据都是一样的。不同的引擎存储，引擎功能，占用的空间大小，读取性能等可能有区别。</p>\r\r<p>MySQL最常用存储引擎为：MyISAM和InnoDB。</p>\r\r<p>全文索引：目前5.5版本，MyISAM和InnoDB都已经支持。</p>\r\r<p>MySQL提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。</p>\r\r<p>在MySQL中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p>\r\r<p>MySQL 5.5支持的存储引擎有：InnoDB, MyISAM, Memory, Merge, Archive, Federated, CSV, BLACKHOLE等。可以使用SHOW ENGINES语句来查看系统所支持的引擎类型。</p>\r\r<p>Support列的值表示某种引擎是否能使用：YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认存储引擎。</p>\r\r<p>&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(357, 'Tengine的session_sticky模块实现基于cookie的会话保持', '357', 1501144187, 1501144187, '<p>本文介绍Tengine的session_sticky模块实现基于cookie的会话保持。</p>\r\r<!--more-->\r\r<p>最近部署基于nginx反向代理实现负载均衡的项目，发现新的nginx已经支持基于cookie的负载均衡和健康检查，功能上已经非常强大，感觉不逊于haproxy。</p>\r\r<p>我在实际环境的中使用的是taobao的Tengine，下面的内容主要来之Tengine官方文档。</p>\r\r<p>该模块是一个负载均衡模块，通过cookie实现客户端与后端服务器的会话保持, 在一定条件下可以保证同一个客户端访问的都是同一个后端服务器。</p>\r\r<p>Example 1</p>\r\r<pre class="brush:bash;">\r# 默认配置：cookie=route mode=insert fallback=on\rupstream foo {\r   server 192.168.0.1;\r   server 192.168.0.2;\r   session_sticky;\r}\r\rserver {\r    location / {\r        proxy_pass http://foo;\r    }\r}</pre>\r\r<p>Example 2</p>\r\r<pre class="brush:bash;">\r#insert + indirect模式：\rupstream test {\r  session_sticky cookie=uid domain=www.xxx.com fallback=on path=/ mode=insert option=indirect;\r  server  127.0.0.1:8080;\r}\r\rserver {\r  location / {\r    #在insert + indirect模式或者prefix模式下需要配置session_sticky_hide_cookie\r    #这种模式不会将保持会话使用的cookie传给后端服务，让保持会话的cookie对后端透明\r    session_sticky_hide_cookie upstream=test;\r    proxy_pass http://test;\r  }\r}</pre>\r\r<p>指令</p>\r\r<pre class="brush:bash;">\r语法：session_sticky [cookie=name] [domain=your_domain] [path=your_path] [maxage=time] [mode=insert|rewrite|prefix] [option=indirect] [maxidle=time] [maxlife=time] [fallback=on|off] [hash=plain|md5]\r默认值：session_sticky cookie=route mode=insert fallback=on\r上下文：upstream</pre>\r\r<p>说明</p>\r\r<pre class="brush:bash;">\r本指令可以打开会话保持的功能，下面是具体的参数：\r&bull;	cookie设置用来记录会话的cookie名称\r&bull;	domain设置cookie作用的域名，默认不设置\r&bull;	path设置cookie作用的URL路径，默认不设置\r&bull;	maxage设置cookie的生存期，默认不设置，即为session cookie，浏览器关闭即失效\r&bull;	mode设置cookie的模式:\ro	insert: 在回复中本模块通过Set-Cookie头直接插入相应名称的cookie。\ro	prefix: 不会生成新的cookie，但会在响应的cookie值前面加上特定的前缀，当浏览器带着这个有特定标识的cookie再次请求时，模块在传给后端服务前先删除加入的前缀，后端服务拿到的还是原来的cookie值，这些动作对后端透明。如：&quot;Cookie: NAME=SRV~VALUE&quot;。\ro	rewrite: 使用服务端标识覆盖后端设置的用于session sticky的cookie。如果后端服务在响应头中没有设置该cookie，则认为该请求不需要进行session sticky，使用这种模式，后端服务可以控制哪些请求需要sesstion sticky，哪些请求不需要。\r&bull;	option 设置用于session sticky的cookie的选项，可设置成indirect或direct。indirect不会将session sticky的cookie传送给后端服务，该cookie对后端应用完全透明。direct则与indirect相反。\r&bull;	maxidle设置session cookie的最长空闲的超时时间\r&bull;	maxlife设置session cookie的最长生存期\r&bull;	fallback设置是否重试其他机器，当sticky的后端机器挂了以后，是否需要尝试其他机器\r&bull;	hash设置cookie中server标识是用明文还是使用md5值，默认使用md5\r语法: session_sticky_hide_cookie upstream=name;\r默认值: none\r上下文： server, location\r说明：配合proxy_pass指令使用。用于在insert+indirect模式和prefix模式下删除请求用于session sticky的cookie，这样就不会将该cookie传递给后端服务。upstream表示需要进行操作的upstream名称。</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 180),
(358, '负载均衡中的四层负载和七层负载', '358', 1501144380, 1502168405, '<p>文介绍负载均衡中的四层负载和七层负载。</p>\r<!--more-->\r\r<p><strong>负载均衡简介</strong></p>\r\r<p>负载均衡，英文名称为LoadBalance，其意思就是将负载(工作任务)进行平衡，分摊到多个操作单元上进行执行(例如Web服务器、FTP服务器等)，实现多个服务器共同完成工作任务的目标。负载均衡建立在现有网络结构之上，它提升了服务器的性能、提高了带宽利用率，增强了网络的灵活性和可靠性。经过十年的发展，负载均衡已经成为网络应用的重要设备，甚至成为大型网络应用的核心设备，与基础路由、交换设备市场并驾齐驱。</p>\r\r<p><strong>四层负载均衡和七层负载均衡</strong></p>\r\r<p>四层负载均衡像银行自助排号机，七层负载均衡像银行大堂经理。</p>\r\r<p>四层负载均衡指的是负载均衡设备通过报文中的目标IP地址和端口负载均衡算法，选择到达目的的内部服务器;七层负载均衡，也被称为&ldquo;内容交换&rdquo;，指的是负载均衡设备通过报文中的应用层信息(URL、HTTP头部等信息)和负载均衡算法，选择到达目的的内部服务器。</p>\r\r<p>二者的区别可以举个例子形象的说明：四层负载均衡就像银行的自助排号机，每一个达到银行的客户根据排号机的顺序，选择对应的窗口接受服务;而七层负载均衡像银行大堂经理，先确认客户需要办理的业务，再安排排号。这样办理理财、存取款等业务的客户，会根据银行内部资源得到统一协调处理，加快客户业务办理流程。</p>\r\r<p>七层应用负载的好处是使得整个网络更&ldquo;智能化&rdquo;。例如，在网站的运行中，用户可以通过七层的方式，将图片类的请求通过缓存技术传输到特定的图片服务器，将对文字类的请求通过压缩技术传输到特定的文字服务器。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意方式的修改，极大提升了应用系统在网络层的灵活性。很多在后台(例如Nginx或者Apache)上部署的功能可以前移到负载均衡设备上(例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入，静态资源与动态资源的分离等)。</p>\r\r<p>另外一个常常被提到功能就是安全性。在网络中常见的SYN Flood攻击中，黑客会控制众多客户端(肉鸡)，使用虚假IP地址对同一目标发动SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(DoS)的目的。从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上;而在七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤SQL Injection等应用层面的特定攻击手段，进一步提高系统整体安全。</p>\r\r<p>国内负载均衡技术缺少根本性突破 &ldquo;浑水摸鱼&rdquo;伪七层负载均衡或将逐步减少，聊到这里，大家应该都明白四层负载均衡和七层负载均衡的区别了。</p>\r\r<p>七层负载均衡技术对产品的性能、算法、高可靠性和安全性有着更高的要求。而导致这种技术的差异性，更多的体现在厂商对负载均衡专有平台的开发上，具体可以概括为以下四点。</p>\r\r<p>第一、七层负载的应用以HTTP协议为主，四层负载的应用以TCP为主，通过测试仪可以看出，七层负载的吞吐性能要比四层负载的吞吐性能低。七层吞吐性能严重考验着负载均衡厂商们，如果不解决这个核心问题，负载均衡设备就会成为网络的瓶颈，严重影响网络的稳定性。<br />\r第二、七层负载算法需要识别URL、Cookie和HTTP head等信息，算法计算程度更丰富，对CPU的负载要求更高，这就需要更高性能的产品。虽然目前硬件平台已经发展到多核，但是国内厂商在多核平台的应用开发上存在着较大差距，严重制约负载均衡设备多核之间计算能力的协调分配和使用。<br />\r第三、七层负载的可靠性体现在两个方面：一方面是保证服务器访问的完整性和连续性，这主要体现在七层负载均衡的会话保持技术，通过HTTP Cookie、HTTP SessionID、HTTP ServerID、HTTP 自定义头域和SSL SessionID等方式实现。另一方面是保证网络的稳定性，网络的稳定性主要通过设备关键部件的冗余设计，以及双机、集群部署方式实现。<br />\r第四、七层负载的安全性同样至关重要，因为目前负载均衡已经成为网络的核心组件，成为服务器业务连续性、完整性、可靠性的保护神。七层负载均衡的安全性需要从两个方面体现：一是系统本身的安全性，软件系统应采用自主研发，无系统漏洞和后门;二是可以提供必要的网络安全防护，减少服务器被直接攻击的威胁，这样可以减少服务器区设备串联堆叠带来的单点故障。</p>\r\r<p><strong>总结</strong></p>\r\r<p>从以上几点可以看出，七层负载均衡有着严格的定义，优势也非常明显。但是，从市场份额来看，七层负载均衡设备还是以国外厂商占据主导地位，国内能够进行自主研发的只有太一星晨等少数的几家厂商。而且，国内负载均衡厂商应用场景以链路负载为主，难以进入占据负载均衡市场70%份额、主导负载均衡技术发展的服务器负载均衡市场，更缺乏在大型数据中心及大型门户网站使用案例。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(359, 'keepalived的工作原理', '359', 1501223040, 1501223717, '<p>本文介绍keepalived的工作原理。</p>\r<!--more-->\r\r<p>keepalived高可用对之间是通过VRRP通信的，因此，从VRRP讲起：</p>\r\r<p>1.VRRP，全称Vritual-Router-Redundancy-Protocol，中文名为虚拟路由冗余协议，VRRP的出现时为了解决静态路由的单点故障；<br />\r2.VRRP是通过一种竞选协议机制来将路由任务交某台VRRP路由器的；<br />\r3.VRRP用IP多播的方式（默认多播地址224.0.0.18）实现高可用对之间通信；<br />\r4.工作时主节点发包，备节点接包，当备节点接收不到主节点发的数据包的时候，就启动接管程序接管主节点的资源。备节点可以有多个，通过优先级竞选，但一般keepalived系统运维工作中都是一对；<br />\r5.VRRP使用了加密协议加密数据，但keepalived官方目前还是推荐用明文的方式配置认证类型和密码。</p>\r\r<p>介绍完了VRRP，接下来再介绍一下keepalived服务的工作原理：</p>\r\r<p>keepalived高可用对之间是通过VRRP进行通信的，VRRP是通过竞选机制来确定主备的，主的优先级高于备的，因此，工作时主会优先获得所有的资源，备节点处于等待状态，当主挂了的时候，备节点就会接管主节点的资源，然后顶替主节点对外提供服务。</p>\r\r<p>在keepalived服务对之间，只有作为主的服务器会一直发送VRRP广播包，告诉备它还活着，此时备不会抢占主，当主不可用时，即备监听不到主发送的广播包时，就会启动相关服务接管资源，保证业务的连续性。接管速度最快可以小于1秒。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(360, '数据库发展历史大事记', '360', 1501252140, 1503198413, '<p>本文介绍数据发展的几个历史大事记。</p>\r<!--more-->\r\r<p>1951年 Univac系统使用磁带和穿孔卡片作为数据存储<br />\r1956年 IBM公司在其Model 305 RAMAC中第一次引入了磁盘驱动器<br />\r1961年&nbsp;通用电气（GE）公司的Charles Bachman开发了第一个数据库管理系统IDS<br />\r1969年 E.F.Codd发明了关系数据库<br />\r1973年 由John J.Cullinane领导Cullinane公司开发了针对IBM主机的基于网络模型的数据库IDMS<br />\r1976年 Honeywell公司推出了第一个商用关系数据库产品Multics Relational Data Store<br />\r1979年 Oracle公司引入了第一个商用SQL关系数据库管理系统<br />\r1983年 IBM推出了DB2数据库产品<br />\r1985年 为Procter&amp;Gamble系统设计的第一个上午智能系统产生<br />\r1991年 W.H.Bill Inmon发表了&ldquo;构建数据仓库&rdquo;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 173),
(361, 'MySQL数据库介绍', '361', 1501254180, 1503198405, '<p>本文简单的介绍下MySQL数据库。</p>\r<!--more-->\r\r<p>MySQL数据库是一款深受欢迎的开源领域的重要的关系型数据库产品，由瑞典MySQL AB公司开发与维护，2006年，MySQL AB公司被SUN公司收购，并做了很多改进，2008年，SUN公司又被数据库龙头公司甲骨文（Oracle公司）收购。因此，MySQL数据库目前属于Oracle公司，成为传统数据库领域老大的又一个数据库产品，甲骨文公司收购MySQL后，使得自身在商业数据库和开源数据库领域市场占有份额都跃居第一的位置，这样的格局，引起了业内很多的人士的担忧，这种担忧直接导致后来的MySQL分支数据库MariaDB的诞生与发展。</p>\r\r<p>前面已经介绍过，MySQL属于传统关系型数据库产品，它的开放式的架构使得用户选择性很强，同时社区开发与维护人数众多，其功能比较稳定，性能卓越，且在遵守GPL协议的前提下，可以免费使用与修改，也为MySQL的推广与使用带来了更多利好。在MySQL成长与发展过程中，支持的功能逐渐增多，性能也在不断提高，对平台的支持也越来越多。</p>\r\r<p>MySQL是一种关系型数据库管理系统，关系型数据库的特点是将数据保存在不同的表中，再讲这些表放入不同的数据库中，而不是将所有数据统一放在一个大仓库里，这样的设计增加了MySQL的读取速度，灵活性可管理性也得到了很大提高。访问以及管理MySQL数据库的最常用标准化语言为SQL结构化查询语言。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 83),
(362, 'MariaDB数据库诞生背景', '362', 1501254900, 1503198396, '<p>本文介绍MariaDB数据库诞生背景。</p>\r<!--more-->\r\r<p>自从甲骨文公司收购了MySQL数据库产品后，引起了很多业界人士担忧，因为商业数据库的老大有可能将MySQL闭源的潜在风险，为了避免Oracle将MySQL闭源，而无开源的类MySQL数据库可用，MySQL社区采用分支的方式来避开这个风险。因此MariaDB数据库就这样诞生了，MariaDB是一个向后兼容、可能在以后替代MySQL的数据库的一个不错的新的数据库产品，但是还是建议大家使用更稳当使用更广泛的MySQL数据库，MariaDB数据库可以先测试，等产品应用人员做多一些，社区更活跃后再考虑使用为好。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 121),
(402, 'MySQL事务隔离级别详解', '402', 1507768380, 1507799896, '<p>本文介绍MySQL的4种事务隔离级别。</p>\r<!--more-->\r\r<p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>\r\r<p><strong>Read Uncommitted（读取未提交内容）</strong></p>\r\r<p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>\r\r<p><strong>Read Committed（读取提交内容）</strong></p>\r\r<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>\r\r<p><strong>Repeatable Read（可重读）</strong></p>\r\r<p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的&ldquo;幻影&rdquo; 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>\r\r<p><strong>Serializable（可串行化）&nbsp;</strong></p>\r\r<p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>\r\r<p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p>\r\r<p><strong>脏读(Drity Read)</strong>：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>\r\r<p><strong>不可重复读(Non-repeatable read)</strong>:在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>\r\r<p><strong>幻读(Phantom Read)</strong>:在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>\r\r<p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/10/804665256.jpg" style="width: 600px; height: 191px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 140),
(410, '《淘宝技术这十年》PDF完整版下载', '410', 1508673060, 1526793371, '<p>本文分享一本关于阿里发家史的书&mdash;&mdash;《淘宝技术这十年》。</p>\r<!--more-->\r\r<p>第0章 引言：光棍节的狂欢<br />\r第1章 个人网站<br />\rLAMP架构的网站<br />\r武侠和倒立文化的起源<br />\r第2章 个人网站的升级<br />\r数据库从mySQL到Oracle<br />\r支付手段的创新&mdash;&mdash;支付宝<br />\r交流方式的创新&mdash;&mdash;淘宝旺旺<br />\r第3章 企业级Java网站<br />\r脱胎换骨<br />\r脱胎换骨的升级&mdash;&mdash;更换开发语言<br />\r坚若磐石&mdash;&mdash;围绕性能、容量和成本的进化<br />\r第4章 创造技术<br />\r淘宝文件系统&mdash;&mdash;TFS<br />\r淘宝KV缓存系统&mdash;&mdash;Tair<br />\r第5章 分布式***商务操作系统<br />\r服务化<br />\r中间件<br />\r高性能服务框架HSF<br />\r消息中间件Notify<br />\r分布式数据访问层TDDL<br />\rSession框架<br />\r开放平台<br />\r第6章 我在淘宝这八年<br />\r第7章 牛P列传<br />\r正明&mdash;&mdash;集团核心系统高级研究员<br />\r正祥&mdash;&mdash;淘宝高级研究员，OceanBase项目负责人<br />\r毕玄&mdash;&mdash;集团核心系统***技术专家<br />\r放翁&mdash;&mdash;淘宝开放平台项目负责人<br />\r吴翰清&mdash;&mdash;阿里云集团信息安全中心高级安全专家<br />\r云铮&mdash;&mdash;数据平台与产品部***技术专家<br />\r小马&mdash;&mdash;淘宝UED前端通用平台高级技术专家<br />\r淘宝传奇工程师多隆的程序世界</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1pK75yg7" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 169),
(411, '《MYSQL 5.5从零开始学》PDF完整版下载', '411', 1509000000, 1526793354, '<p>本文分享一本书&mdash;&mdash;《MYSQL 5.5从零开始学》。</p>\r<!--more-->\r\r<p>第1章 初识mysql<br />\r1.1 数据库基础<br />\r1.2 数据库技术构成<br />\r1.3 什么是mysql<br />\r1.4 mysol工具<br />\r1.5 如何学习mysql<br />\r第2章 mysql的安装与配置<br />\r2.1 windows*下安装与配置mysql5.5<br />\r2.2 启动服务并登录mysql数据库<br />\r2.3 更改mysql的配置<br />\r2.4 mysql常用图形管理工具<br />\r2.5 linux*下安装与配置mysql5.5<br />\r2.6 专家点拨<br />\r2.7 经典习题<br />\r第3章 数据库的基本操作<br />\r3.1 创建数据库<br />\r3.2 删除数据库<br />\r3.3 数据库存储引擎<br />\r3.4 综合案例&mdash;&mdash;数据库的创建和删隙：<br />\r3.5 专家点拨<br />\r3.6 经典习题<br />\r第4章 数据表的基本操作<br />\r4.1 创建数据表<br />\r4.2 查看数据表结构<br />\r4.3 修改数据表<br />\r4.4 删除数据表<br />\r4.5 综合案例&mdash;&mdash;数据表的基本操作<br />\r4.6 专家点拨<br />\r4.7 经典习题<br />\r第5章 数据类型和运算符<br />\r5.1 mysql数据类型介绍<br />\r5.2 如何选择数据类型<br />\r5.3 常见运算符介绍<br />\r5.4 综合案例&mdash;&mdash;运算符的使用<br />\r5.5 专家点拨<br />\r5.6 经典习题<br />\r第6章 mysql函数<br />\r6.1 mysql函数简介<br />\r6.2 数学函数<br />\r6.3 字符串函数<br />\r6.4 日期和时间函数<br />\r6.5 条件判断函数<br />\r6.6 系统信息函数<br />\r6.7 加密函数<br />\r6.8 其他函数<br />\r6.9 综合案例&mdash;&mdash;mysqi函数的使用<br />\r6.10 专家点拨<br />\r6.11 经典习题<br />\r第7章 查询数据<br />\r7.1 基本查询语句<br />\r7.2 单表查询<br />\r7.3 使用集合函数查询<br />\r7.4 连接查询<br />\r7.5 子查询<br />\r7.6 合并查询结果<br />\r7.7 为表和字段取别名<br />\r7.8 使用正则表达式查询<br />\r7.9 综合案例&mdash;&mdash;数据表查询操作<br />\r7.10 专家点拨<br />\r7.11 经典习题<br />\r第8章 插入、更新与删除数据<br />\r8.1 插入数据<br />\r8.2 更新数据<br />\r8.3 删除数据<br />\r8.4 综合案例&mdash;&mdash;记录的插入、更新和删除<br />\r8.5 专家点拨<br />\r8.6 经典习题<br />\r第9章 索引<br />\r9.1 索引简介<br />\r9.2 创建索引<br />\r9.3 删除索引<br />\r9.4 综合案例&mdash;&mdash;创建索引<br />\r9.5 专家点拨<br />\r9.6 经典习题<br />\r第10章 存储过程和函数<br />\r10.1 创建存储过程和函数<br />\r10.2 调用存储过程和函数<br />\r10.3 查看存储过程和函数<br />\r10.4 修改存储过程和函数<br />\r10.5 删除存储过程和函数<br />\r10.6 综合案例&mdash;&mdash;创建存储过程和函数<br />\r10.7 专家点拨<br />\r10.8 经典习题<br />\r第11章 视图<br />\r11.1 视图概述<br />\r11.2 创建视图<br />\r11.3 查看视图<br />\r11.4 修改视图<br />\r11.5 更新视图<br />\r11.6 删除视图<br />\r11.7 综合案例&mdash;&mdash;视图应用<br />\r11.8 专家点拨<br />\r11.9 经典习题<br />\r第12章 mysql函数<br />\r12.1 创建触发器<br />\r12.2 查看触发器<br />\r12.3 触发器的使用<br />\r12.4 删除触发器<br />\r12.5 综合案例&mdash;&mdash;触发器使用<br />\r12.6 专家点拨<br />\r12.7 经典习题<br />\r第13章 mysql用户管理<br />\r13.1 权限表<br />\r13.2 账户管理<br />\r13.3 权限管理<br />\r13.4 访问控制<br />\r13.5 综合案例&mdash;&mdash;综合管理用户权限<br />\r13.6 专家点拨<br />\r13.7 经典习题<br />\r第14章 数据备份与还原<br />\r14.1 数据备份<br />\r14.2 数据还原<br />\r14.3 数据库迁移<br />\r14.4 表的导出和导入<br />\r14.5 综合案例&mdash;&mdash;数据的备份与恢复<br />\r14.6 专家点拨<br />\r14.7 经典习题<br />\r第15章 mysql日志<br />\r15.1 日志简介<br />\r15.2 进制日志<br />\r15.3 错误日志<br />\r15.4 通用查询日志<br />\r15.5 慢查询日志<br />\r15.6 综合案例&mdash;&mdash;mysql日志的综合管理<br />\r15.7 专家点拨<br />\r15.8 经典习题<br />\r第16章 性能优化<br />\r16.1 优化简介<br />\r16.2 优化查询<br />\r16.3 优化数据库结构<br />\r16.4 优化mysql服务器<br />\r16.5 综合案例&mdash;&mdash;全面优化mysql服务器<br />\r16.6 专家点拨<br />\r16.7 经典习题</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1i5zk6iD" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 225),
(364, '为什么选择MySQL数据库', '364', 1501379520, 1503198388, '<p>本文主要介绍MySQL的优势。</p>\r<!--more-->\r\r<p>毫无疑问，既成事实，绝大多数的使用Linux操作系统的大中小型互联网网站都在使用MySQL作为其后端的数据库存储，从大型的BAT门户，到电商平台，分类门户等无语例外都使用MySQL作为其后端的数据库存储。那么，MySQL数据库到底有哪些优势和特点，让大家义无反顾的选择它呢？</p>\r\r<p>原因可能有以下几点：</p>\r\r<p>1.MySQL性能卓越，服务稳定，很少出现异常宕机；<br />\r2.MySQL开放源代码且无版权制约，自主性及使用成本低；<br />\r3.MySQL历史悠久，社区及用户非常活跃，遇到问题，可以寻求帮助；<br />\r4.MySQL软件体积小，安装使用简单，并且易于维护，安装及维护成本低；<br />\r5.MySQL品牌口碑效应，使得企业无需考虑就直接用之，LAMP，LEMP流行架构；<br />\r6.MySQL支持多种操作系统，提供多种API接口，支持多种开发语言，特别对流行的PHP语言有很好的支持。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 124),
(365, 'MySQL数据库商业版发布介绍', '365', 1501380660, 1503198380, '<p>本文主要介绍下MySQL的商业版，MySQL共分为两个版本&mdash;&mdash;商业版和社区版。</p>\r<!--more-->\r\r<p>MySQL商业版是由MySQL AB公司内部专门的人员负责开发及维护，但同时也会吸纳社区人员编写的优秀代码及算法，并且由专门的人员严格按照软件测试流程对这些采纳的代码进行严格测试，没有问题再进行发布。简单地说，MySQL商业版是由MySQL公司内部发布，同时参考社区版的先进代码功能和算法，是MySQL公司的赢利产品。需要付费才能使用及提供服务支持，稳定性和可靠性无疑都是最好的，当然了，企业腰包得足够鼓才能买的起。据了解到的信息，某知名分类门户网站早期就购买过MySQL商业版，价格不比那些闭源的商业数据库便宜，也是大几十万，好贵的说。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(368, 'MySQL数据库四种发布版本介绍', '368', 1501592820, 1503198359, '<p>本文主要介绍MySQL数据库的四种发布版本。</p>\r<!--more-->\r\r<p>在前面已经阐述过，MySQL的版本发布采用双授权政策，即分为社区版和商业版，而这两个版本又各自分四个版本依次发布：Alpha版、Beta版，RC版和GA版。</p>\r\r<p>这四种发布版本之间的说明及区别，如下：<br />\r1.Alpha版<br />\rAlpha版一般只在开发的公司内部运行，不对外公开。主要是开发者自己对产品进行测试，检查产品是否存在缺陷、错误，验证产品功能与说明书、用户手册是否一致。MySQL是属于开放源代码的开源产品，因此需要世界各地开发者、爱好者和用户参与软件的开发、测试和手册编写等工作。所以会对外公布此版本的源码和产品，方便任何人可以参与开发或测试工作，甚至编写与修改用户手册。<br />\r2.Beta版<br />\rBeta版一般是完成功能的开发和所有的测试工作之后的产品，不会存在较大的功能或性能BUG，并且邀请或提供给用户体验与测试，以便更全面地测试软件的不足之处或存在的问题。<br />\r3.RC版<br />\rRC版属于生产环境发布之前的一个小版本或称候选版，是根据Beta版本测试结果，收集到的BUG或缺陷之处等收集到的信息，进行修改和完善之后的一版产品。<br />\r4.GA版<br />\rGA版是软件产品正式发布的版本，也称生产版本的产品。一版情况下，企业的生产环境都会选择GA版本的MySQL软件，用于真实的生产环境中。偶尔有个别大型企业会追求新功能驱动而牺牲稳定性使用其他版本，但这是个例。</p>\r\r<p>MySQL四种发布版本选择说明：</p>\r\r<p>MySQL AB官方网站会把五种数据库版本都提供下载，主要是MySQL数据库属于开放源代码的数据库产品，鼓励全球的技术爱好者参与研发、测试、文档编写和经验分享，甚至包括产品发展规划，对于Development版本、Alpha版本和Beta版本是绝对不允许使用在任何生产环境的，肯定是存在重大的问题或功能未完全实现。绝大多数情况下RC版本也是不允许使用在生产环境，毕竟这是一个GA版本之前，也即生产版本发布之前的一个小版本。另外，对MySQL数据库GA版本，也是需要慎重选择，开源社区产品毕竟不是经过严格的测试工序完成的产品，是全球开源技术人员的资源完成的，会存在比商业产品稳定性弱的缺陷。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(366, 'MySQL数据库社区版发布介绍', '366', 1501428300, 1503198373, '<p>本文主要介绍MySQL数据库的社区版。</p>\r<!--more-->\r\r<p>MySQL社区版是由在世界各地的MySQL开发者、爱好者以及用户参与开发与测试，并完成软件代码的管理、测试工作，社区也会设立BUG汇报机制，收集用户使用遇到BUG问题情况，相比商业版，社区版的开发及测试环境没有那么严格。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(367, 'MySQ数据库商业版与社区版区别', '367', 1501428780, 1503198367, '<p>本文主要解释MySQL数据库商业版与社区版之间的区别。</p>\r<!--more-->\r\r<p>MySQL商业版与社区版之间的区别在于：</p>\r\r<p>1.商业版本组织管理与测试环节控制更严格，稳定性方面会比社区版本更稳定；<br />\r2.MySQL是成熟产品，商业版与社区版之间性能方面相差不大；<br />\r3.商业版不遵守GPL协议，社区版遵守GPL协议可以免费使用；<br />\r4.使用商业版后可以购买相关的服务，享受7*24小时技术支持以及定时打补丁等服务，但是用户必须为此支付服务费用；<br />\r5.社区版本的维护服务只能靠社区提供，无法像商业版本获得故障及补丁解决服务了。但是，使用社区版是完全免费的方式，社区版的服务质量与时效性等方面就无法与MySQL AB公司提供的服务相比了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(401, 'transaction.jpg', 'transaction', 1507768319, 1507799878, 'a:8:{s:4:"name";s:40:"af5b9c1e-4517-3df2-ad62-af25d1672d12.jpg";s:4:"path";s:34:"/usr/uploads/2017/10/804665256.jpg";s:4:"size";i:61703;s:4:"type";s:3:"jpg";s:4:"mime";s:10:"image/jpeg";s:7:"isImage";b:1;s:3:"url";s:55:"http://www.oliver.ren/usr/uploads/2017/10/804665256.jpg";s:11:"description";N;}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 402, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(369, '《细说PHP》PDF完整版下载', '369', 1501593540, 1528760051, '<p>本文分析一本很好的PHP入门书籍&mdash;&mdash;《细说PHP》。</p>\r<!--more-->\r\r<p>第1部分 web开发入门篇<br />\r第1章 lamp网站构建<br />\r1.1 介绍网站给你认识<br />\r1.1.1 web应用的优势<br />\r1.1.2 web 2.0时代的互联网<br />\r1.1.3 web开发标准<br />\r1.1.4 认识脚本语言<br />\r1.1.5 了解http协议<br />\r1.2 动态网站开发所需的web构件<br />\r1.2.1 客户端浏览器<br />\r1.2.2 超文本标记语言html<br />\r1.2.3 层叠样式表css<br />\r1.2.4 客户端脚本编程语言javascript<br />\r1.2.5 web服务器<br />\r1.2.6 服务器端编程语言第1部分 web开发入门篇<br />\r第1章 lamp网站构建<br />\r1.1 介绍网站给你认识<br />\r1.1.1 web应用的优势<br />\r1.1.2 web 2.0时代的互联网<br />\r1.1.3 web开发标准<br />\r1.1.4 认识脚本语言<br />\r1.1.5 了解http协议<br />\r1.2 动态网站开发所需的web构件<br />\r1.2.1 客户端浏览器<br />\r1.2.2 超文本标记语言html<br />\r1.2.3 层叠样式表css<br />\r1.2.4 客户端脚本编程语言javascript<br />\r1.2.5 web服务器<br />\r1.2.6 服务器端编程语言<br />\r1.2.7 数据库管理系统<br />\r1.3 几种主流的web应用程序平台<br />\r1.3.1 web应用程序开发平台对比分析<br />\r1.3.2 动态网站开发平台技术比较<br />\r1.4 web的工作原理<br />\r1.4.1 情景1：服务器不带应用程序服务器和数据库<br />\r1.4.2 情景2：带应用程序服务器的web服务器<br />\r1.4.3 情景3：浏览器访问服务器端的数据库<br />\r1.5 lamp网站开发组合概述<br />\r1.5.1 linux操作系统<br />\r1.5.2 web服务器apache<br />\r1.5.3 mysql数据库管理系统<br />\r1.5.4 php后台脚本编程语言<br />\r1.5.5 lamp发展趋势<br />\r1.6 学php需要学习什么内容<br />\r1.6.1 学php之前的准备<br />\r1.6.2 学php时需要了解或掌握的内容<br />\r1.6.3 优秀的web程序员是怎样练成的<br />\r1.7 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r第2章 html的设计与应用<br />\r2.1 网页制作概述<br />\r2.1.1 html基础<br />\r2.1.2 简单html实例制作<br />\r2.2 html语言的语法<br />\r2.2.1 html标签和元素<br />\r2.2.2 html语法不区分字母大小写<br />\r2.2.3 html标签属性<br />\r2.2.4 html颜色值的设置<br />\r2.2.5 html文档注释<br />\r2.2.6 html代码格式<br />\r2.2.7 html字符实体<br />\r2.3 html文件的主体结构<br />\r2.4 html文档头部元素[head]<br />\r2.4.1 [title]元素<br />\r2.4.2 [base]元素<br />\r2.4.3 [link]元素<br />\r2.4.4 [meta]元素<br />\r2.5 html文档主体标记<br />\r2.6 文字版面的编辑<br />\r2.6.1 格式标签<br />\r2.6.2 文本标签<br />\r2.7 创建图像和链接<br />\r2.7.1 插入图片<br />\r2.7.2 建立锚点和超链接<br />\r2.8 使用html表格<br />\r2.9 html框架结构<br />\r2.10 html表单设计<br />\r2.11 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r本章的学习建议<br />\r第3章 层叠样式表css<br />\r3.1 css简介<br />\r3.2 css规则的组成<br />\r3.2.1 css注释<br />\r3.2.2 长度单位<br />\r3.2.3 颜色单位和url值<br />\r3.3 在html文档中放置css的几种方式<br />\r3.3.1 内联样式表<br />\r3.3.2 嵌入一个样式表<br />\r3.3.3 连接到一个外部的样式表<br />\r3.4 css选择器<br />\r3.4.1 html选择器<br />\r3.4.2 类选择器<br />\r3.4.3 id选择器<br />\r3.4.4 关联选择器<br />\r3.4.5 组合选择器<br />\r3.4.6 伪元素选择器<br />\r3.5 css常见的样式属性和值<br />\r3.5.1 字体属性<br />\r3.5.2 颜色属性<br />\r3.5.3 背景属性<br />\r3.5.4 文本属性<br />\r3.5.5 边框属性<br />\r3.5.6 鼠标光标属性<br />\r3.5.7 列表属性<br />\r3.5.8 综合示例<br />\r3.6 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r本章的学习建议<br />\r第4章 div+css网页标准化布局<br />\r4.1 div+css对页面布局的优势<br />\r4.2 &ldquo;无意义&rdquo;的html元素div和span<br />\r4.3 w3c盒子模型<br />\r4.4 和页面布局有关的css属性<br />\r4.5 盒子区块框的定位<br />\r4.5.1 相对定位<br />\r4.5.2 绝对定位<br />\r4.6 使用盒子模型的浮动布局<br />\r4.6.1 设置浮动<br />\r4.6.2 行框和清理<br />\r4.7 div+css的兼容性问题<br />\r4.7.1 不同浏览器解释盒子模型的差异<br />\r4.7.2 设置浏览器去遵循w3c标准<br />\r4.8 使用盒子模型设计页面布局<br />\r4.8.1 居中设计<br />\r4.8.2 设置两列浮动的布局<br />\r4.8.3 设置三列浮动的布局<br />\r4.8.4 设置多列浮动的布局<br />\r4.9 div+css网站首页面布局实例<br />\r4.9.1 html文件的设计<br />\r4.9.2 css文件设计<br />\r4.10 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r本章的学习建议<br />\r第2部分 php基础篇<br />\r第5章 从搭建你的php开发环境开始<br />\r5.1 几种常见的php环境安装方式<br />\r5.1.1 linux系统下源代码包方式安装环境<br />\r5.1.2 在windows系统上安装web工作环境<br />\r5.1.3 搭建学习型的php工作环境<br />\r5.2 环境安装对操作系统的选择<br />\r5.2.1 选择网站运营的操作系统<br />\r5.2.2 选择网站开发的操作系统<br />\r5.3 安装集成php开发环境<br />\r5.3.1 安装前准备<br />\r5.3.2 安装步骤<br />\r5.3.3 环境测试<br />\r5.4 phpmyadmin的配置与应用<br />\r5.4.1 http身份验证模式<br />\r5.4.2 cookie身份验证模式<br />\r5.4.3 config身份验证模式<br />\r5.5 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第6章 php的基本语法<br />\r6.1 php在web开发中的应用<br />\r6.1.1 就从认识php开始吧<br />\r6.1.2 php都能做什么<br />\r6.2 第一个php脚本程序<br />\r6.3 php语言标记<br />\r6.3.1 将php代码嵌入html中的位置<br />\r6.3.2 解读开始和结束标记<br />\r6.4 指令分隔符&ldquo;分号&rdquo;<br />\r6.5 程序注释<br />\r6.6 在程序中使用空白的处理<br />\r6.7 变量<br />\r6.7.1 变量的声明<br />\r6.7.2 变量的命名<br />\r6.7.3 可变变量<br />\r6.7.4 变量的引用赋值<br />\r6.8 变量的类型<br />\r6.8.1 类型介绍<br />\r6.8.2 布尔型（boolean）<br />\r6.8.3 整型（integer）<br />\r6.8.4 浮点型（float或double）<br />\r6.8.5 字符串（string）<br />\r6.8.6 数组（array）<br />\r6.8.7 对象（object）<br />\r6.8.8 资源类型（resource）<br />\r6.8.9 null类型<br />\r6.8.10 伪类型介绍<br />\r6.9 数据类型之间相互转换<br />\r6.9.1 自动类型转换<br />\r6.9.2 强制类型转换<br />\r6.9.3 类型转换细节<br />\r6.9.4 变量类型的测试函数<br />\r6.10 常量<br />\r6.10.1 常量的定义和使用<br />\r6.10.2 常量和变量<br />\r6.10.3 系统中的预定义常量<br />\r6.10.4 php中的魔术常量<br />\r6.11 php中的运算符<br />\r6.11.1 算术运算符<br />\r6.11.2 字符串运算符<br />\r6.11.3 赋值运算符<br />\r6.11.4 比较运算符<br />\r6.11.5 逻辑运算符<br />\r6.11.6 位运算符<br />\r6.11.7 其他运算符<br />\r6.11.8 运算符的优先级<br />\r6.12 表达式<br />\r6.13 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第7章 php的流程控制结构<br />\r7.1 分支结构<br />\r7.1.1 单一条件分支结构（if）<br />\r7.1.2 双向条件分支结构（else从句）<br />\r7.1.3 多向条件分支结构（elseif子句）<br />\r7.1.4 多向条件分支结构（switch语句）<br />\r7.1.5 巢状条件分支结构<br />\r7.1.6 条件分支结构实例应用（简单计算器）<br />\r7.2 循环结构<br />\r7.2.1 while语句<br />\r7.2.2 do.while循环<br />\r7.2.3 for语句<br />\r7.3 特殊的流程控制语句<br />\r7.3.1 break语句<br />\r7.3.2 continue语句<br />\r7.3.3 exit语句<br />\r7.4 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r第8章 php的函数应用<br />\r8.1 函数的定义<br />\r8.2 自定义函数<br />\r8.2.1 函数的声明<br />\r8.2.2 函数的调用<br />\r8.2.3 函数的参数<br />\r8.2.4 函数的返回值<br />\r8.3 函数的工作原理和结构化编程<br />\r8.4 php变量的范围<br />\r8.4.1 局部变量<br />\r8.4.2 全局变量<br />\r8.4.3 静态变量<br />\r8.5 声明及应用各种形式的php函数<br />\r8.5.1 常规参数的函数<br />\r8.5.2 伪类型参数的函数<br />\r8.5.3 引用参数的函数<br />\r8.5.4 默认参数的函数<br />\r8.5.5 可变个数参数的函数<br />\r8.5.6 回调函数<br />\r8.6 递归函数<br />\r8.7 使用自定义函数库<br />\r8.8 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第9章 php中的数组与数据结构<br />\r9.1 数组的分类<br />\r9.2 数组的定义<br />\r9.2.1 直接赋值的方式声明数组<br />\r9.2.2 使用array()语言结构新建数组<br />\r9.2.3 多维数组的声明<br />\r9.3 数组的遍历<br />\r9.3.1 使用for语句循环遍历数组<br />\r9.3.2 使用foreach语句遍历数组<br />\r9.3.3 联合使用list( )、each( )和while循环遍历数组<br />\r9.3.4 使用数组的内部指针控制函数遍历数组<br />\r9.4 预定义数组<br />\r9.4.1 服务器变量：$_server<br />\r9.4.2 环境变量：$_env<br />\r9.4.3 url get变量：$_get<br />\r9.4.4 http post变量：$_post<br />\r9.4.5 request变量：$_request<br />\r9.4.6 http文件上传变量：$_files<br />\r9.4.7 http cookies：$_cookie<br />\r9.4.8 session变量：$_session<br />\r9.4.9 global变量：$globals<br />\r9.5 数组的相关处理函数<br />\r9.5.1 数组的键/值操作函数<br />\r9.5.2 统计数组元素的个数和唯一性<br />\r9.5.3 使用回调函数处理数组的函数<br />\r9.5.4 数组的排序函数<br />\r9.5.5 拆分、合并、分解和接合数组<br />\r9.5.6 数组与数据结构<br />\r9.5.7 其他有用的数组处理函数<br />\r9.6 操作php数组需要注意的一些细节<br />\r9.6.1 数组运算符号<br />\r9.6.2 删除数组中的元素操作<br />\r9.6.3 关于数组下标的注意事项<br />\r9.7 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第10章 php面向对象的程序设计<br />\r10.1 面向对象的介绍<br />\r10.1.1 类和对象之间的关系<br />\r10.1.2 面向对象的程序设计<br />\r10.2 如何抽象一个类<br />\r10.2.1 类的声明<br />\r10.2.2 成员属性<br />\r10.2.3 成员方法<br />\r10.3 通过类实例化对象<br />\r10.3.1 实例化对象<br />\r10.3.2 对象类型在内存中的分配<br />\r10.3.3 对象中成员的访问<br />\r10.3.4 特殊的对象引用&ldquo;$this&rdquo;<br />\r10.3.5 构造方法与析构方法<br />\r10.4 封装性<br />\r10.4.1 设置私有成员<br />\r10.4.2 私有成员的访问<br />\r10.4.3 __set()、__get()、__isset()和__unset()四个方法<br />\r10.5 继承性<br />\r10.5.1 类继承的应用<br />\r10.5.2 访问类型控制<br />\r10.5.3 子类中重载父类的方法<br />\r10.6 常见的关键字和魔术方法<br />\r10.6.1 final关键字的应用<br />\r10.6.2 static关键字的使用<br />\r10.6.3 单态设计模式<br />\r10.6.4 const关键字<br />\r10.6.5 instanceof关键字<br />\r10.6.6 克隆对象<br />\r10.6.7 类中通用的方法__tostring()<br />\r10.6.8 __call()方法的应用<br />\r10.6.9 自动加载类<br />\r10.6.10 对象串行化<br />\r10.7 抽象类与接口<br />\r10.7.1 抽象类<br />\r10.7.2 接口技术<br />\r10.8 多态性的应用<br />\r10.9 面向对象版图形计算器<br />\r10.9.1 需求分析<br />\r10.9.2 功能设计及实现<br />\r10.9.3 类的组织架构<br />\r10.10 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第11章 字符串处理<br />\r11.1 字符串的处理介绍<br />\r11.1.1 字符串的处理方式<br />\r11.1.2 字符串类型的特点<br />\r11.1.3 双引号中变量解析总结<br />\r11.2 常用的字符串输出函数<br />\r11.3 常用的字符串格式化函数<br />\r11.3.1 去除空格和字符串填补函数<br />\r11.3.2 字符串大小写的转换<br />\r11.3.3 和html标签相关的字符串格式化<br />\r11.3.4 其他字符串格式化函数<br />\r11.4 字符串比较函数<br />\r11.4.1 按字节顺序进行字符串比较<br />\r11.4.2 按自然排序进行字符串比较<br />\r11.5 小结<br />\r本章必须掌握的知识点<br />\r本章需要拓展的内容<br />\r第12章 正则表达式<br />\r12.1 正则表达式简介<br />\r12.1.1 选择php正则表达式的处理函数库<br />\r12.2 正则表达式的语法规则<br />\r12.2.1 定界符<br />\r12.2.2 原子<br />\r12.2.3 元字符<br />\r12.2.4 模式修正符<br />\r12.3 与perl兼容的正则表达式函数<br />\r12.3.1 字符串的匹配与查找<br />\r12.3.2 字符串的替换<br />\r12.3.3 字符串的分割和连接<br />\r12.4 文章发布操作示例<br />\r12.5 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要扩展的内容<br />\r第3部分 php常用功能模块篇<br />\r第13章 php的错误和异常处理<br />\r13.1 错误处理<br />\r13.1.1 错误报告级别<br />\r13.1.2 调整错误报告级别<br />\r13.1.3 使用trigger_error()函数来替代die()<br />\r13.1.4 自定义错误处理<br />\r13.1.5 写错误日志<br />\r13.2 异常处理<br />\r13.2.1 异常处理实现<br />\r13.2.2 扩展php内置的异常处理类<br />\r13.2.3 捕获多个异常<br />\r13.3 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r第14章 php的日期和时间<br />\r14.1 unix时间戳<br />\r14.1.1 将日期和时间转变成unix时间戳<br />\r14.1.2 日期的计算<br />\r14.2 在php中获取日期和时间<br />\r14.2.1 调用getdate()函数取得日期/时间信息<br />\r14.2.2 日期和时间格式化输出<br />\r14.3 修改php的默认时区<br />\r14.4 使用微秒计算php脚本执行时间<br />\r14.5 日历类<br />\r14.6 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r本章的学习建议<br />\r第15章 文件系统处理<br />\r15.1 文件系统概述<br />\r15.1.1 文件类型<br />\r15.1.2 文件的属性<br />\r15.2 目录的基本操作<br />\r15.2.1 解析目录路径<br />\r15.2.2 遍历目录<br />\r15.2.3 统计目录大小<br />\r15.2.4 建立和删除目录<br />\r15.2.5 复制目录<br />\r15.3 文件的基本操作<br />\r15.3.1 文件的打开与关闭<br />\r15.3.2 写入文件<br />\r15.3.3 读取文件内容<br />\r15.3.4 访问远程文件<br />\r15.3.5 移动文件指针<br />\r15.3.6 文件的锁定机制<br />\r15.3.7 文件的一些基本操作函数<br />\r15.4 文件的上传与下载<br />\r15.4.1 文件上传<br />\r15.4.2 处理多个文件上传<br />\r15.4.3 文件下载<br />\r15.5 设计经典的文件上传类<br />\r15.5.1 需求分析<br />\r15.5.2 程序设计<br />\r15.5.3 文件上传类代码实现<br />\r15.5.4 文件上传类的应用过程<br />\r15.6 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r本章的学习建议<br />\r第16章 php动态图像处理<br />\r16.1 php中gd库的使用<br />\r16.1.1 画布管理<br />\r16.1.2 设置颜色<br />\r16.1.3 生成图像<br />\r16.1.4 绘制图像<br />\r16.1.5 在图像中绘制文字<br />\r16.2 设计经典验证码类<br />\r16.2.1 设计验证码类<br />\r16.2.2 应用验证码类的实例对象<br />\r16.2.3 表单中应用验证码<br />\r16.2.4 实例演示<br />\r16.3 php图片处理<br />\r16.3.1 图片背景管理<br />\r16.3.2 图片缩放<br />\r16.3.3 图片裁剪<br />\r16.3.4 添加图片水印<br />\r16.3.5 图片旋转和翻转<br />\r16.4 设计经典的图像处理类<br />\r16.4.1 需求分析<br />\r16.4.2 程序设计<br />\r16.4.3 图像处理类代码实现<br />\r16.4.4 图像处理类的应用过程<br />\r16.5 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第4部分 数据库开发篇<br />\r第17章 mysql数据库概述<br />\r17.1 数据库的应用<br />\r17.1.1 数据库在web开发中的重要地位<br />\r17.1.2 为什么php会选择mysql作为自己的黄金搭档<br />\r17.1.3 php和mysql的合作方式<br />\r17.1.4 结构化查询语言sql<br />\r17.2 mysql数据库的常见操作<br />\r17.2.1 mysql数据库的连接与关闭<br />\r17.2.2 创建新用户并授权<br />\r17.2.3 创建数据库<br />\r17.2.4 创建数据表<br />\r17.2.5 数据表内容的简单管理<br />\r17.3 小结<br />\r本章必须掌握的知识点<br />\r第18章 mysql数据表的设计<br />\r18.1 数据表（table）<br />\r18.2 数据值和列类型<br />\r18.2.1 数值类的数据列类型<br />\r18.2.2 字符串类数据列类型<br />\r18.2.3 日期和时间型数据列类型<br />\r18.2.4 null值<br />\r18.2.5 类型转换<br />\r18.3 数据字段属性<br />\r18.4 数据表对象管理<br />\r18.4.1 创建表（create table）<br />\r18.4.2 修改表（alter table）<br />\r18.4.3 删除表（drop table）<br />\r18.5 数据表的类型及存储位置<br />\r18.5.1 myisam数据表<br />\r18.5.2 innodb数据表<br />\r18.5.3 如何选择innodb还是myisam表类型<br />\r18.5.4 数据表的储存位置<br />\r18.6 数据表的默认字符集<br />\r18.6.1 字符集<br />\r18.6.2 字符集支持原理<br />\r18.6.3 创建数据对象时修改字符集<br />\r18.7 创建索引<br />\r18.7.1 主键索引（primary key）<br />\r18.7.2 唯一索引（unique）<br />\r18.7.3 常规索引（index）<br />\r18.7.4 全文索引（fulltext）<br />\r18.8 规范化<br />\r18.8.1 起点<br />\r18.8.2 第一范式<br />\r18.8.3 第二范式<br />\r18.8.4 第三范式<br />\r18.8.5 规范化理论<br />\r18.9 数据库的设计技巧<br />\r18.9.1 数据库设计要求<br />\r18.9.2 起名字的技巧<br />\r18.9.3 数据库具体设计工作中的技巧<br />\r18.10 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第19章 sql语句设计<br />\r19.1 操作数据表中的数据记录（dml）<br />\r19.1.1 使用insert语句向数据表中添加数据<br />\r19.1.2 使用update语句更新数据表中已存在的数据<br />\r19.1.3 使用delete语句删除数据表中不需要的数据记录<br />\r19.2 通过dql命令查询数据表中的数据<br />\r19.2.1 选择特定的字段<br />\r19.2.2 使用as子句为字段取别名<br />\r19.2.3 distinct关键字的使用<br />\r19.2.4 在select语句中使用表达式的列<br />\r19.2.5 使用where子句按条件检索<br />\r19.2.6 根据空值（null）确定检索条件<br />\r19.2.7 使用between and进行范围比较<br />\r查询<br />\r19.2.8 使用in进行范围比对查询<br />\r19.2.9 使用like进行模糊查询<br />\r19.2.10 多表查询（连接查询）<br />\r19.2.11 嵌套查询（子查询）<br />\r19.2.12 使用order by对查询结果排序<br />\r19.2.13 使用limit限定结果行数<br />\r19.2.14 使用统计函数<br />\r19.2.15 使用group by对查询结果分组<br />\r19.3 查询优化<br />\r19.4 小结<br />\r本章必须掌握的知识点<br />\r本章需要拓展的内容<br />\r本章的学习建议<br />\r第20章 php访问mysql的扩展函数<br />\r20.1 php访问mysql数据库服务器的流程<br />\r20.2 在php脚本中连接mysql服务器<br />\r20.2.1 在php程序中选择已创建的数据库<br />\r20.2.2 执行sql命令<br />\r20.2.3 在php脚本中处理select查询结果集<br />\r20.3 设计完美分页类<br />\r20.3.1 需求分析<br />\r20.3.2 程序设计<br />\r20.3.3 完美分页类的代码实现<br />\r20.3.4 分页类的应用过程<br />\r20.4 管理books表实例<br />\r20.4.1 需求分析<br />\r20.4.2 程序设计<br />\r20.5 php的mysqli扩展介绍<br />\r20.5.1 启用mysqli扩展模块<br />\r20.5.2 mysqli扩展接口的应用概述<br />\r20.6 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r本章的学习建议<br />\r第21章 数据库抽象层pdo<br />\r21.1 pdo所支持的数据库<br />\r21.2 pdo的安装<br />\r21.3 创建pdo对象<br />\r21.3.1 以多种方式调用构造方法<br />\r21.3.2 pdo对象中的成员方法<br />\r21.4 使用pdo对象<br />\r21.4.1 调整pdo的行为属性<br />\r21.4.2 pdo处理php程序和数据库之间的<br />\r数据类型转换<br />\r21.4.3 pdo的错误处理模式<br />\r21.4.4 使用pdo执行sql语句<br />\r21.5 pdo对预处理语句的支持<br />\r21.5.1 了解pdostatement对象<br />\r21.5.2 准备语句<br />\r21.5.3 绑定参数<br />\r21.5.4 执行准备好的查询<br />\r21.5.5 获取数据<br />\r21.5.6 大数据对象的存取<br />\r21.6 pdo的事务处理<br />\r21.6.1 mysql的事务处理<br />\r21.6.2 构建事务处理的应用程序<br />\r21.7 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第5部分 php开发高级篇<br />\r第22章 memcache管理与应用<br />\r22.1 memcache概述<br />\r22.1.1 初识memcache<br />\r22.1.2 memcache在web中的应用<br />\r22.2 memcached的安装及管理<br />\r22.2.1 linux下安装memcache软件<br />\r22.2.2 windows下安装memcached软件<br />\r22.2.3 memcached服务器的管理<br />\r22.3 使用telnet作为memcached的客户端管理<br />\r22.3.1 连接memcached服务器<br />\r22.3.2 基本的memcached客户端命令<br />\r22.3.3 查看当前memcached服务器的运行状态信息<br />\r22.3.4 数据管理指令<br />\r22.4 php的memcached管理接口<br />\r22.4.1 安装php中的memcache应用程序扩展接口<br />\r22.4.2 memcache应用程序扩展接口<br />\r22.4.3 memcache的实例应用<br />\r22.5 memcached服务器的安全防护<br />\r22.6 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第23章 会话控制<br />\r23.1 为什么要使用会话控制<br />\r23.2 会话跟踪的方式<br />\r23.3 cookie的应用<br />\r23.3.1 cookie概述<br />\r23.3.2 向客户端计算机中设置cookie<br />\r23.3.3 在php脚本中读取cookie的资料内容<br />\r23.3.4 数组形态的cookie应用<br />\r23.3.5 删除cookie<br />\r23.3.6 基于cookie的用户登录模块<br />\r23.4 session的应用<br />\r23.4.1 session概述<br />\r23.4.2 配置session<br />\r23.4.3 session的声明与使用<br />\r23.4.4 注册一个会话变量和读取session<br />\r23.4.5 注销变量与销毁session<br />\r23.4.6 session的自动回收机制<br />\r23.4.7 传递session id<br />\r23.5 一个简单的邮件系统实例<br />\r23.5.1 为邮件系统准备数据<br />\r23.5.2 编码实现邮件系统<br />\r23.5.3 邮件系统执行说明<br />\r23.6 自定义session处理方式<br />\r23.6.1 自定义session的存储机制<br />\r23.6.2 使用数据库处理session信息<br />\r23.6.3 使用memcached处理session信息<br />\r23.7 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第24章 php的模板引擎smarty<br />\r24.1 什么是模板引擎<br />\r24.2 自定义模板引擎<br />\r24.2.1 自定义模板引擎类<br />\r24.2.2 使用自己的模板引擎<br />\r24.2.3 应用自定义模板引擎的示例分析<br />\r24.3 选择smarty模板引擎<br />\r24.4 安装smarty及初始化配置<br />\r24.4.1 安装smarty<br />\r24.4.2 初始化smarty类库的默认设置<br />\r24.4.3 第一个smarty的简单示例<br />\r24.5 smarty的基本应用<br />\r24.5.1 php程序员常用和smarty相关的操作<br />\r24.5.2 模板设计时美工的常用操作<br />\r24.6 smarty模板设计的基本语法<br />\r24.6.1 模板中的注释<br />\r24.6.2 模板中的变量应用<br />\r24.6.3 模板中的函数应用<br />\r24.6.4 忽略smarty解析<br />\r24.7 在smarty模板中的变量应用<br />\r24.7.1 从配置文件中读取变量<br />\r24.7.2 在模板中使用保留变量<br />\r24.8 在smarty模板中的变量调解器<br />\r24.8.1 变量调解器函数的使用方式<br />\r24.8.2 smarty默认提供的变量调解器<br />\r24.8.3 自定义变量调解器插件<br />\r24.9 smarty模板中自定义函数<br />\r24.9.1 为smarty模板扩充函数插件<br />\r24.9.2 为smarty模板扩充块函数插件<br />\r24.10 smarty模板中的内置函数<br />\r24.10.1 变量声明<br />\r24.10.2 流程控制<br />\r24.10.3 声明和调用模板函数<br />\r24.10.4 数组遍历<br />\r24.10.5 smarty提供的其他内置函数<br />\r24.11 smarty的模板继承特性<br />\r24.11.1 使用{extends}函数实现模板继承<br />\r24.11.2 在子模板中覆盖父模板中的部分内容区域<br />\r24.11.3 合并子模板和父模板的{block}标签内容<br />\r24.12 smarty的缓存控制<br />\r24.12.1 在smarty中控制缓存<br />\r24.12.2 每个模板多个缓存<br />\r24.12.3 为缓存实例消除处理开销<br />\r24.12.4 清除缓存<br />\r24.12.5 关闭局部缓存<br />\r24.13 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r本章需要拓展的内容<br />\r第25章 mvc模式与php框架<br />\r25.1 mvc模式在web中的应用<br />\r25.1.1 mvc模式的工作原理<br />\r25.1.2 mvc模式的优缺点<br />\r25.2 php开发框架<br />\r25.2.1 什么是框架<br />\r25.2.2 为什么要用框架<br />\r25.2.3 框架和mvc设计模式的关系<br />\r25.2.4 比较流行的php框架<br />\r25.3 划分模块和操作<br />\r25.3.1 为项目划分模块<br />\r25.3.2 为模块设置操作<br />\r第26章 超轻量级php框架brophp<br />\r26.1 brophp框架概述<br />\r26.1.1 系统特点<br />\r26.1.2 环境要求<br />\r26.1.3 brophp框架源码的目录结构<br />\r26.2 单一入口<br />\r26.2.1 基于brophp框架的单一入口编写规则<br />\r26.3 部署项目应用目录<br />\r26.3.1 项目部署方式<br />\r26.3.2 url访问<br />\r26.4 brophp框架的基本设置<br />\r26.4.1 默认开启<br />\r26.4.2 配置文件<br />\r26.4.3 内置函数<br />\r26.5 声明控制器（control）<br />\r26.5.1 控制器的声明（模块）<br />\r26.5.2 操作的声明<br />\r26.5.3 页面跳转<br />\r26.5.4 重定向<br />\r26.6 设计视图（view）<br />\r26.6.1 视图与控制器之间的交互<br />\r26.6.2 切换模板风格<br />\r26.6.3 模板文件的声明规则<br />\r26.6.4 display()用新用法<br />\r26.6.5 在模板中的几个常用变量应用<br />\r26.6.6 在php程序中定义资源位置<br />\r26.7 应用模型（model）<br />\r26.7.1 brophp数据库操作接口的特性<br />\r26.7.2 切换数据库驱动<br />\r26.7.3 声明和实例化model<br />\r26.7.4 数据库的统一操作接口<br />\r26.8 自动验证<br />\r26.9 缓存设置<br />\r26.9.1 基于memcached缓存设置<br />\r26.9.2 基于smarty的缓存机制<br />\r26.10 调试模式<br />\r26.11 内置扩展类库<br />\r26.11.1 分页类page<br />\r26.11.2 验证码类vcode<br />\r26.11.3 图像处理类image<br />\r26.11.4 文件上传类fileupload<br />\r26.12 自定义功能扩展<br />\r26.12.1 自定义扩展类库<br />\r26.12.2 自定义扩展函数库<br />\r26.13 小结<br />\r本章必须掌握的知识点<br />\r本章需要了解的内容<br />\r第6部分 项目开发篇<br />\r第27章 b/s结构软件开发流程<br />\r27.1 软件开发过程的划分<br />\r27.2 需求开发<br />\r27.2.1 需求分析流程<br />\r27.2.2 需求分析说明<br />\r27.2.3 输出<br />\r27.3 系统设计<br />\r27.3.1 系统设计流程<br />\r27.3.2 系统设计说明<br />\r27.4 编码测试<br />\r27.4.1 编码与测试流程<br />\r27.4.2 编码说明<br />\r27.4.3 结果测试说明<br />\r27.5 试运行<br />\r27.5.1 软件试运行流程<br />\r27.5.2 软件试运行说明<br />\r27.6 实施<br />\r27.6.1 软件实施流程<br />\r27.6.2 软件实施说明<br />\r27.7 验收<br />\r27.7.1 软件验收流程<br />\r27.7.2 软件验收说明<br />\r27.7.3 验收标准<br />\r27.8 服务与维护<br />\r27.8.1 责任人<br />\r27.8.2 收集信息<br />\r27.8.3 维护分析<br />\r27.8.4 软件维护<br />\r27.8.5 改进<br />\r27.8.6 输出<br />\r27.9 项目管理<br />\r27.9.1 软件项目的计划<br />\r27.9.2 软件项目的组织<br />\r27.9.3 项目小组组织形式<br />\r27.10 项目参考<br />\r第28章 需求分析说明书<br />\r28.1 文档介绍<br />\r28.1.1 编写说明<br />\r28.1.2 项目背景<br />\r28.1.3 读者对象<br />\r28.1.4 参考资料<br />\r28.1.5 术语与缩写解释<br />\r28.2 任务概述<br />\r28.2.1 产品的描述<br />\r28.2.2 系统目标<br />\r28.2.3 系统功能结构<br />\r28.2.4 系统流程图<br />\r28.3 业务描述<br />\r28.3.1 后台登录管理<br />\r28.3.2 后台操作界面管理<br />\r28.3.3 常规管理<br />\r28.3.4 公告管理<br />\r28.3.5 友情链接管理<br />\r28.3.6 相册管理<br />\r28.3.7 图片管理<br />\r28.3.8 栏目管理<br />\r28.3.9 文章管理<br />\r28.3.10 幻灯片管理<br />\r28.3.11 用户组管理<br />\r28.3.12 用户管理<br />\r28.3.13 前台首页管理<br />\r28.3.14 栏目列表管理<br />\r28.3.15 文章内容管理<br />\r28.3.16 文章搜索管理<br />\r28.3.17 登录注册管理<br />\r28.3.18 个人空间管理<br />\r28.3.19 消息管理<br />\r28.3.20 动态管理<br />\r28.4 系统运行环境<br />\r28.4.1 硬件环境<br />\r28.4.2 软件环境<br />\r28.5 需求设计评审<br />\r第29章 数据库设计说明书<br />\r29.1 引言<br />\r29.1.1 编写目的<br />\r29.1.2 背景<br />\r29.1.3 定义<br />\r29.1.4 参考资料<br />\r29.2 外部设计<br />\r29.2.1 标识符和状态<br />\r29.2.2 使用它的程序<br />\r29.2.3 约定<br />\r29.2.4 支持软件<br />\r29.3 结构设计<br />\r29.4 逻辑结构设计<br />\r29.4.1 er图向关系模型的转化<br />\r29.4.2 确定关系模式<br />\r29.4.3 消除冗余<br />\r29.5 物理结构设计<br />\r29.5.1 设计数据表结构<br />\r29.5.2 创建数据表<br />\r29.5.3 数据表记录的输入<br />\r29.6 安全保密设计<br />\r29.6.1 完整性<br />\r29.6.2 数据库设计的其他问题<br />\r第30章 程序设计说明书<br />\r30.1 引言<br />\r30.1.1 编写目的<br />\r30.1.2 背景<br />\r30.1.3 定义</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1SnnrupxhfaK4OGoaGQIUVA" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 255),
(371, '《人月神话》PDF完整版下载', '371', 1501639740, 1528759934, '<p>本文分享一本软件管理行业的圣经&mdash;&mdash;《人月神话》。</p>\r<!--more-->\r\r<p>第1章 焦油坑<br />\r编程系统产品<br />\r职业的乐趣<br />\r职业的苦恼<br />\r第2章 人月神话<br />\r乐观主义<br />\r人月<br />\r系统测试<br />\r空泛的估算<br />\r重复产生的进度灾难<br />\r第3章 外科手术队伍<br />\r问题<br />\rMills的建议<br />\r如何运作<br />\r团队的扩建<br />\r第4章 贵族专制、民主政治和系统设计<br />\r概念的完整性<br />\r获得概念的完整性<br />\r贵族专制统治和民主政治<br />\r在等待时，实现人员应该做什么<br />\r第5章 画蛇添足<br />\r结构师的交互准则和机制<br />\r自律-- 开发第二个系统所带来的后果<br />\r第6章 贯彻执行<br />\r文档化的规格说明-- 手册<br />\r形式化定义<br />\r直接整合<br />\r会议和大会<br />\r多重实现<br />\r电话日志<br />\r产品测试<br />\r第7章 为什么巴比伦塔会失败<br />\r巴比伦塔的管理教训<br />\r大型编程项目中的交流<br />\r项目工作手册<br />\r大型编程项目的组织架构<br />\r第8章 胸有成竹<br />\rPortman的数据<br />\rAron的数据<br />\rHarr的数据<br />\rOS/360的数据<br />\rCorbat&oacute;的数据<br />\r第9章 削足适履<br />\r作为成本的程序空间<br />\r规模控制<br />\r空间技能<br />\r数据的表现形式是编程的根本<br />\r第10章 提纲挈领<br />\r计算机产品的文档<br />\r大学科系的文档<br />\r软件项目的文档<br />\r为什么要有正式的文档<br />\r第11章 未雨绸缪<br />\r试验性工厂和增大规模<br />\r不变的就是变化本身<br />\r为变更设计系统<br />\r为变更计划组织架构<br />\r前进两步，后退一步<br />\r前进一步，后退一步<br />\r第12章 干将莫邪<br />\r目标机器<br />\r辅助机器和数据服务<br />\r高级语言和交互式编程<br />\r第13章 整体部分<br />\r剔除bug的设计<br />\r构件单元调试<br />\r系统集成调试<br />\r第14章 祸起萧墙<br />\r里程碑还是沉重的负担<br />\r&quot;其他的部分反正会落后&quot;<br />\r地毯的下面<br />\r第15章 另外一面<br />\r需要什么样的文档<br />\r流程图<br />\r自文档化的程序<br />\r第16章 没有银弹<br />\r摘要<br />\r介绍<br />\r根本困难<br />\r以往解决次要困难的一些突破<br />\r银弹的希望<br />\r针对概念上根本问题的颇具前途的方法<br />\r第17章 再论&quot;没有银弹&quot;<br />\r人狼和其他恐怖传说<br />\r存在着银弹-- 就在这里<br />\r含糊的表达将会导致误解<br />\rHarel的分析<br />\rJones的观点-- 质量带来生产率<br />\r那么，生产率的情形如何<br />\r面向对象编程-- 这颗铜质子弹可以吗<br />\r重用的情况怎样<br />\r学习大量的词汇-- 对软件重用的一个可预见但还没有被预言的问题<br />\r子弹的本质-- 形势没有发生改变<br />\r第18章 《人月神话》的观点：是与非<br />\r第1章 焦油坑<br />\r第2章 人月神话<br />\r第3章 外科手术队伍<br />\r第4章 贵族专制、民主政治和系统设计<br />\r第5章 画蛇添足<br />\r第6章 贯彻执行<br />\r第7章 为什么巴比伦塔会失败<br />\r第8章 胸有成竹<br />\r第9章 削足适履<br />\r第10章 提纲挈领<br />\r第11章 未雨绸缪<br />\r第12章 干将莫邪<br />\r第13章 整体部分<br />\r第14章 祸起萧墙<br />\r第15章 另外一面<br />\r第1版结束语<br />\r第19章 20年后的《人月神话》<br />\r为什么要出版20周年纪念版本<br />\r核心观点-- 概念完整性和结构师<br />\r开发第二个系统所引起的后果-- 盲目的功能和频率猜测<br />\r图形界面的成功<br />\r没有构建舍弃原型-- 瀑布模型是错误的<br />\r增量开发模型更佳-- 渐进地精化<br />\r关于信息隐藏，Parnas是正确的，我是错误的<br />\r人月到底有多少神话色彩？Boehm的模型和数据<br />\r人就是一切(或者说，几乎是一切)<br />\r放弃权力的力量<br />\r最令人惊讶的新事物是什么？数百万的计算机<br />\r全新的软件产业-- 塑料薄膜包装的成品软件<br />\r买来开发-- 使用塑料包装的成品软件包作为构件<br />\r软件工程的状态和未来<br />\r结束语：令人向往、激动人心和充满乐趣的50年<br />\r注解与参考文献<br />\r附录：人月落地实战体验<br />\r一、名家谈人月<br />\r1. 年金<br />\r2. 《人月神话》与实践<br />\r3. Frank Chance评人月<br />\r4. 软件尚方宝剑(Silver Bullet)何在<br />\r二、名著评人月<br />\r三、读者感言<br />\r1. 读书有感--人月神话<br />\r2. 我这几天很烦(产品概念完整性)<br />\r3. 关于我们的思考--&quot;项目开发&quot;及读《人月神话》有感<br />\r4. 我的&quot;人月神话&quot;<br />\r5. 《人月神话》软玉生香</p>\r\r<p>下载地址：<a href="https://wenjianmeile.com" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 159),
(372, 'MySQL产品路线变更历史背景', '372', 1501682400, 1503198352, '<p>本文介绍MySQL产品线变更的历史背景。</p>\r<!--more-->\r\r<p>早期，MySQL也是遵循版本号逐渐增加的方式发展，格式：mysql-X.XX.XX.tar.gz。例如，DBA老手们都非常熟悉的生产场景版本：4.1.7、5.0.56等。</p>\r\r<p>近几年，为了提高MySQL产品的竞争优势、以及提高性能、降低开发维护成本等原因，同时，更方便企业用户更精准的选择适合的版本产品用于自己的企业生产环境中，MySQL在发展到5.1系列版本之后，重新规划为三条产品线。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 118),
(373, 'MySQL第一条产品路线——5.0.xx到5.1.xx产品线', '373', 1501683720, 1503198346, '<p>本文介绍MySQL的第一条产品路线。</p>\r<!--more-->\r\r<p>第一条产品线：5.0.xx及升级到5.1.xx的产品系列，这条产品线继续完善与改进用户体验和性能，同时增加新功能，这条路线可以说是MySQL早期产品的延续系列，这一系列的产品发布情况及历史版本如下：</p>\r\r<p>MySQL 5.1是当前稳定（产品质量）发布系列。只针对严重漏洞修复和安全修复重新发布；没有增加会影响该系列的重要功能。<br />\r*MySQL 5.1：Previous stable（production-quality） release</p>\r\r<p>MySQL 5.0是前一稳定（产品质量）发布系列。只针对严重漏洞修复和安全修复重新发布；没有增加会影响该系列的重要功能。<br />\r*MySQL 5.0：Older stable release nearing the end of the product lifecycle</p>\r\r<p>MySQL 4.0和3.23是旧的稳定（产品质量）发布系列。该版本不再使用，新的发布只用来修复特别严重的漏洞（以前的安全问题）。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(374, 'MySQL第二条产品路线——5.4.xx开始到5.7.xx产品线', '374', 1501683840, 1503198339, '<p>本文介绍MySQL的第二条产品路线。</p>\r<!--more-->\r\r<p>第二条产品线：为了更好地整合MySQL AB公司社区和第三方公司开发的新存储引擎，以及吸收新的实现算法等，从而更好地支持SMP架构，提高性能而做了大量的代码重构。版本编号为从5.4.xx开始，目前发展到了5.6.xx。<br />\r*MySQL 5.5：Latest General Availability Production release</p>\r\r<p>目前主流的互联网公司都用MySQL 5.5。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 125),
(375, 'MySQL第三条产品路线——6.0.xx到5.7.xx产品线系列介绍', '375', 1501683900, 1503198332, '<p>本文介绍MySQL的第三条产品路线。</p>\r<!--more-->\r\r<p>第三条产品线：为了更好地推广MySQL Cluster版本，以及提高MySQL Cluster的性能和稳定性，以及功能改进和增加，以及改动MySQL基础功能，使其对Cluster存储引擎提供更有效的支持与优化。版本号为6.0.xx，目前发展到7.1.xx。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(376, 'Linux常用命令——curl', '376', 1502076600, 1502676995, '<p>C<span style="line-height: 1.6em;">url是Linux下面的一款强大的文件传输工具。</span></p>\r<!--more-->\r\r<p><strong>作用</strong></p>\r\r<p>文件传输，模拟web请求</p>\r\r<p><strong>语法</strong></p>\r\r<pre class="brush:bash;">\rcurl [option] [url]</pre>\r\r<p><strong>参数</strong></p>\r\r<p>-A/--user-agent &lt;string&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;设置用户代理发送给服务器<br />\r-c，&ndash;cookie-jar：将cookie写入到文件<br />\r-b，&ndash;cookie：从文件中读取cookie<br />\r-C，&ndash;continue-at：断点续传<br />\r-d，&ndash;data：http post方式传送数据<br />\r-D，&ndash;dump-header：把header信息写入到文件<br />\r-F，&ndash;from：模拟http表达提交数据<br />\r-s，&ndash;slient：减少输出信息<br />\r-o，&ndash;output：将信息输出到文件<br />\r-O，&ndash;remote-name：按照服务器上的文件名，存在本地<br />\r&ndash;l，&ndash;head：仅返回头部信息<br />\r-u，&ndash;user[user:pass]：设置http认证用户和密码<br />\r-T，&ndash;upload-file：上传文件<br />\r-e，&ndash;referer：指定引用地址<br />\r-x，&ndash;proxy：指定代理服务器地址和端口<br />\r-w，&ndash;write-out：输出指定格式内容<br />\r&ndash;retry：重试次数<br />\r&ndash;connect-timeout：指定尝试连接的最大时间/s</p>\r\r<p><strong>实例</strong></p>\r\r<p>抓取页面到指定文件，如果有乱码可以使用iconv转码</p>\r\r<pre class="brush:bash;">\rcurl -o baidu.html www.baidu.com\rcurl &ndash;s &ndash;o baidu.html www.baidu.com |iconv -f utf-8</pre>\r\r<p>模拟浏览器头（user-agent）</p>\r\r<pre class="brush:bash;">\rcurl -A &ldquo;Mozilla/4.0 (compatible;MSIE 6.0; Windows NT 5.0)&rdquo; www.baidu.com</pre>\r\r<p>处理重定向页面</p>\r\r<pre class="brush:bash;">\rcurl &ndash;L http://192.168.1.100/301.php #默认curl是不处理重定向</pre>\r\r<p>模拟用户登陆，保存cookie信息到cookies.txt文件，再使用cookie登陆</p>\r\r<pre class="brush:bash;">\r#NAME和PWD是表单属性不同，每个网站基本都不同\rcurl -c ./cookies.txt -F NAME=user -F PWD=***URL \rcurl -b ./cookies.txt &ndash;o URL</pre>\r\r<p>获取HTTP响应头headers</p>\r\r<pre class="brush:bash;">\rcurl -I http://www.baidu.com\r#将headers保存到文件中\rcurl -D ./header.txt http://www.baidu.com</pre>\r\r<p>访问HTTP认证页面</p>\r\r<pre class="brush:bash;">\rcurl &ndash;u user:pass URL</pre>\r\r<p>通过ftp上传和下载文件</p>\r\r<pre class="brush:bash;">\r#上传\rcurl -T filename ftp://user:pass@ip/docs\r#下载\rcurl -O ftp://user:pass@ip/filename</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 136),
(378, '001.png', '001-png-2', 1502202991, 1502202991, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2017/08/1677966143.png";s:4:"size";i:43068;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 335, 0),
(379, 'Ubuntu下安装wireshark', '379', 1502675590, 1502675590, '<p>本文介绍Ubuntu下如何安装wireshark，以及如何设置非root用户抓包。</p>\r<!--more-->\r\r<p>Wireshark是世界上最流行的网络分析工具。这个强大的工具可以捕捉网络中的数据，并为用户提供关于网络和上层协议的各种信息。与很多其他网络工具一样，Wireshark也使用pcap network library来进行封包捕捉。</p>\r\r<p>1.安装wireshark</p>\r\r<pre class="brush:bash;">\rsudo apt-get install wireshark</pre>\r\r<p>2.添加wireshark用户组（可能已经存在了，但不影响命令执行）</p>\r\r<pre class="brush:bash;">\rsudo groupadd  wireshark</pre>\r\r<p>3.将dumpcap更改为wireshark用户组</p>\r\r<pre class="brush:bash;">\rsudo chgrp wireshark /usr/bin/dumpcap</pre>\r\r<p>4.让wireshark用户组有root权限使用dumpcap</p>\r\r<pre class="brush:bash;">\rsudo chmod 4755 /usr/bin/dumpcap </pre>\r\r<p>5.将需要使用的普通用户名加入wireshark用户组（将oliver改成对应的用户）</p>\r\r<pre class="brush:bash;">\rsudo gpasswd -a oliver wireshark</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 179),
(380, 'Linux管理员如何强行踢出用户', '380', 1502675895, 1502675895, '<p>本文介绍Linux管理员root如何强行踢出用户，写这篇文章的初衷是Ubuntu的guest用户登入后很难登出。</p>\r\r<!--more-->\r\r<p>1.使用w查看目前登录的用户</p>\r\r<pre class="brush:bash;">\rw</pre>\r\r<p>2.将要踢出的用户的tty直接kill</p>\r\r<pre class="brush:bash;">\rpkill -kill -t tty8</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 150),
(383, '编译安装MySQL 5.6', '383', 1504070040, 1511182446, '<p>本文介绍如何编译安装MySQL 5.6，其中，cmake也是编译安装的。</p>\r<!--more-->\r\r<p>1.安装依赖库</p>\r\r<pre class="brush:bash;">\ryum -y install gcc gcc-c++\ryum -y install ncurses-devel openssl-devel\ryum -y install perl-Data-Dumper</pre>\r\r<p>2.添加mysql用户和用户组</p>\r\r<pre class="brush:bash;">\ruseradd -M -s /sbin/nologin mysql</pre>\r\r<p>3.编译安装cmake</p>\r\r<pre class="brush:bash;">\rwget https://cmake.org/files/v3.9/cmake-3.9.1.tar.gz\rtar xf cmake-3.9.1.tar.gz\rcd cmake-3.9.1\r./configure\rgmake\rgmake install</pre>\r\r<p>4.编译安装MySQL</p>\r\r<pre class="brush:bash;">\rwget http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-5.6.35.tar.gz\rtar xf mysql-5.6.35.tar.gz\rcd mysql-5.6.35\rcmake \\\r-DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\\r-DMYSQL_DATADIR=/usr/local/mysql/data \\\r-DSYSCONFDIR=/etc \\\r-DWITH_MYISAM_STORAGE_ENGINE=1 \\\r-DWITH_INNOBASE_STORAGE_ENGINE=1 \\\r-DWITH_MEMORY_STORAGE_ENGINE=1 \\\r-DWITH_READLINE=1 \\\r-DMYSQL_TCP_PORT=3306 \\\r-DENABLED_LOCAL_INFILE=1 \\\r-DWITH_PARTITION_STORAGE_ENGINE=1 \\\r-DEXTRA_CHARSETS=all \\\r-DDEFAULT_CHARSET=utf8 \\\r-DDEFAULT_COLLATION=utf8_general_ci \\\r-DMYSQL_USER=mysql \\\r-DWITH_DEBUG=0 \\\r-DWITH_SSL=system\rmake\rmake install\rcp -f support-files/my-default.cnf /etc/my.cnf\rchown -R mysql.mysql /usr/local/mysql/\r/usr/local/mysql/scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql\rcp -f support-files/mysql.server /etc/init.d/mysqld\recho &#39;export PATH=/usr/local/mysql/bin/:$PATH&#39; &gt;&gt;/etc/profile\rsource /etc/profile\rchmod +x /etc/init.d/mysqld\rchkconfig mysqld on\rservice mysqld start\rmysqladmin -u root password &#39;你的密码&#39;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 128),
(384, 'Spring报错Referenced file contains errors解决办法', '384', 1504078980, 1504106329, '<p>本文记录下在EDAS开发中遇到的一个问题&mdash;&mdash;Referenced file contains errors (http://www.taobao.com/hsf/hsf.xsd).&nbsp;</p>\r<!--more-->\r\r<p>解决办法：</p>\r\r<p>在Eclipse中，Window -&gt; Preferences -&gt; General -&gt; Network Connections -&gt; Cache，关闭缓存。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 355),
(385, 'Nginx日志常用变量', '385', 1504106318, 1504106318, '<p>本文介绍Nginx日志中的几个常用变量。</p>\r\r<!--more-->\r\r<p>$remote_addr<br />\r记录访问网站的客户端地址</p>\r\r<p>$http_x_forwarded_for<br />\r当前端有代理服务器时，设置Web节点记录客户端地址的配置，此参数生效的前提是代理服务器上也进行了相关的x_forwarded_for设置</p>\r\r<p>$remote_user<br />\r远程客户端用户名称</p>\r\r<p>$time_local<br />\r记录访问时间与时区</p>\r\r<p>$request<br />\r用户的http请求起始行信息</p>\r\r<p>$status<br />\rhttp状态码，记录请求返回的状态，例如：200、301、404等等</p>\r\r<p>$body_bytes_sents<br />\r服务器发送给客户端的响应body字节数</p>\r\r<p>$http_referer<br />\r记录此次请求是从哪个链接访问过来的，可以根据referer进行防盗链设置</p>\r\r<p>$http_user_agent<br />\r记录客户端访问信息，例如：浏览器、手机客户端等</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(386, 'CentOS一键批量移除无用软件包', '386', 1504436580, 1504439910, '<p>本文介绍CentOS软件一键移除无用软件包。</p>\r<!--more-->\r\r<p>直接执行下面的命令即可。</p>\r\r<pre class="brush:bash;">\ryum -y remove Deployment_Guide-en-US finger cups-libs cups ypbind\ryum -y remove bluez-libs desktop-file-utils ppp rp-pppoe wireless-tools irda-utils\ryum -y remove sendmail* samba* talk-server finger-server bind* xinetd\ryum -y remove nfs-utils nfs-utils-lib rdate fetchmail eject ksh mkbootdisk mtools\ryum -y remove syslinux tcsh startup-notification talk apmd rmt dump setserial portmap yp-tools java\ryum -y groupremove &quot;Mail Server&quot; &quot;Games and Entertainment&quot; &quot;X Window System&quot; &quot;X Software Development&quot;\ryum -y groupremove &quot;Development Libraries&quot; &quot;Dialup Networking Support&quot;\ryum -y groupremove &quot;Games and Entertainment&quot; &quot;Sound and Video&quot;\ryum -y groupremove &quot;Graphics&quot; &quot;Editors&quot;yum groupremove &quot;Text-based Internet&quot;\ryum -y groupremove &quot;GNOME Desktop Environment&quot; &quot;GNOME Software Development&quot;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 151);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(387, 'resolv.conf中search作用', '387', 1505720820, 1505720884, '<p>本文介绍resolv.conf中的search的作用。</p>\r\r<!--more-->\r\r<p>reslov.conf中的search主要是用来补全hostname的，有时候域名太长，可以做一个短域名做主机名字，但是DNS解析需要的是FQDN，而在resolv.conf中设置search能进行补全。</p>\r\r<pre class="brush:bash;">\rvim /etc/hosts\r8.8.8.8 www</pre>\r\r<p>ping www能通，返回就是8.8.8.8，ping会首先解析hosts。</p>\r\r<pre class="brush:bash;">\rvim /etc/resolv.conf\rsearch oliver.ren\rnameserver 223.5.5.5</pre>\r\r<p>这时候nslookup www</p>\r\r<pre class="brush:bash;">\rServer:        223.5.5.5\rAddress:       223.5.5.5#53\r\rNon-authoritative answer:\rName:    www.oliver.ren\rAddress: 8.8.8.8</pre>\r\r<p>看到没，search的作用就是补全要访问的短域名<br />\r正确的域名解析顺序是:<br />\r1. 查找/etc/hosts<br />\r2. 根据nameserver查找域名<br />\r3. 如果在nameserver查找不到域名就进行search补全，重新走1~2步</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 170),
(388, '接线子的类型', '388', 1505730660, 1505824986, '<p>本文介绍下接线子的类型，共有K1,K2,K3,K4和K5五种。</p>\r<!--more-->\r\r<p>K1型扣式接线子是单体防潮式，采用单刀连接，用于二线直接接续。适用线径为0.4-0.7mm, 最大绝缘外径为1.52mm。</p>\r\r<p>K2型扣式接线子是单体防潮式，采用双刀连接，用于二线直接接续。适用线径为0.4-0.9mm，最大绝缘外径为2.08mm。</p>\r\r<p>K3型扣式接线子是单体防潮式，采用双刀连接，用于Y型三线复接接续。适用线径为0.4-0.9mm，最大绝缘外径为1.67mm。</p>\r\r<p>k4型扣式接线子是单体防潮式，采用单刀连接，用于主干线不切断的T型桥接接续。适用线径为0.4-0.7mm，最大绝缘外径为2.08mm。</p>\r\r<p>k5型扣式接线子是单体防潮式，用于主干线不切断的T型桥接，适用线径为0.4-0.9mm，最大绝缘外径为1.67mm。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 122),
(389, 'Linux负载均衡软件LVS基本概念', '389', 1505786880, 1505787774, '<p>本文介绍LVS的一些基本概念。</p>\r<!--more-->\r\r<p>一、 LVS简介</p>\r\r<p>LVS是Linux Virtual Server的简称，也就是Linux虚拟服务器, 是一个由章文嵩博士发起的自由软件项目，它的官方站点是www.linuxvirtualserver.org。现在LVS已经是 Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须要重新编译内核以支持LVS功能模块，但是从Linux2.4内核以后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。</p>\r\r<p>使用LVS技术要达到的目标是：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。</p>\r\r<p>LVS自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。可以利用LVS技术实现高可伸缩的、高可用的网络服务，例如WWW服务、Cache服务、DNS服务、FTP服务、MAIL服务、视频/音频点播服务等等，有许多比较著名网站和组织都在使用LVS架设的集群系统，例如：Linux的门户网站（www.linux.com）、向RealPlayer提供音频视频服务而闻名的Real公司（www.real.com）、全球最大的开源网站（sourceforge.net）等。</p>\r\r<p>二、 LVS体系结构</p>\r\r<p>使用LVS架设的服务器集群系统有三个部分组成：最前端的负载均衡层，用Load Balancer表示，中间的服务器群组层，用Server Array表示，最底端的数据共享存储层，用Shared Storage表示，在用户看来，所有的内部应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2017/09/264244042.png" style="width: 600px; height: 387px;" /></p>\r\r<p>下面对LVS的各个组成部分进行详细介绍：</p>\r\r<p>Load Balancer层：位于整个集群系统的最前端，有一台或者多台负载调度器（Director Server）组成，LVS模块就安装在Director Server上，而Director的主要作用类似于一个路由器，它含有完成LVS功能所设定的路由表，通过这些路由表把用户的请求分发给Server Array层的应用服务器（Real Server）上。同时，在Director Server上还要安装对Real Server服务的监控模块Ldirectord，此模块用于监测各个Real Server服务的健康状况。在Real Server不可用时把它从LVS路由表中剔除，恢复时重新加入。</p>\r\r<p>Server Array层：由一组实际运行应用服务的机器组成，Real Server可以是WEB服务器、MAIL服务器、FTP服务器、DNS服务器、视频服务器中的一个或者多个，每个Real Server之间通过高速的LAN或分布在各地的WAN相连接。在实际的应用中，Director Server也可以同时兼任Real Server的角色。</p>\r\r<p>Shared Storage层：是为所有Real Server提供共享存储空间和内容一致性的存储区域，在物理上，一般有磁盘阵列设备组成，为了提供内容的一致性，一般可以通过NFS网络文件系统共享数据，但是NFS在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如Red hat的GFS文件系统，oracle提供的OCFS2文件系统等。</p>\r\r<p>从整个LVS结构可以看出，Director Server是整个LVS的核心，目前，用于Director Server的操作系统只能是Linux和FreeBSD，linux2.6内核不用任何设置就可以支持LVS功能，而FreeBSD作为Director Server的应用还不是很多，性能也不是很好。</p>\r\r<p>对于Real Server，几乎可以是所有的系统平台，Linux、windows、Solaris、AIX、BSD系列都能很好的支持。</p>\r\r<p>三、 &nbsp;LVS集群的特点</p>\r\r<p>3.1 &nbsp;IP负载均衡与负载调度算法</p>\r\r<p>1．IP负载均衡技术</p>\r\r<p>负载均衡技术有很多实现方案，有基于DNS域名轮流解析的方法、有基于客户端调度访问的方法、有基于应用层系统负载的调度方法，还有基于IP地址的调度方法，在这些负载调度算法中，执行效率最高的是IP负载均衡技术。</p>\r\r<p>LVS的IP负载均衡技术是通过IPVS模块来实现的，IPVS是LVS集群系统的核心软件，它的主要作用是：安装在Director Server上，同时在Director Server上虚拟出一个IP地址，用户必须通过这个虚拟的IP地址访问服务。这个虚拟IP一般称为LVS的VIP，即Virtual IP。访问的请求首先经过VIP到达负载调度器，然后由负载调度器从Real Server列表中选取一个服务节点响应用户的请求。</p>\r\r<p>当用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的Real Server节点，而Real Server节点如何返回数据给用户，是IPVS实现的重点技术，IPVS实现负载均衡机制有三种，分别是NAT、TUN和DR，详述如下：&nbsp;</p>\r\r<p>VS/NAT： 即（Virtual Server via Network Address Translation）<br />\r也就是网络地址翻译技术实现虚拟服务器，当用户请求到达调度器时，调度器将请求报文的目标地址（即虚拟IP地址）改写成选定的Real Server地址，同时报文的目标端口也改成选定的Real Server的相应端口，最后将报文请求发送到选定的Real Server。在服务器端得到数据后，Real Server返回数据给用户时，需要再次经过负载调度器将报文的源地址和源端口改成虚拟IP地址和相应端口，然后把数据发送给用户，完成整个负载调度过程。<br />\r可以看出，在NAT方式下，用户请求和响应报文都必须经过Director Server地址重写，当用户请求越来越多时，调度器的处理能力将称为瓶颈。</p>\r\r<p>VS/TUN ：即（Virtual Server via IP Tunneling）&nbsp;<br />\r也就是IP隧道技术实现虚拟服务器。它的连接调度和管理与VS/NAT方式一样，只是它的报文转发方法不同，VS/TUN方式中，调度器采用IP隧道技术将用户请求转发到某个Real Server，而这个Real Server将直接响应用户的请求，不再经过前端调度器，此外，对Real Server的地域位置没有要求，可以和Director Server位于同一个网段，也可以是独立的一个网络。因此，在TUN方式中，调度器将只处理用户的报文请求，集群系统的吞吐量大大提高。</p>\r\r<p>VS/DR： 即（Virtual Server via Direct Routing）&nbsp;<br />\r也就是用直接路由技术实现虚拟服务器。它的连接调度和管理与VS/NAT和VS/TUN中的一样，但它的报文转发方法又有不同，VS/DR通过改写请求报文的MAC地址，将请求发送到Real Server，而Real Server将响应直接返回给客户，免去了VS/TUN中的IP隧道开销。这种方式是三种负载调度机制中性能最高最好的，但是必须要求Director Server与Real Server都有一块网卡连在同一物理网段上。</p>\r\r<p>2．负载调度算法</p>\r\r<p>上面我们谈到，负载调度器是根据各个服务器的负载情况，动态地选择一台Real Server响应用户请求，那么动态选择是如何实现呢，其实也就是我们这里要说的负载调度算法，根据不同的网络服务需求和服务器配置，IPVS实现了如下八种负载调度算法，这里我们详细讲述最常用的四种调度算法，剩余的四种调度算法请参考其它资料。</p>\r\r<p>轮叫调度（Round Robin）<br />\r&ldquo;轮叫&rdquo;调度也叫1:1调度，调度器通过&ldquo;轮叫&rdquo;调度算法将外部用户请求按顺序1:1的分配到集群中的每个Real Server上，这种算法平等地对待每一台Real Server，而不管服务器上实际的负载状况和连接状态。&nbsp;</p>\r\r<p>加权轮叫调度（Weighted Round Robin）&nbsp;<br />\r&ldquo;加权轮叫&rdquo;调度算法是根据Real Server的不同处理能力来调度访问请求。可以对每台Real Server设置不同的调度权值，对于性能相对较好的Real Server可以设置较高的权值，而对于处理能力较弱的Real Server，可以设置较低的权值，这样保证了处理能力强的服务器处理更多的访问流量。充分合理的利用了服务器资源。同时，调度器还可以自动查询Real Server的负载情况，并动态地调整其权值。&nbsp;</p>\r\r<p>最少链接调度（Least Connections）&nbsp;<br />\r&ldquo;最少连接&rdquo;调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用&ldquo;最小连接&rdquo;调度算法可以较好地均衡负载。&nbsp;</p>\r\r<p>加权最少链接调度（Weighted Least Connections）&nbsp;<br />\r&ldquo;加权最少链接调度&rdquo;是&ldquo;最少连接调度&rdquo;的超集，每个服务节点可以用相应的权值表示其处理能力，而系统管理员可以动态的设置相应的权值，缺省权值为1，加权最小连接调度在分配新连接请求时尽可能使服务节点的已建立连接数和其权值成正比。<br />\r其它四种调度算法分别为：基于局部性的最少链接（Locality-Based Least Connections）、带复制的基于局部性最少链接（Locality-Based Least Connections with Replication）、目标地址散列（Destination Hashing）和源地址散列（Source Hashing），对于这四种调度算法的含义，本文不再讲述，如果想深入了解这其余四种调度策略的话，可以登陆LVS中文站点zh.linuxvirtualserver.org，查阅更详细的信息。</p>\r\r<p>3.2 高可用性</p>\r\r<p>LVS是一个基于内核级别的应用软件，因此具有很高的处理性能，用LVS构架的负载均衡集群系统具有优秀的处理能力，每个服务节点的故障不会影响整个系统的正常使用，同时又实现负载的合理均衡，使应用具有超高负荷的服务能力，可支持上百万个并发连接请求。如配置百兆网卡，采用VS/TUN或VS/DR调度技术，整个集群系统的吞吐量可高达1Gbits/s；如配置千兆网卡，则系统的最大吞吐量可接近10Gbits/s。</p>\r\r<p>3.3 高可靠性</p>\r\r<p>LVS负载均衡集群软件已经在企业、学校等行业得到了很好的普及应用，国内外很多大型的、关键性的web站点也都采用了LVS集群软件，所以它的可靠性在实践中得到了很好的证实。有很多以LVS做的负载均衡系统，运行很长时间，从未做过重新启动。这些都说明了LVS的高稳定性和高可靠性。</p>\r\r<p>3.4 适用环境</p>\r\r<p>LVS对前端Director Server目前仅支持Linux和FreeBSD系统，但是支持大多数的TCP和UDP协议，支持TCP协议的应用有：HTTP，HTTPS ，FTP，SMTP，，POP3，IMAP4，PROXY，LDAP，SSMTP等等。支持UDP协议的应用有：DNS，NTP，ICP，视频、音频流播放协议等。LVS对Real Server的操作系统没有任何限制，Real Server可运行在任何支持TCP/IP的操作系统上，包括Linux，各种Unix（如FreeBSD、Sun Solaris、HP Unix等），Mac/OS和Windows等。</p>\r\r<p>3.5 开源软件&nbsp;</p>\r\r<p>LVS集群软件是按GPL（GNU Public License）许可证发行的自由软件，因此，使用者可以得到软件的源代码，并且可以根据自己的需要进行各种修改，但是修改必须是以GPL方式发行。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 150),
(390, 'LVS.png', 'LVS', 1505786987, 1505787004, 'a:8:{s:4:"name";s:13:"110349553.png";s:4:"path";s:34:"/usr/uploads/2017/09/264244042.png";s:4:"size";i:47613;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";s:7:"isImage";b:1;s:3:"url";s:55:"http://www.oliver.ren/usr/uploads/2017/09/264244042.png";s:11:"description";N;}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 389, 0),
(395, 'InnoDB存储引擎主要特征', '395', 1505809048, 1505809048, '<p>本文介绍InnoDB存储引擎的主要特征。</p>\r\r<!--more-->\r\r<p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5之后，InnoDB作为默认存储引擎，InnoDB主要特征有：</p>\r\r<p>1.InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表与其他MySQL的表的类型混合起来，甚至在同一个查询中也可以混用；<br />\r2.InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的；<br />\r3.InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上；<br />\r4.InnoDB支持外键完整性约束（FOREIGN KEY）。存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此为主键；<br />\r5.InnoDB被用在众多需要高性能的大型数据库站点上。InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(575, '类的分类与概述', '575', 1519309200, 1519309300, '<p>本文记录Java学习过程中遇到的引用数据类型类的分类与概述～</p>\r<!--more-->\r\r<p>提到引用数据类型（类），其实我们对它并不陌生，如使用过的Scanner类、Random类。</p>\r\r<p>我们可以把类的类型为两种：</p>\r\r<ul>\r	<li>第一种，Java为我们提供好的类，如Scanner类，Random类等，这些已存在的类中包含了很多的方法与属性，可供我们使用。</li>\r	<li>第二种，我们自己创建的类，按照类的定义标准，可以在类中包含多个方法与属性，来供我们使用。</li>\r</ul>\r\r<p>我们在Java中，将现实生活中的事物抽象成了代码。这时，我们可以使用自定义的数据类型（类）来描述（映射）现实生活中的事物。</p>\r\r<p>类，它是引用数据类型，与之前学习的所有引用数据类型相同，自定义类也是一种数据类型。只是自定义类型并非Java为我们预先提供好的类型，而是我们自己定义的一种引用数据类型用来描述一个事物。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(467, '对象的接口', '467', 1514419740, 1514419787, '<p>本文摘自《Java编程思想》，值得记录～</p>\r\r<!--more-->\r\r<p>亚里士多德或许是认真研究&ldquo;类型&rdquo;概念的第一人，他曾谈及&ldquo;鱼类和鸟类&rdquo;的问题。在世界首例面向对象语言Simula-67中，第一次用到了这样的一个概念：</p>\r\r<p>所有对象&mdash;&mdash;尽管各有特色&mdash;&mdash;都属于某一系列对象的一部分，这些对象具有通用的特征和行为。在Simula-67中，首次用到了class这个关键字，它为程序引入了一个全新的类型。</p>\r\r<p>Simula是一个很好的例子。正如这个名字所暗示的，它的作用是&ldquo;模拟&rdquo;（Simulate）象&ldquo;银行出纳员&rdquo;这样的经典问题。在这个例子里，我们有一系列出纳员、客户、帐号以及交易等。每类成员（元素）都具有一些通用的特征：每个帐号都有一定的余额；每名出纳都能接收客户的存款；等等。与此同时，每个成员都有自己的状态；每个帐号都有不同的余额；每名出纳都有一个名字。所以在计算机程序中，能用独一无二的实体分别表示出纳员、客户、帐号以及交易。这个实体便是&ldquo;对象&rdquo;，而且每个对象都隶属一个特定的&ldquo;类&rdquo;，那个类具有自己的通用特征与行为。</p>\r\r<p>因此，在面向对象的程序设计中，尽管我们真正要做的是新建各种各样的数据&ldquo;类型&rdquo;（Type），但几乎所有面向对象的程序设计语言都采用了&ldquo;class&rdquo;关键字。当您看到&ldquo;type&rdquo;这个字的时候，请同时想到&ldquo;class&rdquo;；反之亦然。</p>\r\r<p>建好一个类后，可根据情况生成许多对象。随后，可将那些对象作为要解决问题中存在的元素进行处理。事实上，当我们进行面向对象的程序设计时，面临的最大一项挑战性就是：如何在&ldquo;问题空间&rdquo;（问题实际存在的地方）的元素与&ldquo;方案空间&rdquo;（对实际问题进行建模的地方，如计算机）的元素之间建立理想的&ldquo;一对一&rdquo;对应或映射关系。</p>\r\r<p>如何利用对象完成真正有用的工作呢？必须有一种办法能向对象发出请求，令其做一些实际的事情，比如完成一次交易、在屏幕上画一些东西或者打开一个开关等等。每个对象仅能接受特定的请求。我们向对象发出的请求是通过它的&ldquo;接口&rdquo;（Interface）定义的，对象的&ldquo;类型&rdquo;或&ldquo;类&rdquo;则规定了它的接口形式。&ldquo;类型&rdquo;与&ldquo;接口&rdquo;的等价或对应关系是面向对象程序设计的基础。</p>\r\r<p>下面让我们以电灯泡为例：</p>\r\r<pre class="brush:java;">\rLight\r\rOn()\r\rOff()\r\rBrighten()\r\rDim()\r\r       Type name\r\r       Interface\r\rLight lt = new Light();\r\rlt.on();</pre>\r\r<p>在这个例子中，类型／类的名称是Light，可向Light对象发出的请求包括包括打开（on）、关闭（off）、变得更明亮（brighten）或者变得更暗淡（dim）。通过简单地声明一个名字（lt），我们为Light对象创建了一个&ldquo;句柄&rdquo;。然后用new关键字新建类型为Light的一个对象。再用等号将其赋给句柄。为了向对象发送一条消息，我们列出句柄名（lt），再用一个句点符号（.）把它同消息名称（on）连接起来。从中可以看出，使用一些预先定义好的类时，我们在程序里采用的代码是非常简单和直观的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(418, '个人使用的一份vim配置文件', '418', 1511278080, 1512391899, '<p>本文分享一份个人常用的vim的配置文件，这个配置文件的路径为~/.vimrc。</p>\r<!--more-->\r\r<pre class="brush:bash;">\rset nocompatible\rset history=100\rfiletype on\rfiletype plugin on\rfiletype indent on\rset autoread\rset mouse=a\rsyntax enable\rset guifont=dejaVu\\ Sans\\ MONO\\ 10\rcolorscheme desert\rset cursorline\rhi cursorline guibg=#00ff00\rhi CursorColumn guibg=#00ff00\rset foldenable\rset foldmethod=manual\rset foldcolumn=0\rset foldlevel=3\rset foldclose=all\rnnoremap &lt;space&gt; @=((foldclosed(line(&#39;.&#39;)) &lt; 0) ? &#39;zc&#39; : &#39;zo&#39;)&lt;CR&gt;\rset expandtab\rset tabstop=4\rset shiftwidth=4\rset softtabstop=4\rset smarttab\rset si\rset wrap\rset sw=4\rset wildmenu\rset ruler\rset cmdheight=1\rset nu\rset lz\rset backspace=eol,start,indent\rset whichwrap+=&lt;,&gt;,h,l\rset magic\rset noerrorbells\rset showmatch\rset mat=2\rset hlseyrch\rset ignorecase\rset encoding=utf-8\rset fileencodings=utf-8\rset termencoding=utf-8\rset smartindent\rset cin\rset showmatch\rset guioptions-=T\rset guioptions-=m\rset vb t_vb=\rset laststatus=2\rset pastetoggle=&lt;F9&gt;\rset background=dark\rhighlight Search ctermbg=black ctermfg=white guifg=white guibg=black\rautocmd BufNewFile *.py,*.cc,*.sh,*.java exec &quot;:call SetTitle()&quot;\rfunc SetTitle()\r    if expand(&quot;%:e&quot;) == &#39;sh&#39;\r        call setline(1, &quot;#!/bin/bash&quot;)\r        call setline(2, &quot;#Author: Oliver King&quot;)\r        call setline(3, &quot;#Blog: http://www.oliver.ren&quot;)\r    endif\rendfunc</pre>\r\r<p>&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 184),
(412, '如何才能学好Shell编程', '412', 1509268680, 1509273005, '<p>本文分享如何学好Shell编程，总体来说就是：多练&mdash;&mdash;多思考&mdash;&mdash;再连&mdash;&mdash;再思考，坚持如此循环即可。</p>\r<!--more-->\r\r<p>1.掌握Shell脚本基本语法的方法</p>\r\r<p>最简单有效的方法就是将语法敲n+1遍。为什么不是n遍呢？因为这里的n指的是你刚开始为掌握语法而练习的那些天(21天法则)，而1则是指在确定掌握语法后每天都要写一写、想一想，至少是要看一看，保持一个与Shell脚本接触的热度。</p>\r\r<p>2.掌握Shell脚本的各种常见语法</p>\r\r<p>要掌握各类条件表达式、if多种判断、for循环的不同用法、while多种读文件的循环等，这样做不是为了什么都学会，而是为了能够看懂别人写的代码。掌握常见的各种语法，也就是要经常写，而且要持续写一段时间(让动作定型，在大脑和肌肉里都打上深刻烙印)，各种语法都要用。</p>\r\r<p>3.形成自己的脚本开发风格</p>\r\r<p>当掌握了各种常见的语法之后，就要选定一种适合自己的语法，形成自己的开发风格，例如：if语句的语法就只用一种，条件表达式的语法只用一种，函数的写法也只用一种，有些语法需要根据场景去选择。在解决问题的前提下，掌握一种语法，然后将其用精、用透就是最好的，切记横向贪多，要多纵深学习。</p>\r\r<p>4.从简单做起，简单判断，简单循环</p>\r\r<p>初学者一定要从简单做起，最小化代码学习，简单判断，简单循环，简单案例练习，所有的大程序都是由多个小程序组成的，因此，一开始没必要写多大的程序，免得给自己带来过多的挫败感，形成编程恐惧症。可先通过小的程序培养兴趣及成就感，到碰到大的程序时，即使遇到困难也能坚持下去了。</p>\r\r<p>5.多模仿，多放下参考资料练习，多思考</p>\r\r<p>多找一些脚本例子来仔细分析一下，或者是系统自带的，或者是别人写的，不要只看，看着会并不是真的会。当你闭上眼睛的时候，还能完整地回忆起来，甚至还能完整口述或手写出来才是真的会。</p>\r\r<p>6.学会分析问题，逐渐形成编程思维</p>\r\r<p>在编写程序或脚本时，先将需求理解透，对大的需求进行分解，逐步形成小的程序或模块，然后再开发，或者先分析最终需求的基础实现，最后逐步扩展批量实现。</p>\r\r<p>例如，在编写批量关闭不需要自启动服务的脚本时，就采用了这种分析方法，思路如下：</p>\r\r<p>1)掌握关闭一个服务的命令，即&ldquo;chkconfig 服务名 off&rdquo;；<br />\r2)批量处理时，会有多个服务名，那么就要用到多条以上的命令；<br />\r3)仔细分析以上命令，会发现需要处理的所有命令中，只有&ldquo;服务名&rdquo;不同，其他地方都一样，那么自然就会想到用循环语句来处理。</p>\r\r<p>如果是你已经想到了上面的这些，那么就表示你已经形成了初级的编程思维了。</p>\r\r<p>如果你能够通过分析将一个大的需求细分为各个小的单元，然后利用函数、判断、循环、命令等实现每一个小的单元，那么最后把所有程序组合起来就是一个大的脚本程序了。</p>\r\r<p>如果达到了上述的水平，你就算会编程了，对于领导提出的要求，就能够进行合理的分解，只要在机器上多进行调试，相信一定能写出来。</p>\r\r<p>7.编程变量名字要规范，采用驼峰语法表示</p>\r\r<p>helloWorld用的就是驼峰表示法。记住，在学习的初期，不要去看大的脚本，要从小问题和小的方面着手，当你觉得小的判断、循环等在你的脑子里瞬间就能出来时，再开始去看和写大的脚本，进行深入练习。</p>\r\r<p>新手初期最好的学习方法就是多敲代码，并针对问题进行分解练习，多敲代码就是让自己养成一个编程习惯，使肌肉、视觉和思维形成记忆，分解问题实际上就是掌握软件的设计和实现思想。</p>\r\r<p>对于最高的编程境界，我个人的理解是：能把大问题进行完整的分析、分解且高效解决。</p>\r\r<p>完整性：就是指预先考虑到各种可能性，将问题分解后，合理模块化并实现。<br />\r高效率：例如，在求&ldquo;1+2+3+...+100&rdquo;的和时，考虑使用算法&ldquo;(1+100)X100/2&rdquo;，而不是逐个去加。</p>\r\r<p>8.不要拿来主义，特别是新手</p>\r\r<p>好多网友看书或学习视频时，喜欢要文档、要代码，其实，这是学习的最大误区。</p>\r\r<p>有了文档和代码，你会变得非常懒惰，心里面会觉得已经学会了，而实际上并没有学会。因此无论是看书还是学习视频，都要自己完成学习笔记及代码的书写，这本身就是最重要的学习过程，在学习上要肯于花时间和精力，而不是投机取巧。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(413, 'Shell脚本语言的优势', '413', 1509272993, 1509272993, '<p>本文介绍Shell脚本语言的优势。</p>\r\r<!--more-->\r\r<p>Shell脚本语言的优势在于处理偏操作系统底层的业务，例如：Linux系统内部的很多应用(有的是应用的一部分)都是使用Shell脚本开发的，因为有1000多个Linux系统命令为它做支撑，特别是Linux正则表达式及三剑客grep、sed、awk等命令。</p>\r\r<p>对于一些常见的系统脚本使用Shell开发会更简单、更快速，例如：让软件一键自动化安装、优化，监控报警脚本，软件启动脚本，日志分析脚本等，虽然PHP/Python语言也能够做到这些，但是，考虑到掌握难度、开发效率、开发习惯等因素，它们可能就不如Shell脚本语言流行及有优势了。对于一些常规的业务应用，使用Shell更符合Linux运维简单、易用、高效的三大基本原则。</p>\r\r<p>PHP语言的优势在于小型网站系统的开发；Python语言的优势在于开发较复杂的运维工具、Web界面的管理工具和Web业务的开发（例如：CMDB自动化运维平台、跳板机、批量管理软件SaltStack、云计算OpenStack软件）等。我们在开发一个应用时应根据业务需求，结合不同语言的优势及自身擅长的语言来选择，扬长避短，从而达到高效开发及易于自身维护等目的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 121),
(414, '学习Shell编程需要什么基础', '414', 1509273060, 1509273131, '<p>本文介绍学习Shell编程需要什么基础。</p>\r<!--more-->\r\r<p>Shell脚本是实现Linux系统及运维自动化管理的重要且必备的工具，几乎每一个合格的Linux系统管理员或运维工程师，都需要熟练Shell脚本语言的编写，只有这样才能提升运维工作的效率，解决工作中的重复劳动。那么，Shell脚本编程难不难呢？学习Shell编程到底需要什么样的Linux基础呢？</p>\r\r<p>下面，就和大家说下，我认为学习Shell编程的基础，这里提到的基础并不是一定具备了才可以学下去，而是，具备了如下的基础，可以把Shell学习的更好，领悟的更深。</p>\r\r<p>学习Shell编程并实现通过Shell脚本自动化管理系统的必备基础：</p>\r\r<p>1.vi/vim编辑器的熟练使用，ssh终端及&quot;.vimrc&quot;的设置等等需要熟悉了；<br />\r2.命令基础：Linux的150个常用命令的熟练使用；<br />\r3.Linux正则表达式以及三剑客(grep,sed,awk)要熟练掌握；<br />\r4.常见Linux网络服务部署、优化及排错。例如：crond,nfs,rsync,inotify,lanmp,sersync,ssh,Memcached,MySQL等。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 92),
(415, 'Shell脚本的建立', '415', 1509279540, 1509279599, '<p>本文介绍如何建立一个Shell脚本。</p>\r<!--more-->\r\r<p>在Linux系统中，Shell脚本(bash)通常是在编辑器vi/vim中编写的，由UNIX/Linux命令、bash命令、程序结构控制语句和注释等内容组成。这里推荐用Linux自带的功能更强大的vim编辑器来编写，可以事先做一个别名alias vi=&#39;vim&#39;，并使其永久生效，这样以后习惯输入vi的用户也就可以直接调用vim编辑器了，设置方法如下：</p>\r\r<pre class="brush:bash;">\recho &quot;alias vi=&#39;vim&#39;&quot; &gt;&gt; /etc/profile\rsource /etc/profile</pre>\r\r<p><strong>1.脚本开头(第一行)</strong></p>\r\r<p>一个规范的Shell脚本在第一行会指出由哪个程序(解释器)来执行脚本中的内容，这一行内容在Linux的bash的编程一般为：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r或\r#!/bin/sh</pre>\r\r<p>其中，开头的&ldquo;#!&rdquo;字符又称为幻数，在执行bash脚本的时候，内核会根据&ldquo;#!&rdquo;后的解释器来确定该用哪个程序解释这个脚本中的内容。</p>\r\r<p>注意，这一行必须位于每个脚本的第一行，如果不是第一行则会被系统认为是注释，例如：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\recho &quot;hello&quot;\r#!/bin/bash\r#!/bin/sh\recho &quot;world&quot;</pre>\r\r<p><strong>2.bash与sh的区别</strong></p>\r\r<p>早期的bash与sh稍有不同，它还包含了csh和ksh的特色，但大多数脚本都可以不加修改地在sh上运行，比如：</p>\r\r<pre class="brush:bash;">\rll /bin/sh\rll /bin/bash</pre>\r\r<p>提示：sh为bash的软链接，大多数情况下，脚本的开头使用&quot;#!/bin/bash&quot;和&quot;#!/bin/sh&quot;是没有区别的，但更规范的写法是在脚本的开头使用&quot;#!/bin/bash&quot;。</p>\r\r<p>下面的Shell脚本是系统自带的软件启动脚本的开头部分。</p>\r\r<pre class="brush:bash;">\rhead -1 /etc/init.d/sshd\rhead -1 /etc/init.d/ntpd\rhead -1 /etc/init.d/crond</pre>\r\r<p>提示：如果使用/bin/sh执行脚本出现异常，那么可以再使用/bin/bash试一试，但是一般不会发生此类情况。</p>\r\r<p>一般情况下，在安装Linux系统时会自动安装好bash软件，查看系统的bash版本的命令如下：</p>\r\r<pre class="brush:bash;">\rcat /etc/redhat-release\rbash --version</pre>\r\r<p>如果使用的是较老版本的Shell，那么建议将其升级到最新版本的Shell，特别是企业使用，因为近两年老版本的bash被暴露出存在较严重的安全漏洞。</p>\r\r<p>例如：bash软件曾经爆出了严重漏洞(破壳漏洞)，凭借此漏洞，攻击者可能会接管计算机的整个操作系统，得以访问各种系统内的机密信息，并对系统进行更改等。任何人的计算机系统，如果使用了bash软件，都需要立即打上补丁。</p>\r\r<p>检测系统是否存在漏洞的方法为：</p>\r\r<pre class="brush:bash;">\renv x=&#39;() { :;}; echo be careful&#39; bash -c &quot;echo this is a test&quot;</pre>\r\r<p>如果返回如下两行，则表明需要尽快升级bash了，不过，仅仅是用于学习和测试就无所谓了。</p>\r\r<pre class="brush:bash;">\rbe careful\rthis is a test</pre>\r\r<p>升级方法为：</p>\r\r<pre class="brush:bash;">\ryum -y update bash\rrpm -qa bash</pre>\r\r<p>提示：如果没有输出be careful，则不需要升级。</p>\r\r<p>下面是Linux中常用脚本开头的写法，不同语言的脚本在开头一般都要加上如下标识内容：</p>\r\r<pre class="brush:bash;">\r#!/bin/sh\r#!/bin/bash\r#!/usr/bin/awk\r#!/bin/sed\r#!/usr/bin/tcl\r#!/usr/bin/expect\r#!/usr/bin/perl\r#!/usr/bin/env python</pre>\r\r<p>CentOS和Red Hat Linux下默认的Shell均为bash。因此，在写Shell脚本的时候，脚本的开头即使不加&quot;#!/bin/bash&quot;，它也会交给bash解释。如果写脚本不希望使用系统默认的Shell解释，那么就必须要指定解释器了，否则脚本文件执行后的结果可能就不是你所要的。建议养成好的编程习惯，不管采用什么脚本，最好都加上响应的开头解释器语言标识，遵守Shell编程规范。</p>\r\r<p>如果在脚本开头的第一行不指定解析器，那么就要用对应的解释器来执行脚本，这样才能确保脚本正确执行。</p>\r\r<p>例如：</p>\r\r<p>如果是Shell脚本，就用bash test.sh执行test.sh；<br />\r如果是Python脚本，就用python test.py执行test.py；<br />\r如果是expect脚本，就用expect test.exp执行test.exp。</p>\r\r<p>提示：其他的脚本程序大都是类似的执行方法。</p>\r\r<p><strong>3.脚本注释</strong></p>\r\r<p>在Shell脚本中，跟在#后面的内容表示注释，用来对脚本进行注释说明，注释部分不会被当做程序来执行，仅仅是给开发者和使用者看的，系统解释器是看不到的，更不会执行。注释可自成一行，也可以跟在脚本命令的后面与命令在同一行。开发脚本时，如果没有注释，那么团队里的其他人就会很难理解脚本对应内容的用途，而且时间长了，自己也会忘记。因此，我们要尽量养成为所开发的Shell脚本书写关键注释的习惯，书写注释不光是为了方便别人，更是为了方便自己，避免影响团队的协作效率，以及给后来接手的人带来维护困难。特别提示一下，注释尽量不要用中文，在脚本中最好也不要有中文。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(416, '什么是变量', '416', 1509543060, 1509543098, '<p>本文介绍在Shell中什么是变量。</p>\r<!--more-->\r\r<p>在小学或初中时，我们开始接触数学方程式，例如：已知x=1，y=x+1，那么y等于多少？</p>\r\r<p>在上述问题中，等号左边的x和y当时被称为未知数，但在Shell编程里它们是变量名，等号右边的1和x+1则是变量的内容(变量的值)。注意，这里的等号符号被称为赋值，而不是等号。</p>\r\r<p>通过上面的例子可以得出一个变量概念的小结论：简单的说，变量就是用一个固定的字符串(也可能是字符、数字等的组合)代替更多、更复杂的内容，该内容里可能还会包含变量、路径、字符串等其他的内容。</p>\r\r<p>变量是暂时存储数据的地方及数据标记，所存储的数据存在于内存空间中，通过正确地调用内存空间中变量的名字就可以取出与变量对应的数据。使用变量的最大好处就是使程序开发更为方便，当然，在编程中使用变量也是必须的，否则就很难完成相关的程序开发工作。</p>\r\r<p>下面是定义变量和打印变量的示例：</p>\r\r<pre class="brush:bash;">\roliver=&quot;I am oliver.&quot;\recho $oliver</pre>\r\r<p>变量的赋值方式为：先写变量名称，紧接着是&quot;=&quot;这个字符，最后是值，中间无任何空格，通过echo命令加上$oliver即可输出oliver变量的值，变量的内容一般要加双引号，以防止出错，特别是当值里的内容之间有空格时。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(417, 'Shell变量的特性', '417', 1509543156, 1509543156, '<p>本文介绍Shell变量的特性。</p>\r\r<!--more-->\r\r<p>默认情况下，在bash Shell中是不会区分变量类型的，例如：常见的变量类型为整数、字符串、小数等。这和其他强类型语言(例如：Java/C语言)是有区别的，当然，如果需要指定Shell变量的类型，也可以使用declare显示定义变量的类型，但在一般情况下没有这个需求，Shell开发者在开发脚本时需要自行注意Shell脚本中变量的类型。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 118),
(437, 'Shell脚本范例（十一）——菜单自动化软件部署', '437', 1512393120, 1513987790, '<p>本文分享常用的一些Shell脚本的例子，这是第十一篇&mdash;&mdash;菜单自动化软件部署。</p>\r<!--more-->\r\r<p>示例：</p>\r\r<pre class="brush:bash;">\r1. [install lamp]\r2. [install lamp]\r3. [exit]\rPlease input the num you want:</pre>\r\r<p>要求：</p>\r\r<p>1.当用户输入1时，输出&ldquo;start installing lamp.&rdquo;的提示，然后执行/usr/local/scripts/lamp.sh，脚本内容输出&ldquo;lamp is installed&rdquo;后推出脚本，也就是实际工作中使用的lamp一键安装脚本；</p>\r\r<p>2.<span style="color: rgb(51, 51, 51); font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;; font-size: 13px; background-color: rgb(255, 255, 255);">当用户输入2时，输出&ldquo;start installing lnmp.&rdquo;的提示，然后执行/usr/local/scripts/lnmp.sh，脚本内容输出&ldquo;lnmp is installed&rdquo;后推出脚本，也就是实际工作中使用的lnmp一键安装脚本；</span></p>\r\r<p><span style="color: rgb(51, 51, 51); font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;; font-size: 13px; background-color: rgb(255, 255, 255);">3.当用户输入3时，退出当前菜单及脚本；</span></p>\r\r<p><span style="color: rgb(51, 51, 51); font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;; font-size: 13px; background-color: rgb(255, 255, 255);">4.当用户输入任何其他字符时，给出提示&ldquo;Input error&rdquo;后退出脚本；</span></p>\r\r<p><span style="color: rgb(51, 51, 51); font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;; font-size: 13px; background-color: rgb(255, 255, 255);">5.对要执行的脚本进行相关的条件判断，例如：脚本文件是否存在，是否可执行等判断。</span></p>\r\r<p>准备：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rmkdir -p /usr/local/scripts/\r\rcd /usr/local/scripts/\recho &quot;echo lamp is installed&quot;&gt;lamp.sh\recho &quot;echo lnmp is installed&quot;&gt;lnmp.sh\rchmod +x lamp.sh lnmp.sh</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rpath=/usr/local/scripts/\r\r[ ! -d &quot;$path&quot; ] &amp;&amp; mkdir -p $path\r\rcat &lt;&lt;END\r    1.[install lamp]\r    2.[install lnmp]\r    3.[exit]\r    Please input the num you want:\rEND\r\rread num\rexpr $num + 10 &amp;&gt;/dev/null\r\r[ $? -ne 0 ] &amp;&amp; {\r    echo &quot;the num you input must be {1|2|3}&quot;\r    exit 1\r}\r\r[ $num -eq 1 ] &amp;&amp; {\r    echo &quot;start installing lamp.&quot;\r    sleep 2\r    [ -x &quot;$path/lamp.sh&quot; ] || {\r        echo &quot;$path/lamp.sh does not exist or can not be exec.&quot;\r        exit 1\r    }\r    $path/lamp.sh\r    exit $?\r}\r\r[ $num -eq 2 ] &amp;&amp; {\r    echo &quot;start installing lnmp.&quot;\r    sleep 2\r    [ -x &quot;$path/lnmp.sh&quot; ] || {\r        echo &quot;$path/lnmp.sh does not exist or can not be exec.&quot;\r        exit 1\r    }\r    $path/lnmp.sh\r    exit $?\r}\r\r[ $num -eq 3 ] &amp;&amp; {\r    echo bye.\r    exit 3\r}\r\r[[ ! $num =~ [1-3] ]] &amp;&amp; {\r    echo &quot;the num you input must be {1|2|3}&quot;\r    echo &quot;Input ERROR&quot;\r    exit 4\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(420, '《HTTP权威指南》PDF完整版下载', '420', 1511601420, 1528716759, '<p>本文分享一本学习HTTP协议的经典书籍&mdash;&mdash;《HTTP权威指南》。</p>\r<!--more-->\r\r<p>目录<br />\r第一部分 HTTP：Web的基础<br />\r第1章 HTTP概述 3<br />\r1.1 HTTP&mdash;&mdash;因特网的多媒体信使 4<br />\r1.2 Web客户端和服务器 4<br />\r1.3 资源 5<br />\r1.3.1 媒体类型 6<br />\r1.3.2 URI 7<br />\r1.3.3 URL 7<br />\r1.3.4 URN 8<br />\r1.4 事务 9<br />\r1.4.1 方法 9<br />\r1.4.2 状态码 10<br />\r1.4.3 Web页面中可以包含多个对象 10<br />\r1.5 报文 11<br />\r1.6 连接 13<br />\r1.6.1 TCP/IP 13<br />\r1.6.2 连接、IP地址及端口号 14<br />\r1.6.3 使用Telnet实例 16<br />\r1.7 协议版本 18<br />\r1.8 Web的结构组件 19<br />\r1.8.1 代理 19<br />\r1.8.2 缓存 20<br />\r1.8.3 网关 20<br />\r1.8.4 隧道 21<br />\r1.8.5 Agent代理 21<br />\r1.9 起始部分的结束语 22<br />\r1.10 更多信息 22<br />\r1.10.1 HTTP协议信息 22<br />\r1.10.2 历史透视 23<br />\r1.10.3 其他万维网信息 23<br />\r&nbsp;<br />\r第2章 URL与资源 25<br />\r2.1 浏览因特网资源 26<br />\r2.2 URL的语法 28<br />\r2.2.1 方案&mdash;&mdash;使用什么协议 29<br />\r2.2.2 主机与端口 30<br />\r2.2.3 用户名和密码 30<br />\r2.2.4 路径 31<br />\r2.2.5 参数 31<br />\r2.2.6 查询字符串 32<br />\r2.2.7 片段 33<br />\r2.3 URL快捷方式 34<br />\r2.3.1 相对URL 34<br />\r2.3.2 自动扩展URL 37<br />\r2.4 各种令人头疼的字符 38<br />\r2.4.1 URL字符集 38<br />\r2.4.2 编码机制 38<br />\r2.4.3 字符限制 39<br />\r2.4.4 另外一点说明 40<br />\r2.5 方案的世界 40<br />\r2.6 未来展望 42<br />\r2.7 更多信息 44<br />\r&nbsp;<br />\r第3章 HTTP报文 45<br />\r3.1 报文流 46<br />\r3.1.1 报文流入源端服务器 46<br />\r3.1.2 报文向下游流动 47<br />\r3.2 报文的组成部分 47<br />\r3.2.1 报文的语法 48<br />\r3.2.2 起始行 50<br />\r3.2.3 首部 53<br />\r3.2.4 实体的主体部分 55<br />\r3.2.5 版本0.9的报文 55<br />\r3.3 方法 56<br />\r3.3.1 安全方法 56<br />\r3.3.2 GET 56<br />\r3.3.3 HEAD 57<br />\r3.3.4 PUT 57<br />\r3.3.5 POST 58<br />\r3.3.6 TRACE 58<br />\r3.3.7 OPTIONS 60<br />\r3.3.8 DELETE 60<br />\r3.3.9 扩展方法 61<br />\r3.4 状态码 62<br />\r3.4.1 100～199&mdash;&mdash;信息性状态码 62<br />\r3.4.2 200～299&mdash;&mdash;成功状态码 63<br />\r3.4.3 300～399&mdash;&mdash;重定向状态码 64<br />\r3.4.4 400～499&mdash;&mdash;客户端错误状态码 68<br />\r3.4.5 500～599&mdash;&mdash;服务器错误状态码 69<br />\r3.5 首部 70<br />\r3.5.1 通用首部 71<br />\r3.5.2 请求首部 72<br />\r3.5.3 响应首部 74<br />\r3.5.4 实体首部 75<br />\r3.6 更多信息 77<br />\r&nbsp;<br />\r第4章 连接管理 79<br />\r4.1 TCP连接 80<br />\r4.1.1 TCP的可靠数据管道 80<br />\r4.1.2 TCP流是分段的、由IP分组传送 81<br />\r4.1.3 保持TCP连接的正确运行 82<br />\r4.1.4 用TCP套接字编程 84<br />\r4.2 对TCP性能的考虑 85<br />\r4.2.1 HTTP事务的时延 86<br />\r4.2.2 性能聚焦区域 87<br />\r4.2.3 TCP连接的握手时延 87<br />\r4.2.4 延迟确认 88<br />\r4.2.5 TCP慢启动 89<br />\r4.2.6 Nagle算法与TCP_NODELAY 89<br />\r4.2.7 TIME_WAIT累积与端口耗尽 90<br />\r4.3 HTTP连接的处理 91<br />\r4.3.1 常被误解的Connection首部 91<br />\r4.3.2 串行事务处理时延 92<br />\r4.4 并行连接 94<br />\r4.4.1 并行连接可能会提高页面的加载速度 94<br />\r4.4.2 并行连接不一定更快 95<br />\r4.4.3 并行连接可能让人&ldquo;感觉&rdquo;更快一些 95<br />\r4.5 持久连接 96<br />\r4.5.1 持久以及并行连接 96<br />\r4.5.2 HTTP/1.0+ keep-alive连接 97<br />\r4.5.3 Keep-Alive操作 98<br />\r4.5.4 Keep-Alive选项 98<br />\r4.5.5 Keep-Alive连接的限制和规则 99<br />\r4.5.6 Keep-Alive和哑代理 100<br />\r4.5.7 插入Proxy-Connection 102<br />\r4.5.8 HTTP/1.1持久连接 104<br />\r4.5.9 持久连接的限制和规则 104<br />\r4.6 管道化连接 105<br />\r4.7 关闭连接的奥秘 106<br />\r4.7.1 &ldquo;任意&rdquo;解除连接 106<br />\r4.7.2 Content-Length及截尾操作 107<br />\r4.7.3 连接关闭容限、重试以及幂等性 107<br />\r4.7.4 正常关闭连接 108<br />\r4.8 更多信息 110<br />\r4.8.1 HTTP连接 110<br />\r4.8.2 HTTP性能问题 110<br />\r4.8.3 TCP/IP 111<br />\r&nbsp;<br />\r第二部分 HTTP结构<br />\r&nbsp;<br />\r第5章 Web服务器 115<br />\r5.1 各种形状和尺寸的Web服务器 116<br />\r5.1.1 Web服务器的实现 116<br />\r5.1.2 通用软件Web服务器 117<br />\r5.1.3 Web服务器设备 117<br />\r5.1.4 嵌入式Web服务器 118<br />\r5.2 最小的Perl Web服务器 118<br />\r5.3 实际的Web服务器会做些什么 120<br />\r5.4 第一步&mdash;&mdash;接受客户端连接 121<br />\r5.4.1 处理新连接 121<br />\r5.4.2 客户端主机名识别 122<br />\r5.4.3 通过ident确定客户端用户 122<br />\r5.5 第二步&mdash;&mdash;接收请求报文 123<br />\r5.5.1 报文的内部表示法 124<br />\r5.5.2 连接的输入/输出处理结构 125<br />\r5.6 第三步&mdash;&mdash;处理请求 126<br />\r5.7 第四步&mdash;&mdash;对资源的映射及访问 126<br />\r5.7.1 docroot 127<br />\r5.7.2 目录列表 129<br />\r5.7.3 动态内容资源的映射 130<br />\r5.7.4 服务器端包含项 131<br />\r5.7.5 访问控制 131<br />\r5.8 第五步&mdash;&mdash;构建响应 131<br />\r5.8.1 响应实体 131<br />\r5.8.2 MIME类型 132<br />\r5.8.3 重定向 133<br />\r5.9 第六步&mdash;&mdash;发送响应 134<br />\r5.10 第七步&mdash;&mdash;记录日志 134<br />\r5.11 更多信息 134<br />\r&nbsp;<br />\r第6章 代理 135<br />\r6.1 Web的中间实体 136<br />\r6.1.1 私有和共享代理 136<br />\r6.1.2 代理与网关的对比 137<br />\r6.2 为什么使用代理 138<br />\r6.3 代理会去往何处 143<br />\r6.3.1 代理服务器的部署 144<br />\r6.3.2 代理的层次结构 144<br />\r6.3.3 代理是如何获取流量的 147<br />\r6.4 客户端的代理设置 148<br />\r6.4.1 客户端的代理配置：手工配置 149<br />\r6.4.2 客户端代理配置：PAC文件 149<br />\r6.4.3 客户端代理配置：WPAD 150<br />\r6.5 与代理请求有关的一些棘手问题 151<br />\r6.5.1 代理URI与服务器URI的不同 151<br />\r6.5.2 与虚拟主机一样的问题 152<br />\r6.5.3 拦截代理会收到部分URI 153<br />\r6.5.4 代理既可以处理代理请求，也可以处理服务器请求 154<br />\r6.5.5 转发过程中对URI的修改 154<br />\r6.5.6 URI的客户端自动扩展和主机名解析 155<br />\r6.5.7 没有代理时URI的解析 155<br />\r6.5.8 有显式代理时URI的解析 156<br />\r6.5.9 有拦截代理时URI的解析 157<br />\r6.6 追踪报文 158<br />\r6.6.1 Via首部 158<br />\r6.6.2 TRACE方法 162<br />\r6.7 代理认证 164<br />\r6.8 代理的互操作性 165<br />\r6.8.1 处理代理不支持的首部和方法 166<br />\r6.8.2 OPTIONS：发现对可选特性的支持 166<br />\r6.8.3 Allow首部 167<br />\r6.9 更多信息 167<br />\r&nbsp;<br />\r第7章 缓存 169<br />\r7.1 冗余的数据传输 170<br />\r7.2 带宽瓶颈 170<br />\r7.3 瞬间拥塞 171<br />\r7.4 距离时延 172<br />\r7.5 命中和未命中的 173<br />\r7.5.1 再验证 173<br />\r7.5.2 命中率 175<br />\r7.5.3 字节命中率 176<br />\r7.5.4 区分命中和未命中的情况 176<br />\r7.6 缓存的拓扑结构 177<br />\r7.6.1 私有缓存 177<br />\r7.6.2 公有代理缓存 177<br />\r7.6.3 代理缓存的层次结构 179<br />\r7.6.4 网状缓存、内容路由以及对等缓存 180<br />\r7.7 缓存的处理步骤 181<br />\r7.7.1 第一步&mdash;&mdash;接收 181<br />\r7.7.2 第二步&mdash;&mdash;解析 182<br />\r7.7.3 第三步&mdash;&mdash;查找 182<br />\r7.7.4 第四步&mdash;&mdash;新鲜度检测 182<br />\r7.7.5 第五步&mdash;&mdash;创建响应 182<br />\r7.7.6 第六步&mdash;&mdash;发送 183<br />\r7.7.7 第七步&mdash;&mdash;日志 183<br />\r7.7.8 缓存处理流程图 183<br />\r7.8 保持副本的新鲜 183<br />\r7.8.1 文档过期 184<br />\r7.8.2 过期日期和使用期 185<br />\r7.8.3 服务器再验证 185<br />\r7.8.4 用条件方法进行再验证 186<br />\r7.8.5 If-Modified-Since:Date再验证 187<br />\r7.8.6 If-None-Match：实体标签再验证 189<br />\r7.8.7 强弱验证器 190<br />\r7.8.8 什么时候应该使用实体标签和最近修改日期 190<br />\r7.9 控制缓存的能力 191<br />\r7.9.1 no-Store与no-Cache响应首部 191<br />\r7.9.2 max-age响应首部 192<br />\r7.9.3 Expires响应首部 192<br />\r7.9.4 must-revalidate响应首部 192<br />\r7.9.5 试探性过期 193<br />\r7.9.6 客户端的新鲜度限制 194<br />\r7.9.7 注意事项 194<br />\r7.10 设置缓存控制 195<br />\r7.10.1 控制Apache的HTTP首部 195<br />\r7.10.2 通过HTTP-EQUIV控制HTML缓存 196<br />\r7.11 详细算法 197<br />\r7.11.1 使用期和新鲜生存期 198<br />\r7.11.2 使用期的计算 198<br />\r7.11.3 完整的使用期计算算法 201<br />\r7.11.4 新鲜生存期计算 202<br />\r7.11.5 完整的服务器&mdash;&mdash;新鲜度算法 202<br />\r7.12 缓存和广告 204<br />\r7.12.1 发布广告者的两难处境 204<br />\r7.12.2 发布者的响应 204<br />\r7.12.3 日志迁移 205<br />\r7.12.4 命中计数和使用限制 205<br />\r7.13 更多信息 205<br />\r&nbsp;<br />\r第8章 集成点：网关、隧道及中继 207<br />\r8.1 网关 208<br />\r8.2 协议网关 210<br />\r8.2.1 HTTP/*：服务器端Web网关 211<br />\r8.2.2 HTTP/HTTPS：服务器端安全网关 212<br />\r8.2.3 HTTPS/HTTP客户端安全加速器网关 212<br />\r8.3 资源网关 213<br />\r8.3.1 CGI 215<br />\r8.3.2 服务器扩展API 215<br />\r8.4 应用程序接口和Web服务 216<br />\r8.5 隧道 217<br />\r8.5.1 用CONNECT建立HTTP隧道 217<br />\r8.5.2 数据隧道、定时及连接管理 219<br />\r8.5.3 SSL隧道 219<br />\r8.5.4 SSL隧道与HTTP/HTTPS网关的对比 220<br />\r8.5.5 隧道认证 221<br />\r8.5.6 隧道的安全性考虑 221<br />\r8.6 中继 222<br />\r8.7 更多信息 224<br />\r&nbsp;<br />\r第9章 Web机器人 225<br />\r9.1 爬虫及爬行方式 226<br />\r9.1.1 从哪儿开始：根集 226<br />\r9.1.2 链接的提取以及相对链接的标准化 227<br />\r9.1.3 避免环路的出现 228<br />\r9.1.4 循环与复制 228<br />\r9.1.5 面包屑留下的痕迹 229<br />\r9.1.6 别名与机器人环路 230<br />\r9.1.7 规范化URL 230<br />\r9.1.8 文件系统连接环路 231<br />\r9.1.9 动态虚拟Web空间 232</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1_ss9PiAsxMsAV7LCSwVNzQ" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 380),
(421, '《基督山伯爵》AZW完整版下载', '421', 1511666040, 1528716594, '<p>本文分享一本名著&mdash;&mdash;《基督山伯爵》。</p>\r<!--more-->\r\r<p>目录</p>\r\r<p>第一章　船到马赛<br />\r第二章　父与子<br />\r第三章　迦太罗尼亚人的村庄<br />\r第四章　阴谋<br />\r第五章　婚宴<br />\r第六章　代理检察官<br />\r第七章　审问<br />\r第八章　伊夫堡<br />\r第九章　订婚之夜<br />\r第十章　杜伊勒里宫的小书房<br />\r第十一章　科西嘉岛的魔王<br />\r第十二章　父与子<br />\r第十三章　百日<br />\r第十四章　两犯人<br />\r第十五章　三十四号和二十七号<br />\r第十六章　一位意大利学者<br />\r第十七章　神甫的房间<br />\r第十八章　宝藏<br />\r第十九章　第三次发病<br />\r第二十章　伊夫堡的坟场<br />\r第二十一章　狄布伦岛<br />\r第二十二章　走私贩子<br />\r第二十三章　基督山小岛<br />\r第二十四章　秘密洞窟<br />\r第二十五章　陌生人<br />\r第二十六章　杜加桥客栈<br />\r第二十七章　回忆往事<br />\r第二十八章　监狱档案<br />\r第二十九章　摩莱尔父子公司<br />\r第三十章　九月五日<br />\r第三十一章　意大利：水手辛巴德<br />\r第三十二章　醒来<br />\r第三十三章　罗马强盗<br />\r第三十四章　显身<br />\r第三十五章　锤刑<br />\r第三十六章　狂欢节在罗马<br />\r第三十七章　圣&middot;塞巴斯蒂安的陵墓<br />\r第三十八章　约会<br />\r第三十九章　来宾<br />\r第四十章　早餐<br />\r第四十一章　介绍<br />\r第四十二章　贝尔图乔先生<br />\r第四十三章　欧特伊别墅<br />\r第四十四章　为亲人复仇<br />\r第四十五章　血雨<br />\r第四十六章　无限贷款<br />\r第四十七章　灰斑马<br />\r第四十八章　人生观<br />\r第四十九章　海黛<br />\r第五十章　莫雷尔一家<br />\r第五十一章　巴雷穆斯和狄丝琵①<br />\r第五十二章　毒药学<br />\r第五十三章　《恶棍罗勃脱》<br />\r第五十四章　公债风波<br />\r第五十五章　卡瓦尔康蒂少校<br />\r第五十六章　安德烈&middot;卡瓦尔康蒂<br />\r第五十七章　幽会<br />\r第五十八章　诺瓦蒂埃&middot;德&middot;维尔福先生<br />\r第五十九章　遗嘱<br />\r第六十章　急报<br />\r第六十一章　帮园艺家摆脱睡鼠<br />\r第六十二章　幽灵<br />\r第六十三章　晚宴<br />\r第六十四章　乞丐<br />\r第六十五章　夫妇间的一幕<br />\r第六十六章　婚姻计划<br />\r第六十七章　检察官的办公室<br />\r第六十八章　夏季舞会<br />\r第六十九章　调查<br />\r第七十章　舞会<br />\r第七十一章　面包和盐<br />\r第七十二章　圣&middot;梅朗夫人<br />\r第七十三章　诺言<br />\r第七十四章　维尔福家族之墓<br />\r第七十五章　会议纪要<br />\r第七十六章　小卡瓦尔康蒂的进展<br />\r第七十七章　海黛<br />\r第七十八章　亚尼纳来的消息<br />\r第七十九章　柠檬水<br />\r第八十章　控诉<br />\r第八十一章　一位退休的面包师<br />\r第八十二章　夜盗<br />\r第八十三章　上帝的手<br />\r第八十四章　波尚<br />\r第八十五章　旅行<br />\r第八十六章　审问<br />\r第八十七章　挑衅<br />\r第八十八章　侮辱<br />\r第八十九章　夜<br />\r第九十章　决斗<br />\r第九十一章　母与子<br />\r第九十二章　自杀<br />\r第九十三章　瓦朗蒂娜<br />\r第九十四章　吐露真情<br />\r第九十五章　父与女<br />\r第九十六章　婚约<br />\r第九十七章　去比利时<br />\r第九十八章　钟瓶旅馆<br />\r第九十九章　法律<br />\r第一○○章显身<br />\r第一○一章　赤练蛇<br />\r第一○二章　瓦朗蒂娜<br />\r第一○三章　马西米兰<br />\r第一○四章　腾格拉尔的签字<br />\r第一○五章　公墓<br />\r第一○六章　财产分享<br />\r第一○七章　狮穴<br />\r第一○八章　法官<br />\r第一○九章　开庭<br />\r第一一○章起诉书<br />\r第一一一章　抵罪<br />\r第一一二章　离开<br />\r第一一三章　往事<br />\r第一一四章　庇皮诺<br />\r第一一五章　罗吉&middot;万帕的菜单<br />\r第一一六章　宽恕<br />\r第一一七章　十月五日</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1RIY1oiu7jvfeILmBWQKhOA" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 146),
(423, 'Shell脚本范例（一）——批量生成随机字符文件名', '423', 1511778360, 1513394248, '<p>本文分享常用的一些Shell脚本的例子，这是第一篇&mdash;&mdash;批量生成随机字符文件名。</p>\r<!--more-->\r\r<p>要求：使用for循环在/tmp目录下批量创建10个html文件，其中每个文件需要包含10个随机小写字母加固定字符串oliver。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rPath=/tmp\r\r[ -d &quot;$Path&quot;] || mkdir -p $Path\r\rfor n in `seq 10`\rdo\r    random=$(openssl rand -base64 40|sed &#39;s#[^a-z]##g&#39;|cut -c 2-11)\r    touch $Path/${random}_oldboy.html\rdone</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(425, 'Shell脚本范例（二）——批量文件改名', '425', 1511779680, 1512391884, '<p>本文分享常用的一些Shell脚本的例子，这是第二篇&mdash;&mdash;批量文件改名。</p>\r<!--more-->\r\r<p>要求：将范例一所得文件名中的oliver字符串全部改成cathy（最好用for循环实现），并且将扩展名html全部改成大写。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rFilename=_cathy.HTML\rDirname=&quot;/tmp&quot;\r\rcd $Dirname || exit 1\r\rfor n in `ls`\rdo\r    name=$(echo ${n}|awk -F &#39;_&#39; &#39;{print $1}&#39;)\r    mv $n ${name}${Filename}\rdone</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rPath=&quot;/tmp&quot;\rcd $Path $$ ls|awk -F &#39;_&#39; &#39;{print &quot;mv &quot;$0&quot; &quot;$1&quot;_cathy.HTML&quot;}&#39;|bash</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rrename oliver.html cathy.HTML /tmp/*.html</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 187),
(426, 'Shell脚本范例（三）——批量创建用户', '426', 1511782260, 1512391878, '<p><span style="color: rgb(102, 102, 102); font-family: &quot;microsoft yahei&quot;, Georgia, &quot;Times New Roman&quot;, STHeiti, serif; font-size: 14px;">本文分享常用的一些Shell脚本的例子，这是第三篇&mdash;&mdash;批量创建用户。</span></p>\r<!--more-->\r\r<p><font color="#666666" face="microsoft yahei, Georgia, Times New Roman, STHeiti, serif"><span style="font-size: 14px;">要求：批量创建10个系统账户（user01-user02）并设置密码（密码为随机数，要求是字符和数字等的混合）。</span></font></p>\r\r<p><font color="#666666" face="microsoft yahei, Georgia, Times New Roman, STHeiti, serif"><span style="font-size: 14px;">参考：</span></font></p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rUser=&quot;user&quot;\rPassfile=&quot;/tmp/user.log&quot;\r\rfor num in `seq -w 10`\rdo\r    useradd $user$num\r    pass=&quot;`echo &quot;test$RANDOM&quot;|md5sum|cut -c 3-11`&quot;\r    echo &quot;$pass&quot;|passwd --stdin $user$num\r    echo -e &quot;user:$user$num\\tpasswd:$pass&quot; &gt;&gt; $passfile\rdone\r\rcat $passfile &amp;&amp; &gt;$passfile</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\r. /etc/init.d/functions\r\ruser=&quot;user&quot;\rpassfile=&quot;/tmp/user.log&quot;\r\rfor num in `seq -w 11 15`\rdo\r    pass=&quot;`echo &quot;test$RANDOM&quot;|md5sum|cut -c3-11`&quot;\r    useradd $user$num &amp;&gt; /dev/null &amp;&amp;\\\r        echo &quot;$pass&quot;|passwd --stdin $user$num &amp;&gt; /dev/null &amp;&amp;\\\r        echo -e &quot;user:$user$num\\tpasswd:$pass&quot;&gt;&gt;$passfile\r    if [ $? -eq 0 ]\r    then\r        action &quot;$user$num is ok&quot; /bin/true\r    else\r        action &quot;$user$num is fail&quot; /bin/false\r    fi\rdone\r\rcat $passfile &amp;&amp; &gt;$passfile</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\r. /etc/init.d/functions\r\ruser=&quot;oliver&quot;\rpassfile=&quot;/tmp/user.log&quot;\r\rfor num in `seq -w 10`\rdo\r    pass=&quot;`echo &quot;test$RANDOM&quot;|md5sum|cut -c3-11`&quot;\r    useradd $user$num &amp;&gt; /dev/null &amp;&amp;\\\r        echo -e &quot;$user${num}:$pass&quot; &gt;&gt; $passfile\r    if [ $? -eq 0 ]\r    then\r        action &quot;$user$num is ok&quot; /bin/true\r    else\r        action &quot;$user$num is fail&quot; /bin/true\r    fi\rdone\r\rchpasswd &lt; $passfile\rcat $passfile &amp;&amp; &gt;$passfile</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 127),
(427, 'Shell脚本范例（四）——扫描网络内存活主机', '427', 1511783580, 1512391871, '<p><span style="color: rgb(102, 102, 102); font-family: &quot;microsoft yahei&quot;, Georgia, &quot;Times New Roman&quot;, STHeiti, serif; font-size: 14px; background-color: rgb(255, 255, 255);">本文分享常用的一些Shell脚本的例子，这是第四篇&mdash;&mdash;扫描网络内存活主机。</span></p>\r<!--more-->\r\r<p><font color="#666666" face="microsoft yahei, Georgia, Times New Roman, STHeiti, serif"><span style="font-size: 14px;">要求：写一个Shell脚本，判断10.0.0.0/24网络里当前在线的IP有哪些？</span></font></p>\r\r<p><font color="#666666" face="microsoft yahei, Georgia, Times New Roman, STHeiti, serif"><span style="font-size: 14px;">参考：</span></font></p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rCMD=&quot;ping -W 2 -c 2&quot;\rIp=&quot;10.0.0.&quot;\r\rfor n in $(seq 254)\rdo\r    {\r        $CMD $Ip$n &amp;&gt; /dev/null\r        if [ $? -eq 0 ];then\r            echo &quot;$Ip$n is ok&quot;\r        fi\r    }&amp;\rdone</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rCMD=&quot;nmap -sP &quot;\rIp=&quot;10.0.0.0/24&quot;\r$CMD $Ip|awk &#39;/Nmap scan report for/ {print $NF}&#39;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 154),
(429, 'Shell脚本范例（五）——解决DoS攻击', '429', 1511874420, 1512391862, '<p>本文分享常用的一些Shell脚本的例子，这是第五篇&mdash;&mdash;解决DoS攻击。</p>\r<!--more-->\r\r<p>要求：写一个Shell脚本解决类DDoS攻击的生产案例。请根据Web日志或系统连接数，监控某个IP的并发连接数，若短时间内PV达到100，即调用防火墙命令封掉对应的IP（命令为：iptables -I INPUT -s ip -j DROP）。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rfile=$1\rwhile true\rdo\r    awk &#39;{print $1}&#39; $1|grep -v &quot;^$&quot;|sort|uniq -c &gt; /tmp/tmp.log\r    exec &lt; /tmp/tmp.log\r    while read line\r    do\r        ip=`echo $line|awk &#39;{print $2}&#39;`\r        count=`echo $line|awk &#39;{print $1}&#39;`\r        if [ $count -gt 500 ] &amp;&amp; [ `iptables -L -n|grep &quot;$ip&quot;|wc -l` -lt 1 ]\r        then\r            iptables -I INPUT -s $ip -j DROP\r            echo &quot;$line is dropped&quot; &gt;&gt; /tmp/droplist_$(date +%F).log\r        fi\r    done\r    sleep 3600\rdone</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rfile=$1\r\rif expr &quot;$file&quot; : &quot;.*\\.log&quot; &amp;&gt; /dev/null\rthen\r    :\relse\r    echo &quot;usage:$0 xxx.log&quot;\r    exit 1\rfi\r\rwhile true\rdo\r    grep &quot;ESTABLISHED&quot; $1|awk -F &quot;[ :]+&quot; &#39;{ ++S[$(NF-3)]}END {for(key in S)print S[key],key}&#39;|sort -rn -k1|head -5 &gt; /tmp/tmp.log\r    while read line\r    do\r        ip=`echo $line|awk &#39;{print $1}&#39;`\r        count=`echo $line|awk &#39;{print $1}&#39;`\r        if [ $count -gt 500 ] &amp;&amp; [ `iptables -L -n|grep &quot;$ip&quot;|wc -l` -lt 1 ]\r        then\r            iptables -I INPUT -s $ip -j DROP\r            echo &quot;$line is dropped&quot; &gt;&gt; /tmp/droplist_$(date +%F).log\r        fi\r    done&lt;/tmp/tmp.log\r    sleep 180\rdone</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rfile=$1\r\rfunction JudgeExt(){\r    if expr &quot;$1&quot; : &quot;.*\\.log&quot; &amp;&gt; /dev/null\r    then\r        :\r    else\r        echo &quot;usage:$0 xxx.log&quot;\r        exit 1\r    fi\r}\r\rfunction IpCount(){\r    grep &quot;ESTABLISHED&quot; $1|awk -F &quot;[ :]+&quot; &#39;{ ++S[$(NF-3)]}END {for(key in S)print S[key], key}&#39;|sort -rn -k1|head -5 &gt; /tmp/tmp.log\r}\r\rfunction ipt(){\r    local ip=$1\r    if [ `iptables -L -n|grep &quot;$ip&quot;|wc -l` -lt 1 ]\r    then\r        iptables -I INPUT -s $ip -j DROP\r        echo &quot;$line is dropped&quot; &gt;&gt; /tmp/droplist_$(date +%F).log\r    fi\r}\r\rfunction main(){\r    JudgeExt $file\r    while true\r    do\r        ip=`echo $line|awk &#39;{print $2}&#39;`\r        count=`echo $line|awk &#39;{print $1}&#39;`\r        if [ $count -gt 3 ]\r        then\r            ipt $ip\r        fi\r    done&lt;/tmp/tmp.log\r    sleep 180\r}\r\rmain</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 155),
(585, 'ArrayList03.png', 'ArrayList03-png', 1519524189, 1519524189, 'a:5:{s:4:"name";s:15:"ArrayList03.png";s:4:"path";s:35:"/usr/uploads/2018/02/3978007625.png";s:4:"size";i:118295;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 580, 0),
(431, 'Shell脚本范例（六）——MySQL分库备份', '431', 1511880120, 1512391855, '<p>本文分享常用的一些Shell脚本的例子，这是第六篇&mdash;&mdash;MySQL分库备份。</p>\r<!--more-->\r\r<p>要求：请用脚本实现对MySQL数据库的分库备份。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rPATH=&quot;/usr/local/mysql/bin:$PATH&quot;\rDBPATH=/tmp/backup\rMYUSER=root\rMYPASS=password\rSOCKET=/usr/local/mysql/data/mysql.sock\rMYCMD=&quot;mysql -u$MYUSER -p$MYPASS -S $SOCKET&quot;\rMYDUMP=&quot;mysqldump -u$MYUSER -p$MYPASS -S $SOCKET&quot;\r\r[ ! -d &quot;$DBPATH&quot; ] &amp;&amp; mkdir -p $DBPATH\r\rfor dbname in `MYCMD -e &quot;show databases;&quot;|sed &#39;1,2d&#39;|egrep -v &quot;mysql|schema&quot;`\rdo\r    $MYDUMP $dbname|gzip &gt; $DBPATH/${dbname}_$(date +%F).sql.gz\rdone</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(435, 'Shell脚本范例（九）——MySQL主从复制异常监控', '435', 1512384840, 1512391819, '<p><span style="color: rgb(102, 102, 102); font-family: &quot;microsoft yahei&quot;, Georgia, &quot;Times New Roman&quot;, STHeiti, serif; font-size: 14px; background-color: rgb(255, 255, 255);">本文分享常用的一些Shell脚本的例子，这是第九篇&mdash;&mdash;MySQL主从复制异常监控。</span></p>\r<!--more-->\r\r<p><font color="#666666" face="microsoft yahei, Georgia, Times New Roman, STHeiti, serif"><span style="font-size: 14px;">要求：开发一个守护进程脚本，每30秒监控一次MySQL主从复制是否异常（包括不同步及延迟），如果异常，则发送短信并发送邮件给管理员存档。</span></font></p>\r\r<p><font color="#666666" face="microsoft yahei, Georgia, Times New Roman, STHeiti, serif"><span style="font-size: 14px;">参考：</span></font></p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rcount=0\rstatus=($(awk -F &#39;:&#39; &#39;/_Running|_Behind/{print $NF}&#39; slave.log))\r\rfor((i=0;i&lt;${#status[*]};i++))\rdo\r    if [ &quot;${status[${i}]}&quot; != &quot;Yes&quot; -a &quot;${status[${i}]}&quot; != &quot;0&quot; ]\r    then\r        let count+=1\r    fi\rdone\r\rif [ $count -ne 0 ]\rthen\r    echo &quot;mysql replcation is faild&quot;\relse\r    echo &quot;mysql replcation is success&quot;\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rfunction CheckDB(){\r    count=0\r    status=($(awk -F &#39;:&#39; &#39;/_Running|_Behind/{print $NF}&#39; slave.log))\r\r    for((i=0;i&lt;${#status[*]};i++))\r    do\r        if [ &quot;${status[${i}]}&quot; != &quot;Yes&quot; -a &quot;${status[${i}]}&quot; != &quot;0&quot; ]\r        then\r            let count+=1\r        fi\r    done\r\r    if [ $count -ne 0 ]\r    then\r        echo &quot;mysql replcation is faild&quot;\r        return 1\r    else\r        echo &quot;mysql replcation is success&quot;\r        return 0\r    fi\r}\r\rfunction main(){\r    while true\r    do\r        CheckDB\r        sleep 30\r    done\r}\r\rmain</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rpath=/server/scripts\rMAIL_GROUP=&quot;oliver.csu@gmail.com&quot;\rPAGER_GROUP=&quot;18888888888 18666666666&quot;\rLOG_FILE=&quot;/tmp/web_check.log&quot;\rUSER=root\rPASSWORD=password\rPORT=3307\rMYSQLCMD=&quot;mysql -u$USER -p$PASSWORD -S /data/$PORT/mysql.sock&quot;\r\rerror=(1008 1007 1062)\rRETVAL=0\r\r[ ! -d &quot;$path&quot; ] &amp;&amp; mkdir -p $path\r\rfunction JudgeError(){\r    for((i=0;i&lt;${#error[*]};i++))\r    do\r        if [ &quot;$1&quot; == &quot;${error[$i]}&quot; ]\r        then\r            echo &quot;MySQL slave errorno is $1, auto repairing it.&quot;\r            $MYSQLCMD -e &quot;stop slave;set global sql_slave_skip_counter=1;start slave;&quot;\r        fi\r    done\r    return $1\r}\r\rfunction CheckDb(){\r    status=($(awk -F &#39;:&#39; &#39;/_Running|Last_Errno|_Behind/{print $NF}&#39; slave.log))\r    expr ${status[3]} + 1 &amp;&gt; /dev/null\r    if [ $? -ne 0 ]\r    then\r        status[3]=300\r    fi\r    if [ &quot;${status[0]}&quot; == &quot;Yes&quot; -a &quot;${status[1]}&quot; == &quot;Yes&quot; -a &quot;{status[3]} -lt 120 ]\r    then\r       return 0\r   else\r      JudgeError ${status[2]}\r  fi \r}\r\rfunction MAIL(){\r    local SUBJECT_CONTENT=$1\r    for MAIL_USER in `echo $MAIL_GROUP`\r    do\r        mail -s &quot;$SUBJECT_CONTENT &quot; $MAIL_USER &lt; $LOG_FILE\r    done\r}\r\rfunction PAGER(){\r    for PAGER_USER in `echo $PAGER_GROUP`\r    do\r        TITLE=$1\r        CONTACT=$PAGER_USER\r        HTTPGW=http://oliver.sms.cn/smsproxy/sendsms.action\r        curl -d cdkey=5ADF-EFA -d password=OLDBOY -d phone=$CONTACT -d message=&quot;$TITLE[$2]&quot; $HTTPGW\r    done    \r}\r\rfunction SendMsg(){\r    if [ $1 -ne 0 ]\r    then\r        RETVAL=1\r        NOW_TIME=`date +&quot;%Y-%m-%d %H:%M:%S&quot;`\r        SUBJECT_CONTENT=&quot;mysql slave is error, errorno is $2, ${NOW_TIME}.&quot;\r        echo -e &quot;$SUBJECT_CONTENT&quot;|tee $LOG_FILE\r        MAIL $SUBJECT_CONTENT\r        PAGER $SUBJECT_CONTENT $NOW_TIME\r    else\r        echo &quot;MySQL slave status is ok&quot;\r        RETVAL=0\r    fi\r    return $RETVAL\r}\r\rfunction main(){\r    while true\r    do\r        CheckDb\r        SendMsg $?\r        sleep 30\r    done\r}\r\rmain</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 153),
(436, 'Shell脚本范例（十）——比较整数大小', '436', 1512391680, 1512393083, '<p>本文分享常用的一些Shell脚本的例子，这是第十篇&mdash;&mdash;比较整数大小。</p>\r<!--more-->\r\r<p>要求：开发Shell脚本分别实现以脚本传参及read读入的方式比较2个整数大小。用条件表达式（禁止if）进行判断并以屏幕输出的方式告知用户比较的结果。</p>\r\r<p>注意：一共要开发两个脚本。当使用脚本传参及read读入的方式时，需要对变量是否为数字，以及传参个数是否正确给予提示。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rread -p &quot;Please input two num:&quot; a b\r\r[ -z &quot;$a&quot; ] || [ -z &quot;$b&quot; ] &amp;&amp; {\r    echo &quot;Please input two num again.&quot;\r    exit 1\r}\r\rexpr $a + 10 &amp;&gt; /dev/null\r\rRETVAL1=$?\r\rexpr $b + 10 &amp; &gt; /dev/null\r\rRETVAL2=$?\r\rtest $RETVAL1 -eq 0 -a $RETVAL2 -eq 0 || {\r    echo &quot;Please input two num again.&quot;\r    exit 2\r}\r\r[ $a -lt $b ] &amp;&amp; {\r    echo &quot;$a &lt; $b&quot;\r    exit 0\r}\r\r[ $a -eq $b ] &amp;&amp; {\r    echo &quot;$a = $b&quot;\r    exit 0\r}\r\r[ $a -gt $b ] &amp;&amp; {\r    echo &quot;$a &gt; $b&quot;\r    exit 0\r}</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\ra=$1\rb=$2\r\r[ $# -ne 2 ] &amp;&amp; {\r    echo &quot;USAGE:$0 NUM1 NUM2&quot;\r    exit 1\r}\r\rexpr $a + 10 &amp;&gt; /dev/null\r\rRETVAL1=$?\r\rexpr $b + 10 &amp; &gt; /dev/null\r\rRETVAL2=$?\r\rtest $RETVAL1 -eq 0 -a $RETVAL2 -eq 0 || {\r    echo &quot;Please input two num again.&quot;\r    exit 2\r}\r\r[ $a -lt $b ] &amp;&amp; {\r    echo &quot;$a &lt; $b&quot;\r    exit 0\r}\r\r[ $a -eq $b ] &amp;&amp; {\r    echo &quot;$a = $b&quot;\r    exit 0\r}\r\r[ $a -gt $b ] &amp;&amp; {\r    echo &quot;$a &gt; $b&quot;\r    exit 0\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 127),
(438, 'Shell脚本范例（十二）——MySQL服务异常监测', '438', 1512440520, 1513987782, '<p>本文分享常用的一些Shell脚本的例子，这是第十二篇&mdash;&mdash;MySQL服务异常监测。</p>\r<!--more-->\r\r<p>要求：用if条件语句对MySQL数据库服务是否正常进行检测，如果服务未启动，则启动相应的服务。</p>\r\r<p>准备：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\ryum -y install mysql-server\r\r/etc/init.d/mysqld start</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\ryum -y install mysql-server\r\r/etc/init.d/mysqld start\rOlivers-MacBook:Shell-Examples oliver$ cat 12-1.sh \r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [`netstat -lnt|grep 3306|awk -F &quot;[ :]+&quot; &#39;{print $5}&#39;` -eq 3306 ]\rthen\r    echo &quot;MySQL is Running.&quot;\relse\r    echo &quot;MySQL is Stopped.&quot;\r    /etc/init.d/mysqld start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ &quot;`netstat -lnt|grep 3306|awk -F &quot;[ :]+&quot; &#39;{print $5}&#39;`&quot; = &quot;3306&quot; ]\rthen\r    echo &quot;MySQL is Running.&quot;\relse\r    echo &quot;MySQL is Stopped.&quot;\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `netstat -lntup|grep mysqld|wc -l` -gt 0 ]\rthen\r    echo &quot;MySQL is Running.&quot;\relse\r    echo &quot;MySQL is Stopped.&quot;\r    /etc/init.d/mysqld start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `lsof -i tcp:3306|wc -l` -gt 0 ]\rthen\r    echo &quot;MySQL is Running.&quot;\relse\r    echo &quot;MySQL is Stopped.&quot;\r    /etc/init.d/mysqld start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\r[ `rpm -qa nmap|wc -l` -lt 1 ] &amp;&amp; yun -y install nmap &amp;&gt; /dev/null\r\rif [ `nmap 127.0.0.1 -p 3306 2&gt; /dev/null|grep open|wc -l` -gt 0 ]\rthen\r    echo &quot;MySQL is Running.&quot;\relse\r    echo &quot;MySQL is Stopped.&quot;\r    /etc/init.d/mysqld start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\r[ `rpm -qa nc|wc -l` -lt 1 ] &amp;&amp; yum -y install nc &amp;&gt; /dev/null\r\rif [ `nc -w 2 127.0.0.1 3306 &amp;&gt; /dev/null &amp;&amp; echo ok|grep ok|wc -l` -gt 0 ]\rthen\r    echo &quot;MySQL is Running.&quot;\relse\r    echo &quot;MySQL is Stopped.&quot;\r    /etc/init.d/mysqld start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `ps -ef|grep -v grep|grep mysql|wc -l` -gt 0 ]\rthen\r    echo &quot;MySQL is Running.&quot;\relse\r    echo &quot;MySQL is Stopped.&quot;\r    /etc/init.d/mysqld start\rfi</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 136),
(439, 'Shell脚本范例（十三）——Web服务异常监测', '439', 1512454860, 1513987774, '<p>本文分享常用的一些Shell脚本的例子，这是第十三篇&mdash;&mdash;Web服务异常监测。</p>\r<!--more-->\r\r<p>要求：用if条件语句对MySQL数据库服务是否正常进行检测，如果服务未启动，则启动相应的服务。</p>\r\r<p>准备：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\r[ `rpm -qa wget|wc -l` -lt 1 ] &amp;&amp; yum -y install wget &amp;&gt; /dev/null\r\rwget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo\ryum -y install nginx\r/etc/init.d/nginx start\recho &quot;success&quot; &gt; /usr/share/nginx/html/index.html</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `netstat -lnt|grep 80|awk -F &quot;[ :]+&quot; &#39;{print $5}&#39;` -eq 80 ]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ &quot;`netstat -lnt|grep 80|awk -F &quot;[ :]+&quot; &#39;{print $5}&#39;`&quot; = &quot;80&quot; ]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\r    /etc/init.d/nginx start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `netstat -lntup|grep nginx|wc -l` -gt 0 ]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\r    /etc/init.d/nginx start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `lsof -i tcp:80|wc -l` -gt 0 ]\rthen\r    echo &quot;Nginx is Running&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\r    /etc/init.d/nginx start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\r[ `rpm -qa nmap|wc -l` -lt 1` ] &amp;&amp; yum -y install nmap &amp;&gt; /dev/null\r\rif [ `nmap 127.0.0.1 -p 80 2&gt; /dev/null|grep open|wc -l` -gt 0 ]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\r[ `rpm -qa nc|wc -l` -lt 1 ] &amp;&amp; yum -y install nc &amp;&gt; /dev/null\r\rif [ `nc -w 2 127.0.0.1 80 &amp;&gt; /dev/null &amp;&amp; echo ok|grep ok|wc -l` -gt 0 ]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\r    /etc/init.d/nginx start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `ps -ef|grep -v grep|grep nginx|wc -l` -ge 1 ]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\r    /etc/init.d/nginx start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [[ `curl -I -s -o /dev/null -w &quot;%{http_code}\\n&quot; http://127.0.0.1` =~ [23]0[012] ]]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\r    /etc/init.d/nginx start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `curl -I http://127.0.0.1 2&gt; /dev/null|head -1|egrep &quot;200|301|302&quot;|wc -l` -eq 1 ]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\r    /etc/init.d/nginx start\rfi</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ &quot;`curl -s http://127.0.0.1`&quot; = &quot;susscess&quot; ]\rthen\r    echo &quot;Nginx is Running.&quot;\relse\r    echo &quot;Nginx is Stopped.&quot;\r    /etc/init.d/nginx start\rfi</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(440, 'Shell脚本范例（十四）——监控Memcached缓存服务', '440', 1512455940, 1513987765, '<p>本文分享常用的一些Shell脚本的例子，这是第十四篇&mdash;&mdash;监控Memcached缓存服务。</p>\r<!--more-->\r\r<p>要求：监控Memcached缓存服务是否正常，模拟用户（Web客户端）检测。</p>\r\r<p>准备：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\ryum -y install memcached\ryum -y install nc\rmemcached -uroot -m 16 -p 11211\rnetstat -lntup|grep memcache</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ `netstat -lntup|grep 11211|wc -l` -lt 1 ]\rthen\r    echo &quot;Memcached Service is error.&quot;\r    exit 1\rfi\r\rprintf &quot;del key\\r\\n&quot;|nc 127.0.0.1 11211 &amp;&gt; /dev/null\rprintf &quot;set key 0 0 10 \\r\\noliver\\r\\n&quot;|nc 127.0.0.1 11211 &amp;&gt; /dev/null\r\rMcValues=`printf &quot;get key\\r\\n&quot;|nc 127.0.0.1 11211|grep oliver|wc -l`\r\rif [ $McValues -eq 1 ]\rthen\r    echo &quot;Memcached status is ok.&quot;\relse\r    echo &quot;Memcached status is bad.&quot;\rfi</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(443, 'Shell脚本范例（十六）——rsync服务启动脚本', '443', 1512559500, 1513987749, '<p>本文分享常用的一些Shell脚本的例子，这是第十六篇&mdash;&mdash;编写rsync服务启动脚本。</p>\r<!--more-->\r\r<p>要求：写出网络服务独立进程模式下rsync的系统启动脚本，例如：/etc/init.d/rsyncd {start|stop|restart}。</p>\r\r<ol>\r	<li>要使用系统函数库技巧；</li>\r	<li>要用函数，不能将一堆代码混在一起；</li>\r	<li>可被chkconfig管理。</li>\r</ol>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r# chkconfig: 2345 20 80\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rif [ $# -ne 1 ]\rthen\r    echo &quot;usage:$0 {start|stop|restart}&quot;\r    exit 1\rfi\r\rif [ &quot;$1&quot; = &quot;start&quot; ]\rthen\r    rsync --daemon\r    sleep 2\r    if [ `netstat -lntup|grep rsync|wc -l` -ge 1 ]\r    then\r        echo &quot;rsync is started.&quot;\r        exit 0\r    fi\relif [ &quot;$1&quot; = &quot;stop&quot; ]\rthen\r    killall rsync &amp;&gt; /dev/null\r    sleep 2\r    if [ `netstat -lntup|grep rsync|wc -l` -eq 0 ]\r    then\r        echo &quot;rsyncd is stopped.&quot;\r        exit 0\r    fi\relif [ &quot;$1&quot; = &quot;restart&quot; ]\rthen\r    killall rsync\r    sleep 1\r    killpro=`netstat -lntup|grep rsync|wc -l`\r    rsync --daemon\r    sleep 1\r    startpro=`netstat -lntup|grep rsync|wc -l`\r    if [ $killpro -eq 0 -a $startpro -ge 1 ]\r    then\r        echo &quot;rsync is restarted.&quot;\r        exit 0\r    fi\relse\r    echo &quot;usage:$0 {start|stop|restart}&quot;\r    exit 1\rfi</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 135),
(444, 'Shell脚本范例（十七）——MySQL多实例启动脚本', '444', 1512559800, 1513987742, '<p>本文分享常用的一些Shell脚本的例子，这是第十七篇&mdash;&mdash;编写MySQL多实例启动脚本。</p>\r<!--more-->\r\r<p>要求：用函数、case语句、if条件语句实现MySQL多实例启动脚本。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rPort=3306\rMySQLUser=&quot;root&quot;\rMySQLPass=&quot;password&quot;\rMySQLPath=&quot;/usr/local/mysql/bin&quot;\r\rfunction start(){\r    if [ `netstat -lnt|grep &quot;$Port&quot;|wc -l` -eq 0 ]\r    then\r        printf &quot;Starting MySQL...\\n&quot;\r        /bin/sh ${MySQLPath}/mysql_safe --defaults-file=/data/{$Port}/my.cnf &amp;&gt; /dev/null &amp;\r    else\r        printf &quot;MySQL is running...\\n&quot;\r    fi\r}\r\rfunction stop(){\r    if [ ! `netstat -lnt|grep &quot;$Port&quot;|wc -l` -eq 0 ]\r    then\r        printf &quot;Stoping MySQL...\\n&quot;\r        ${MySQLPath}/mysqladmin -u ${MySQLUser} -p${MySQLPass} -S /data/${Port}/mysql.sock shutdown\r    else\r        printf &quot;MySQL is stopped...\\n&quot;\r    fi\r}\r\rfunction restart(){\r    printf &quot;Restarting MySQL...\\n&quot;\r    stop\r    sleep 2\r    start\r}\r\rcase &quot;$1&quot; in\r    start)\r        start\r        ;;\r    stop)\r        stop\r        ;;\r    restart)\r        restart\r        ;;\r    *)\r        printf &quot;Usage: $0 {start|stop|restart}\\n&quot;\resac</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(445, 'Shell脚本范例（十八）——抓阄脚本', '445', 1512560160, 1513987734, '<p>本文分享常用的一些Shell脚本的例子，这是第十八篇&mdash;&mdash;编写学生实践抓阄脚本。</p>\r<!--more-->\r\r<p>要求：</p>\r\r<ol>\r	<li>执行脚本后，输入想去的同学的英文名字，产生随机数（01-99之间的数字），数字越大就越有机会去参加项目实践，对于前面已经抓到的数字，下次不能再出现；</li>\r	<li>输入第一个名字之后，屏幕输出信息，并将名字和数字记录到文件里，程序不能退出，继续等待别的同学输入。</li>\r</ol>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rFileLog=/tmp/result.log\r\r[ -f &quot;$FileLog&quot; ] || touch $FileLog\r\rfunction Check_Name(){\r    while true\r    do\r        read -p &quot;please input your name: &quot; name\r        if [ -n &quot;$name&quot; -a &quot;$(grep -w &quot;$name&quot; $FileLog|wc -l)&quot; -eq 0 ]\r        then\r            flag=1\r            break\r        else\r            echo &quot;The name you input is null or already exist.&quot;\r            continue\r        fi\r    done\r}\r\rfunction Produce_RandomNum(){\r    if [ $flag -eq 1 ]\r    then\r        while true\r        do\r            RandomNum=$(expr $RANDOM % 99 + 1)\r            if [ $(grep -w &quot;$RandomNum&quot; $FileLog|wc -l) -ne 1 ]\r            then\r                echo &quot;$name, your num is ${RandomNum}.&quot;|tee -a $FileLog\r                flag1=0\r            else\r                flag1=1\r            fi\r            if [ $flag1 -eq 1 ]\r            then\r                Produce_RandomNum\r            else\r                Check_Name\r            fi\r        done\r    fi\r}\r\rfunction main(){\r    Check_Name\r    Produce_RandomNum\r}\r\rmain</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 175),
(442, 'Shell脚本范例（十五）——入侵检测与报警', '442', 1512527460, 1513987758, '<p>本文分享常用的一些Shell脚本的例子，这是第十五篇&mdash;&mdash;网站入侵检测与报警。</p>\r<!--more-->\r\r<p>要求：监控Web站点目录（/var/html/www）下的所有文件是否被恶意篡改（文件内容被更改了），如果有则打印改动的文件名（邮件），定时任务每3分钟执行一次。</p>\r\r<p>准备：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rmkdir -p /var/html/www\rcp -a /etc/a* /var/html/www/\rcp -a /etc/b* /var/html/www/\rls /var/html/www/\r\rfind /var/html/www -type f|xargs md5sum &gt; /tmp/md5sum.txt\rfind /var/html/www -type f &gt; /tmp/web-list.txt</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rRETVAL=0\rexport LANG=en\rCHECK_DIR=/var/html/www\r[ -e $CHECK_DIR ] || exit 1\r\rfingerprint_ori=&quot;/tmp/md5sum.txt&quot;\rweb-list_ori=&quot;/tmp/web-list.txt&quot;\rErrLog=&quot;/tmp/err.log&quot;\r[ -e $fingerprint_ori ] || exit 1\r[ -e $web-list_ori ] || exit 1\r\recho &quot;# md5sum -c --quiet /tmp/md5sum.txt&quot; &gt; $ErrLog\rmd5sum -c --quiet $fingerprint_ori &amp;&gt;&gt; $ErrLog\rRETVAL=$?\r\rfind $CHECK_DIR -type f &gt; /tmp/web-list_curr.txt\r\recho &quot;# diff /tmp/web-list* &amp;&gt;&gt; $ErrLog\rdiff /tmp/web-list* &amp;&gt;&gt; $ErrLog\r\rif [ $RETVAL -ne 0 -o `diff /opt/web-list*|wc -l` -ne 0 ]\rthen\r    mail -s &quot;`uname -n` $(date +%F) err&quot; oliver.csu@gmail.com &lt; $ErrLog\relse\r    echo &quot;Sites dir is ok&quot;|mail -s &quot;`uname -n` $(date +%F) is ok&quot; oliver.csu@gmail.com\rfi</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 122),
(446, 'Shell脚本范例（十九）——破解RANDOM随机数', '446', 1512560400, 1514458807, '<p>本文分享常用的一些Shell脚本的例子，这是第十九篇&mdash;&mdash;破解RANDOM随机数。</p>\r<!--more-->\r\r<p>要求：已知下面的字符串是RANDOM随机数变量经过md5sum处理后，再截取一部分连续字符串的结果，请破解这些字符串在使用md5sum处理前所对应的数字。</p>\r\r<pre class="brush:bash;">\r21029299\r00205d1c\ra3da1677\r1f6d12dd\r890684b</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rarray=(\r21029299\r00205d1c\ra3da1677\r1f6d12dd\r890684b\r)\r\rPath=/tmp/md5.txt\rNum=0\r\rfunction GetMd5(){\r    [ -f &quot;$Path&quot; ] || touch $Path\r    rowNum=$(wc -l &lt; $Path)\r    if [ $rowNum -ne 32768 ]\r    then\r        &gt; $Path\r        for ((Num=0;Num&lt;=32767;Num++))\r        do\r            {\r                Stat=$(echo $Num|md5sum|cut -c 1-8)\r                echo &quot;$Stat $Num&quot; &gt;&gt; $Path\r            } &amp;\r        done\r    else\r        return 0\r    fi\r}\r\rfunction FindMd5(){\r    word=$(echo &quot;${array[@]}&quot;|sed -r &#39;s# |\\n#|#g&#39;)\r    grep -E &quot;$word&quot; $Path\r}\r\rfunction Main(){\r    GetMd5\r    FindMd5\r}\r\rMain</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 171);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(447, 'Shell脚本范例（二十）——批量检测网站是否正常', '447', 1512561660, 1513987700, '<p>本文分享常用的一些Shell脚本的例子，这是第二十篇&mdash;&mdash;批量检测网站是否正常。</p>\r<!--more-->\r\r<p>要求：</p>\r\r<ol>\r	<li>使用Shell数组方法实现，检测策略尽量模拟用户访问；</li>\r	<li>每10秒钟做一次所有的检测，对于无法访问的网址输出报警；</li>\r	<li>待检测的地址如下：</li>\r</ol>\r\r<pre class="brush:java;">\rhttp://www.aliyun.com\rhttp://www.dtdream.com\rhttp://www.oliver.ren</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\r. /etc/init.d/functions\r\rcheck_count=0\rurl_list=(\rhttp://www.aliyun.com\rhttp://www.dtdream.com\rhttp://www.oliver.ren\r)\r\rfunction wait(){\rfor ((i=0;i&lt;3;i++))\r    do\r        echo -n &quot;.&quot;\r        sleep 1\r    done\r}\r\rfunction check_url(){\r    wait\r    for ((i=0;i&lt;`echo ${#url_list[*]}`;i++))\r    do\r        wget -o /dev/null -T 3 --tries=1 --spider ${url_list[$i]} &amp;&gt; /dev/null\r    if [ $? -eq 0 ]\r    then\r        action &quot;${url_list[$i]}&quot; /bin/true\r    else\r        action &quot;${url_list[$i]}&quot; /bin/false\r    fi\r    done\r    ((check_count++))\r}\r\rfunction main(){\r   while true\r   do\r       chech_url\r       echo &quot;----------check count:${check_count}----------&quot;\r       sleep 10\r   done \r}\r\rmain</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 141),
(448, 'Shell脚本范例（二十一）——单词及字母去重排序', '448', 1512562380, 1513987693, '<p>本文分享常用的一些Shell脚本的例子，这是第二十一篇&mdash;&mdash;单词及字母去重排序。</p>\r<!--more-->\r\r<p>要求：用Shell处理以下的内容：</p>\r\r<pre class="brush:bash;">\rthe squid project provides a number of resources to assist users design, implement and support squid installations. Please browse the documentation and support sections for more infomation...</pre>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rawk -F &quot;[,. ]&quot; &#39;{for(i=1;i&lt;=NF;i++)array[$i]++}END{for(key in array)print array[key],key|&quot;sort -nr&quot;}&#39; /tmp/example.txt|column -t</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rtr &quot;[,. ]&quot; &quot;\\n&quot; &lt; /tmp/example.txt|grep -v &quot;^$&quot;|sort|uniq -c|sort -rn</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rtr &quot;[,. ]&quot; &quot;\\n&quot; &lt; /tmp/example.txt|sed &#39;/^$/d&#39;|awk &#39;{++S[$0]}END{for(key in S)print S[key]&quot; &quot; key|&quot;sort -rn&quot;}&#39;</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rtr &quot;{ |,|.}&quot; &quot;\\n&quot; &lt; /tmp/example.txt | awk -F &quot;&quot; &#39;{for(i=1;i&lt;=NF;i++)array[$i]++}END{for(key in array)print array[key],key|&quot;sort -rn&quot;}&#39;</pre>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rgrep -o &quot;[^ ]&quot; /tmp/example.txt|sort|uniq -c|sort -rn -k1</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 146),
(449, 'Shell脚本范例（二十二）——管理服务端LVS', '449', 1512562440, 1513987684, '<p>本文分享常用的一些Shell脚本的例子，这是第二十二篇&mdash;&mdash;开发脚本管理服务端LVS。</p>\r<!--more-->\r\r<p>要求：利用ipvsadm可以启动并配置好LVS服务，脚本如下：/etc/init.d/lvs {start|stop|restart}</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rIPVSADM=/sbin/ipvsadm\rVIP=10.0.0.3\rPORT=80\rRIPS=(\r10.0.0.7\r10.0.0.8\r)\r\rwhile true\rdo\r    for((i=0;i&lt;${#RIPS[*]};i++))\r    do\r        PORT_COUNT=`nmap ${RIPS[$i]} -p $PORT|grep open|wc -l`\r        if [ $PORT_COUNT -ne 1 ]\r        then\r            if [ `$IPVSADM -Ln|grep ${RIPS[$i]}|wc -l` -ne 0 ]\r            then\r                $IPVSADM -d -t $VIP:$PORT -r ${RIPS[$i]}:$PORT &amp;&gt; /dev/null\r            fi\r        else\r            if [ `$IPVSADM -Ln|grep ${RIPS[$i]}|wc -l` -eq 0 ]\r            then\r                $IPVSADM -a -t $VIP:$PORT -r ${RIPS[$i]}:$PORT &amp;&gt; /dev/null\r            fi\r        fi\r    done\r    sleep 5\rdone</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 137),
(451, 'Shell脚本范例（二十三）——LVS节点健康检查及管理脚本', '451', 1512563040, 1513987678, '<p>本文分享常用的一些Shell脚本的例子，这是第二十三篇&mdash;&mdash;LVS节点健康检查及管理脚本。</p>\r<!--more-->\r\r<p>要求：请在LVS负载均衡主节点上，模拟keepalived健康检查功能管理LVS节点，当节点挂掉时从服务器池中将其剔除，好了后再将其加到服务器池中来。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rIPVSADM=/sbin/ipvsadm\rVIP=10.0.0.3\rPORT=80\rRIPS=(\r10.0.0.7\r10.0.0.8\r)\r\rwhile true\rdo\r    for((i=0;i&lt;${#RIPS[*]};i++))\r    do\r        PORT_COUNT=`nmap ${RIPS[$i]} -p $PORT|grep open|wc -l`\r        if [ $PORT_COUNT -ne 1 ]\r        then\r            if [ `$IPVSADM -Ln|grep ${RIPS[$i]}|wc -l` -ne 0 ]\r            then\r                $IPVSADM -d -t $VIP:$PORT -r ${RIPS[$i]}:$PORT &amp;&gt; /dev/null\r            fi\r        else\r            if [ `$IPVSADM -Ln|grep ${RIPS[$i]}|wc -l` -eq 0 ]\r            then\r                $IPVSADM -a -t $VIP:$PORT -r ${RIPS[$i]}:$PORT &amp;&gt; /dev/null\r            fi\r        fi\r    done\r    sleep 5\rdone</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(452, 'Shell脚本范例（二十四）——LVS客户端配置', '452', 1512563520, 1513987671, '<p>本文分享常用的一些Shell脚本的例子，这是第二十四篇&mdash;&mdash;开发LVS节点健康检查及管理脚本。</p>\r<!--more-->\r\r<p>要求：请在LVS客户端节点上，开发LVS客户端设置VIP及抑制ARP的管理脚本。实现：/etc/init.d/lvsclient {start|stop|restart}。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rRETVAR=0\rVIP=(\r10.0.0.3\r10.0.0.4\r)\r\r. /etc/init.d/functions\r\rcase &quot;$1&quot; in\r    start)\r        for ((i=0;i&lt;`echo ${#VIP[*]}`;i++))\r        do\r            interface=&quot;lo:`echo ${VIP[$i]}|awk -F . &#39;{print $4}&#39;`&quot;\r            /sbin/ip addr add ${VIP[$i]}/24 dev lo label $interface\r            REVTAR=$?\r        done\r        echo &quot;1&quot; &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore\r        echo &quot;2&quot; &gt; /proc/sys/net/ipv4/conf/lo/arp_announce\r        echo &quot;1&quot; &gt; /proc/sys/net/ipv4/conf/all/arp_ignore\r        echo &quot;2&quot; &gt; /proc/sys/net/ipv4/conf/all/arp_announce\r        if [ $RETVAR -eq 0 ]\r        then\r            action &quot;Start LVS Config of RealServer.&quot; /bin/true\r        else\r            action &quot;Start LVS Config of RealServer.&quot; /bin/false\r        fi\r        ;;\r    stop)\r        for((i=0;i&lt;`echo ${#VIP[$i]}`;i++))\r        do\r            interface=&quot;lo:`echo ${VIP[$i]}|awk -F . &#39;{print $4}&#39;`&quot;\r            /sbin/ip addr del ${VIP[$i]}/24 dev lo label $interface &amp;&gt; /dev/null\r        done\r        echo &quot;0&quot; &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore\r        echo &quot;0&quot; &gt; /proc/sys/net/ipv4/conf/lo/arp_announce\r        echo &quot;0&quot; &gt; /proc/sys/net/ipv4/conf/all/arp_ignore\r        echo &quot;0&quot; &gt; /proc/sys/net/ipv4/conf/all/arp_announce\r        if [ $RETVAR -eq 0 ]\r        then\r            action &quot;Close LVS Config of RealServer.&quot; /bin/true\r        else\r            action &quot;Close LVS Config of RealServer.&quot; /bin/false\r        fi\r        ;;\r    *)\r        echo &quot;Usage: $0 {start|stop}&quot;\r        exit 1\resac\rexit $RETVAR</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(453, 'Shell脚本范例（二十五）——模拟keepalived软件高可用', '453', 1512563880, 1513987645, '<p>本文分享常用的一些Shell脚本的例子，这是第二十五篇&mdash;&mdash;模拟keepalived软件高可用。</p>\r<!--more-->\r\r<p>要求：请在LVS服务端备用节点上，模拟keepalived vrrp功能，监听主节点，如果主节点不可访问，则启用备用节点并配置LVS服务，接管主节点的资源并对用户提供服务（提醒：注意ARP缓存）。</p>\r\r<p>参考：</p>\r\r<pre class="brush:bash;">\r#!/bin/bash\r#Author: Oliver King\r#Blog: http://www.oliver.ren\r\rVIP=10.0.0.3\rPORT=80\ripvs_tools=`rpm -qa ipvsadm|wc -l`\r\rif [ $ipvs_tools -ne 1 ]\rthen\r    yum -y install ipvsadm\rfi\r\rwhile true\rdo\r    ping -w2 -c2 ${VIP} &amp;&gt; /dev/null\r    if [ $? -ne 0 ]\r    then\r        /bin/sh 22.sh start &amp;&gt; /dev/null\r    else\r        /bin/sh 22.sh sotp &amp;&gt; /dev/null\r    fi\r    sleep 5\rdone</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 158),
(455, '抽象类的几点注意事项', '455', 1512995957, 1512995957, '<p>&nbsp;本文分享抽象类的几点注意事项，使用的时候要注意哈～</p>\r\r<!--more-->\r\r<ol>\r	<li>抽象方法不能包含在非抽象类中。如果抽象父类的子类不能实现所有的抽象方法，那么子类也必须定义为抽象的。换句话说，在抽象类扩展的非抽象子类中，必须实现所有的抽象方法。还要注意到，抽象方法是非静态的。</li>\r	<li>抽象类是不能使用new操作符来初始化的。但是，仍然可以定义它的构造方法，这个构造方法在它的子类的构造方法中调用。</li>\r	<li>包含抽象方法的类必须是抽象的。但是，可以定义一个不包含抽象方法的抽象类。在这种情况下，不能使用new操作符创建该类的实例。这种类是用来定义新子类的基类的。</li>\r	<li>子类可以覆盖父类的方法并将它定义为abstract。这是很少见的，但是它在当父类的方法实现在子类中变得无效时是很有用的。在这种情况下，子类必须定义为abstract。</li>\r	<li>即使子类的父类是具体的，这个子类也可以是抽象的。例如，Object类是具体的，但是它的子类有很多都是抽象的。</li>\r	<li>不能使用new操作符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 139),
(559, 'JVM内存划分', '559', 1516083547, 1516083547, '<p>本文记录Java学习过程中遇到的JVM内存划分～</p>\r\r<!--more-->\r\r<p><span style="font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-size: 14.399999618530273px; white-space: pre-wrap;">JVM对自己的内存划分为5个区域：</span></p>\r\r<ol>\r	<li><span style="font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-size: 14.399999618530273px; white-space: pre-wrap;">寄存器:内存和CUP之间；</span></li>\r	<li><span style="font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-size: 14.399999618530273px; white-space: pre-wrap;">本地方法栈: JVM调用了系统中的功能；</span></li>\r	<li><span style="font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-size: 14.399999618530273px; white-space: pre-wrap;">方法和数据共享区: 运行时存储class文件的地方；</span></li>\r	<li><span style="font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-size: 14.399999618530273px; white-space: pre-wrap;">方法栈:所有的方法运行的时候进入内存；</span></li>\r	<li><span style="font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-size: 14.399999618530273px; white-space: pre-wrap;">堆:存储的是容器和对象。</span></li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(560, '数组常见的异常', '560', 1516164240, 1516164535, '<p>本文记录在Java学习过程中遇到的数组中的异常～</p>\r<!--more-->\r\r<p><strong>数组越界异常</strong>：每个数组的索引都有一个范围，即0~length-1。在访问数组的元素时，索引不能超出这个范围，否则程序会报错。</p>\r\r<p>示例代码（数组越界）：</p>\r\r<pre class="brush:java;">\rpublic class ArrayDemo {\r	public static void main(String[] args) {\r		int[] arr = new int[4]; // 定义一个长度为4的数组\r		System.out.println(&quot;arr[0]=&quot; + arr[4]); // 通过角标4访问数组元素\r	}\r}</pre>\r\r<p>上述代码运行所提示的错误信息是数组越界异常ArrayIndexOutOfBoundsException，出现这个异常的原因是数组的长度为4，其索引范围为0~3，而上述代码中的第4行代码使用索引4来访问元素时超出了数组的索引范围。</p>\r\r<p>所谓异常指程序中出现的错误，它会报告出错的异常类型、出错的行号以及出错的原因。</p>\r\r<p><strong>空指针异常</strong>：在使用变量引用一个数组时，变量必须指向一个有效的数组对象，如果该变量的值为null，则意味着没有指向任何数组，此时通过该变量访问数组的元素会出现空指针异常。</p>\r\r<pre class="brush:java;">\rpublic class ArrayDemo {\r	public static void main(String[] args) {\r		int[] arr = new int[3]; // 定义一个长度为3的数组\r		arr[0] = 5; // 为数组的第一个元素赋值\r		System.out.println(&quot;arr[0]=&quot; + arr[0]); // 访问数组的元素\r		arr = null; // 将变量arr置为null\r		System.out.println(&quot;arr[0]=&quot; + arr[0]); // 访问数组的元素\r	}\r}</pre>\r\r<p>上述代码中第4、5行代码都能通过变量arr正常地操作数组。第6行代码将变量置为null，当第7行代码再次访问数组时就出现了空指针异常NullPointerException。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(566, '方法', '566', 1516849200, 1517042738, '<p>本文记录Java学习过程中遇到的方法～</p>\r<!--more-->\r\r<p>在Java中，方法就是用来完成解决某件事情或实现某个功能的办法，与C++中的函数相似。</p>\r\r<p>方法实现的过程中，会包含很多条语句用于完成某些有意义的功能&mdash;&mdash;通常是处理文本，控制输入或计算数值。</p>\r\r<p>我们可以通过在程序代码中引用方法名称和所需的参数，实现在该程序中执行（或称调用）该方法。方法，一般都有一个返回值，用来作为事情的处理结果。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\r修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2,．．．．．．){ \r	执行语句\r	&hellip;&hellip;&hellip; \r	return 返回值;\r}</pre>\r\r<p>对于上面的语法格式中具体说明如下：</p>\r\r<ul>\r	<li>修饰符：方法的修饰符比较多，有对访问权限进行限定的，有静态修饰符static，还有最终修饰符final等，这些修饰符在后面的学习过程中会逐步介绍；</li>\r	<li>返回值类型：用于限定方法返回值的数据类型；</li>\r	<li>参数类型：用于限定调用方法时传入参数的数据类型</li>\r	<li>参数名：是一个变量，用于接收调用方法时传入的数据</li>\r	<li>return关键字：用于结束方法以及返回方法指定类型的值</li>\r	<li>返回值：被return语句返回的值，该值会返回给调用者</li>\r</ul>\r\r<p>需要特别注意的是，方法中的&ldquo;参数类型 参数名1，参数类型 参数名2&rdquo;被称作参数列表，它用于描述方法在被调用时需要接收的参数，如果方法不需要接收任何参数，则参数列表为空，即()内不写任何内容。方法的返回值必须为方法声明的返回值类型，如果方法中没有返回值，返回值类型要声明为void，此时，方法中return语句可以省略。</p>\r\r<p>示例代码（求矩形面积）：</p>\r\r<pre class="brush:java;">\rpublic class MethodDemo {\r	public static void main(String[] args) {\r		int area = getArea(3, 5); // 调用 getArea方法\r		System.out.println(&quot; The area is &quot; + area);\r	}\r\r	// 下面定义了一个求矩形面积的方法，接收两个参数，其中x为高，y为宽\r	public static int getArea(int x, int y) {\r		int temp = x * y; // 使用变量temp记住运算结果\r		return temp; // 将变量temp的值返回\r	}\r}</pre>\r\r<p>在上述代码中，定义了一个getArea()方法用于求矩形的面积，参数x和y分别用于接收调用方法时传入的高和宽，return语句用于返回计算所得的面积。在main()方法中通过调用getArea()方法，获得矩形的面积，并将结果打印。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(553, 'm01.png', 'm01-png', 1516081768, 1516081768, 'a:5:{s:4:"name";s:7:"m01.png";s:4:"path";s:34:"/usr/uploads/2018/01/719909001.png";s:4:"size";i:31910;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 552, 0),
(555, 'm02.png', 'm02-png', 1516081923, 1516081923, 'a:5:{s:4:"name";s:7:"m02.png";s:4:"path";s:35:"/usr/uploads/2018/01/3415026511.png";s:4:"size";i:63387;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 552, 0),
(557, 'm03.png', 'm03-png', 1516082284, 1516082284, 'a:5:{s:4:"name";s:7:"m03.png";s:4:"path";s:35:"/usr/uploads/2018/01/2251799843.png";s:4:"size";i:105761;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 552, 0),
(561, '二维数组', '561', 1516164600, 1516280369, '<p>本文记录Java学习过程中遇到的二维数组～</p>\r<!--more-->\r\r<p>多维数组可以简单地理解为在数组中嵌套数组，在程序中比较常见的就是二维数组。</p>\r\r<p>二维数组的定义有很多方式，具体如下：</p>\r\r<p>第一种方式：</p>\r\r<pre class="brush:java;">\rint[][] arr = new int[3][4];</pre>\r\r<p>上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组，如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/279104980.png" style="width: 600px; height: 88px;" /></p>\r\r<p>第二种方式：</p>\r\r<pre class="brush:java;">\rint[][] arr = new int[3][];</pre>\r\r<p>第二种方式和第一种类似，只是数组中每个元素的长度不确定，如图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2538120519.png" style="width: 600px; height: 125px;" /></p>\r\r<p>第三种方式：</p>\r\r<pre class="brush:java;">\rint[][] arr = {{1,2},{3,4,5,6},{7,8,9}};</pre>\r\r<p>上面的二维数组中定义了三个元素，这三个元素都是数组，分别为{1,2}、{3,4,5,6}、{7,8,9}，如图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3121825939.png" style="width: 600px; height: 104px;" /></p>\r\r<p>对二维数组中元素的访问也是通过角标的方式，如需访问二维数组中第一个元素数组的第二个元素，具体代码如下：</p>\r\r<pre class="brush:java;">\rarr[0][1];</pre>\r\r<p>示例代码（数组元素的访问）：</p>\r\r<pre class="brush:java;">\rclass ArrayDemo {\r	public static void main(String[] args){\r	\r		//定义二维数组的方式\r		int[][] arr = new int[3][4];\r	\r		System.out.println( arr );\r		System.out.println(&quot;二维数组的长度: &quot; + arr.length);\r		//获取二维数组的3个元素\r		System.out.println( arr[0] );\r		System.out.println( arr[1] );\r		System.out.println( arr[2] );\r		\r		System.out.println(&quot;打印第一个一维数组的元素值&quot;);\r		System.out.println( arr[0][0] );\r		System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素\r		System.out.println( arr[0][2] );\r		System.out.println( arr[0][3] );\r		\r		System.out.println(&quot;打印第二个一维数组的元素值&quot;);\r		System.out.println( arr[1][0] );\r		System.out.println( arr[1][1] );\r		System.out.println( arr[1][2] );\r		System.out.println( arr[1][3] );\r		\r		System.out.println(&quot;打印第三个一维数组的元素值&quot;);\r		System.out.println( arr[2][0] );\r		System.out.println( arr[2][1] );\r		System.out.println( arr[2][2] );\r		System.out.println( arr[2][3] );\r	}\r}</pre>\r\r<p>示例代码（数组遍历求和）：</p>\r\r<pre class="brush:java;">\rclass ArrayDemo {\r	public static void main(String[] args){\r		//一维数组的求累加和并遍历\r		int[] arr = {10,20,30,40,50};\r		int sum = 0; \r		for (int i=0; i&lt;arr.length; i++) {\r              //System.out.println(arr[i]);\r			sum += arr[i];\r		}\r		System.out.println(&quot;sum= &quot; + sum);\r		System.out.println(&quot;---------------------&quot;);\r		\r                //二维数组的求累加和并遍历\r		int[][] arr2 = { {1,2},{3,4,5},{6,7,8,9,10} };\r		int sum2 = 0;\r		for (int i=0; i&lt;arr2.length; i++) {\r			for (int j=0; j&lt;arr2[i].length; j++) {\r                 //System.out.println(arr2[i][j])\r				sum2 += arr2[i][j];\r			}\r		}\r		System.out.println(&quot;sum2= &quot;+ sum2);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 125),
(549, '跳转语句continue', '549', 1515984900, 1515986572, '<p>本文记录Java学习过程中遇到的跳转语句continue～</p>\r<!--more-->\r\r<p>continue语句用在循环语句中，它的作用是终止本次循环，执行下一次循环。</p>\r\r<p>示例代码（对1~100之内的奇数求和）：</p>\r\r<pre class="brush:java;">\rpublic class ContinueDemo {\r	public static void main(String[] args) {\r		int sum = 0; // 定义变量sum，用于记住和\r		for (int i = 1; i &lt;= 100; i++) {\r			if (i % 2 == 0) { // i是一个偶数，不累加\r				continue; // 结束本次循环\r			}\r			sum += i; // 实现sum和i的累加\r		}\r		System.out.println(&quot;sum = &quot; + sum);\r	}\r}</pre>\r\r<p>上述代码中，使用for循环让变量i的值在1~100之间循环，在循环过程中，当i的值为偶数时，将执行continue语句结束本次循环，进入下一次循环。当i的值为奇数时，sum和i进行累加，最终得到1~100之间所有奇数的和，打印&ldquo;sum = 2500&rdquo;。</p>\r\r<p>在嵌套循环语句中，continue语句后面也可以通过使用标记的方式结束本次外层循环，用法与break语句相似。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 180),
(550, '选择语句switch', '550', 1516015680, 1516017844, '<p>本文记录Java学习过程中遇到的选择语句switch～</p>\r<!--more-->\r\r<p>switch 条件语句也是一种很常用的选择语句，它和if条件语句不同，它只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\rswitch (表达式){\r	case 目标值1:\r		执行语句1\r		break;\r	case 目标值2:\r		执行语句2\r		break;\r	．．．．．．\r	case 目标值n:\r		执行语句n\r		break;\r	default:\r		执行语句n+1\r		break;\r}</pre>\r\r<p>在上面的格式中，switch语句将表达式的值与每个case中的目标值进行匹配，如果找到了匹配的值，会执行对应case后的语句，如果没找到任何匹配的值，就会执行default后的语句。switch语句中的break关键字将在后面的做具体介绍，此处，我们只需要知道break的作用是跳出switch语句即可。</p>\r\r<p>示例代码（打印星期几）：</p>\r\r<pre class="brush:java;">\rpublic class SwitchDemo {\r	public static void main(String[] args) {\r		int week = 5;\r		switch (week) {\r		case 1:\r			System.out.println(&quot;星期一&quot;);\r			break;\r		case 2:\r			System.out.println(&quot;星期二&quot;);\r			break;\r		case 3:\r			System.out.println(&quot;星期三&quot;);\r			break;\r		case 4:\r			System.out.println(&quot;星期四&quot;);\r			break;\r		case 5:\r			System.out.println(&quot;星期五&quot;);\r			break;\r		case 6:\r			System.out.println(&quot;星期六&quot;);\r			break;\r		case 7:\r			System.out.println(&quot;星期天&quot;);\r			break;\r		default:\r			System.out.println(&quot;输入的数字不正确...&quot;);\r			break;\r		}\r	}\r}</pre>\r\r<p>注意：switch语句中的表达式只能是byte、short、char、int类型的值，如果传入其它类型的值，程序会报错。但上述说法并不严谨，实际上在JDK5.0中引入的新特性enum枚举也可以作为switch语句表达式的值，在JDK7.0中也引入了新特性，switch语句可以接收一个String类型的值。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(551, 'case穿透', '551', 1516019820, 1516020006, '<p>本文记录Java学习过程中遇到的case穿透～</p>\r<!--more-->\r\r<p>case穿透：漏写break语句，使其继续执行下一个case的语句。</p>\r\r<p>在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class SwitchDemo {\r	public static void main(String[] args) {\r		int week = 2;\r		switch (week) {\r		case 1:\r		case 2:\r		case 3:\r		case 4:\r		case 5:\r			// 当 week 满足值 1、2、3、4、5 中任意一个时，处理方式相同\r			System.out.println(&quot;今天是工作日&quot;);\r			break;\r		case 6:\r		case 7:\r			// 当 week 满足值 6、7 中任意一个时，处理方式相同\r			System.out.println(&quot;今天是休息日&quot;);\r			break;\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(543, '循环语句do…while', '543', 1515914520, 1553956000, '<p>本文记录Java学习过程中遇到的循环语句do&hellip;while～</p>\r<!--more-->\r\r<p>do&hellip;while循环语句和while循环语句功能类似。</p>\r\r<p>语法结构：</p>\r\r<pre class="brush:java;">\rdo {\r        执行语句\r        &hellip;&hellip;&hellip;\r} while(循环条件);</pre>\r\r<p>在上面的语法结构中，关键字do后面{}中的执行语句是循环体。do&hellip;while循环语句将循环条件放在了循环体的后面。这也就意味着，循环体会无条件执行一次，然后再根据循环条件来决定是否继续执行。</p>\r\r<p>流程图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/4037521405.png" style="width: 600px; height: 550px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class DoWhileDemo {\r	public static void main(String[] args) {\r		int x = 1; // 定义变量x，初始值为1\r		do {\r			System.out.println(&quot;x = &quot; + x); // 打印x的值\r			x++; // 将x的值自增\r		} while (x &lt;= 4); // 循环条件\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(544, 'do-while.png', 'do-while-png', 1515914839, 1515914839, 'a:5:{s:4:"name";s:12:"do-while.png";s:4:"path";s:35:"/usr/uploads/2018/01/4037521405.png";s:4:"size";i:58483;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 543, 0),
(546, '无限循环', '546', 1515915360, 1553956061, '<p>本文记录Java学习过程中遇到的无限循环～</p>\r<!--more-->\r\r<p>无限循环，也被称为死循环。最简单无限循环格式：</p>\r\r<pre class="brush:java;">\rwhile(true){} </pre>\r\r<p>或者</p>\r\r<pre class="brush:java;">\rfor(;;){}</pre>\r\r<p>无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 132),
(547, '嵌套循环', '547', 1515930120, 1515930414, '<p>本文记录Java学习过程遇到的嵌套循环～</p>\r<!--more-->\r\r<p>嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do&hellip;while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在for循环中嵌套for循环，格式如下：</p>\r\r<pre class="brush:java;">\rfor(初始化表达式; 循环条件; 操作表达式) {\r	&hellip;&hellip;&hellip;\r	for(初始化表达式; 循环条件; 操作表达式) {\r		执行语句\r		&hellip;&hellip;&hellip;\r	}\r	&hellip;&hellip;&hellip;\r}</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ForForDemo {\r	public static void main(String[] args) {\r		int i, j; // 定义两个循环变量\r		for (i = 1; i &lt;= 9; i++) { // 外层循环\r			for (j = 1; j &lt;= i; j++) { // 内层循环\r				System.out.print(&quot;*&quot;); // 打印*\r			}\r			System.out.print(&quot;\\n&quot;); // 换行\r		}\r	}\r}</pre>\r\r<p>在上述代码中定义了两层for循环，分别为外层循环和内层循环，外层循环用于控制打印的行数，内层循环用于打印&ldquo;*&rdquo;，每一行的&ldquo;*&rdquo;个数逐行增加，最后输出一个直角三角形。由于嵌套循环程序比较复杂，下面分步骤进行详细地讲解，具体如下：</p>\r\r<ul>\r	<li>第一步，在第3行代码定义了两个循环变量i和j，其中i为外层循环变量，j为内层循环变量。</li>\r	<li>第二步，在第4行代码将i初始化为1，条件i &lt;= 9为true，首次进入外层循环的循环体。</li>\r	<li>第三步，在第5行代码将j初始化为1，由于此时i的值为1，条件j &lt;= i为true，首次进入内层循环的循环体，打印一个&ldquo;*&rdquo;。</li>\r	<li>第四步，执行第5行代码中内层循环的操作表达式j++，将j的值自增为2。</li>\r	<li>第五步，执行第5行代码中的判断条件j&lt;=i，判断结果为false，内层循环结束。执行后面的代码，打印换行符。</li>\r	<li>第六步，执行第4行代码中外层循环的操作表达式i++，将i的值自增为2。</li>\r	<li>第七步，执行第4行代码中的判断条件i&lt;=9，判断结果为true，进入外层循环的循环体，继续执行内层循环。</li>\r	<li>第八步，由于i的值为2，内层循环会执行两次，即在第2行打印两个&ldquo;*&rdquo;。在内层循环结束时会打印换行符。</li>\r	<li>第九步，以此类推，在第3行会打印3个&ldquo;*&rdquo;，逐行递增，直到i的值为10时，外层循环的判断条件i &lt;= 9结果为false，外层循环结束，整个程序也就结束了。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 126),
(548, '跳转语句break', '548', 1515983880, 1515984840, '<p>本文记录Java学习过程中遇到的跳转语句break～</p>\r<!--more-->\r\r<p>在switch条件语句和循环语句中都可以使用break语句。当它出现在switch条件语句中时，作用是终止某个case并跳出switch结构。当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class BreakDemo {\r	public static void main(String[] args) {\r		int x = 1; // 定义变量x，初始值为1\r		while (x &lt;= 4) { // 循环条件\r			System.out.println(&quot;x = &quot; + x); // 条件成立，打印x的值\r			if (x == 3) {\r				break;\r			}\r			x++; // x进行自增\r		}\r	}\r}</pre>\r\r<p>在上述带代码中，通过while循环打印x的值，当x的值为3时使用break语句跳出循环。因此打印结果中并没有出现&ldquo;x=4&rdquo;。</p>\r\r<p>当break语句出现在嵌套循环中的内层循环时，它只能跳出内层循环，如果想使用break语句跳出外层循环则需要对外层循环添加标记。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class BreakDemo {\r	public static void main(String[] args) {\r		int i, j; // 定义两个循环变量\r		tag: for (i = 1; i &lt;= 9; i++) { // 外层循环\r			for (j = 1; j &lt;= i; j++) { // 内层循环\r				if (i &gt; 4) { // 判断i的值是否大于4\r					break itcast; // 跳出外层循环\r				}\r				System.out.print(&quot;*&quot;); // 打印*\r			}\r			System.out.print(&quot;\\n&quot;); // 换行\r		}\r	}\r}</pre>\r\r<p>上述代码中，当i&gt;4时，使用break tag;语句跳出外层循环。因此程序只打印了4行&ldquo;*&rdquo;。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 118),
(533, 'if01.png', 'if01-png', 1515842028, 1515842028, 'a:5:{s:4:"name";s:8:"if01.png";s:4:"path";s:35:"/usr/uploads/2018/01/2412764824.png";s:4:"size";i:42933;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 532, 0),
(535, 'if02.png', 'if02-png', 1515842300, 1515842300, 'a:5:{s:4:"name";s:8:"if02.png";s:4:"path";s:34:"/usr/uploads/2018/01/838500068.png";s:4:"size";i:120055;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 532, 0),
(537, 'if03.png', 'if03-png', 1515842517, 1515842517, 'a:5:{s:4:"name";s:8:"if03.png";s:4:"path";s:34:"/usr/uploads/2018/01/200151952.png";s:4:"size";i:43786;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 532, 0),
(538, '三元运算符', '538', 1515912420, 1515912620, '<p>本文记录Java学习过程中遇到的三元运算符～</p>\r<!--more-->\r\r<p>三元运算符，与if-else语句类似，语法如下：</p>\r\r<pre class="brush:java;">\r判断条件 ? 表达式1 : 表达式2</pre>\r\r<p>三元运算符会得到一个结果，通常用于对某个变量进行赋值，当判断条件成立时，运算结果为表达式1的值，否则结果为表达式2的值。</p>\r\r<p>示例代码：</p>\r\r<ul>\r	<li>例如求两个数x、y中的较大者，如果用if&hellip;else语句来实现，具体代码如下：</li>\r</ul>\r\r<pre class="brush:java;">\rint x = 0;\rint y = 1;\rint max;\rif (x &gt; y) {\r	max = x;\r} else {\r	max = y;\r}</pre>\r\r<ul>\r	<li>上面的代码运行之后，变量max的值为1。</li>\r	<li>其中3-8行的代码可以使用下面的三元运算来替换：</li>\r</ul>\r\r<pre class="brush:java;">\rint max = x &gt; y ? x : y;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(539, '循环语句while', '539', 1515912720, 1553955910, '<p>本文记录Java学习过程中遇到的循环语句while～</p>\r<!--more-->\r\r<p>while循环语句和选择结构if语句有些相似，都是根据条件判断来决定是否执行大括号内的执行语句。区别在于，while语句会反复地进行条件判断，只要条件成立，{}内的执行语句就会执行，直到条件不成立，while循环结束。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\rwhile(循环条件){\r        执行语句\r        &hellip;&hellip;&hellip;\r}</pre>\r\r<p>在上面的语法结构中，{}中的执行语句被称作循环体，循环体是否执行取决于循环条件。当循环条件为true时，循环体就会执行。循环体执行完毕时会继续判断循环条件，如条件仍为true则会继续执行，直到循环条件为false时，整个循环过程才会结束。</p>\r\r<p>流程图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3075300007.png" style="width: 400px; height: 402px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class WhileDemo {\r	public static void main(String[] args) {\r		int x = 1; // 定义变量x，初始值为1\r		while (x &lt;= 4) { // 循环条件\r			System.out.println(&quot;x = &quot; + x); // 条件成立，打印x的值\r			x++; // x进行自增\r		}\r	}\r}</pre>\r\r<p>在上述代码中，x初始值为1，在满足循环条件x &lt;= 4的情况下，循环体会重复执行，打印x的值并让x进行自增。因此打印结果中x的值分别为1、2、3、4。</p>\r\r<p>要注意的是，代码x++用于在每次循环时改变变量x的值，从而达到最终改变循环条件的目的。如果没有这行代码，整个循环会进入无限循环的状态，永远不会结束。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(540, 'while.png', 'while-png', 1515912854, 1515912854, 'a:5:{s:4:"name";s:9:"while.png";s:4:"path";s:35:"/usr/uploads/2018/01/3075300007.png";s:4:"size";i:31221;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 539, 0),
(542, '循环语句for', '542', 1515913920, 1515914170, '<p>本文记录Java学习过程中遇到的循环语句for～</p>\r<!--more-->\r\r<p>for循环语句是最常用的循环语句，一般用在循环次数已知的情况下。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\rfor（初始化表达式; 循环条件; 操作表达式）{\r	执行语句\r	&hellip;&hellip;&hellip;\r}</pre>\r\r<p>在上面的语法结构中，for关键字后面()中包括了三部分内容：初始化表达式、循环条件和操作表达式，它们之间用&ldquo;;&rdquo;分隔，{}中的执行语句为循环体。</p>\r\r<p>接下来分别用①表示初始化表达式、②表示循环条件、③表示操作表达式、④表示循环体，通过序号来具体分析for循环的执行流程。具体如下：</p>\r\r<pre class="brush:java;">\rfor（① ; ② ; ③）{\r	④\r}\r第一步，执行①\r第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步\r第三步，执行④\r第四步，执行③，然后重复执行第二步\r第五步，退出循环</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ForDemo {\r	public static void main(String[] args) {\r		int sum = 0; // 定义变量sum，用于记住累加的和\r		for (int i = 1; i &lt;= 4; i++) { // i的值会在1~4之间变化\r			sum += i; // 实现sum与i的累加\r		}\r		System.out.println(&quot;sum = &quot; + sum); // 打印累加的和\r	}\r}</pre>\r\r<p>上述代码中，变量i的初始值为1，在判断条件i&lt;=4为true的情况下，会执行循环体sum+=i，执行完毕后，会执行操作表达式i++，i的值变为2，然后继续进行条件判断，开始下一次循环，直到i=5时，条件i&lt;=4为false，结束循环，执行for循环后面的代码，打印&ldquo;sum=10&rdquo;。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 168),
(466, '抽象的进步', '466', 1514301428, 1514301428, '<p>本文摘自《Java编程思想》，值得记录～</p>\r\r<!--more-->\r\r<p>所有编程语言的最终目的都是提供一种&ldquo;抽象&rdquo;方法。一种较有争议的说法是：解决问题的复杂程度直接取决于抽象的种类及质量。这儿的&ldquo;种类&rdquo;是指准备对什么进行&ldquo;抽象&rdquo;？汇编语言是对基础机器的少量抽象。后来的许多&ldquo;命令式&rdquo;语言（如FORTRAN，BASIC和C）是对汇编语言的一种抽象。与汇编语言相比，这些语言已有了长足的进步，但它们的抽象原理依然要求我们着重考虑计算机的结构，而非考虑问题本身的结构。在机器模型（位于&ldquo;方案空间&rdquo;）与实际解决的问题模型（位于&ldquo;问题空间&rdquo;）之间，程序员必须建立起一种联系。这个过程要求人们付出较大的精力，而且由于它脱离了编程语言本身的范围，造成程序代码很难编写，而且要花较大的代价进行维护。由此造成的副作用便是一门完善的&ldquo;编程方法&rdquo;学科。</p>\r\r<p>为机器建模的另一个方法是为要解决的问题制作模型。对一些早期语言来说，如LISP和APL，它们的做法是&ldquo;从不同的角度观察世界&rdquo;&mdash;&mdash;&ldquo;所有问题都归纳为列表&rdquo;或&ldquo;所有问题都归纳为算法&rdquo;。PROLOG则将所有问题都归纳为决策链。对于这些语言，我们认为它们一部分是面向基于&ldquo;强制&rdquo;的编程，另一部分则是专为处理图形符号设计的。每种方法都有自己特殊的用途，适合解决某一类的问题。但只要超出了它们力所能及的范围，就会显得非常笨拙。</p>\r\r<p>面向对象的程序设计在此基础上则跨出了一大步，程序员可利用一些工具表达问题空间内的元素。由于这种表达非常普遍，所以不必受限于特定类型的问题。我们将问题空间中的元素以及它们在方案空间的表示物称作&ldquo;对象&rdquo;（Object）。当然，还有一些在问题空间没有对应体的其他对象。通过添加新的对象类型，程序可进行灵活的调整，以便与特定的问题配合。所以在阅读方案的描述代码时，会读到对问题进行表达的话语。与我们以前见过的相比，这无疑是一种更加灵活、更加强大的语言抽象方法。总之，OOP允许我们根据问题来描述问题，而不是根据方案。然而，仍有一个联系途径回到计算机。每个对象都类似一台小计算机；它们有自己的状态，而且可要求它们进行特定的操作。与现实世界的&ldquo;对象&rdquo;或者&ldquo;物体&rdquo;相比，编程&ldquo;对象&rdquo;与它们也存在共通的地方：它们都有自己的特征和行为。</p>\r\r<p>Alan Kay总结了Smalltalk的五大基本特征。这是第一种成功的面向对象程序设计语言，也是Java的基础语言。通过这些特征，我们可理解&ldquo;纯粹&rdquo;的面向对象程序设计方法是什么样的：</p>\r\r<p>(1) 所有东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。</p>\r\r<p>(2) 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那个对象&ldquo;发送一条消息&rdquo;。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。</p>\r\r<p>(3) 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。</p>\r\r<p>(4) 每个对象都有一种类型。根据语法，每个对象都是某个&ldquo;类&rdquo;的一个&ldquo;实例&rdquo;。其中，&ldquo;类&rdquo;（Class）是&ldquo;类型&rdquo;（Type）的同义词。一个类最重要的特征就是&ldquo;能将什么消息发给它？&rdquo;。</p>\r\r<p>(5) 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为&ldquo;圆&rdquo;（Circle）的一个对象也属于类型为&ldquo;形状&rdquo;（Shape）的一个对象，所以一个圆完全能接收形状消息。这意味着可让程序代码统一指挥&ldquo;形状&rdquo;，令其自动控制所有符合&ldquo;形状&rdquo;描述的对象，其中自然包括&ldquo;圆&rdquo;。这一特性称为对象的&ldquo;可替换性&rdquo;，是OOP最重要的概念之一。</p>\r\r<p>一些语言设计者认为面向对象的程序设计本身并不足以方便解决所有形式的程序问题，提倡将不同的方法组合成&ldquo;多形程序设计语言&rdquo;。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 122),
(578, '对象内存图.jpg', '对象内存图-jpg', 1519346551, 1519346551, 'a:5:{s:4:"name";s:19:"对象内存图.jpg";s:4:"path";s:35:"/usr/uploads/2018/02/2181335884.jpg";s:4:"size";i:87330;s:4:"type";s:3:"jpg";s:4:"mime";s:10:"image/jpeg";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 577, 0),
(468, '黑盒测试和白盒测试常用的测试方法', '468', 1514817360, 1514987511, '<p>本文记录常用的测试方法，面试中常被问到～</p>\r<!--more-->\r\r<p>白盒测试：逻辑覆盖法，主要包括语句覆盖，判断覆盖，条件覆盖，判断条件覆盖，条件组合覆盖、路径覆盖。</p>\r\r<p>黑盒测试：等价划分类，边界值分析，错误推测法等。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(469, '白盒测试中的静态测试和动态测试', '469', 1514817540, 1514987505, '<p>本文记录白盒测试中的静态测试和动态测试的区别～</p>\r<!--more-->\r\r<p>静态测试是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。静态方法通过程序静态特性的分析，找出欠缺和可疑之处，例如不匹配的参数、不适当的循环嵌套和分支嵌套、不允许的递归、未使用过的变量、空指针的引用和可疑的计算等。静态测试结果可用于进一步的查错，并为测试用例选取提供指导。</p>\r\r<p>动态测试是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率和健壮性等性能，这种方法由三部分组成：构造测试实例、执行程序、分析程序的输出结果。所谓软件的动态测试，就是通过运行软件来检验软件的动态行为和运行结果的正确性。目前，动态测试也是公司的测试工作的主要方式。根据动态测试在软件开发过程中所处的阶段和作用，动态测试可分为如下几个步骤：1、单元测试 2、集成测试 3、系统测试 4、验收测试 5、回归测试。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 124),
(504, '001.png', '001-png-5', 1515398709, 1515398709, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2018/01/3488927701.png";s:4:"size";i:31882;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 509, 0),
(505, '002.png', '002-png-2', 1515398709, 1515398709, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/01/4249690038.png";s:4:"size";i:74514;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 509, 0),
(506, '003.png', '003-png-2', 1515398709, 1515398709, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:35:"/usr/uploads/2018/01/3774957363.png";s:4:"size";i:36837;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 509, 0),
(507, '004.png', '004-png-1', 1515398709, 1515398709, 'a:5:{s:4:"name";s:7:"004.png";s:4:"path";s:35:"/usr/uploads/2018/01/3200562009.png";s:4:"size";i:19982;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 509, 0),
(508, '005.png', '005-png-2', 1515398709, 1515398709, 'a:5:{s:4:"name";s:7:"005.png";s:4:"path";s:35:"/usr/uploads/2018/01/1192595035.png";s:4:"size";i:53712;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 509, 0),
(509, '如何配置环境变量', '509', 1515398838, 1515398838, '<p>本文记录如何配置Java开发环境的环境变量~</p>\r\r<!--more-->\r\r<p>1. 找到jdk的安装路径，一般默认安装在C:\\Program Files\\Java；</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3488927701.png" style="width: 600px; height: 372px;" /></p>\r\r<p>2. 打开环境变量设置：桌面&mdash;&mdash;我的电脑（右键）&mdash;&mdash;属性&mdash;&mdash;高级系统设置&mdash;&mdash;环境变量；</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/4249690038.png" style="width: 600px; height: 353px;" /></p>\r\r<p>3. 修改环境变量Path：在用户变量的Path变量中添加C:\\Program Files\\Java\\jdk1.8.0_144\\bin；</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3774957363.png" style="width: 600px; height: 635px;" /></p>\r\r<p>4. 添加环境变量CLASSPATH：在用户变量中新建一项CLASSPATH，并将其值设置（英文的点和分号）为.;C:\\Program Files\\Java\\jdk1.8.0_144\\lib；</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/3200562009.png" style="width: 600px; height: 184px;" /></p>\r\r<p>5. 添加环境变量JAVA_HOME：在用户变量中新建一项JAVA_HOME，并将其值设置为C:\\Program Files\\Java\\jdk1.8.0_144；</p>\r\r<p>6. 验证配置是否正确：新打开一个CMD窗口，输入javac。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/1192595035.png" style="width: 600px; height: 372px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(510, '变量', '510', 1515410193, 1515410193, '<p>本文记录Java学习中遇到的变量～</p>\r\r<!--more-->\r\r<p>变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。那么变量是装载什么的呢？答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(511, '计算机存储单元', '511', 1515411629, 1515411629, '<p>本文记录Java学习过程中遇到的计算机存储单元～</p>\r\r<!--more-->\r\r<p>变量是内存中的小容器，用来存储数据。那么计算机是怎么存储数据的呢？无论是内存还是硬盘，计算机存储设备的最小信息单元叫做&ldquo;位(bit)&rdquo;，我们又称之为&ldquo;比特位&rdquo;，通常用小写的字母b表示。而计算机最小的存储单元叫&ldquo;字节(byte)&rdquo;，通常用大写字母B表示，字节是由连续的8个位组成。</p>\r\r<p>当程序需要使用存储空间时，操作系统最小会分派给程序1个字节，而不是1个位。你可能说，如果程序只需要1个位的空间，系统分派不能只分派1个位吗？答案是不能。</p>\r\r<p>常用储存单位</p>\r\r<ul>\r	<li>1B&nbsp;= 8bit</li>\r	<li>1KB = 1024B</li>\r	<li>1MB = 1024KB</li>\r	<li>1GB = 1024MB</li>\r	<li>1TB = 1024GB</li>\r	<li>1PB = 1024TB</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 133),
(512, 'type.png', 'type-png', 1515472865, 1515472865, 'a:5:{s:4:"name";s:8:"type.png";s:4:"path";s:35:"/usr/uploads/2018/01/2960847572.png";s:4:"size";i:77227;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 513, 0),
(513, '基础数据类型', '513', 1515472912, 1515472912, '<p>本文记录在Java学习过程中遇到的四类八种基础数据类型～</p>\r\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/01/2960847572.png" style="width: 600px; height: 233px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(514, '常量和数据类型', '514', 1515483349, 1515483349, '<p>本文记录Java学习过程中遇到的常量和数据类型～</p>\r\r<!--more-->\r\r<ol>\r	<li>​整形常量默认是int类型</li>\r	<li>小数常量默认是double类型</li>\r	<li>定义长整形数据如果值超过int取值范围后面要+&quot;L&quot;</li>\r	<li>定义float类型的数据后面要+&quot;f&quot; 否则默认是double</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(515, '变量的三要素', '515', 1515484454, 1515484454, '<p>本文记录在Java学习过程中遇到的变量的三要素～</p>\r\r<!--more-->\r\r<p>定义变量的语法格式：数据类型 变量名 = 变量值</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r      public class Variable {\r		public static void main(String[] args) {\r			int a = 10;\r			double b = 3.14;\r			char c = &#39;z&#39;;\r			String s = &quot;i love java&quot;;\r		\r			a = 20;\r			System.out.println(a);\r		}\r	}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 167),
(516, '变量定义的注意事项', '516', 1515558120, 1515558277, '<p>本文记录Java学习过程中遇到的变量定义的注意事项～</p>\r<!--more-->\r\r<ol>\r	<li>变量定义后可以不赋值，使用时再赋值，但是不赋值就不能使用；</li>\r	<li>变量使用时有作用域的限制（变量的作用范围只在定义的大括号内）；</li>\r	<li>变量不可以重复定义。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(517, '数据类型转换', '517', 1515559320, 1515561652, '<p>本文记录Java学习过程中的数据类型转换～</p>\r<!--more-->\r\r<p>转换的顺序（从小类型转换为大类型）：byte-short-int-long-float-double</p>\r\r<p>自动类型转换：表示范围小的数据类型转换成范围大的数据类型（布尔类型不参与类型转换）。</p>\r\r<p>自动类型转换格式：范围大的数据类型 变量 = 范围小的数据类型值。</p>\r\r<p>强制类型转换：表示范围大的数据类型转换成范围小的数据类型（布尔类型不参与类型转换）。</p>\r\r<p>强制类型转换格式： 范围小的数据类型 变量 = (范围小的数据类型) 范围大的数据类型值。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(599, '数组元素普通查找', '599', 1521274440, 1521274634, '<p>本文记录Java学习过程中遇到的数组元素普通查找～</p>\r<!--more-->\r\r<p>如图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/3115237335.png" style="width: 600px; height: 242px;" /></p>\r\r<p>题目分析：</p>\r\r<p>通过观察发现，本题目要实现查找指定数值第一次在数组中存储的位置（索引），返回该位置（索引）。</p>\r\r<ol>\r	<li>我们可以通过遍历数组，得到每个数组元素的值</li>\r	<li>在遍历数组过程中，使用当前数组元素值与要查找的数值进行对比\r	<ol style="list-style-type:lower-alpha;">\r		<li>数值相等，返回当前数组元素值的索引</li>\r		<li>整个循环结束后，比对结果数值没有相等的情况，说明该数组中没有存储要查找的数值，此时，返回一个索引值-1，来表示没有查询到对应的位置。（使用 -1来表示没有查询到，是因为数组的索引没有负数）</li>\r	</ol>\r	</li>\r</ol>\r\r<p>解题步骤：</p>\r\r<ol>\r	<li>使用for循环，遍历数组，得到每个数组元素值</li>\r	<li>在每次循环中，使用if条件语句进行当前数组元素值与要查找的数值进行对比，若比较结果相等，直接返回当前数组元素的索引值</li>\r	<li>若整个循环结束后，比对结果数值没有相等的情况，说明该数组中没有存储要查找的数值，此时，返回一个索引值-1</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//普通查找\rpublic static int getArrayIndex(int[] arr, int number) {\r	//把数组中的元素依次与指定的数值 进行比较\r	for (int i = 0; i &lt; arr.length; i++) {\r		if (arr[i] == number) {\r			//找到了\r			return i;\r		}\r	}\r	return -1;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 107),
(600, '001.png', '001-png-7', 1521274535, 1521274535, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2018/03/3115237335.png";s:4:"size";i:175459;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 599, 0),
(602, '数组元素二分查找', '602', 1521274680, 1553961283, '<p>本文记录Java学习过程中遇到的数组元素二分查找～</p>\r<!--more-->\r\r<p>如图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/2636310161.png" style="width: 600px; height: 414px;" /></p>\r\r<p>题目分析：</p>\r\r<p>通过观察发现，本题目要实现查找指定数值在<strong>元素有序的数组</strong>中存储的位置（索引），返回该位置（索引）。</p>\r\r<p>1.我们使用数组最中间位置的元素值与要查找的指定数值进行比较，若相等，返回中间元素值的索引</p>\r\r<p>2.最中间位置的元素值与要查找的指定数值进行比较，若不相等，则根据比较的结果，缩小查询范围为上次数组查询范围的一半；</p>\r\r<p style="margin-left: 40px;">再根据新的查询范围，更新最中间元素位置，然后使用中间元素值与要查找的指定数值进行比较：</p>\r\r<ul style="list-style-type:square;">\r	<li>比较结果相等，返回中间元素值的索引</li>\r	<li>比较结果不相等，继续缩小查询范围为上次数组查询范围的一半，更新最中间元素位置，继续比较，依次类推。</li>\r</ul>\r\r<p>3.当查询范围缩小到小于0个元素时，则指定数值没有查询到，返回索引值-1。</p>\r\r<p>解题步骤：</p>\r\r<p>1.定义3个用来记录索引值的变量，变量min记录当前范围最小索引值，初始值为0；变量max记录当前范围最大索引值，初始值为数组长度-1；变量mid记录当前当前范围最中间元素的索引值，初始值为(min+max) / 2；</p>\r\r<p>2.使用循环，判断当前范围下，最中间元素值与指定查找的数值是否相等</p>\r\r<ul style="list-style-type:square;">\r	<li>若相等，结束循环，返回当前范围最中间元素的索引值mid</li>\r	<li>若不相等，根据比较结果，缩小查询范围为上一次查询范围的一般\r	<ul>\r		<li>中间元素值 比 要查询的数值大，说明要查询的数值在当前范围的最小索引位置与中间索引位置之间，此时，更新查询范围为：</li>\r	</ul>\r	</li>\r</ul>\r\r<pre class="brush:java;">\r范围最大索引值 = 上一次中间索引位置 -1；</pre>\r\r<ul style="list-style-type: square; margin-left: 40px;">\r	<li>中间元素值 比 要查询的数值小，说明要查询的数值在当前范围的最大索引位置与中间索引位置之间，此时，更新查询范围为:</li>\r</ul>\r\r<pre class="brush:java;">\r范围最小索引值 = 上一次中间索引位置 +1；</pre>\r\r<ul style="list-style-type: square; margin-left: 40px;">\r	<li>在新的查询范围中，更新中间元素值的位置，再次使用最中间元素值与指定查找的数值是否相等。</li>\r</ul>\r\r<pre class="brush:java;">\r中间索引值 = (范围最小索引值 +范围最大索引值) / 2;</pre>\r\r<p>3.&nbsp; 每次查询范围缩小一半后，使用if语句判断，查询范围是否小于0个元素，若小于0个元素，则说明指定数值没有查询到，返回索引值-1。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//二分查找法(折半查找法)\rpublic static int halfSearch(int[] arr, int number) {\r	//定义3个变量，用来记录min, min, mid的位置\r	int min = 0;\r	int max = arr.length-1;\r	int mid = 0;\r	while (min &lt;= max) {\r           mid = (min+max)/2;\r		//没找了， 更新范围，继续比较\r		//更新范围\r		if (arr[mid] &gt; number) {\r			//在左边\r			max = mid-1;\r		} else if(arr[i] &lt; number){\r			//在右边\r			min = mid+1;\r		}\r		else{\r              return mid ;\r          }\r	 \r	return -1;\r}</pre>\r\r<p>时间复杂度：</p>\r\r<ul>\r	<li>折半查找的时间复杂度为O(logn)，远远好于顺序查找的O(n)。</li>\r	<li>虽然二分查找的效率高，但是要将表按关键字排序。而排序本身是一种很费时的运算。既使采用高效率的排序方法也要花费O(nlgn)的时间。</li>\r</ul>\r\r<p>二分查找只适用顺序存储结构。为保持表的有序性，在顺序结构里插入和删除都必须移动大量的结点。因此，二分查找特别适用于那种一经建立就很少改动、而又经常需要查找的线性表。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(603, 'binary.png', 'binary-png', 1521274810, 1521274810, 'a:5:{s:4:"name";s:10:"binary.png";s:4:"path";s:35:"/usr/uploads/2018/03/2636310161.png";s:4:"size";i:103916;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 602, 0),
(605, '面向过程和面向对象', '605', 1521281400, 1521281729, '<p>本文记录Java学习过程遇到的面向过程和面向对象～</p>\r<!--more-->\r\r<p>面向过程与面向对象都是我们编程中，编写程序的一种思维方式。</p>\r\r<ul>\r	<li>面向过程的程序设计方式，是遇到一件事时，思考&ldquo;我该怎么做&rdquo;，然后一步步实现的过程。</li>\r</ul>\r\r<p style="margin-left:42.0pt;">例如：公司打扫卫生（擦玻璃、扫地、拖地、倒垃圾等），按照面向过程的程序设计方式会思考&ldquo;打扫卫生我该怎么做，然后一件件的完成&rdquo;，最后把公司卫生打扫干净了。</p>\r\r<ul>\r	<li>面向对象的程序设计方式，是遇到一件事时，思考&ldquo;我该让谁来做&rdquo;，然后那个&ldquo;谁&rdquo;就是对象，他要怎么做这件事是他自己的事，反正最后一群对象合力能把事就好就行了。</li>\r</ul>\r\r<p style="margin-left:42.0pt;">例如，公司打扫卫生（擦玻璃、扫地、拖地、倒垃圾等），按照面向对象的程序设计方式会思考&ldquo;我该让谁来做，如小明擦玻璃、让小丽扫地、让小郭拖地、让小强倒垃圾等&rdquo;这里的&ldquo;小明、小丽、小郭、小强&rdquo;就是对象，他们要打扫卫生，怎么打扫是他们自己的事，反正最后一群对象合力把公司卫生打扫干净了。</p>\r\r<p><strong>举例：</strong></p>\r\r<ul>\r	<li>买电脑（组装机）</li>\r</ul>\r\r<p>先使用面向过程说明买电脑这件事：假如我们需要买组装电脑，这时首先会在网上查询具体每一个硬件的参数和报价。然后会去电脑城进行多家询价，接着询价结束后回家根据具体的结果分析出自己比较满意的哪家报价，接着会到这家店里进行组装，组装时还需要进行现场监督，组装完成安装相应的系统，然后电脑抱回家。</p>\r\r<p>分析上述整个过程大体分一下几步：上网查询参数和报价、电脑城询价、现场安装和监督、抱电脑回家。在整个过程中我们参与了每一个细节，并且会感觉相当累。</p>\r\r<p>使用面向对象说明买电脑这件事：假如我们需要买组装机，这时应该找一个懂电脑硬件的人，让他帮我们查看参数和报价，并进行询价和杀价，以及现场组装监督。而我们自己并不需要亲历亲为具体怎么做，只要告诉这个人我们想要的具体需求即可。</p>\r\r<p>分析上述整个过程，发现瞬间变的十分轻松，只要找到懂电脑硬件的这个人，我们的问题都可以解决。并且在这个过程中我们不用那么辛苦。</p>\r\r<p><strong>好处：</strong></p>\r\r<p style="margin-left:21.0pt;">通过生活中的真实场景使用面向对象分析完之后，我们开始分析面向过程和面向对象的差异做出总结：</p>\r\r<ul>\r	<li>面向对象思维方式是一种更符合人们思考习惯的思想</li>\r	<li>面向过程思维方式中更多的体现的是执行者（自己做事情），面向对象中更多的体现是指挥者（指挥对象做事情）。</li>\r</ul>\r\r<p>面向对象思维方式将复杂的问题简单化。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 107),
(606, '对象内存图解', '606', 1521369540, 1521369757, '<p>本文记录Java学习过程中遇到的对象内存图解～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/1806621444.png" style="width: 600px; height: 317px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(607, 'memory.png', 'memory-png', 1521369736, 1521369736, 'a:5:{s:4:"name";s:10:"memory.png";s:4:"path";s:35:"/usr/uploads/2018/03/1806621444.png";s:4:"size";i:258325;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 606, 0),
(609, '类和对象的区别', '609', 1521944040, 1521944214, '<p>本文记录Java学习过程中遇到的类和对象的区别～</p>\r<!--more-->\r\r<p>面向对象的编程思想力图在程序中对事物的描述与该事物在现实中的形态保持一致。为了做到这一点，面向对象的思想中提出两个概念，即类和对象。其中，类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体。接下来通过一个图例来抽象描述类与对象的关系，如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/2781852744.png" style="width: 600px; height: 356px;" /></p>\r\r<p>在上图中，可以将玩具模型看作是一个类，将一个个玩具看作对象，从玩具模型和玩具之间的关系便可以看出类与对象之间的关系。类用于描述多个对象的共同特征，它是对象的模板。对象用于描述现实中的个体，它是类的实例。从上图中可以明显看出对象是根据类创建的，并且一个类可以对应多个对象，接下来分别讲解什么是类和对象。</p>\r\r<p>经过前面几个知识点的学习，基本上掌握了类是用于描述事物的，类中可以定义事物的属性和行为。而对象是通过描述的这个类，使用new关键字创建出来，通过对象就可以调用该对象具体的属性和功能了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 170),
(610, '类和对象.png', '类和对象-png', 1521944161, 1521944161, 'a:5:{s:4:"name";s:16:"类和对象.png";s:4:"path";s:35:"/usr/uploads/2018/03/2781852744.png";s:4:"size";i:192127;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 609, 0),
(612, '局部变量和成员变量区别', '612', 1521945120, 1553961469, '<p>本文记录Java学习过程中遇到的局部变量和成员变量区别～</p>\r<!--more-->\r\r<p>理解清楚了类和对象之后，发现在描述类的属性和前面学习定义变量差别不大，唯一区别就是位置发生了改变，那么类中定义的变量，和在方法定义的变量有啥差别呢？</p>\r\r<p>回忆以前学习时变量的定义方式，和位置，以及现在定义类中属性的特点。总结下面几点区别：</p>\r\r<p>区别一：定义的位置不同</p>\r\r<p style="margin-left:21.0pt;">定义在类中的变量是成员变量</p>\r\r<p style="margin-left:21.0pt;">定义在方法中或者{}语句里面的变量是局部变量</p>\r\r<p>区别二：在内存中的位置不同</p>\r\r<p style="margin-left:21.0pt;">成员变量存储在堆内存的对象中</p>\r\r<p style="margin-left:21.0pt;">局部变量存储在栈内存的方法中</p>\r\r<p>区别三：生命周期不同</p>\r\r<p style="margin-left:21.0pt;">成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失</p>\r\r<p style="margin-left:21.0pt;">局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失</p>\r\r<p>区别四：初始化不同</p>\r\r<p style="margin-left:21.0pt;">成员变量因为在堆内存中，所有默认的初始化值</p>\r\r<p style="margin-left:21.0pt;">局部变量没有默认的初始化值，必须手动的给其赋值才可以使用。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 141),
(613, '基本类型和引用类型的参数传递', '613', 1521985740, 1521986452, '<p>本文记录Java学习过程中遇到的基本类型和引用类型的参数传递～</p>\r<!--more-->\r\r<p>引用类型数据和基本类型数据作为参数传递有没有差别呢？我们用如下代码进行说明，并配合图解。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/204433264.png" style="width: 600px; height: 271px;" /></p>\r\r<p>基本类型作为参数传递时，其实就是将基本类型变量x空间中的值复制了一份传递给调用的方法show()，当在show()方法中x接受到了复制的值，再在show()方法中对x变量进行操作，这时只会影响到show中的x。当show方法执行完成，弹栈后，程序又回到main方法执行，main方法中的x值还是原来的值。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/2873850496.png" style="width: 600px; height: 289px;" /></p>\r\r<p>当引用变量作为参数传递时，这时其实是将引用变量空间中的内存地址(引用)复制了一份传递给了show方法的d引用变量。这时会有两个引用同时指向堆中的同一个对象。当执行show方法中的d.x=6时，会根据d所持有的引用找到堆中的对象，并将其x属性的值改为6.show方法弹栈。</p>\r\r<p>由于是两个引用指向同一个对象，不管是哪一个引用改变了引用的所指向的对象的中的值，其他引用再次使用都是改变后的值。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 149),
(614, '参数.png', '参数-png', 1521986334, 1521986334, 'a:5:{s:4:"name";s:10:"参数.png";s:4:"path";s:34:"/usr/uploads/2018/03/204433264.png";s:4:"size";i:179518;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 613, 0),
(616, 'chuandi.png', 'chuandi-png', 1521986415, 1521986415, 'a:5:{s:4:"name";s:11:"chuandi.png";s:4:"path";s:35:"/usr/uploads/2018/03/2873850496.png";s:4:"size";i:197240;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 613, 0),
(617, '封装概述', '617', 1521986520, 1553961677, '<p>本文记录Java学习过程中遇到的封装～</p>\r<!--more-->\r\r<p>提起封装，大家并不陌生。前面我们学习方法时，就提起过，将具体功能封装到方法中，学习对象时，也提过将方法封装在类中，其实这些都是封装。</p>\r\r<p>封装，它也是面向对象思想的特征之一。面向对象共有三个特征：封装，继承，多态。接下来我们具体学习封装。</p>\r\r<ul>\r	<li>封装表现：\r	<ul style="list-style-type:square;">\r		<li>1、方法就是一个最基本封装体；</li>\r		<li>2、类其实也是一个封装体。</li>\r	</ul>\r	</li>\r	<li>从以上两点得出结论，封装的好处：\r	<ul style="list-style-type:square;">\r		<li>1、提高了代码的复用性；</li>\r		<li>2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念；</li>\r		<li>3、提高了安全性。</li>\r	</ul>\r	</li>\r</ul>\r\r<p><strong>举例：</strong></p>\r\r<p>机箱：一台电脑，它是由CPU、主板、显卡、内存、硬盘、电源等部件组成，其实我们将这些部件组装在一起就可以使用电脑了，但是发现这些部件都散落在外面，很容造成不安全因素，于是，使用机箱壳子，把这些部件都装在里面，并在机箱壳上留下一些插口等，若不留插口，大家想想会是什么情况。</p>\r\r<p>总结：机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(618, 'private关键字', '618', 1521986940, 1521987135, '<p>本文记录Java学习过程中遇到的private关键字～</p>\r<!--more-->\r\r<p>了解到封装在生活的体现之后，又要回到Java中，细说封装的在Java代码中的体现，先从描述Person说起。</p>\r\r<p>描述人。Person</p>\r\r<p>属性：年龄。</p>\r\r<p>行为：说话：说出自己的年龄。</p>\r\r<pre class="brush:java;">\rclass Person {\r	int age;\r	String name;\r\r	public void show() {\r		System.out.println(&quot;age=&quot; + age + &quot;,name&quot; + name);\r	}\r}\r\rpublic class PersonDemo {\r	public static void main(String[] args) {\r		// 创建Person对象\r		Person p = new Person();\r		p.age = -20; // 给Person对象赋值\r		p.name = &quot;人妖&quot;;\r		p.show(); // 调用Person的show方法\r	}\r}</pre>\r\r<p>通过上述代码发现，虽然我们用Java代码把Person描述清楚了，但有个严重的问题，就是Person中的属性的行为可以任意访问和使用。这明显不符合实际需求。</p>\r\r<p>可是怎么才能不让访问呢？需要使用一个Java中的关键字也是一个修饰符 private(私有，权限修饰符)。只要将Person的属性和行为私有起来，这样就无法直接访问。</p>\r\r<pre class="brush:java;">\rclass Person {\r	private int age;\r	private String name;\r\r	public void show() {\r		System.out.println(&quot;age=&quot; + age + &quot;,name&quot; + name);\r	}\r}</pre>\r\r<p>年龄已被私有，错误的值无法赋值，可是正确的值也赋值不了，这样还是不行，那肿么办呢？按照之前所学习的封装的原理，隐藏后，还需要提供访问方式。只要对外提供可以访问的方法，让其他程序访问这些方法。同时在方法中可以对数据进行验证。</p>\r\r<p>一般对成员属性的访问动作：赋值(设置 set)，取值(获取 get)，因此对私有的变量访问的方式可以提供对应的 setXxx或者getXxx的方法。</p>\r\r<pre class="brush:java;">\rclass Person {\r	// 私有成员变量\r	private int age;\r	private String name;\r\r	// 对外提供设置成员变量的方法\r	public void setAge(int a) {\r		// 由于是设置成员变量的值，这里可以加入数据的验证\r		if (a &lt; 0 || a &gt; 130) {\r			System.out.println(a + &quot;不符合年龄的数据范围&quot;);\r			return;\r		}\r		age = a; \r	}\r\r	// 对外提供访问成员变量的方法\r	public void getAge() {\r		return age;\r	}\r}</pre>\r\r<ul>\r	<li>总结：</li>\r</ul>\r\r<ol>\r	<li style="margin-left:21.0pt;">类中不需要对外提供的内容都私有化，包括属性和方法。</li>\r	<li style="margin-left:21.0pt;">以后再描述事物，属性都私有化，并提供setXxx getXxx方法对其进行访问。</li>\r</ol>\r\r<ul>\r	<li>注意：私有仅仅是封装的体现形式而已。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(619, 'this关键字', '619', 1521987300, 1521991758, '<p>本文记录Java学习过程中遇到的this关键字～</p>\r<!--more-->\r\r<p><strong>成员变量和局部变量同名问题</strong></p>\r\r<p>当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变量成员变量呢？可以在成员变量名前面加上this.来区别成员变量和局部变量。</p>\r\r<pre class="brush:java;">\rclass Person {\r	private int age;\r	private String name;\r	\r	public void speak() {\r		this.name = &quot;小强&quot;;\r		this.age = 18;\r		System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);\r	}\r}\r\rclass PersonDemo {\r	public static void main(String[] args) {\r		Person p = new Person();\r		p.speak();\r	}\r}</pre>\r\r<p><strong>对象的内存解释</strong></p>\r\r<p>我们已经学习了如何把生活中的事物使用Java代码描述，接下来我们分析对象在内存中的分配情况。这里需要画图一步一步演示，严格按照画图流程讲解内存对象创建使用过程。</p>\r\r<pre class="brush:java;">\rclass Person {\r	private int age;\r	public int getAge() {\r		return this.age;\r	}\r	public void setAge(int age) {\r		this.age = age;\r	}\r}\rpublic class PersonDemo {\r	public static void main(String[] args) {\r		Person p = new Person();\r		p.setAge(30);\r		System.out.println(&quot;大家好，今年我&quot; + p.getAge() + &quot;岁&quot;);\r	}\r}</pre>\r\r<p>下图为程序中内存对象的创建使用过程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/03/348745964.png" style="width: 600px; height: 436px;" /></p>\r\r<p style="margin-left:21.0pt;">程序执行流程说明：</p>\r\r<ol>\r	<li value="NaN">先执行main方法（压栈），执行其中的 Person p = new Person()；</li>\r	<li value="NaN">在堆内存中开辟空间，并为其分配内存地址0x1234，紧接着成员变量默认初始化(age = 0)；将内存地址0x1234赋值给栈内中的Person p 变量</li>\r	<li value="NaN">继续执行p.setAge(30)语句，这时会调用setAge(int age)方法，将30赋值为setAge方法中的&ldquo;age&rdquo;变量；执行this.age = age语句，将age变量值30 赋值给成员变量this.age为30；</li>\r	<li value="NaN">setAge()方法执行完毕后（弹栈），回到main()方法，执行输出语句System.out.println()，控制台打印p对象中的age年龄值。</li>\r</ol>\r\r<ul>\r	<li>注意：\r	<ul style="list-style-type:square;">\r		<li>this到底代表什么呢？this代表的是对象，具体代表哪个对象呢？哪个对象调用了this所在的方法，this就代表哪个对象。</li>\r		<li>上述代码中的 p.setAge(30)语句中，setAge(int age)方法中的this代表的就是p对象。</li>\r	</ul>\r	</li>\r</ul>\r\r<p><strong>this的应用</strong></p>\r\r<p>学习this的用法之后，现在做个小小的练习。</p>\r\r<p>需求：在Person类中定义功能，判断两个人是否是同龄人</p>\r\r<pre class="brush:java;">\rclass Person {\r	private int age;\r	private String name;\r	\r	public int getAge() {\r		return age;\r	}\r\r	public void setAge(int age) {\r		this.age = age;\r	}\r\r	public String getName() {\r		return name;\r	}\r\r	public void setName(String name) {\r		this.name = name;\r	}\r\r	public void speak() {\r		System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);\r	}\r\r	// 判断是否为同龄人\r	public boolean equalsAge(Person p) {\r		// 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较\r		// 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替\r		/*\r		 * if(this.age == p.age) { return true; } return false;\r		 */\r		return this.age == p.age;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(620, 'm.png', 'm-png', 1521991661, 1521991661, 'a:5:{s:4:"name";s:5:"m.png";s:4:"path";s:34:"/usr/uploads/2018/03/348745964.png";s:4:"size";i:317114;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 619, 0),
(622, '继承的概念 ', '622', 1523374680, 1523374897, '<p>本文记录Java学习过程中遇到的继承的概念～</p>\r<!--more-->\r\r<p>在现实生活中，继承一般指的是子女继承父辈的财产。在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如公司中的研发部员工和维护部员工都属于员工，程序中便可以描述为研发部员工和维护部员工继承自员工，同理，JavaEE工程师和Android工程师继承自研发部员工，而维网络维护工程师和硬件维护工程师继承自维护部员工。这些员工之间会形成一个继承体系，具体如下图所示 ：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/04/2015222399.png" style="width: 600px; height: 304px;" /></p>\r\r<p>在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(623, 'extend.png', 'extend-png', 1523374857, 1523374857, 'a:5:{s:4:"name";s:10:"extend.png";s:4:"path";s:35:"/usr/uploads/2018/04/2015222399.png";s:4:"size";i:192702;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 622, 0),
(625, '继承的格式及使用', '625', 1523374980, 1523375110, '<p>本文记录Java学习过程中遇到的继承的格式及使用～</p>\r<!--more-->\r\r<p>在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。</p>\r\r<pre class="brush:java;">\r格式：\rclass 子类 extends 父类 {}</pre>\r\r<p><span style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 10.5pt; font-family: 宋体;">接下来通过一个案例来学习子类是如何继承父类的，如下所示：</span></p>\r\r<pre class="brush:java;">\r/*\r * 定义员工类Employee\r */\rclass Employee {\r	String name; // 定义name属性\r	// 定义员工的工作方法\r	public void work() {\r		System.out.println(&quot;尽心尽力地工作&quot;);\r	}\r}\r\r/*\r * 定义研发部员工类Developer 继承 员工类Employee\r */\rclass Developer extends Employee {\r	// 定义一个打印name的方法\r	public void printName() {\r		System.out.println(&quot;name=&quot; + name);\r	}\r}\r\r/*\r * 定义测试类\r */\rpublic class Example01 {\r	public static void main(String[] args) {\r		Developer d = new Developer(); // 创建一个研发部员工类对象\r		d.name = &quot;小明&quot;; // 为该员工类的name属性进行赋值\r		d.printName(); // 调用该员工的printName()方法\r		d.work(); // 调用Developer类继承来的work()方法\r	}\r}</pre>\r\r<p class="Java" style="margin: 0cm 0cm 0.0001pt; text-align: justify; text-indent: 21pt; font-size: 10.5pt; font-family: &quot;Times New Roman&quot;, serif; caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0);"><span style="font-family: 宋体;">在上述代码中，</span><span lang="EN-US">Developer</span><span style="font-family: 宋体;">类通过</span><span lang="EN-US">extends</span><span style="font-family: 宋体;">关键字继承了</span><span lang="EN-US">Employee</span><span style="font-family: 宋体;">类，这样</span><span lang="EN-US">Developer</span><span style="font-family: 宋体;">类便是</span><span lang="EN-US">Employee</span><span style="font-family: 宋体;">类的子类。从运行结果不难看出，子类虽然没有定义</span><span lang="EN-US">name</span><span style="font-family: 宋体;">属性和</span><span lang="EN-US">work()</span><span style="font-family: 宋体;">方法，但是却能访问这两个成员。这就说明，子类在继承父类的时候，会自动拥有父类的成员。</span></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(626, '继承的好处及注意事项', '626', 1523375280, 1523375372, '<p>本文记录Java学习过程中遇到的继承的好处及注意事项～</p>\r<!--more-->\r\r<p>继承的好处：</p>\r\r<p style="margin-left:21pt;">1、继承的出现提高了代码的复用性，提高软件开发效率。</p>\r\r<p style="margin-left:21pt;">2、继承的出现让类与类之间产生了关系，提供了多态的前提。</p>\r\r<p>在类的继承中，需要注意一些问题，具体如下：</p>\r\r<ul>\r	<li>1、在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。</li>\r</ul>\r\r<pre class="brush:java;">\rclass A{} \r\r     class B{}\r\r     class C extends A,B{}  // C类不可以同时继承A类和B类</pre>\r\r<ul>\r	<li>2、多个类可以继承一个父类，例如下面这种情况是允许的。</li>\r</ul>\r\r<pre class="brush:java;">\r     class A{}\r\r     class B extends A{}\r\r     class C extends A{}   // 类B和类C都可以继承类A</pre>\r\r<ul>\r	<li>3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。</li>\r</ul>\r\r<pre class="brush:java;">\rclass A{}\r\r     class B extends A{}   // 类B继承类A，类B是类A的子类\r\r     class C extends B{}   // 类C继承类B，类C是类B的子类，同时也是类A的子类</pre>\r\r<ul>\r	<li>4、在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(627, '继承中子父类成员变量的特点', '627', 1523619180, 1523619593, '<p>本文记录Java学习过程中遇到的继承中父子类成员变量的特点～</p>\r<!--more-->\r\r<p>了解了继承给我们带来的好处，提高了代码的复用性。继承让类与类或者说对象与对象之间产生了关系。那么，当继承出现后，类的成员之间产生了那些变化呢？</p>\r\r<p>类的成员重点学习成员变量、成员方法的变化。</p>\r\r<p>成员变量：如果子类父类中出现不同名的成员变量，这时的访问是没有任何问题。</p>\r\r<p>代码示例：</p>\r\r<pre class="brush:java;">\rclass Fu\r{\r	//Fu中的成员变量。\r	int num = 5;\r}\rclass Zi extends Fu\r{\r	//Zi中的成员变量\r	int num2 = 6;\r	//Zi中的成员方法\r	public void show()\r	{\r		//访问父类中的num\r		System.out.println(&quot;Fu num=&quot;+num);\r		//访问子类中的num2\r		System.out.println(&quot;Zi num2=&quot;+num2);\r	}\r}\rclass Demo \r{\r	public static void main(String[] args) \r	{\r		Zi z = new Zi(); //创建子类对象\r		z.show(); //调用子类中的show方法\r	}\r}</pre>\r\r<p>说明：Fu类中的成员变量是非私有的，子类中可以直接访问，若Fu类中的成员变量私有了，子类是不能直接访问的。</p>\r\r<p><span style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 10.5pt; font-family: 宋体;">当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字</span><span lang="EN-US" style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 10.5pt; font-family: Calibri, sans-serif;">super</span><span style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 10.5pt; font-family: 宋体;">来完成。</span><span lang="EN-US" style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 10.5pt; font-family: Calibri, sans-serif;">super</span><span style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 10.5pt; font-family: 宋体;">用来表示当前对象中包含的父类对象空间的引用。使用格式为：</span></p>\r\r<pre class="brush:java;">\rsuper.父类中的成员变量</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu\r{\r	//Fu中的成员变量。\r	int num = 5;\r}\rclass Zi extends Fu\r{\r	//Zi中的成员变量\r	int num = 6;\r	void show()\r	{\r		//子父类中出现了同名的成员变量时\r		//在子类中需要访问父类中非私有成员变量时，需要使用super关键字\r		//访问父类中的num\r		System.out.println(&quot;Fu num=&quot;+super.num);\r		//访问子类中的num2\r		System.out.println(&quot;Zi num2=&quot;+this.num);\r	}\r}\rclass Demo5 \r{\r	public static void main(String[] args) \r	{\r		Zi z = new Zi(); //创建子类对象\r		z.show(); //调用子类中的show方法\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(628, '继承中的重写及应用', '628', 1523624040, 1523624180, '<p>本文记录Java学习过程中遇到的继承中的重写及应用～</p>\r<!--more-->\r\r<ul>\r	<li>子父类中成员方法的特点</li>\r</ul>\r\r<p>当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu{\r\r    public void show(){\r\r        System.out.println(&quot;Fu类中的show方法执行&quot;);\r\r    }\r\r}\r\rclass Zi extends Fu{\r\r    public void show2(){\r\r        System.out.println(&quot;Zi类中的show2方法执行&quot;);\r\r    }\r\r}\r\rpublic  class Test{\r\r    public static void main(String[] args) {\r\r        Zi z = new Zi();\r\r        z.show(); //子类中没有show方法，但是可以找到父类方法去执行\r\r        z.show2();\r\r    }\r}</pre>\r\r<ul>\r	<li>成员方法特殊情况&mdash;&mdash;覆盖</li>\r</ul>\r\r<p>子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu\r\r{\r\r    public void show()\r\r    {\r\r        System.out.println(&quot;Fu show&quot;);\r\r    }\r\r}\r\rclass Zi extends Fu\r\r{\r\r    //子类复写了父类的show方法\r\r    public void show()\r\r    {\r\r        System.out.println(&quot;Zi show&quot;);\r\r    }\r}</pre>\r\r<ul>\r	<li>方法重写（覆盖）的应用：</li>\r</ul>\r\r<p>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。</p>\r\r<p>举例：比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，后期由于手机需要在来电显示功能中增加显示姓名和头像，这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能。</p>\r\r<p>在子类中，访问父类中的成员方法格式：</p>\r\r<pre class="brush:java;">\rsuper.父类中的成员方法();</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class Test {\r\r    public static void main(String[] args) {\r\r        new NewPhone().showNum();\r\r    }\r\r}\r\r\r\r//手机类\r\rclass Phone{\r\r    public void sendMessage(){\r\r        System.out.println(&quot;发短信&quot;);\r\r    }\r\r    public void call(){\r\r        System.out.println(&quot;打电话&quot;);\r\r    }\r\r    public void showNum(){\r\r        System.out.println(&quot;来电显示号码&quot;);\r\r    }\r\r}\r\r\r\r//智能手机类\r\rclass NewPhone extends Phone{\r\r    \r\r    //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能\r\r    public void showNum(){\r\r        //调用父类已经存在的功能使用super\r\r        super.showNum();\r\r        //增加自己特有显示姓名和图片功能\r\r        System.out.println(&quot;显示来电姓名&quot;);\r\r        System.out.println(&quot;显示头像&quot;);\r\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(629, '重写的注意事项', '629', 1523624220, 1523624333, '<p>本文记录Java学习过程中遇到的重写的注意事项～</p>\r<!--more-->\r\r<p>重写需要注意的细节问题：</p>\r\r<ul>\r	<li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li>\r</ul>\r\r<pre class="brush:java;">\rclass Fu(){  \r\rvoid show(){}\r    public void method(){}\r}\r\rclass Zi() extends Fu{\r\rpublic void show(){}  //编译运行没问题\r    void method(){}      //编译错误\r}</pre>\r\r<ul>\r	<li>写法上稍微注意:必须一模一样:方法的返回值类型 方法名 参数列表都要一样。</li>\r</ul>\r\r<p>总结：当一个类是另一个类中的一种时，可以通过继承，来继承属性与功能。如果父类具备的功能内容需要子类特殊定义时，进行方法重写。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97),
(630, '抽象类的概述', '630', 1523627340, 1523627500, '<p>本文记录Java学习过程中遇到的抽象类～</p>\r<!--more-->\r\r<p>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体。</p>\r\r<p>但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。比如一个图形类应该有一个求周长的方法，但是不同的图形求周长的算法不一样。那该怎么办呢？</p>\r\r<p>分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。</p>\r\r<p>例如：</p>\r\r<ul>\r	<li>描述JavaEE工程师：行为：工作。</li>\r	<li>描述Android工程师：行为：工作。</li>\r</ul>\r\r<p>JavaEE工程师和Android工程师之间有共性，可以进行向上抽取。抽取它们的所属共性类型：研发部员工。由于JavaEE工程师和Android工程师都具有工作功能，但是他们具体工作内容却不一样。这时在描述研发部员工时，发现了有些功能（工作）不具体，这些不具体的功能，需要在类中标识出来，通过java中的关键字abstract(抽象)。</p>\r\r<p>当定义了抽象函数的类也必须被abstract关键字修饰，被abstract关键字修饰的类是抽象类。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(631, '抽象类和抽象方法的定义', '631', 1523642400, 1523642525, '<p>本文记录Java学习过程中遇到的抽象类和抽象方法的定义～</p>\r<!--more-->\r\r<p>抽象方法定义的格式：</p>\r\r<pre class="brush:java;">\rpublic abstract 返回值类型方法名(参数);</pre>\r\r<p>抽象类定义的格式：</p>\r\r<pre class="brush:java;">\rabstract class 类名{\r\r}</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//研发部员工\r\rabstractclassDeveloper {\r\r    publicabstractvoidwork();//抽象函数。需要abstract修饰，并分号;结束\r\r}\r\r\r\r//JavaEE工程师\r\rclassJavaEE extendsDeveloper{\r\r    publicvoidwork() {\r\r        System.out.println(&quot;正在研发淘宝网站&quot;);\r\r    }\r\r}\r\r\r\r//Android工程师\r\rclassAndroid extendsDeveloper {\r\r    publicvoidwork() {\r\r        System.out.println(&quot;正在研发淘宝手机客户端软件&quot;);\r\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(632, '抽象类的特点', '632', 1523642580, 1553962094, '<p>本文记录Java学习过程中遇到的抽象类的特点～</p>\r<!--more-->\r\r<ol>\r	<li>抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中；</li>\r	<li>抽象类不可以直接创建对象，原因：调用抽象方法没有意义；</li>\r	<li>只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。</li>\r</ol>\r\r<p>之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(633, '抽象类的一些细节', '633', 1523642820, 1523702788, '<p>本文记录Java学习过程中遇到的抽象类的一些细节～</p>\r<!--more-->\r\r<p>1、抽象类一定是个父类？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\r<p>是的，因为不断抽取而来的。</p>\r\r<p>2、抽象类中是否可以不定义抽象方法？</p>\r\r<p>是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用</p>\r\r<p>3、抽象关键字abstract不可以和哪些关键字共存？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\r<ul>\r	<li>1、private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子类根本无法得到父类这个方法。互相矛盾。</li>\r	<li>2、final：方法不能被子类重写；</li>\r	<li>3、static：类方法必须是已经实现了的，不能是抽象的。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(634, '接口的概念', '634', 1523702880, 1523702944, '<p>本文记录Java学习过程中遇到的接口～</p>\r<!--more-->\r\r<p>接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的&rdquo;类&rdquo;。</p>\r\r<p>接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。</p>\r\r<p>请记住：一切事物均有功能，即一切事物均有接口。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(635, '接口的定义', '635', 1523703000, 1523705336, '<p>本文记录Java学习过程中遇到的接口的定义方法～</p>\r<!--more-->\r\r<p>与定义类的class不同，接口定义时需要使用interface关键字。</p>\r\r<p>定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\rpublic interface 接口名 {\r\r    抽象方法1;\r    抽象方法2;\r    抽象方法3;\r}</pre>\r\r<p>​使用interface代替了原来的class，其他步骤与定义类相同：</p>\r\r<ul>\r	<li>接口中的方法均为公共访问的抽象方法；</li>\r	<li>接口中无法定义普通的成员变量。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 89);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(636, '类实现接口', '636', 1523704440, 1553962355, '<p>本文记录Java学习过程中遇到的类实现接口～</p>\r<!--more-->\r\r<p>类与接口的关系为实现关系，即类实现接口。</p>\r\r<p>实现的动作类似继承，只是关键字不同，实现使用implements。</p>\r\r<p>其他类(实现类)实现接口后，就相当于声明：&ldquo;我应该具备这个接口中的功能&rdquo;，实现类仍然需要重写方法以实现具体的功能。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\rclass 类implements 接口{\r\r    重写接口中方法\r} </pre>\r\r<p>在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类需要重写该抽象方法，完成具体的逻辑：</p>\r\r<ul>\r	<li>接口中定义功能，当需要具有该功能时，可以让类实现该接口，只声明了应该具备该方法，是功能的声明；</li>\r	<li>在具体实现类中重写方法，实现功能，是方法的具体实现。</li>\r</ul>\r\r<p>于是，通过以上两个动作将功能的声明与实现便分开了。(注意：类是现实事物的描述，接口是功能的集合。)</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(637, '接口中成员的特点', '637', 1523704920, 1523705410, '<p>本文记录Java学习过程中遇到的接口中成员的特点～</p>\r<!--more-->\r\r<ol>\r	<li>接口中可以定义变量，但是变量必须有固定的修饰符修饰public static final，所以接口中的变量也称之为常量，其值不能改变；</li>\r	<li>接口中可以定义方法，方法也有固定的修饰符public abstract；</li>\r	<li>接口不可以创建对象；</li>\r	<li>子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化；否则子类是一个抽象类。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//定义一个名称为Demo的接口\rinterface Demo { \r\r    // NUM的值不能改变\r    public static final int NUM = 3;\r    public abstract void show1();\r    public abstract void show2();\r}\r\r//子类实现Demo接口\rclass DemoImpl implementsDemo { \r\r    //重写接口中的方法。\r    public void show1(){}\r    public void show2(){}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(638, '接口的多实现', '638', 1523705520, 1523705667, '<p>本文记录Java学习过程中遇到的接口的多实现～</p>\r<!--more-->\r\r<p>了解了接口的特点后，那么想想为什么要定义接口，使用抽象类描述也没有问题，接口到底有啥用呢？</p>\r\r<p>接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。</p>\r\r<pre class="brush:java;">\rinterface Fu1{\r\r    void show1();\r}\r\rinterface Fu2{\r\r    void show2();\r}\r\r//多实现，同时实现多个接口\rclass Zi implements Fu1,Fu2{\r\r    public void show1(){}\r    public void show2(){}\r}</pre>\r\r<p>1.怎么解决多继承的弊端呢？</p>\r\r<p>弊端：多继承时，当多个父类中有相同功能时，子类调用会产生不确定性。</p>\r\r<p>其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。</p>\r\r<p>2.为什么多实现能解决了呢？</p>\r\r<p>因为接口中的功能都没有方法体，由子类来明确。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(639, '类继承类同时实现接口', '639', 1523712360, 1523712516, '<p>本文记录Java学习过程中遇到的类继承的同时实现接口～</p>\r<!--more-->\r\r<p>接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了。</p>\r\r<p>子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu {\r\r	public void show(){}\r}\r\rinterface Inter {\r\r	pulbic abstract void show1();\r}\r\rclass Zi extends Fu implements Inter {\r\r	public void show1() {}\r}</pre>\r\r<p>接口的出现避免了单继承的局限性：父类中定义的事物的基本功能，接口中定义的事物的扩展功能。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(640, '接口的多继承', '640', 1523712540, 1523712653, '<p>本文记录Java学习过程中遇到的接口的多继承～</p>\r<!--more-->\r\r<p>学习类的时候，知道类与类之间可以通过继承产生关系，接口和类之间可以通过实现产生关系，那么接口与接口之间会有什么关系。</p>\r\r<p>多个接口之间可以使用extends进行继承。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rinterface Fu1{\r\r	void show();\r}\r\rinterface Fu2{\r\r	void show1();\r}\r\rinterface Fu3{\r\r	void show2();\r}\r\rinterface Zi extends Fu1,Fu2,Fu3{\r\r	void show3();\r}</pre>\r\r<p>在开发中如果多个接口中存在相同方法，这时若有个类实现了这些接口，那么就要实现接口中的方法，由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(641, '接口的思想', '641', 1523712720, 1553962485, '<p>本文记录Java学习过程中遇到的接口的思想～</p>\r<!--more-->\r\r<p>前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。</p>\r\r<p><strong>举例：</strong>我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用，所以这个插口的出现让我们使用更多的设备。</p>\r\r<p><strong>总结（</strong>接口在开发中的好处<strong>）：</strong></p>\r\r<ol>\r	<li style="margin-left:10.5pt;">接口的出现扩展了功能；</li>\r	<li style="margin-left:10.5pt;">接口其实就是暴漏出来的规则；</li>\r	<li style="margin-left:10.5pt;">接口的出现降低了耦合性，即设备与设备之间实现了解耦。</li>\r</ol>\r\r<p>接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(642, '接口和抽象类的区别', '642', 1523712900, 1553962530, '<p>本文记录Java学习过程中遇到的接口和抽象类的区别～</p>\r<!--more-->\r\r<p>明白了接口思想和接口的用法后，接口和抽象类的区别是什么呢？接口在生活体现也基本掌握，那在程序中接口是如何体现的呢？</p>\r\r<p>我们通过实例进行分析和代码演示抽象类和接口的用法：</p>\r\r<p><strong>举例</strong>：</p>\r\r<pre class="brush:java;">\r犬：\r\r    行为：\r\r       吼叫；\r\r       吃饭；\r\r缉毒犬：\r\r    行为：\r\r        吼叫；\r\r        吃饭；\r\r        缉毒；</pre>\r\r<p><strong>思考</strong>：</p>\r\r<p>由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。</p>\r\r<p>可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。</p>\r\r<p>代码示例：</p>\r\r<pre class="brush:java;">\rinterface 缉毒{\r\r    public abstract void 缉毒();\r}\r\r//定义犬科的这个提醒的共性功能\rabstract class 犬科{\r\r    public abstract void 吃饭();\r    public abstract void 吼叫();\r}\r\r// 缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，\r//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能\rclass 缉毒犬 extends 犬科 implements 缉毒{\r    public void 缉毒() {\r\r    }\r\r    void 吃饭() {\r    }\r\r    void 吼叫() {\r    }\r}</pre>\r\r<p>3、通过上面的例子总结接口和抽象类的区别：</p>\r\r<p><strong>相同：</strong></p>\r\r<ul>\r	<li>都位于继承的顶端,用于被其他类实现或继承；</li>\r	<li>都不能直接实例化对象；</li>\r	<li>都包含抽象方法,其子类都必须覆写这些抽象方法。</li>\r</ul>\r\r<p><strong>区别：</strong></p>\r\r<ul>\r	<li>抽象类为部分方法提供实现，避免子类重复实现这些方法，提高代码重用性，接口只能包含抽象方法；</li>\r	<li>一个类只能继承一个直接父类(可能是抽象类)，却可以实现多个接口，弥补了Java的单继承；</li>\r	<li>抽象类是这个事物中应该具备的你内容,&nbsp;继承体现是一种is..a关系；</li>\r	<li>接口是这个事物中的额外内容，实现体现是一种like..a关系。</li>\r</ul>\r\r<p>二者的选用原则：</p>\r\r<ul>\r	<li>优先选用接口，尽量少用抽象类；</li>\r	<li>需要定义子类的行为，又要为子类提供共性功能时才选用抽象类。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 121),
(643, '多态概述', '643', 1523766120, 1523766240, '<p>本文记录Java学习过程中遇到的多态概述～</p>\r<!--more-->\r\r<p>多态是继封装、继承之后，面向对象的第三大特性。</p>\r\r<p>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\r\r<p>Java作为面向对象的语言，同样可以描述一个事物的多种形态，如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</p>\r\r<p>Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。比如，Student类可以为Person类的子类，那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。</p>\r\r<p>最终多态体现为父类引用变量可以指向子类对象。</p>\r\r<p>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。</p>\r\r<p>在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(644, '多态的定义与使用格式', '644', 1523768340, 1523768896, '<p>本文记录Java学习过程中遇到的多态的定义与使用格式～</p>\r<!--more-->\r\r<p>多态的定义格式：</p>\r\r<pre class="brush:java;">\r父类类型  变量名= new 子类类型();\r变量名.方法名();</pre>\r\r<ul>\r	<li>普通类多态定义的格式</li>\r</ul>\r\r<pre class="brush:java;">\r父类变量名= new 子类();</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu {}\r\rclass Zi extends Fu {}\r\r//类的多态使用\rFu f = new Zi();</pre>\r\r<ul>\r	<li>抽象类多态定义的格式</li>\r</ul>\r\r<pre class="brush:java;">\r抽象类变量名= new 抽象类子类();</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rabstract class Fu {\r\r    public abstract void method();\r}\r\rclass Zi extends Fu {\r\r    public void method(){\r        System.out.println(&ldquo;重写父类抽象方法&rdquo;);\r    }\r}\r\r//类的多态使用\rFu fu= new Zi();</pre>\r\r<ul>\r	<li>接口多态定义的格式</li>\r</ul>\r\r<pre class="brush:java;">\r接口变量名= new 接口实现类();</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rinterface Fu {\r    public abstract void method();\r}\r\rclass Zi implements Fu {\r\r    public void method(){\r        System.out.println(&ldquo;重写接口抽象方法&rdquo;);\r    }\r}\r\r//接口的多态使用\rFu fu = new Zi();</pre>\r\r<ul>\r	<li>注意事项：同一个父类的方法会被不同的子类重写，在调用方法时，调用的为各个子类重写后的方法。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rPerson p1 = new Student();\rPerson p2 = new Teacher();\r\rp1.work(); //p1会调用Student类中重写的work方法\rp2.work(); //p2会调用Teacher类中重写的work方法</pre>\r\r<p>当变量名指向不同的子类对象时，由于每个子类重写父类方法的内容不同，所以会调用不同的方法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(645, '多态中成员的特点', '645', 1523768940, 1523769528, '<p>本文记录Java学习过程中遇到的多态中成员的特点～</p>\r<!--more-->\r\r<p>掌握了多态的基本使用后，那么多态出现后类的成员有啥变化呢？前面学习继承时，我们知道子父类之间成员变量有了自己的特定变化，那么当多态出现后，成员变量在使用上有没有变化呢？</p>\r\r<p>多态出现后会导致子父类中的成员变量有微弱的变化。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu {\r	int num = 4;\r}\r\rclass Zi extends Fu {\r	int num = 5;\r}\r\rclass Test {\r	public static void main(String[] args) 	{\r		Fu f = new Zi();\r		System.out.println(f.num);\r		Zi z = new Zi();\r		System.out.println(z.num);\r	}\r}\r</pre>\r\r<ul>\r	<li>多态成员变量</li>\r</ul>\r\r<p style="margin-left:21pt;">当子父类中出现同名的成员变量时，多态调用该变量时：</p>\r\r<p style="margin-left:21pt;">编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量，没有则编译失败。</p>\r\r<p style="margin-left:21pt;">运行时期：调用引用型变量所属的类中的成员变量。</p>\r\r<p style="margin-left:21pt;">简单记作：编译和运行都参考等号的左边。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\r\r<p>多态出现后会导致子父类中的成员方法有微弱的变化。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu {\r    int num = 4;\r    void show()  {\r        System.out.println(&quot;Fu show num&quot;);\r    }\r}\r\rclass Zi extends Fu {\r    int num = 5;\r    void show()  {\r        System.out.println(&quot;Zi show num&quot;);\r    }\r}\r\rclass Demo {\r    public static void main(String[] args)    {\r        Fu f = new Zi();\r        f.show();\r    }\r}</pre>\r\r<ul>\r	<li>多态成员方法</li>\r</ul>\r\r<p style="margin-left:21pt;">编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。</p>\r\r<p style="margin-left:21pt;">运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。</p>\r\r<p style="margin-left:21pt;">简而言之：编译看左边，运行看右边。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 118),
(646, 'instanceof关键字', '646', 1523769600, 1553992175, '<p>本文记录Java学习过程中遇到的instanceof关键字～</p>\r<!--more-->\r\r<p>我们可以通过instanceof关键字来判断某个对象是否属于某种数据类型。如学生的对象属于学生类，学生的对象也属于人类。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\rboolean  b  = 对象  instanceof 数据类型;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 前提条件，学生类已经继承了人类\rPerson p1 = new Student();\r//flag结果为true\rboolean flag = p1 instanceof Student;\r//flag结果为false\rboolean flag2 = p1 instanceof Teacher;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 133),
(647, '多态的转型', '647', 1523770620, 1523783216, '<p>本文记录Java学习过程中遇到的多态的转型～</p>\r<!--more-->\r\r<p>多态的转型分为向上转型与向下转型两种：</p>\r\r<ul>\r	<li>向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。</li>\r</ul>\r\r<p style="margin-left:21pt;">使用格式：</p>\r\r<pre class="brush:java;">\r      父类类型  变量名= new 子类类型();</pre>\r\r<p style="margin-left:21pt;">示例代码：</p>\r\r<pre class="brush:java;">\r      Person p = new Student();</pre>\r\r<ul>\r	<li>向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。但是，如果是直接创建父类对象，是无法向下转型的。</li>\r</ul>\r\r<p style="margin-left:21pt;">使用格式：</p>\r\r<pre class="brush:java;">\r      子类类型变量名= (子类类型) 父类类型的变量;</pre>\r\r<p style="margin-left:21pt;">示例代码：</p>\r\r<pre class="brush:java;">\r      //变量p 实际上指向Student对象\r      Student stu = (Student) p;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(648, '多态的好处与弊端', '648', 1523783460, 1553992247, '<p>本文记录Java学习过程中遇到的多态的好处与弊端～</p>\r<!--more-->\r\r<p>当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。向上转型的好处是隐藏了子类类型，提高了代码的扩展性。</p>\r\r<p>但向上转型也有弊端，只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。</p>\r\r<p>代码示例：</p>\r\r<pre class="brush:java;">\r//描述动物类，并抽取共性eat方法\rabstract class Animal {\r	abstract void eat();\r}\r \r// 描述狗类，继承动物类，重写eat方法，增加lookHome方法\rclass Dog extends Animal {\r	void eat() {\r		System.out.println(&quot;啃骨头&quot;);\r	}\r\r	void lookHome() {\r		System.out.println(&quot;看家&quot;);\r	}\r}\r\r// 描述猫类，继承动物类，重写eat方法，增加catchMouse方法\rclass Cat extends Animal {\r	void eat() {\r		System.out.println(&quot;吃鱼&quot;);\r	}\r\r	void catchMouse() {\r		System.out.println(&quot;抓老鼠&quot;);\r	}\r}\r\rpublic class Test {\r	public static void main(String[] args) {\r		Animal a = new Dog(); //多态形式，创建一个狗对象\r		a.eat(); // 调用对象中的方法，会执行狗类中的eat方法\r		// a.lookHome();//使用Dog类特有的方法，需要向下转型，不能直接使用\r		\r		// 为了使用狗类的lookHome方法，需要向下转型\r                // 向下转型过程中，可能会发生类型转换的错误，即ClassCastException异常\r		// 那么，在转之前需要做健壮性判断 \r		if( !a instanceof Dog){ // 判断当前对象是否是Dog类型\r		 		System.out.println(&quot;类型不匹配，不能转换&quot;); \r		 		return; \r		} \r		Dog d = (Dog) a; //向下转型\r		d.lookHome();//调用狗类的lookHome方法\r	}\r}</pre>\r\r<p>总结一下：</p>\r\r<ul>\r	<li>什么时候使用向上转型：</li>\r</ul>\r\r<p style="margin-left:21pt;">当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。</p>\r\r<p style="margin-left:21pt;">示例代码：</p>\r\r<pre class="brush:java;">\rAnimal a = newDog();\ra.eat();</pre>\r\r<ul>\r	<li>什么时候使用向下转型</li>\r</ul>\r\r<p style="margin-left:21pt;">当要使用子类特有功能时，就需要使用向下转型。</p>\r\r<pre class="brush:java;">\r//向下转型\rDog d= (Dog) a; \r//调用狗类的lookHome方法\rd.lookHome();</pre>\r\r<ul>\r	<li>向下转型的好处：可以使用子类特有功能。</li>\r	<li>弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rif( !a instanceofDog){&hellip;}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(649, '封装、继承和多态的作用', '649', 1523784420, 1523803692, '<p>本文总结下在Java的三大特性的作用～</p>\r<!--more-->\r\r<p>封装：把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式。</p>\r\r<p>继承：子类会自动拥有父类所有可继承的属性和方法。</p>\r\r<p>多态：配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(651, '构造方法调用&amp;内存图解', '651', 1525068120, 1525068846, '<p>本文记录Java学习过程中遇到的构造方法调用和内存图解～</p>\r<!--more-->\r\r<p>理解构造方法的格式和基本功能之后，现在就要研究构造方法是怎么执行的呢？在创建对象的时候是如何初始化的呢？</p>\r\r<p>构造方法是专门用来创建对象的，也就是在new对象时要调用构造方法。</p>\r\r<p>示例代码（构造方法调用）：</p>\r\r<pre class="brush:java;">\rclass Person {\r	// Person的成员属性age和name\r	private int age;\r	private String name;\r\r	// Person的构造方法，拥有参数列表\r	Person(int a, String nm) {\r		// 接受到创建对象时传递进来的值，将值赋给成员属性\r		age = a;\r		name = nm;\r	}\r\r	public void speak() {\r		System.out.println(&quot;name=&quot; + name + &quot;,age=&quot; + age);\r	}\r}\r\rclass Test {\r	public static void main(String[] args) {\r		// 创建Person对象，并明确对象的年龄和姓名\r		Person p2 = new Person(23, &quot;张三&quot;);\r		p2.speak();\r	}\r}</pre>\r\r<p>上述代码演示了创建对象时构造方法的调用。即在创建对象时，会调用与参数列表对应的构造方法。</p>\r\r<p>上述代码的图解：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/04/1872166686.png" style="width: 600px; height: 375px;" /></p>\r\r<p>图解说明：</p>\r\r<ol>\r	<li>首先会将main方法压入栈中，执行main方法中的new Person(23,&quot;张三&quot;);&nbsp;</li>\r	<li>在堆内存中分配一片区域，用来存放创建的Person对象，这片内存区域会有属于自己的内存地址（0x88）。然后给成员变量进行默认初始化（name=null，age=0）；</li>\r	<li>执行构造方法中的代码（age = a ; name = nm;）,将变量a对应的23赋值给age，将变量nm对应的&rdquo;张三赋值给name，这段代码执行结束后，成员变量age和name的值已经改变。执行结束之后构造方法弹栈，Person对象创建完成。将Person对象的内存地址0x88赋值给p2。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(652, 'memory.png', 'memory-png-1', 1525068265, 1525068265, 'a:5:{s:4:"name";s:10:"memory.png";s:4:"path";s:35:"/usr/uploads/2018/04/1872166686.png";s:4:"size";i:111138;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 651, 0),
(654, '默认构造方法和细节', '654', 1525069020, 1525069262, '<p>本文记录Java学习过程中遇到的默认构造方法和细节～</p>\r<!--more-->\r\r<p>在没有学习构造方法之前，我们也可以通过new关键字创建对象，并调用相应的方法，同时在描述事物时也没有写构造方法。这是为什么呢？</p>\r\r<p>在之前学习的过程中，描述事物时，并没有显示指定构造方法，当在编译Java文件时，编译器会自动给class文件中添加默认的构造方法。如果在描述类时，我们显示指定了构造方法，那么，当在编译Java源文件时，编译器就不会再给class文件中添加默认构造方法。</p>\r\r<p>示例代码（无参构造方法）：</p>\r\r<pre class="brush:java;">\rclass  Person {\r	//如果没有显示指定构造方法，编译会在编译时自动添加默认的构造方法\r	//Person(){}  //空参数的默认构造方法\r}</pre>\r\r<p>当在描述事物时，要不要在类中写构造方法呢？这时要根据描述事物的特点来确定，当描述的事物在创建其对象时就要明确属性的值，这时就需要在定义类的时候书写带参数的构造方法。若创建对象时不需要明确具体的数据，这时可以不用书写构造方法（不书写也有默认的构造方法）。</p>\r\r<p>构造方法的细节：</p>\r\r<ol>\r	<li>一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的；</li>\r	<li>构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。</li>\r</ol>\r\r<p>示例代码（默认构造方法）：</p>\r\r<pre class="brush:java;">\rclass Person {\r	private int age;\r	private String name;\r\r	// 私有无参数的构造方法，即外界不能通过new Person();语句创建本类对象\r	private Person() {\r	}\r\r	// 多个构造方法是以重载的形式存在\r	Person(int a) {\r		age = a;\r	}\r\r	Person(String nm, int a) {\r		name = nm;\r		age = a;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(655, '构造方法和一般方法区别', '655', 1525071120, 1525071677, '<p>本文记录Java学习过程中遇到的构造方法与一般方法的区别～</p>\r<!--more-->\r\r<p>到目前为止，学习两种方法，分别为构造方法和一般方法，那么他们之间有什么异同呢？</p>\r\r<ul>\r	<li>构造方法在对象创建时就执行了，而且只执行一次。</li>\r	<li>一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。</li>\r</ul>\r\r<p>问题：有了构造方法之后可以对对象的属性进行初始化，那么还需要对应的和方法吗？</p>\r\r<ul>\r	<li>需要相应的set和get方法，因为对象在创建之后需要修改和访问相应的属性值时，在这时只能通过set或者get方法来操作。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Person {\r	void Person() {\r	}\r}\r\rclass PersonDemo {\r	public static void main(String[] args) {\r		Person p = new Person();\r	}\r}</pre>\r\r<p>代码分析：void返回类型的Person()方法只是重载了Person类的构造方法而已，并不会与构造方法冲突。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(656, 'this调用构造方法', '656', 1525072560, 1525073072, '<p>本文记录Java学习过程中遇到的使用this关键字调用构造方法～</p>\r<!--more-->\r\r<p>在之前学习方法之间调用时，可以通过方法名进行调用。可是针对构造方法，无法通过构造方法名来相互调用。不过，构造方法之间的调用，可以通过this关键字来完成。</p>\r\r<p>构造方法调用格式：</p>\r\r<pre class="brush:java;">\rthis(参数列表);</pre>\r\r<p>示例代码（通过this调用构造方法）：</p>\r\r<pre class="brush:java;">\rclass Person {\r	// Person的成员属性\r	private int age;\r	private String name;\r\r	// 无参数的构造方法\r	Person() {\r	}\r\r	// 给姓名初始化的构造方法\r	Person(String nm) {\r		name = nm;\r	}\r\r	// 给姓名和年龄初始化的构造方法\r	Person(String nm, int a) {\r		// 由于已经存在给姓名进行初始化的构造方法 name = nm;因此只需要调用即可\r		// 调用其他构造方法，需要通过this关键字来调用\r		this(nm);\r		// 给年龄初始化\r		age = a;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(657, 'this的调用原理图解', '657', 1525073280, 1525074054, '<p>本文记录Java学习过程中遇到的this的调用原理～</p>\r<!--more-->\r\r<p>了解了构造方法之间是可以相互调用，那为什么他们之间通过this就可以调用呢？</p>\r\r<p>通过上面的学习，简单知道使用this可以实现构造方法之间的调用，但是为什么就会知道this调用哪一个构造方法呢？接下来需要图解完成。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Person {\r	private int age;\r	private String name;\r\r	Person() {\r	}\r	Person(String nm) {\r		name = nm;\r	}\r	Person(String nm, int a) {\r		this(nm);\r		age = a;\r	}\r}\r\rclass Test {\r	public static void main(String[] args) {\r		Person p = new Person(&quot;张三&quot;, 23);\r	}\r}</pre>\r\r<p>如图所示（内存图）：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/04/3321959068.png" style="width: 600px; height: 384px;" /></p>\r\r<p>图列说明：</p>\r\r<ol>\r	<li>先执行main方法，main方法压栈，执行其中的new Person(&ldquo;张三&rdquo;,23);</li>\r	<li>堆内存中开辟空间，并为其分配内存地址0x33，，紧接着成员变量默认初始化（name=null&nbsp;&nbsp;age = 0）；</li>\r	<li>拥有两个参数的构造方法（Person（String nm , int a））压栈，在这个构造方法中有一个隐式的this，因为构造方法是给对象初始化的，那个对象调用到这个构造方法，this就指向堆中的那个对象；</li>\r	<li>由于Person（String nm , int a）构造方法中使用了this(nm);构造方法Person(String nm)就会压栈，并将&ldquo;张三&rdquo;传递给nm。在Person（String nm , int a）构造方法中同样也有隐式的this，this的值同样也为0x33，这时会执行其中name = nm，即把&ldquo;张三&rdquo;赋值给成员的name。当赋值结束后Person（String nm , int a）构造方法弹栈；</li>\r	<li>程序继续执行构造方法（Person（String nm , int a）中的age = a；这时会将23赋值给成员属性age。赋值结束构造方法（Person（String nm , int a）弹栈；</li>\r	<li>当构造方法（Person（String nm , int a）弹栈结束后，Person对象在内存中创建完成，并将0x33赋值给main方法中的p引用变量。</li>\r</ol>\r\r<p>注意事项：</p>\r\r<ul>\r	<li>this代表的是对象，哪个对象调用了this所在的方法，this就代表哪个对象；</li>\r	<li>调用其他构造方法的语句必须定义在构造方法的第一行，原因是初始化动作要最先执行。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(658, 'tu.png', 'tu-png', 1525073757, 1525073757, 'a:5:{s:4:"name";s:6:"tu.png";s:4:"path";s:35:"/usr/uploads/2018/04/3321959068.png";s:4:"size";i:191400;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 657, 0),
(660, '成员变量与局部变量同名问题', '660', 1525074180, 1525074370, '<p>本文记录Java学习过程中遇到的成员变量与局部变量的同名问题～</p>\r<!--more-->\r\r<p>当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变量成员变量呢？</p>\r\r<ul>\r	<li>可以在成员变量名前面加上this.来区别成员变量和局部变量。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Person {\r	private int age;\r	private String name;\r\r	// 给姓名和年龄初始化的构造方法\r	Person(String name, int age) {\r		// 当需要访问成员变量是，只需要在成员变量前面加上this.即可\r		this.name = name;\r		this.age = age;\r	}\r\r	public void speak() {\r		System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);\r	}\r}\r\rclass Test {\r	public static void main(String[] args) {\r		Person p = new Person(&quot;张三&quot;, 23);\r		p.speak();\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(661, '子父类中构造方法的调用', '661', 1525076760, 1553992692, '<p>本文记录Java学习过程中遇到的子类调用父类的构造方法～</p>\r<!--more-->\r\r<p>在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\r//调用本类中的构造方法\rthis(实参列表);\r//调用父类中的空参数构造方法\rsuper();\r//调用父类中的有参数构造方法\rsuper(实参列表);</pre>\r\r<p>为什么子类对象创建都要访问父类中的构造方法？因为子类继承了父类的内容，所以创建对象时，必须要先看父类是如何对其内容进行初始化的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class Test {\r	public static void main(String[] args) {\r		new Zi();\r	}\r	\r}\rclass Fu{\r	int num ;\r	Fu(){\r		System.out.println(&quot;Fu构造方法&quot;+num);\r		num = 4;\r	}\r}\rclass Zi extends Fu{\r	Zi(){\r         //super(); 调用父类空参数构造方法\r		System.out.println(&quot;Zi构造方法&quot;+num);\r	}\r}</pre>\r\r<p>执行结果：</p>\r\r<pre class="brush:java;">\rFu构造方法0\rZi构造方法4</pre>\r\r<p>通过结果发现，子类构造方法执行时中，调用了父类构造方法，这说明，子类构造方法中有一句super()。</p>\r\r<p>那么，子类中的构造方法为什么会有一句隐式的super()呢？</p>\r\r<p>原因：子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的初始化动作。这样，才可以使用父类中的内容。当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句，指定要访问的父类有参数构造方法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 126),
(662, '子类对象创建过程的细节', '662', 1525077180, 1553992798, '<p>本文记录Java学习过程中遇到的子类对象创建过程中的一些小细节～</p>\r<!--more-->\r\r<p>如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？</p>\r\r<ul>\r	<li>这时是没有的，因为this()或者super()，只能定义在构造方法的第一行，因为初始化动作要先执行。</li>\r</ul>\r\r<p>父类构造方法中是否有隐式的super呢？</p>\r\r<ul>\r	<li>也是有的。记住：只要是构造方法默认第一行都是super();</li>\r</ul>\r\r<p>父类的父类是谁呢？super调用的到底是谁的构造方法呢？</p>\r\r<ul>\r	<li>Java体系在设计，定义了一个所有对象的父类Object</li>\r</ul>\r\r<p>注意：</p>\r\r<ul>\r	<li>类中的构造方法默认第一行都有隐式的super()语句，在访问父类中的空参数构造方法。所以父类的构造方法既可以给自己的对象初始化，也可以给自己的子类对象初始化;</li>\r	<li>如果默认的隐式super()语句在父类中没有对应的构造方法，那么必须在构造方法中通过this或者super的形式明确要调用的构造方法。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(663, 'final关键字', '663', 1525147980, 1525165207, '<p>本文记录Java学习过程中遇到的final关键字～</p>\r<!--more-->\r\r<p>继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？</p>\r\r<p>要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。</p>\r\r<p>final的特点：</p>\r\r<ul>\r	<li>final修饰类不可以被继承，但是可以继承其他类。</li>\r</ul>\r\r<pre class="brush:java;">\rclass Yy {}\rfinal class Fu extends Yy{} //可以继承Yy类\rclass Zi extends Fu{} //不能继承Fu类</pre>\r\r<ul>\r	<li>final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。</li>\r</ul>\r\r<pre class="brush:java;">\rclass Fu {\r    // final修饰的方法，不可以被覆盖，但可以继承使用\r    public final void method1(){}\r    public void method2(){}\r}\r\rclass Zi extends Fu {\r    //重写method2方法\r    public final void method2(){}\r}</pre>\r\r<ul>\r	<li>final修饰的变量称为常量，这些变量只能赋值一次。</li>\r</ul>\r\r<pre class="brush:java;">\rfinal int i = 20;\ri = 30; //赋值报错，final修饰的变量只能赋值一次</pre>\r\r<ul>\r	<li>引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改。</li>\r</ul>\r\r<pre class="brush:java;">\rfinal Person p = new Person();\rPerson p2 = new Person();\rp = p2; //final修饰的变量p，所记录的地址值不能改变\rp.name = &quot;小明&quot;;//可以更改p对象中name属性值\r//p不能为别的对象，而p对象中的name或age属性值可更改。​\r</pre>\r\r<ul>\r	<li>修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)</li>\r</ul>\r\r<pre class="brush:java;">\rclass Demo {\r    //直接赋值\r    final int m= 100;\r    //final修饰的成员变量，需要在创建对象前赋值，否则报错。\r    final int n;\r    public Demo(){\r        //可以在创建对象时所调用的构造方法中，为变量n赋值\r        n = 2016;\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(664, 'static关键字', '664', 1525172100, 1525172186, '<p>本文记录Java学习过程中遇到的static关键字～</p>\r<!--more-->\r\r<p>当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？</p>\r\r<p>可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97),
(665, 'static特点', '665', 1525172400, 1525173379, '<p>本文记录Java学习过程中遇到的static的特点～</p>\r<!--more-->\r\r<ul>\r	<li>被static修饰的成员变量属于类，不属于这个类的某个对象。（也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量）；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Demo {\r    public static int num= 100;\r}\r\rclass Test {\r    public static void main(String[] args) {\r        Demo d1 = newDemo();\r        Demo d2 = newDemo();\r        d1.num = 200;\r        //结果为200\r        System.out.println(d1.num);\r        //结果为200\r        System.out.println(d2.num);\r    }\r}\r</pre>\r\r<ul>\r	<li>被static修饰的成员可以并且建议通过类名直接访问。</li>\r</ul>\r\r<p>访问静态成员的格式：</p>\r\r<pre class="brush:java;">\r类名.静态成员变量名\r类名.静态成员方法名(参数)\r对象名.静态成员变量名       ------不建议使用该方式，会出现警告\r对象名.静态成员方法名(参数)     ------不建议使用该方式，会出现警告</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Demo {\r    //静态成员变量\r    public static int num= 100;\r    //静态方法\r    public static void method(){\r        System.out.println(&quot;静态方法&quot;);\r    }\r}\r\rclass Test {\r    public static void main(String[] args) {\r        System.out.println(Demo.num);\r        Demo.method();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(666, 'static注意事项', '666', 1525173900, 1525174182, '<p>本文记录Java学习过程中遇到的static关键字的注意事项～</p>\r<!--more-->\r\r<ul>\r	<li>静态内容是优先于对象存在，只能访问静态，不能使用this/super。静态修饰的内容存于静态区；</li>\r</ul>\r\r<pre class="brush:java;">\rclass Demo {\r    //成员变量\r    public int num= 100;\r    //静态方法\r    public static void method(){\r        //this.num; 不能使用this/super。\r        System.out.println(this.num);\r    }\r}\r</pre>\r\r<ul>\r	<li>同一个类中，静态成员只能访问静态成员；</li>\r</ul>\r\r<pre class="brush:java;">\rclass Demo {\r    //成员变量\r    public int num = 100;\r    //静态成员变量\r    public static int count = 200;\r    //静态方法\r    public static void method(){\r        //System.out.println(num); 静态方法中，只能访问静态成员变量或静态成员方法\r        System.out.println(count);\r    }\r}</pre>\r\r<ul>\r	<li>main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(667, '静态常量', '667', 1525174380, 1553993195, '<p>本文记录Java学习过程中遇到的静态常量～</p>\r<!--more-->\r\r<p>开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。此时变量名用全部大写，多个单词使用下划线连接。</p>\r\r<p>定义格式：</p>\r\r<pre class="brush:java;">\rpublic static final 数据类型 变量名 = 值;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Company {\r	public static final String COMPANY_NAME = &quot;Oliver&#39;s Blog&quot;;\r	public static void method(){\r		System.out.println(&quot;一个静态方法&quot;);\r	}\r}</pre>\r\r<p>当我们想使用类的静态成员时，不需要创建对象，直接使用类名来访问即可。</p>\r\r<pre class="brush:java;">\rSystem.out.println(Company.COMPANY_NAME); //打印Oliver&#39;s Blog\rCompany.method(); // 调用一个静态方法</pre>\r\r<p><strong>注意：</strong></p>\r\r<ul>\r	<li>接口中的每个成员变量都默认使用public static final修饰。</li>\r	<li>所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。</li>\r</ul>\r\r<pre class="brush:java;">\rinterface Inter {\r    public static final int COUNT = 100;\r}</pre>\r\r<p>访问接口中的静态变量：</p>\r\r<pre class="brush:java;">\rInter.COUNT</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(668, '匿名对象', '668', 1525177140, 1525177402, '<p>本文记录Java学习过程中遇到的匿名对象～</p>\r<!--more-->\r\r<p>匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Person{\r    public void eat(){\r        System.out.println(&quot;eat!!!&quot;);\r    }\r}\r\rpublic class Test{\r    public static void main(String[] args){\r        //创建一个普通对象\r        Person p = new Person();\r\r        //创建一个匿名对象\r        new Person();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(669, '匿名对象特点', '669', 1525177500, 1525177790, '<p>本文记录Java学习过程中遇到的匿名对象的特点～</p>\r<!--more-->\r\r<ul>\r	<li>创建匿名对象直接使用，没有变量名。</li>\r</ul>\r\r<pre class="brush:java;">\rnew Person().eat()  //eat方法被一个没有名字的Person对象调用了</pre>\r\r<ul>\r	<li>匿名对象在没有指定其引用变量时，只能使用一次。</li>\r</ul>\r\r<pre class="brush:java;">\rnew Person().eat(); //创建一个匿名对象，调用eat方法\rnew Person().eat(); //想再次调用eat方法，重新创建了一个匿名对象</pre>\r\r<ul>\r	<li>匿名对象可以作为方法接收的参数、方法返回值使用</li>\r</ul>\r\r<pre class="brush:java;">\rclass Demo {\r    public static Person getPerson(){\r        //普通方式\r        //Person p = new Person();   \r        //return p;\r\r        //匿名对象作为方法返回值\r        return new Person(); \r    }\r    public static void method(Person p){\r    }\r}\r\rclass Test {\r    public static void main(String[] args) {\r        //调用getPerson方法，得到一个Person对象\r        Person person = Demo.getPerson();\r        //调用method方法\r        Demo.method(person);\r        //匿名对象作为方法接收的参数\r        Demo.method(new Person());\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(670, '内部类', '670', 1525179120, 1525189720, '<p>本文记录Java学习过程中遇到的内部类～</p>\r<!--more-->\r\r<ul>\r	<li>什么是内部类</li>\r</ul>\r\r<p>将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类，其他类也称为外部类。</p>\r\r<ul>\r	<li>什么时候使用内部类</li>\r</ul>\r\r<p>在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//外部类\rclass 汽车{\r    //内部类\r    class 发动机{\r    }\r}\r</pre>\r\r<ul>\r	<li>内部类的分类</li>\r</ul>\r\r<p>内部类分为成员内部类与局部内部类。</p>\r\r<p>我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(671, '成员内部类', '671', 1525189800, 1525190136, '<p>本文记录Java学习过程中遇到的成员内部类～</p>\r<!--more-->\r\r<p>成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问。</p>\r\r<ul>\r	<li>定义格式</li>\r</ul>\r\r<pre class="brush:java;">\rclass 外部类{ \r    修饰符 class 内部类{\r        //其他代码\r    }\r}</pre>\r\r<ul>\r	<li>访问方式</li>\r</ul>\r\r<pre class="brush:java;">\r外部类名.内部类名变量名= new 外部类名().new 内部类名();</pre>\r\r<ul>\r	<li>示例代码（成员内部类）：</li>\r</ul>\r\r<pre class="brush:java;">\r//外部类，身体\rclass Body {\r    private boolean life= true; //生命状态\r    public class Heart { //内部类，心脏\r        public void jump() {\r            System.out.println(&quot;心脏噗通噗通的跳&quot;);\r            System.out.println(&quot;生命状态&quot; + life); //访问外部类成员变量\r         }\r    }\r}\r\rpublic class Test{\r    public static void main(String[] args) {\r        //创建内部类对象\r        Body.Heart bh = new Body().new Heart();\r        //调用内部类中的方法\r        bh.jump();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(672, '局部内部类', '672', 1525190160, 1525219671, '<p>本文记录Java学习过程中遇到的局部内部类～</p>\r<!--more-->\r\r<p>局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问</p>\r\r<ul>\r	<li>定义格式</li>\r</ul>\r\r<pre class="brush:java;">\rclass 外部类{ \r    修饰符 返回值 类型 方法名(参数) {\r        class 内部类{\r            //其他代码\r        }\r   }\r}\r</pre>\r\r<ul>\r	<li>访问方式</li>\r</ul>\r\r<p>在外部类方法中，创建内部类对象，进行访问。</p>\r\r<ul>\r	<li>示例代码（局部内部类）：</li>\r</ul>\r\r<pre class="brush:java;">\r//定义类\rclass Party {//外部类，聚会\r    public void puffBall(){// 吹气球方法\r        class Ball {// 内部类，气球\r             public void puff(){\r                 System.out.println(&quot;气球膨胀了&quot;);\r             }\r        }\r       //创建内部类对象，调用puff方法\r       new Ball().puff();\r    }\r}\r\r//访问内部类\rpublic class Test{\r    public static void main(String[] args) {\r        //创建外部类对象\r        Party p = new Party();\r        //调用外部类中的puffBall方法\r        p.puffBall();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(673, '匿名内部类', '673', 1525220040, 1525220128, '<p>本文记录Java学习过程中遇到的匿名内部类～</p>\r<!--more-->\r\r<p>内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。</p>\r\r<p>最常用到的内部类就是匿名内部类，它是局部内部类的一种。</p>\r\r<p>定义的匿名内部类有两个含义：</p>\r\r<ul>\r	<li>临时定义某一指定类型的子类</li>\r	<li>定义后即刻创建刚刚定义的这个子类的对象</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(674, '匿名内部类的作用与定义格式', '674', 1525220340, 1525220659, '<p>本文记录Java学习过程中遇到的匿名内部类的作用与定义格式～</p>\r<!--more-->\r\r<p><strong>作用：</strong>匿名内部类是创建某个类型子类对象的快捷方式。</p>\r\r<p><strong>使用格式：</strong></p>\r\r<pre class="brush:java;">\rnew 父类或接口(){\r    //进行方法重写\r};</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//已经存在的父类：\rpublic abstract class Person{\r    public abstract void eat();\r}\r\rpublic class Test{\r    //定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量\r    Person  p = new Person(){\r        public void eat() {\r             System.out.println(&ldquo;我吃了&rdquo;);\r        }\r    };\r    //调用eat方法\r    p.eat();\r}</pre>\r\r<p>使用匿名对象的方式，将定义子类与创建子类对象两个步骤由一个格式一次完成，。虽然是两个步骤，但是两个步骤是连在一起完成的。</p>\r\r<p>匿名内部类如果不定义变量引用，则也是匿名对象。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rnew Person(){\r    public void eat() {\r        System.out.println(&ldquo;我吃了&rdquo;);\r    }\r}.eat();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(675, '包的概念', '675', 1525220940, 1525221047, '<p>本文记录Java学习过程中遇到的包的概念～</p>\r<!--more-->\r\r<p>java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。</p>\r\r<p>当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为分包管理。</p>\r\r<p>在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。</p>\r\r<p>类中声明的包必须与实际class文件所在的文件夹情况相一致，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(676, '包的声明格式', '676', 1525221120, 1525221281, '<p>本文记录Java学习过程中遇到的包的定义格式～</p>\r<!--more-->\r\r<p>包名通常使用公司网址反写，可以有多层包，包名采用全部小写字母，多层包之间用&rdquo;.&rdquo;连接</p>\r\r<p>类中包的声明格式：</p>\r\r<pre class="brush:java;">\rpackage 包名.包名.包名&hellip;;</pre>\r\r<p>如：百度网址baidu.com那么网址反写就为com.baidu</p>\r\r<p><strong>注意</strong>：声明包的语句，必须写在程序有效代码的第一行（注释不算）</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage com.baidu; //包的声明，必须在有效代码的第一行\r\rimport java.util.Scanner;\rimport java.util.Random;\r\rpublic class Demo {\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(677, '包的访问格式', '677', 1525221360, 1553994697, '<p>本文记录Java学习过程中遇到的包的访问格式～</p>\r<!--more-->\r\r<p>在访问类时，为了能够找到该类，必须使用含有包名的类全名（包名.类名）。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\r包名.包名&hellip;.类名</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rjava.util.Scanner\rjava.util.Random\rren.oliver.Test</pre>\r\r<p>带有包的类，创建对象格式：</p>\r\r<pre class="brush:java;">\r包名.类名变量名= new包名.类名();</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rren.oliver.Test t = new ren.oliver.Test();</pre>\r\r<p><strong>注意：</strong>包的访问与访问权限密切相关，这里以一般情况来说，即类用public修饰的情况。</p>\r\r<p><strong>类的简化访问</strong></p>\r\r<p>当我们要使用一个类时，这个类与当前程序在同一个包中（即同一个文件夹中），或者这个类是java.lang包中的类时通常可以省略掉包名，直接使用该类。</p>\r\r<p>如：ren.oliver包中有两个类，PersonTest类，与Person类。我们在PersonTest类中，访问Person类时，由于是同一个包下，访问时可以省略包名，即直接通过类名访问Person。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\r类名变量名= new类名();\r\r例如：</pre>\r\r<pre class="brush:java;">\rPerson p = new Person();</pre>\r\r<p>注意：当我们要使用的类，与当前程序不在同一个包中（即不同文件夹中），要访问的类必须用public修饰才可访问。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver;\rpublic class Person {\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 131),
(678, '包的导入', '678', 1525221840, 1525222023, '<p>本文记录Java学习过程中遇到的包的导入～</p>\r<!--more-->\r\r<p>我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。</p>\r\r<p>可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\rimport 包名.类名;</pre>\r\r<p>当程序导入指定的包后，使用类时，就可以简化了。</p>\r\r<p>示例代码：</p>\r\r<ul>\r	<li>导入包前的方式</li>\r</ul>\r\r<pre class="brush:java;">\r//创建对象\rjava.util.Random r1 = new java.util.Random();\rjava.util.Random r2 = new java.util.Random();\rjava.util.Scanner sc1 = new java.util.Scanner(System.in);\rjava.util.Scanner sc2 = new java.util.Scanner(System.in);</pre>\r\r<ul>\r	<li>导入包后的方式</li>\r</ul>\r\r<pre class="brush:java;">\rimport java.util.Random;\rimport java.util.Scanner;\r\r//创建对象\rRandom r1 = new Random();\rRandom r2 = new Random();\rScanner sc1 = new Scanner(System.in);\rScanner sc2 = new Scanner(System.in);</pre>\r\r<p>import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import包名.包名.类名;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(679, '访问修饰符', '679', 1525222140, 1553994888, '<p>本文记录Java学习过程中遇到的访问修饰符～</p>\r<!--more-->\r\r<p>在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限。</p>\r\r<p>下表总结了不同权限的访问能力：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/1237374782.png" style="width: 600px; height: 330px;" /></p>\r\r<p>归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问</p>\r\r<ul>\r	<li>要想仅能在本类中访问使用private修饰；</li>\r	<li>要想本包中的类都可以访问不加修饰符即可；</li>\r	<li>要想本包中的类与其他包中的子类可以访问使用protected修饰；</li>\r	<li>要想所有包中的所有类都可以访问使用public修饰；</li>\r	<li>注意：如果类用public修饰，则类名必须与文件名相同，一个文件中只能有一个public修饰的类。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(680, 'table.png', 'table-png', 1525222276, 1525222276, 'a:5:{s:4:"name";s:9:"table.png";s:4:"path";s:35:"/usr/uploads/2018/05/1237374782.png";s:4:"size";i:79859;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 679, 0),
(682, '局部代码块', '682', 1525223100, 1553994989, '<p>本文记录Java学习过程中遇到的局部代码块～</p>\r<!--more-->\r\r<p>局部代码块是定义在方法或语句中。</p>\r\r<p>特点：</p>\r\r<ul>\r	<li>以&rdquo;{}&rdquo;划定的代码区域，此时只需要关注作用域的不同即可；</li>\r	<li>方法和类都是以代码块的方式划定边界的。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Demo{\r    public static void main(String[] args)    {\r        {\r              int x = 1;\r              System.out.println(&quot;普通代码块&quot; + x);\r        }\r\r        int x = 99;\r        System.out.println(&quot;代码块之外&quot; + x);\r    }\r}\r</pre>\r\r<p>运行结果：</p>\r\r<pre class="brush:java;">\r普通代码块1\r代码块之外99</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 117),
(683, '构造代码块', '683', 1525223280, 1553995026, '<p>本文记录Java学习过程中遇到的构造代码块～</p>\r<!--more-->\r\r<p>构造代码块是定义在类中成员位置的代码块。</p>\r\r<p>特点：</p>\r\r<ul>\r	<li>优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作；</li>\r	<li>每创建一个对象均会执行一次构造代码块。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Person {\r    private String name;\r    private int age;\r    //构造代码块\r    {\r        System.out.println(&quot;构造代码块执行了&quot;);\r    }\r    Person(){\r        System.out.println(&quot;Person无参数的构造函数执行&quot;);\r    }\r    Person(int age){\r        this.age = age;\r        System.out.println(&quot;Person（age）参数的构造函数执行&quot;);\r    }\r}\r\rpublic class Test{\r    public static void main(String[] args)    {\r        Person p1 = new Person();\r        Person p2 = new Person(23);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(684, '静态构造代码块', '684', 1525223460, 1525223591, '<p>本文记录Java学习过程中遇到的静态构造代码块～</p>\r<!--more-->\r\r<p>静态构造代码块是定义在成员位置，使用static修饰的代码块。</p>\r\r<p>特点：</p>\r\r<ul>\r	<li>它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行；</li>\r	<li>该类不管创建多少对象，静态代码块只执行一次；</li>\r	<li>可用于给静态变量赋值，用来给类进行初始化。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class Person {\r    private String name;\r    private int age;\r\r     //静态代码块\r    static{\r        System.out.println(&quot;静态代码块执行了&quot;);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 117),
(685, '修饰符使用细节', '685', 1525313820, 1553995202, '<p>本文总结Java学习过程中遇到的常用的几个修饰符的细节～</p>\r<!--more-->\r\r<p>常用来修饰类、方法、变量的修饰符如下：</p>\r\r<ul>\r	<li>public&nbsp;权限修饰符，公共访问，可以修饰类，方法和成员变量；</li>\r	<li>protected&nbsp;权限修饰符，受保护访问，可以修饰方法和成员变量；</li>\r	<li>package 默认什么也不写 也是一种权限修饰符，默认访问，可以修饰类，方法和成员变量；</li>\r	<li>private&nbsp;权限修饰符，私有访问，可以修饰方法和成员变量；</li>\r	<li>static&nbsp;静态修饰符，可以修饰方法和成员变量；</li>\r	<li>final&nbsp;最终修饰符，可以修饰类，方法，成员变量和局部变量；</li>\r	<li>abstract&nbsp;抽象修饰符，可以修饰类和方法。</li>\r</ul>\r\r<p>我们编写程序时，权限修饰符一般放于所有修饰符之前，一般有如下规则：</p>\r\r<ul>\r	<li>不同的权限修饰符不能同时使用；</li>\r	<li>abstract与private不能同时使用；</li>\r	<li>abstract与static不能同时使用；</li>\r	<li>abstract与final不能同时使用。</li>\r</ul>\r\r<p><strong>修饰类能够使用的修饰符：</strong></p>\r\r<p>修饰类只能使用public、默认的、final、abstract关键字，使用最多的是public关键字</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//最常用的方式\rpublicclassDemo {}\rclassDemo2{}\rpublic finalclassDemo3{}\rpublic abstractclassDemo4{}</pre>\r\r<p>修饰<strong>成员变量</strong>能够使用的修饰符：</p>\r\r<ul>\r	<li>public：公共的</li>\r	<li>protected：受保护的</li>\r	<li>package：默认的</li>\r	<li>private：私有的</li>\r	<li>final：最终的</li>\r	<li>static：静态的</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//使用最多的是private\rpublic int count1 = 100;\rprotected int count2 = 100;\rint count3 = 100;\r//最常用的方式\rprivate int count4 = 100; \rpublic final int count5 = 100;\rpublic static int count6 = 100;</pre>\r\r<p>修饰<strong>构造方法</strong>能够使用的修饰符：</p>\r\r<ul>\r	<li>public：公共的</li>\r	<li>protected：受保护的</li>\r	<li>package：默认的</li>\r	<li>private：私有的</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//使用最多的是public\rpublicDemo(){}\rprotectedDemo(){}\rDemo(){}\rprivateDemo(){}</pre>\r\r<p>修饰<strong>成员方法</strong>能够使用的修饰符：</p>\r\r<ul>\r	<li>public：公共的</li>\r	<li>protected：受保护的</li>\r	<li>package：默认的</li>\r	<li>private：私有的</li>\r	<li>final：最终的</li>\r	<li>static：静态的</li>\r	<li>abstract：抽象的</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//最常用的方式\rpublic void method1(){}\rprotected void method2(){}\rvoid method3(){}\rprivate void method4(){}\rpublic final void method5(){}\r//最常用的方式\rpublic static void method6(){}\r//最常用的方式\rpublic abstract void method7();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 132),
(686, 'Object类', '686', 1525394220, 1553995362, '<p>本文记录Java学习过程中遇到的Object类～</p>\r<!--more-->\r\r<p>Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。所有类在创建对象的时候，最终找的父类就是Object。</p>\r\r<p><strong>equals方法​</strong></p>\r\r<p>equals方法，用于比较两个对象是否相同，它其实就是使用两个对象的内存地址在比较。Object类中的equals方法内部使用的就是==比较运算符。</p>\r\r<p>在开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较，也就是在开发经常需要子类重写equals方法根据对象的属性值进行比较。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/*\r 	描述人这个类，并定义功能根据年龄判断是否是同龄人\r 	由于要根据指定类的属性进行比较，这时只要覆盖Object中的equals方法\r 	在方法体中根据类的属性值进行比较\r */\rclass Person extends Object{\r	int age ;\r	//复写父类的equals方法，实现自己的比较方式\r	public boolean equals(Object obj) {\r		//判断当前调用equals方法的对象和传递进来的对象是否是同一个\r		if(this == obj){\r			return true;\r		}\r		//判断传递进来的对象是否是Person类型\r		if(!(obj instanceof Person)){\r			return false;\r		}\r		//将obj向下转型为Perosn引用，访问其属性\r		Person p = (Person)obj;\r		return this.age == p.age;\r	}\r}</pre>\r\r<p>注意：在复写Object中的equals方法时，一定要注意public boolean equals(Object obj)的参数是Object类型，在调用对象的属性时，一定要进行类型转换，在转换之前必须进行类型判断。</p>\r\r<p><strong>toString方法</strong></p>\r\r<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>\r\r<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Person extends Object{\r	int age ;\r	//根据Person类的属性重写toString方法\r	public String toString() {\r		return &quot;Person [age=&quot; + age + &quot;]&quot;;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 181),
(1527, 'Oracle查询语句——单行函数', '1527', 1554442374, 1554442374, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;单行函数～</p>\r<!--more-->\r\r<p>单行函数的分类：</p>\r\r<ul>\r	<li>字符函数；</li>\r	<li>数值函数；</li>\r	<li>转换函数；</li>\r	<li>日期函数；</li>\r	<li>通用函数。</li>\r</ul>\r\r<p><strong>字符函数</strong></p>\r\r<p>大小写空值函数：</p>\r\r<ul>\r	<li>lower：小写；</li>\r	<li>upper：大写；</li>\r	<li>initcap：首字母大写。</li>\r</ul>\r\r<p>字符控制函数：</p>\r\r<ul>\r	<li>concat：字符串连接；</li>\r	<li>substr：字串；</li>\r	<li>length/lengthb：获取长度；</li>\r	<li>instr：暂无；</li>\r	<li>lpad/rpad：暂无；</li>\r	<li>trim：去除前后字符；</li>\r	<li>replace：替换。</li>\r</ul>\r\r<p>示例代码（大写）：</p>\r\r<pre class="brush:sql;">\rselect upper(&#39;smith&#39;) from dual;</pre>\r\r<p>示例代码（小写）：</p>\r\r<pre class="brush:sql;">\rselect lower(&#39;SMITH&#39;) from dual;</pre>\r\r<p>示例代码（首字母大写）：</p>\r\r<pre class="brush:sql;">\rselect initcat(&quot;smith&quot;) from dual;</pre>\r\r<p>示例代码（字符串连接）：</p>\r\r<pre class="brush:sql;">\rselect concat(&#39;hello&#39;, &#39;world&#39;) from dual;</pre>\r\r<p>示例代码（字符串截取）：</p>\r\r<pre class="brush:sql;">\rselect substr(&#39;hello&#39;, 0, 3) from dual;</pre>\r\r<p>示例代码（获取字符串长度）：</p>\r\r<pre class="brush:sql;">\rselect length(&#39;hello&#39;) from dual;</pre>\r\r<p>示例代码（字符串替换）：</p>\r\r<pre class="brush:sql;">\rselect replace(&#39;hello&#39;, &#39;l&#39;, &#39;x&#39;) from dual;</pre>\r\r<p><strong>数值函数</strong></p>\r\r<ul>\r	<li>round：四舍五入；</li>\r	<li>trunc：截断；</li>\r	<li>mod：求余。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rselect round(45.926, 2) from dual;\rselect trunc(45.926, 2) from dual;\rselect mod(1600, 300) from dual;</pre>\r\r<p><strong>日期函数</strong></p>\r\r<p>Oracle中的日期</p>\r\r<ul>\r	<li>实际包含两个值：日期+时间，默认的日期格式是：DD-MON-RR。</li>\r</ul>\r\r<p>日期的数学运算：</p>\r\r<ul>\r	<li>在日期上加上或减去一个数字结果仍为日期；</li>\r	<li>两个日期相减返回日期之间相差的天数；</li>\r	<li>可以用数字除以24。</li>\r</ul>\r\r<p>常用函数：</p>\r\r<ul>\r	<li>months_between：两个日期相差的月数；</li>\r	<li>add_months：向指定日期中加上若干月数；</li>\r	<li>next_day：指定日期的下一个日期，例如，下一个星期五；</li>\r	<li>last_day：本月的最后一天；</li>\r	<li>round：日期四舍五入；</li>\r	<li>trunc：日期截断。</li>\r</ul>\r\r<p>示例代码（日期四舍五入）：</p>\r\r<pre class="brush:sql;">\rselect round(sysdate, &#39;year&#39;) from dual;\rselect round(sysdate, &#39;month&#39;) from dual;</pre>\r\r<p>示例代码（查询入职周数）：</p>\r\r<pre class="brush:sql;">\rselect ename, round((sysdate - hiredate)/7) from emp;</pre>\r\r<p>示例代码（获取两个时间段中的月数）：</p>\r\r<pre class="brush:sql;">\rselect ename, round(months_between(sysdate, hiredate)) from emp;</pre>\r\r<p>示例代码（获取几个月后的日期）：</p>\r\r<pre class="brush:sql;">\rselect add_months(sysdate, 3) from dual;</pre>\r\r<p><strong>转化函数</strong></p>\r\r<p>隐式转换函数：</p>\r\r<ul>\r	<li>varchar2 or char：可以自动转number；</li>\r	<li>varchar2 or char：可以自动转date；</li>\r	<li>number：可以自动的转varchar2；</li>\r	<li>date：可以自动转varchar2。</li>\r</ul>\r\r<p>显式转换函数：</p>\r\r<p>to_char对日期的转换：to_char(date, &#39;format_model&#39;)</p>\r\r<p>日期的格式：</p>\r\r<ul>\r	<li>YYYY：年，四位数；</li>\r	<li>YEAR：年的英文全称；</li>\r	<li>MM：月份，两位数；</li>\r	<li>MONTH：月的全称；</li>\r	<li>DY：星期几；</li>\r	<li>DAY：星期几的全称；</li>\r	<li>DD：几号。</li>\r</ul>\r\r<p>to_char对数字的转换：to_char(number, &#39;format_model&#39;)</p>\r\r<p>数字的格式：</p>\r\r<ul>\r	<li>9：数字；</li>\r	<li>0：零；</li>\r	<li>$：美元符号；</li>\r	<li>L：本地货币符号；</li>\r	<li>.：小数点；</li>\r	<li>,：千位符号。</li>\r</ul>\r\r<p>to_number将字符转成数字：to_number(char[, &#39;format_model&#39;])</p>\r\r<p>to_date将字符转成日期：to_date(char[, &#39;format_model&#39;])</p>\r\r<p>示例代码（to_char函数）：</p>\r\r<pre class="brush:sql;">\rselect empno, ename, to_char(hiredate, &#39;yyyy-mm-dd&#39;) from emp;\rselect epmno, ename, to_char(hiredate, &#39;fmyyyy-mm-dd&#39;) from emp;\rselect ename, to_char(sal, &#39;99, 999&#39;) from emp;\rselect ename, to_char(sal, &#39;$99, 999&#39;) from emp;\rselect ename, to_char(sal, &#39;L99, 999&#39;) from emp;</pre>\r\r<p>示例代码（to_number函数）：</p>\r\r<pre class="brush:sql;">\rselect to_number(&#39;10&#39;) + to_number(&#39;10&#39;) from dual;</pre>\r\r<p>示例代码（to_date函数）：</p>\r\r<pre class="brush:sql;">\rselect to_date(&#39;1985-04-22&#39;, &#39;yyyy-mm-dd&#39;) from dual;</pre>\r\r<p><strong>通用函数</strong></p>\r\r<p>适用于任何数据类型，也适用于空值。</p>\r\r<p>常用函数：</p>\r\r<ul>\r	<li>nvl(expr1, expr2)；</li>\r	<li>nvl2(expr1, expr2, expr3)；</li>\r	<li>nullif(expr1, expr2)；</li>\r	<li>coalesce(expr1, expr2, ..., exprn)。</li>\r</ul>\r\r<p>示例代码（nvl）：</p>\r\r<pre class="brush:sql;">\rselect ename, sal*12 + comm from emp;\rselect ename, sal*12 + nvl(comm, 0) from emp;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 35),
(687, 'String类概述', '687', 1525701780, 1553995492, '<p>本文记录Java学习过程中遇到的String类～</p>\r<!--more-->\r\r<p>查阅API中的String类的描述，发现String&nbsp;类代表字符串。Java&nbsp;程序中的所有字符串字面值（如&quot;abc&quot;&nbsp;）都作为此类的实例实现。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//演示字符串\rString str  = &quot;www.oliver.ren&quot;;\rstr = &quot;Oliver&#39;s Blog&quot;;</pre>\r\r<p>继续查阅API发现说字符串是常量；它们的值在创建之后不能更改，这是什么意思呢？其实就是说一旦这个字符串确定了，那么就会在内存区域中就生成了这个字符串。字符串本身不能改变，但str变量中记录的地址值是可以改变的。</p>\r\r<p>再继续查API发现，字符串有大量的重载的构造方法。通过String类的构造方法可以完成字符串对象的创建，那么，通过使用双引号的方式创建对象与new的方式创建对象，有什么不同呢？</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString s3 = &quot;abc&quot;;\rString s4 = new String(&quot;abc&quot;);\rSystem.out.println(s3==s4);//false\rSystem.out.println(s3.equals(s4));//true,\r//因为String重写了equals方法，建立了字符串自己的判断相同的依据（通过字符串对象中的字符来判断）</pre>\r\r<p>s3和s4的创建方式有什么不同呢？</p>\r\r<ul>\r	<li>s3创建，在内存中只有一个对象。这个对象在字符串常量池中；</li>\r	<li>s4创建，在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象，在字符串常量池中。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(688, 'String类构造方法', '688', 1525702260, 1525702436, '<p>本文记录Java学习过程中遇到的String类的构造方法～</p>\r<!--more-->\r\r<p>构造方法是用来完成String对象的创建，下图中给出了一部分构造方法需要在API中找到，并能够使用下列构造方法创建对象。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/3529086546.png" style="width: 600px; height: 266px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString s1 = new String(); //创建String对象，字符串中没有内容\r	\rbyte[] bys = new byte[]{97,98,99,100};\rString s2 = new String(bys); // 创建String对象，把数组元素作为字符串的内容\rString s3 = new String(bys, 1, 3); //创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数length为要几个元素\r	\rchar[] chs = new char[]{&rsquo;a&rsquo;,&rsquo;b&rsquo;,&rsquo;c&rsquo;,&rsquo;d&rsquo;,&rsquo;e&rsquo;};\rString s4 = new String(chs); //创建String对象，把数组元素作为字符串的内容\rString s5 = new String(chs, 0, 3);//创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数count为要几个元素\r\rString s6 = new String(&ldquo;abc&rdquo;); //创建String对象，字符串内容为abc</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(689, 'constructor.png', 'constructor-png', 1525702353, 1525702353, 'a:5:{s:4:"name";s:15:"constructor.png";s:4:"path";s:35:"/usr/uploads/2018/05/3529086546.png";s:4:"size";i:222348;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 688, 0),
(691, 'String类查找方法', '691', 1525703100, 1525704982, '<p>本文记录Java学习过程中遇到的String类的常用的查找方法～</p>\r<!--more-->\r\r<p>String类中有很多的常用的方法，我们在学习一个类的时候，不要盲目的把所有的方法尝试去使用一遍，这时我们应该根据这个对象的特点分析这个对象应该具备那些功能，这样大家应用起来更方便。</p>\r\r<p>字符串是一个对象，那么它的方法必然是围绕操作这个对象的数据而定义的。我们想想字符串中有哪些功能呢？</p>\r\r<ul>\r	<li>获取字符串的长度</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/3968990282.png" style="width: 600px; height: 59px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString str = &quot;abcde&quot;;\rint len = str.length();\rSystem.out.println(&quot;len=&quot;+len);</pre>\r\r<ul>\r	<li><span style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 10.5pt; font-family: 宋体;">获取部分字符串</span></li>\r</ul>\r\r<p><span style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 10.5pt; font-family: 宋体;"><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/3394598771.png" style="width: 600px; height: 97px;" />​</span></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString str = &quot;abcde&quot;;\rString s1 = str.substring(1); //返回一个新字符串，内容为指定位置开始到字符串末尾的所有字符\rString s2 = str.substring(2, 4);//返回一个新字符串，内容为指定位置开始到指定位置结束所有字符\rSystem.out.println(&quot;str=&quot;+str);\rSystem.out.println(&quot;s1=&quot;+s1);\rSystem.out.println(&quot;s2=&quot;+s2);</pre>\r\r<ul>\r	<li>字符串是否以指定字符串开头或者结尾</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/1157405071.png" style="width: 600px; height: 119px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString str = &quot;StringDemo.java&quot;;\rboolean b1 = str.startsWith(&quot;Demo&quot;);//判断是否以给定字符串开头\rboolean b2 = str.startsWith(&quot;String&quot;);\rboolean b3 = str.endsWith(&quot;java&quot;);//判断是否以给定字符串结尾</pre>\r\r<ul>\r	<li>字符串中是否包含另一个字符串</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/1692562612.png" style="width: 600px; height: 89px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString str = &quot;abcde&quot;;\rint index = str.indexOf(&ldquo;bcd&rdquo;); //判断是否包含指定字符串，包含则返回第一次出现该字符串的索引，不包含则返回-1\rboolean b2 = str.contains(&quot;bcd&quot;);//判断是否包含指定字符串，包含返回true，不包含返回false</pre>\r\r<ul>\r	<li>将字符串转成一个字符数组或者字节数组</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/4212975226.png" style="width: 600px; height: 64px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString str = &quot;abcde&quot;;\rchar[] chs = str.toCharArray();\rbyte[] bytes = str.getBytes();</pre>\r\r<ul>\r	<li>判断两个字符串中的内容是否相同</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/2705993799.png" style="width: 600px; height: 99px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString str = &quot;abcde&quot;;\rString str2 = &quot;abcde&quot;;\rString str3 = &quot;hello&quot;;\rboolean b1 = str.equals(str2);\rboolean b2 = str.equals(str3);</pre>\r\r<ul>\r	<li>获取该字符串对象中的内容</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/1774775794.png" style="width: 600px; height: 52px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString str = new String(&quot;hello&quot;);\rSystem.out.println( str.toString() );\rSystem.out.pintln( str );\r//直接打印引用类型变量时，默认调用该类型进行重写后的toString方法</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(692, 'length.png', 'length-png', 1525703221, 1525703221, 'a:5:{s:4:"name";s:10:"length.png";s:4:"path";s:35:"/usr/uploads/2018/05/3968990282.png";s:4:"size";i:23467;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 691, 0),
(694, 'substring.png', 'substring-png', 1525703323, 1525703323, 'a:5:{s:4:"name";s:13:"substring.png";s:4:"path";s:35:"/usr/uploads/2018/05/3394598771.png";s:4:"size";i:74974;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 691, 0),
(695, 'with.png', 'with-png', 1525703664, 1525703664, 'a:5:{s:4:"name";s:8:"with.png";s:4:"path";s:35:"/usr/uploads/2018/05/1157405071.png";s:4:"size";i:74068;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 691, 0),
(697, 'contains.png', 'contains-png', 1525703879, 1525703879, 'a:5:{s:4:"name";s:12:"contains.png";s:4:"path";s:35:"/usr/uploads/2018/05/1692562612.png";s:4:"size";i:71872;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 691, 0),
(702, 'StringBuffer类', '702', 1526281620, 1553995962, '<p>本文记录Java学习过程中遇到的StringBuffer类～</p>\r<!--more-->\r\r<p>在学习String类时，API中说字符串缓冲区支持可变的字符串，什么是字符串缓冲区呢？接下来我们来研究下字符串缓冲区。</p>\r\r<p>查阅StringBuffer的API，StringBuffer又称为可变字符序列，它是一个类似于String&nbsp;的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>\r\r<p>原来StringBuffer是个字符串的缓冲区，即就是它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>\r\r<p>StringBuffer常用的方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/05/1762852107.png" style="width: 600px; height: 273px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建一个字符串缓冲区对象。用于存储数据。\rStringBuffer sb = new StringBuffer();\r//添加字符串\rsb.append(&quot;haha&quot;); \r//在指定位置插入\rsb.insert(2, &quot;it&quot;);\r//删除\rsb.delete(1, 4);\r//替换指定范围内的内容\rsb.replace(1, 4, &quot;cast&quot;);\rString str = sb.toString();</pre>\r\r<p>注意：append、delete、insert、replace、reverse方法调用后，返回值都是当前对象自己，所以说，StringBuffer它可以改变字符序列的长度和内容。</p>\r\r<p>在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。这种时候，我们就可以把代码写在一起，如append方法。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建一个字符串缓冲区对象。用于存储数据。\rStringBuffer sb = new StringBuffer();\r//添加数据。不断的添加数据后，要对缓冲区的最后的数据进行操作，必须转成字符串才可以。\rString str = sb.append(true).append(&quot;hehe&quot;).toString();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 136),
(703, 'method.png', 'method-png-2', 1526281755, 1526281755, 'a:5:{s:4:"name";s:10:"method.png";s:4:"path";s:35:"/usr/uploads/2018/05/1762852107.png";s:4:"size";i:269461;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 702, 0),
(699, 'char.png', 'char-png', 1525704060, 1525704060, 'a:5:{s:4:"name";s:8:"char.png";s:4:"path";s:35:"/usr/uploads/2018/05/4212975226.png";s:4:"size";i:46242;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 691, 0),
(700, 'equals.png', 'equals-png', 1525704236, 1525704236, 'a:5:{s:4:"name";s:10:"equals.png";s:4:"path";s:35:"/usr/uploads/2018/05/2705993799.png";s:4:"size";i:76052;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 691, 0),
(701, 'tostring.png', 'tostring-png', 1525704843, 1525704843, 'a:5:{s:4:"name";s:12:"tostring.png";s:4:"path";s:35:"/usr/uploads/2018/05/1774775794.png";s:4:"size";i:32842;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 691, 0),
(705, 'StringBuilder类', '705', 1526282640, 1528423622, '<p>本文记录Java学习过程中遇到的StringBuilder类～</p>\r<!--more-->\r\r<p>查阅API发现还有一个StringBuilder类，它也是字符串缓冲区，StringBuilder与它和StringBuffer的有什么不同呢？</p>\r\r<p>我们阅读StringBuilder的API说明发现，它也是一个可变的字符序列。此类提供一个与StringBuffer&nbsp;兼容的API，但不保证同步。该类被设计用作StringBuffer&nbsp;的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer&nbsp;要快。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130),
(718, '分布式架构的演变过程', '718', 1528523400, 1528542266, '<p>本文记录最近听Chacky老师讲的一次公开课&mdash;&mdash;分布式架构的演变过程。</p>\r<!--more-->\r\r<p>1. 单点集中式web应用，也称之为巨石应用</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/132243111.png" style="width: 600px; height: 316px;" /></p>\r\r<p>很多中小型企业的中小型项目都是基于这样的架构，架构很简单，一般以后台管理应用为主，比如CRM或者OA系统等。</p>\r\r<p>数据库以及war包都是部署在同一台服务器上的，文件上传也是上传到这台服务器。</p>\r\r<p>特点：</p>\r\r<ol>\r	<li>所有资源都是部署在同一台服务器上，并发量小，适用于小项目；</li>\r	<li>上线方便，运维工作量小；</li>\r	<li>不利于扩展，项目会越做越大，war包体积也会越来越大。</li>\r</ol>\r\r<p>缺点：一台服务器宕了，整个应用就都无法访问了，必须人工去恢复。</p>\r\r<p>2.应用服务与文件服务以及数据库单独拆分</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/3796740996.png" style="width: 600px; height: 324px;" /></p>\r\r<p>随着时间的推移，数据库以及文件的量不断增加，单台服务器的容量是有限的，原有架构已经不足以支撑，此时必须要把web应用与数据库还有文件服务拆分为三个独立的服务，以此来避免存储瓶颈。</p>\r\r<p>特点：三个服务独立部署，单一服务器宕机，其他的仍可以使用。</p>\r\r<p>3.引入缓存改善读取性能</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/1676738417.png" style="width: 600px; height: 391px;" /></p>\r\r<p>请求并发量上去了，单台tomcat不足以支撑全部流量的时候，我们可以引入缓存来增加读取效率。也就是把大量用户的读请求引导至缓存中，而写操作仍然直接写到数据库中。</p>\r\r<p>特点：把数据库中的一部分数据放入缓存，减少数据库压力，提高并发量。</p>\r\r<p>4.引入集群，多机负载均衡</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/2270635270.png" style="width: 600px; height: 342px;" /></p>\r\r<p>部署多台tomcat来减少单台tomcat的压力，常见的手段是采用 nginx+lvs。</p>\r\r<p>但需要注意的是，要把有状态session改为无状态session，可以使用redis或者spring-session来解决。</p>\r\r<p>特点：多台服务器构成负载均衡，减少单机的负载压力。</p>\r\r<p>5.数据库读写分离</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/59163964.png" style="width: 600px; height: 337px;" /></p>\r\r<p>数据库连接池提供的连接数是一定的，往往用户的读请求远远大于写请求，他们会相互竞争，在这个时候往往写库操作就进行不了，出现了数据库存储瓶颈，所以可以考虑讲读写请求进行分离。</p>\r\r<p>特点：数据库读写分离，提高数据库的吞吐量。</p>\r\r<p>6.使用反向代理以及CDN加速服务</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/371424706.png" style="width: 600px; height: 240px;" /></p>\r\r<p>这样做目的是加快网站的访问速度，尤其是静态资源。</p>\r\r<p>7.使用分布式文件系统和分布式数据库</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/1510482434.png" style="width: 600px; height: 239px;" /></p>\r\r<p>经统计与监测后系统对某些表有大量的请求的时候，为了减少压力，我们需要做分库分表。</p>\r\r<p>两种拆分方式：</p>\r\r<ol>\r	<li>根据业务拆分数据库，比如用户服务相关，订单服务相关，日志服务相关等</li>\r	<li>根据业务竖向拆分或者横向拆分数据表，常见拆分 user表，order表</li>\r</ol>\r\r<ul>\r	<li>竖向拆分：比如order表中某些字段经常访问，那就把这些字段归在一个表，其他不经常访问的字段归在另外一张表，也就是主表和从表，之间使用外键关联</li>\r	<li>横向拆分：根据某个时间点或者业务点来拆分，比如3个月内的订单数据放在order_a中，3个月到1年内的数据放在order_b中，1年-3年的数据放在order_c中，3年前的订单数据放在order_d中，这样拆分每张表的数据体积减少，增加查询效率。当然除了根据时间还能根据地域来做拆分，具体根据各自的业务进行。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 185),
(719, '图片1.png', '图片1-png', 1528523680, 1528523680, 'a:5:{s:4:"name";s:11:"图片1.png";s:4:"path";s:34:"/usr/uploads/2018/06/132243111.png";s:4:"size";i:42273;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 718, 0),
(720, '图片2.png', '图片2-png', 1528523957, 1528523957, 'a:5:{s:4:"name";s:11:"图片2.png";s:4:"path";s:35:"/usr/uploads/2018/06/3796740996.png";s:4:"size";i:24492;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 718, 0),
(721, '图片3.png', '图片3-png', 1528523994, 1528523994, 'a:5:{s:4:"name";s:11:"图片3.png";s:4:"path";s:35:"/usr/uploads/2018/06/1676738417.png";s:4:"size";i:27360;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 718, 0),
(722, '图片4.png', '图片4-png', 1528524074, 1528524074, 'a:5:{s:4:"name";s:11:"图片4.png";s:4:"path";s:35:"/usr/uploads/2018/06/2270635270.png";s:4:"size";i:31686;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 718, 0),
(723, '图片5.png', '图片5-png', 1528524135, 1528524135, 'a:5:{s:4:"name";s:11:"图片5.png";s:4:"path";s:33:"/usr/uploads/2018/06/59163964.png";s:4:"size";i:33157;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 718, 0),
(724, '图片6.png', '图片6-png', 1528524644, 1528524644, 'a:5:{s:4:"name";s:11:"图片6.png";s:4:"path";s:34:"/usr/uploads/2018/06/371424706.png";s:4:"size";i:49263;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 718, 0),
(725, '图片7.png', '图片7-png', 1528524698, 1528524698, 'a:5:{s:4:"name";s:11:"图片7.png";s:4:"path";s:35:"/usr/uploads/2018/06/1510482434.png";s:4:"size";i:40118;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 718, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(726, '《测试架构师修炼之道：从测试工程师到测试架构师》PDF完整版下载', '726', 1528675560, 1528701183, '<p>本文分享一本书&mdash;&mdash;《测试架构师修炼之道：从测试工程师到测试架构师》。</p>\r<!--more-->\r\r<p>目录如下：</p>\r\r<p>前　言<br />\r第一部分　瓶颈：软件测试工程师该如何进行职业规划<br />\r第1章　软件测试工程师的&ldquo;三年之痒&rdquo; 3<br />\r1.1　软件测试发展简史 3<br />\r1.2　中国的软件测试行业 4<br />\r1.2.1　软件测试整体起点较高 4<br />\r1.2.2　软件测试的困境和迷局 5<br />\r1.2.3　迷茫的软件测试工程师 7<br />\r1.3　认识软件测试的优势和劣势 9<br />\r1.3.1　软件测试的优势 9<br />\r1.3.2　软件测试的劣势 10<br />\r第2章　软件测试工程师的职业规划 12<br />\r2.1　软件测试的职业发展方向 13<br />\r2.1.1　软件测试在管理上的发展 13<br />\r2.1.2　软件测试在技术上的发展 14<br />\r2.1.3　&ldquo;角色&rdquo;和&ldquo;段位&rdquo; 16<br />\r2.1.4　软件测试在质量领域的发展 18<br />\r2.2　软件测试工程师职业规划建议 20<br />\r2.2.1　做管理还是做技术 20<br />\r2.2.2　对测试工作&ldquo;跳槽&rdquo;的建议 22<br />\r2.2.3　软件测试创业 23<br />\r第二部分　突破：向软件测试架构师的目标迈进<br />\r第3章　软件测试架构师应该做和不该做的事情 29<br />\r3.1　软件测试架构师需要关注和不需要关注的事情 29<br />\r3.1.1　测试架构师在需求分析中 30<br />\r3.1.2　测试架构师在测试分析和设计中 32<br />\r3.1.3　测试架构师在测试执行中 34<br />\r3.1.4　测试架构师在测试质量评估中 35<br />\r3.2　像软件测试架构师一样的思考 36<br />\r3.3　软件测试经理可以替代软件测试架构师吗 36<br />\r3.4　系统架构师可以替代软件测试架构师吗 38<br />\r第4章　软件测试架构师的知识能力模型 40<br />\r4.1　软件产品质量模型 41<br />\r4.1.1　软件产品质量六属性 41<br />\r4.1.2　功能性 43<br />\r4.1.3　可靠性 45<br />\r4.1.4　易用性 46<br />\r4.1.5　效率 49<br />\r4.1.6　可维护性 50<br />\r4.1.7　可移植性 51<br />\r4.2　测试类型 52<br />\r4.3　测试方法 54<br />\r4.3.1　产品测试车轮图 54<br />\r4.3.2　功能测试方法 55<br />\r4.3.3　可靠性测试方法 61<br />\r4.3.4　性能测试方法 68<br />\r4.3.5　易用性测试法 72<br />\r4.4　测试设计技术 74<br />\r4.4.1　测试点不等于测试用例 75<br />\r4.4.2　四步测试设计法 77<br />\r4.4.3　对测试点进行分类 79<br />\r4.4.4　流程类测试设计：路径分析法 84<br />\r4.4.5　参数类测试设计：&ldquo;输入&mdash;输出表&rdquo;分析法 96<br />\r4.4.6　数据类测试设计：等价类和边界值分析法 102<br />\r4.4.7　组合类测试设计：正交分析法 107<br />\r4.4.8　控制用例粒度：测试点的组合和拆分 111<br />\r4.4.9　错误推断法 116<br />\r4.5　探索式测试 117<br />\r4.5.1　探索式测试的基本思想：CPIE 117<br />\r4.5.2　选择合适的探索式测试方法 118<br />\r4.5.3　开展探索式测试 121<br />\r4.6　自动化测试 124<br />\r4.6.1　需要知道的一些自动化测试真相 124<br />\r4.6.2　如何评估自动化的收益 126<br />\r4.6.3　自动化测试工具介绍 127<br />\r第5章　软件测试架构师的软能力修炼 130<br />\r5.1　沟通和协商 131<br />\r5.1.1　产品测试中的沟通原则 131<br />\r5.1.2　通过沟通来获得对产品测试有用的信息 134<br />\r5.1.3　和测试团队成员沟通 136<br />\r5.1.4　和领导或投资决策者沟通 140<br />\r5.2　写出漂亮的测试用例 141<br />\r5.2.1　测试用例模板 141<br />\r5.2.2　测试用例标题要是一个完整的句子 142<br />\r5.2.3　用条件而不是参数来描述测试用例标题 143<br />\r5.2.4　如果一个用例中包含有多个参数，用例中应该是每个参数的取值 145<br />\r5.2.5　不要在测试用例中引用别的测试用例 147<br />\r5.2.6　避免测试用例中包含过多的用户接口细节 149<br />\r5.2.7　明确测试步骤和预期结果的对应关系 150<br />\r5.2.8　避免在测试步骤中使用笼统的词 151<br />\r第三部分　修炼：软件测试架构师的核心技能<br />\r第6章　如何才能制定好测试策略 155<br />\r6.1　理解测试策略 155<br />\r6.2　四步测试策略制定法 159<br />\r6.3　产品质量评估模型 165<br />\r6.3.1　优秀的产品质量评估模型的特征 165<br />\r6.3.2　软件产品质量评估模型 167<br />\r6.4　测试覆盖度评估 167<br />\r6.4.1　需求覆盖度评估 168<br />\r6.4.2　路径覆盖度评估 170<br />\r6.5　测试过程评估 171<br />\r6.5.1　测试用例评估 171<br />\r6.5.2　测试方法分析 173<br />\r6.5.3　测试投入分析 174<br />\r6.6　缺陷分析 174<br />\r6.6.1　缺陷密度 174<br />\r6.6.2　缺陷修复率 176<br />\r6.6.3　缺陷趋势分析 177<br />\r6.6.4　缺陷年龄分析 183<br />\r6.6.5　缺陷触发因素分析 188<br />\r6.6.6　组合使用各种缺陷分析技术 190<br />\r6.7　风险分析技术 191<br />\r6.7.1　风险分析 192<br />\r6.7.2　风险应对 196<br />\r6.7.3　老功能分析 198<br />\r6.8　分层测试技术 201<br />\r6.8.1　V模型 201<br />\r6.8.2　设计测试层次 201<br />\r第7章　测试策略实战攻略 204<br />\r7.1　开始 204<br />\r7.2　初次使用&ldquo;四步测试策略制定法&rdquo; 205<br />\r7.2.1　产品质量等级 205<br />\r7.2.2　确定项目中各个特性的质量等级 206<br />\r7.2.3　对项目整体进行风险分析 206<br />\r7.2.4　确定测试策略的结构 207<br />\r7.2.5　初步确定测试分层 208<br />\r7.2.6　回顾 209<br />\r7.3　制定总体测试策略 211<br />\r7.3.1　分解产品质量目标 211<br />\r7.3.2　使用老功能分析法来对特性进行分类 214<br />\r7.3.3　基于质量和风险来确定测试深度与测试广度 215<br />\r7.3.4　确定测试优先级 218<br />\r7.3.5　确定测试的总体框架 219<br />\r7.3.6　回顾 220<br />\r7.4　制定阶段测试策略 222<br />\r7.4.1　测试设计策略 223<br />\r7.4.2　集成测试策略 230<br />\r7.4.3　系统测试策略 234<br />\r7.4.4　验收测试策略 236<br />\r7.4.5　回顾 238<br />\r第8章　版本测试策略和产品质量评估 240<br />\r8.1　开始 240<br />\r8.2　第一个版本测试策略 243<br />\r8.2.1　测试范围以及和计划相比的偏差 243<br />\r8.2.2　本版本的测试目标 244<br />\r8.2.3　需要重点关注的内容 245<br />\r8.2.4　测试用例的选择 246<br />\r8.2.5　测试执行顺序 247<br />\r8.2.6　试探性的测试策略&mdash;&mdash;需要大家分工合作的地方 248<br />\r8.2.7　接收测试策略 249<br />\r8.2.8　回顾 250<br />\r8.3　跟踪测试执行 251<br />\r8.3.1　跟踪测试用例执行情况 251<br />\r8.3.2　每日缺陷跟踪 256<br />\r8.3.3　调整测试策略 262<br />\r8.4　版本质量评估 264<br />\r8.4.1　使用软件产品质量评估模型来进行质量评估 265<br />\r8.4.2　版本质量评估中的缺陷分析 271<br />\r8.4.3　调整测试策略 273<br />\r8.4.4　建立特性版本质量档案 274<br />\r8.5　后面的版本测试策略 274<br />\r8.5.1　回归测试策略 275<br />\r8.5.2　探索式测试策略 280<br />\r8.5.3　自动化测试策略 283<br />\r8.5.4　回顾 286<br />\r8.6　阶段质量评估（包括发布质量评估） 287<br />\r8.6.1　阶段质量评估项目 288<br />\r8.6.2　非测试用例发现缺陷的原因分析 293<br />\r8.6.3　组合缺陷分析 295<br />\r8.6.4　遗留缺陷分析 297<br />\r8.6.5　临近发布时的缺陷修复策略 299<br />\r8.6.6　非必然重现bug的处理 299<br />\r8.6.7　总结 299</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1NfDS5nxKCTUH7_QvLvBM0Q" target="_blank">点我下载</a></p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请联系微信1184451075获取，还有微信交流群等你哦~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 267),
(727, '正则表达式的概念', '727', 1528789080, 1528789171, '<p>本文记录Java学习过程中遇到的正则表达式~</p>\r<!--more-->\r\r<p>正则表达式（英语：Regular Expression，在代码中常简写为regex）。</p>\r\r<p>正则表达式是一个字符串，使用单个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。</p>\r\r<p>在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 137),
(728, '正则表达式的匹配规则', '728', 1528789320, 1528789991, '<p>本文记录Java学习过程中遇到的正则表达式的匹配规则~</p>\r<!--more-->\r\r<p>参照Java的API文档，在Pattern类中有正则表达式的的规则定义，正则表达式中明确区分大小写字母。</p>\r\r<p>正则表达式的语法规则总结如下：</p>\r\r<ul>\r	<li>字符：x</li>\r</ul>\r\r<p>含义：代表的是字符x</p>\r\r<p>例如：匹配规则为 &quot;a&quot;，那么需要匹配的字符串内容就是 &quot;a&quot;</p>\r\r<ul>\r	<li>字符：\\\\</li>\r</ul>\r\r<p>含义：代表的是反斜线字符&#39;\\&#39;</p>\r\r<p>例如：匹配规则为&quot;\\\\&quot; ，那么需要匹配的字符串内容就是 &rdquo;\\&rdquo;</p>\r\r<ul>\r	<li>字符：\\t</li>\r</ul>\r\r<p>含义：制表符</p>\r\r<p>例如：匹配规则为&quot;\\t&quot; ，那么对应的效果就是产生一个制表符的空间</p>\r\r<ul>\r	<li>字符：\\n</li>\r</ul>\r\r<p>含义：换行符</p>\r\r<p>例如：匹配规则为&quot;\\n&quot;，那么对应的效果就是换行,光标在原有位置的下一行</p>\r\r<ul>\r	<li>字符：\\r</li>\r</ul>\r\r<p>含义：回车符</p>\r\r<p>例如：匹配规则为&quot;\\r&quot; ，那么对应的效果就是回车后的效果,光标来到下一行行首</p>\r\r<ul>\r	<li>字符类：[abc]</li>\r</ul>\r\r<p>含义：代表的是字符a、b 或 c</p>\r\r<p>例如：匹配规则为&quot;[abc]&quot; ，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个</p>\r\r<ul>\r	<li>字符类：[^abc]</li>\r</ul>\r\r<p>含义：代表的是除了 a、b 或 c以外的任何字符</p>\r\r<p>例如：匹配规则为&quot;[^abc]&quot;，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符</p>\r\r<ul>\r	<li>字符类：[a-zA-Z]</li>\r</ul>\r\r<p>含义：代表的是a 到 z 或 A 到 Z，两头的字母包括在内</p>\r\r<p>例如：匹配规则为&quot;[a-zA-Z]&quot;，那么需要匹配的是一个大写或者小写字母</p>\r\r<ul>\r	<li>字符类：[0-9]</li>\r</ul>\r\r<p>含义：代表的是 0到9数字，两头的数字包括在内</p>\r\r<p>例如：匹配规则为&quot;[0-9]&quot;，那么需要匹配的是一个数字</p>\r\r<ul>\r	<li>字符类：[a-zA-Z_0-9]</li>\r</ul>\r\r<p>含义：代表的字母或者数字或者下划线(即单词字符)</p>\r\r<p>例如：匹配规则为&quot; [a-zA-Z_0-9] &quot;，那么需要匹配的是一个字母或者是一个数字或一个下滑线</p>\r\r<ul>\r	<li>预定义字符类：.</li>\r</ul>\r\r<p>含义：代表的是任何字符</p>\r\r<p>例如：匹配规则为&quot; . &quot;，那么需要匹配的是一个任意字符。如果，就想使用 . 的话，使用匹配规则&quot;\\\\.&quot;来实现</p>\r\r<ul>\r	<li>预定义字符类：\\d</li>\r</ul>\r\r<p>含义：代表的是 0到9数字，两头的数字包括在内，相当于[0-9]</p>\r\r<p>例如：匹配规则为&quot;\\d &quot;，那么需要匹配的是一个数字</p>\r\r<ul>\r	<li>预定义字符类：\\w</li>\r</ul>\r\r<p>含义：代表的字母或者数字或者下划线(即单词字符)，相当于[a-zA-Z_0-9]</p>\r\r<p>例如：匹配规则为&quot;\\w &quot;，，那么需要匹配的是一个字母或者是一个数字或一个下滑线</p>\r\r<ul>\r	<li>边界匹配器：^</li>\r</ul>\r\r<p>含义：代表的是行的开头</p>\r\r<p>例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号</p>\r\r<ul>\r	<li>边界匹配器：$</li>\r</ul>\r\r<p>含义：代表的是行的结尾</p>\r\r<p>例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容以[0-9]这个结束, 相当于右双引号</p>\r\r<ul>\r	<li>边界匹配器：\\b</li>\r</ul>\r\r<p>含义：代表的是单词边界</p>\r\r<p>例如：匹配规则为&quot;\\b[abc]\\b&quot; ，那么代表的是字母a或b或c的左右两边需要的是非单词字符([a-zA-Z_0-9])</p>\r\r<ul>\r	<li>数量词：X?</li>\r</ul>\r\r<p>含义：代表的是X出现一次或一次也没有</p>\r\r<p>例如：匹配规则为&quot;a?&quot;，那么需要匹配的内容是一个字符a，或者一个a都没有</p>\r\r<ul>\r	<li>数量词：X*</li>\r</ul>\r\r<p>含义：代表的是X出现零次或多次</p>\r\r<p>例如：匹配规则为&quot;a*&quot; ，那么需要匹配的内容是多个字符a，或者一个a都没有</p>\r\r<ul>\r	<li>数量词：X+</li>\r</ul>\r\r<p>含义：代表的是X出现一次或多次</p>\r\r<p>例如：匹配规则为&quot;a+&quot;，那么需要匹配的内容是多个字符a，或者一个a</p>\r\r<ul>\r	<li>数量词：X{n}</li>\r</ul>\r\r<p>含义：代表的是X出现恰好 n 次</p>\r\r<p>例如：匹配规则为&quot;a{5}&quot;，那么需要匹配的内容是5个字符a</p>\r\r<ul>\r	<li>数量词：X{n,}</li>\r</ul>\r\r<p>含义：代表的是X出现至少 n 次</p>\r\r<p>例如：匹配规则为&quot;a{5, }&quot;，那么需要匹配的内容是最少有5个字符a</p>\r\r<ul>\r	<li>数量词：X{n,m}</li>\r</ul>\r\r<p>含义：代表的是X出现至少 n 次，但是不超过 m 次</p>\r\r<p>例如：匹配规则为&quot;a{5,8}&quot;，那么需要匹配的内容是有5个字符a 到 8个字符a之间</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 142),
(729, '正则表达式的常用方法', '729', 1528794900, 1528795566, '<p>本文记录Java学习过程中遇到的正则表达式相关的常用方法~</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/3666690759.png" style="width: 600px; height: 118px;" /></p>\r\r<ul>\r	<li>public boolean matches(String regex) ：判断字符串是否匹配给定的规则</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/*\r校验qq号码：\r1.要求必须是5-15位数字\r2.不能以0开头\r*/\rString qq = &quot;604154942&quot;;\rString regex = &quot;[1-9][0-9]{4,14}&quot;;\rboolean flag2 = qq.matches(regex);</pre>\r\r<pre class="brush:java;">\r/*\r校验手机号码：\r1.要求为11位数字\r2.第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。\r*/\rString phone = &quot;18800022116&quot;;\rString regex = &quot;1[34578][0-9]{9}&quot;;\rboolean flag = phone.matches(regex);</pre>\r\r<ul>\r	<li>\r	<p>public String[] split(String regex) ：根据给定正则表达式的匹配规则，拆分此字符串</p>\r	</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/*\r分割出字符串中的的数字:\r*/\r//以-为分隔符\rString s = &quot;18-22-40-65&quot;;\rString regex = &quot;-&quot;;\rString[] result = s.split(regex);\r//以空格为分隔符\rString s = &quot;18 22 40 65&quot;;\rString regex = &quot; &quot;;\rString[] result = s.split(regex);</pre>\r\r<ul>\r	<li>\r	<p>public String replaceAll(String regex,String replacement)：将符合规则的字符串内容，全部替换为新字符串</p>\r	</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/*\r把文字中的数字替换成*\r*/\rString s = &quot;Hello12345World6789012&quot;;\rString regex = &quot;[0-9]&quot;;\rString result = s.replaceAll(regex, &quot;*&quot;);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 145),
(730, '微信截图_20180612171607.png', '微信截图_20180612171607-png', 1528795022, 1528795022, 'a:5:{s:4:"name";s:31:"微信截图_20180612171607.png";s:4:"path";s:35:"/usr/uploads/2018/06/3666690759.png";s:4:"size";i:32004;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 729, 0),
(731, '常用的几个正则表达式', '731', 1528801440, 1528805132, '<p>本文记录Java学习过程中遇到的几个常用的正则表达式~</p>\r<!--more-->\r\r<ul>\r	<li>匹配正整数：</li>\r</ul>\r\r<pre class="brush:java;">\r\\\\d+</pre>\r\r<ul>\r	<li>匹配正小数：</li>\r</ul>\r\r<pre class="brush:java;">\r\\\\d+\\\\.\\\\d+</pre>\r\r<ul>\r	<li>匹配负整数：</li>\r</ul>\r\r<pre class="brush:java;">\r-\\\\d+</pre>\r\r<ul>\r	<li>匹配负小数：</li>\r</ul>\r\r<pre class="brush:java;">\r-\\\\d+\\\\.\\\\d+</pre>\r\r<ul>\r	<li>匹配保留两位小数的正数：</li>\r</ul>\r\r<pre class="brush:java;">\r\\\\d+\\\\.\\\\d{2}</pre>\r\r<ul>\r	<li>匹配保留1-3位小数的正数：</li>\r</ul>\r\r<pre class="brush:java;">\r\\\\d+\\\\.\\\\d{1,3}</pre>\r\r<ul>\r	<li>匹配合法的邮箱：</li>\r</ul>\r\r<pre class="brush:java;">\r[a-zA-Z_0-9]+@[a-zA-Z_0-9]+(\\\\.[a-zA-Z_0-9]+)+\r\\\\w+@\\\\w+(\\\\.\\\\w+)+</pre>\r\r<ul>\r	<li>获取IP地址(192.168.1.100)中的每段数字：</li>\r</ul>\r\r<pre class="brush:java;">\r\\\\.</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 158),
(732, 'IntelliJ IDEA快捷键大全', '732', 1529452440, 1529453219, '<p>本文分享一份总结得比较全的常用IntellJ IDEA快捷键大全~</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/06/1068185345.jpg" style="width: 980px; height: 2964px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 145),
(733, 'IntelliJ-IDEA-Hotkeys.jpg', 'IntelliJ-IDEA-Hotkeys-jpg', 1529452557, 1529452557, 'a:5:{s:4:"name";s:25:"IntelliJ-IDEA-Hotkeys.jpg";s:4:"path";s:35:"/usr/uploads/2018/06/1068185345.jpg";s:4:"size";i:1250315;s:4:"type";s:3:"jpg";s:4:"mime";s:10:"image/jpeg";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 732, 0),
(734, 'Date类', '734', 1531089660, 1531551562, '<p>本文记录Java学习过程中遇到的Date类～</p>\r<!--more-->\r\r<p>Date类表示特定的瞬间，可以精确到毫秒。查阅Date类的API描述，发现Date有很多个构造函数，但是大部分已经过时，除了其中未过时的部分构造函数，这部分构造函数可以把毫秒值转成日期对象。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3758571912.png" style="width: 600px; height: 60px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建日期对象，把当前的毫秒值转成日期对象\rDate date = new Date(1607616000000L);\r//打印刚刚创建的日期对象\rSystem.out.println(date);\r//打印结果：Fri Dec 11 00:00:00 CST 2020</pre>\r\r<p>将毫秒值转成日期后，发现输出的格式不利于我们阅读，继续查阅API发现Date中有getYear、getMouth等方法，可是他们都已经过时，继续往下查阅，看到了toString方法。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4172198565.png" style="width: 600px; height: 36px;" /></p>\r\r<p>点开toString()方法查阅，原来上面打印的date对象就是默认调用了这个toString方法，并且在这个方法下面还写着让我们参见toLocaleString方法。再点开toLocaleString方法，发现这个方法又过时了。从JDK 1.1&nbsp;开始，该方法由DateFormat.format(Date date)&nbsp;取代。</p>\r\r<p>既然这个方法被DateFormat.format(Date date)&nbsp;取代，那么就要去查阅DateFormat类，这里就不多赘述了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 124),
(735, 'date.png', 'date-png', 1531089827, 1531089827, 'a:5:{s:4:"name";s:8:"date.png";s:4:"path";s:35:"/usr/uploads/2018/07/3758571912.png";s:4:"size";i:22272;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 734, 0),
(736, 'tostring.png', 'tostring-png-1', 1531090003, 1531090003, 'a:5:{s:4:"name";s:12:"tostring.png";s:4:"path";s:35:"/usr/uploads/2018/07/4172198565.png";s:4:"size";i:12415;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 734, 0),
(737, 'Date类常用方法', '737', 1531090380, 1531551681, '<p>本文记录Java学习过程中遇到的Date类的常用方法～</p>\r<!--more-->\r\r<p>Date类最常用的方法应该就是getTime了，该方法会把日期对象转换成对应的时间毫秒值。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1757082545.png" style="width: 600px; height: 39px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建日期对象，把当前的毫秒值转成日期对象\rDate date = new Date(1607616000000L);\r//打印刚刚创建的日期对象\rSystem.out.println(date);\r//打印结果：Fri Dec 11 00:00:00 CST 2020\rSystem.out.println(date.getTime());\r//打印结果：1607616000000</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(738, 'fangfa.png', 'fangfa-png', 1531090514, 1531090514, 'a:5:{s:4:"name";s:10:"fangfa.png";s:4:"path";s:35:"/usr/uploads/2018/07/1757082545.png";s:4:"size";i:8411;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 737, 0),
(739, 'DateFormat类', '739', 1531106220, 1553997098, '<p>本文记录Java学习过程中遇到的DateFormat类～</p>\r<!--more-->\r\r<p>DateFormat&nbsp;是日期/时间格式化子类的抽象类，它采用与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如SimpleDateFormat类）允许进行格式化（也就是日期-&gt;&nbsp;文本）、解析（文本-&gt;&nbsp;日期）和标准化。</p>\r\r<p>我们通过这个类可以帮我们完成日期和文本之间的转换。继续阅读API可以发现，DateFormat可以帮助我们进行格式化并解析任何语言环境的日期。对于月、星期，甚至日历格式（阴历和阳历）。</p>\r\r<p>要格式化一个当前语言环境下的日期也就是日期-&gt;&nbsp;文本，要通过下面的方法来完成。DateFormat是抽象类，我们需要使用其子类SimpleDateFormat来创建对象。</p>\r\r<ul>\r	<li>构造方法</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/520489460.png" style="width: 600px; height: 46px;" /></p>\r\r<ul>\r	<li>format方法</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/43571146.png" style="width: 600px; height: 54px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建日期格式化对象,在获取格式化对象时可以指定风格\rDateFormat df= new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//对日期进行格式化\rDate date = new Date(1607616000000L);\rString str_time = df.format(date);\rSystem.out.println(str_time);//2020年12月11日</pre>\r\r<ul>\r	<li>DateFormat类的作用</li>\r</ul>\r\r<p>可以将一个Date对象转换为一个符合指定格式的字符串，也可以将一个符合指定格式的字符串转为一个Date对象。</p>\r\r<ul>\r	<li>格式的规则</li>\r</ul>\r\r<ol>\r	<li>当出现y时，会将y替换成年</li>\r	<li>当出现M时，会将M替换成月</li>\r	<li>当出现d时，会将d替换成日</li>\r	<li>当出现H时，会将H替换成时</li>\r	<li>当出现m时，会将m替换成分</li>\r	<li>当出现s时，会将s替换成秒</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 128),
(740, 'gouzao.png', 'gouzao-png', 1531106554, 1531106554, 'a:5:{s:4:"name";s:10:"gouzao.png";s:4:"path";s:34:"/usr/uploads/2018/07/520489460.png";s:4:"size";i:30624;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 739, 0),
(741, 'format.png', 'format-png', 1531106635, 1531106635, 'a:5:{s:4:"name";s:10:"format.png";s:4:"path";s:33:"/usr/uploads/2018/07/43571146.png";s:4:"size";i:22973;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 739, 0),
(742, 'DateFormat类常用方法', '742', 1531107240, 1531114692, '<p>本文记录Java学习过程中遇到的DateFormat类的常用方法～</p>\r<!--more-->\r\r<p>DataFormat类的常用方法有两个：format和parse。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2156837777.png" style="width: 600px; height: 101px;" /></p>\r\r<p>format方法用来讲Date对象转换成String，而parse方法正好相反，是讲String转换成Date。需要注意的是，使用parse方法时，输入的String要符合指定格式，否则不能转换。</p>\r\r<p>示例代码（将Date对象转换成String）：</p>\r\r<pre class="brush:java;">\rDate date = new Date(1607616000000L);//Fri Dec 11 00:00:00 CST 2020\rDateFormat df = new SimpleDateFormat(&ldquo;yyyy年MM月dd日&rdquo;);\rString str = df.format(date);\r//str中的内容为2020年12月11日</pre>\r\r<p>示例代码（将String转换成Date对象）：</p>\r\r<pre class="brush:java;">\rString str = &rdquo;2020年12月11日&rdquo;;\rDateFormat df = new SimpleDateFormat(&ldquo;yyyy年MM月dd日&rdquo;);\rDate date = df.parse( str );\r//Date对象中的内容为Fri Dec 11 00:00:00 CST 2020</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 117),
(743, 'fangfa.png', 'fangfa-png-1', 1531114413, 1531114413, 'a:5:{s:4:"name";s:10:"fangfa.png";s:4:"path";s:35:"/usr/uploads/2018/07/2156837777.png";s:4:"size";i:48527;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 742, 0),
(744, 'Calendar类', '744', 1531116540, 1531116719, '<p>本文记录Java学习过程中遇到的Calendar类～</p>\r<!--more-->\r\r<p>Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</p>\r\r<p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/466285352.png" style="width: 600px; height: 50px;" /></p>\r\r<p>示例代码（返回当前时间）：</p>\r\r<pre class="brush:java;">\rCalendar c = Calendar.getInstance();  //返回当前时间</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(745, 'static.png', 'static-png', 1531116653, 1531116653, 'a:5:{s:4:"name";s:10:"static.png";s:4:"path";s:34:"/usr/uploads/2018/07/466285352.png";s:4:"size";i:26306;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 744, 0),
(746, 'Calendar类常用方法', '746', 1531116780, 1531119267, '<p>本文记录Java学习过程中遇到的Calendar类的常用方法～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2633172222.png" style="width: 600px; height: 177px;" /></p>\r\r<ul>\r	<li>public static Calendar&nbsp;getInstance()</li>\r</ul>\r\r<p>获取日期对象</p>\r\r<ul>\r	<li>public int&nbsp;get(int field)</li>\r</ul>\r\r<p>获取时间字段值，常用格式如下：</p>\r\r<ol>\r	<li>YEAR &nbsp; &nbsp; &nbsp;年</li>\r	<li>MONTH &nbsp; 月，从0开始算起，最大11；0代表1月，11代表12月。</li>\r	<li>DATE &nbsp; &nbsp; &nbsp;天</li>\r	<li>HOUR &nbsp; &nbsp; 时</li>\r	<li>MINUTE &nbsp;分</li>\r	<li>SECOND 秒</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rCalendar c = Calendar.getInstance();\rint year = c.get(Calendar.YEAR);</pre>\r\r<ul>\r	<li>public void&nbsp;add(int field,int amount)</li>\r</ul>\r\r<p>指定字段增加某值</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rCalendar c = Calendar.getInstance();\r//修改当前时间为3天后\rc.add(Calendar.DATE, 3);\r//修改当前时间为5小时后\rc.add(Calendar.HOUR, 5);</pre>\r\r<ul>\r	<li>public final void&nbsp;set(int field,int value)</li>\r</ul>\r\r<p>设置指定字段的值</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rCalendar c = Calendar.getInstance();\r//设置时间为2020年5月20日\rc.set(Calendar.YEAR, 2020);\rc.set(Calendar.MONTH, 4);\rc.set(Calendar.DATE, 20);</pre>\r\r<ul>\r	<li>public final Date&nbsp;getTime()</li>\r</ul>\r\r<p>获取该日历对象转成的日期对象</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rCalendar c = Calendar.getInstance();\rDate d = c.getTime();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(747, 'calendar.png', 'calendar-png', 1531118531, 1531118531, 'a:5:{s:4:"name";s:12:"calendar.png";s:4:"path";s:35:"/usr/uploads/2018/07/2633172222.png";s:4:"size";i:83046;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 746, 0),
(748, '日历类使用时的注意事项', '748', 1531121340, 1531121392, '<p>本文记录Java学习过程中的日历类的使用注意事项～</p>\r<!--more-->\r\r<ol>\r	<li>西方星期的开始为周日，中国为周一。</li>\r	<li>在Calendar类中，月份的表示是以0-11代表1-12月。</li>\r	<li>日期是有大小关系的，时间靠后，时间越大。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(749, '基本类型包装类', '749', 1531136580, 1531137238, '<p>本文记录Java学习过程中遇到的基本类型包装类～</p>\r<!--more-->\r\r<p>在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等。那么，想实现字符串与基本数据之间转换怎么办呢？</p>\r\r<p>Java中提供了相应的对象来解决该问题，基本数据类型对象包装类：Java将基本数据类型值封装成了对象。封装成对象可以提供更多的操作基本数值的功能。</p>\r\r<p>8种基本类型对应的包装类如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4098886683.png" style="width: 600px; height: 170px;" />​</p>\r\r<p>其中需要注意int对应的是Integer，char对应的Character，其他6个都是基本类型首字母大写即可。</p>\r\r<p>基本数据类型对象包装类特点：用于在基本数据和字符串之间进行转换。</p>\r\r<ul>\r	<li>将字符串转成基本类型</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1385982759.png" style="width: 600px; height: 296px;" /></p>\r\r<p>parseXXX(String s)中XXX表示基本类型，参数为可以转成基本类型的字符串，如果字符串无法转成基本类型，将会发生数字转换的问题NumberFormatException。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rSystem.out.println(Integer.parseInt(&quot;123&quot;) + 2);\r//打印结果为 125</pre>\r\r<ul>\r	<li>将基本数值转成字符串</li>\r</ul>\r\r<p>1. 基本类型直接与&rdquo;&rdquo;相连接即可；34+&quot;&quot;；</p>\r\r<p>2.&nbsp;调用String的valueOf方法；</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1781294764.png" style="width: 600px; height: 392px;" /></p>\r\r<p>3.&nbsp;调用包装类中的toString方法。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/995856938.png" style="width: 600px; height: 482px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(750, '8.png', '8-png', 1531136768, 1531136768, 'a:5:{s:4:"name";s:5:"8.png";s:4:"path";s:35:"/usr/uploads/2018/07/4098886683.png";s:4:"size";i:63313;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 749, 0),
(751, 'string.png', 'string-png', 1531136927, 1531136927, 'a:5:{s:4:"name";s:10:"string.png";s:4:"path";s:35:"/usr/uploads/2018/07/1385982759.png";s:4:"size";i:81733;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 749, 0),
(752, 'base.png', 'base-png', 1531137126, 1531137126, 'a:5:{s:4:"name";s:8:"base.png";s:4:"path";s:35:"/usr/uploads/2018/07/1781294764.png";s:4:"size";i:73549;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 749, 0),
(753, 'tostring.png', 'tostring-png-2', 1531137214, 1531137214, 'a:5:{s:4:"name";s:12:"tostring.png";s:4:"path";s:34:"/usr/uploads/2018/07/995856938.png";s:4:"size";i:96529;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 749, 0),
(754, '基本类型与包装类的相互转换', '754', 1531137360, 1531137910, '<p>本文记录Java学习过程中遇到的基本数据类型与相应的包装类对象直接的相互转换～</p>\r<!--more-->\r\r<p>这里使用int类型与Integer对象转换进行演示，其他基本类型转换方式类似。</p>\r\r<ul>\r	<li>基本数值----&gt;包装对象</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3320877726.png" style="width: 600px; height: 94px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rInteger i = new Integer(4);//使用构造函数函数\rInteger ii = new Integer(&quot;4&quot;);//构造函数中可以传递一个数字字符串</pre>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1070919988.png" style="width: 600px; height: 98px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法\rInteger iiii = Integer.valueOf(&quot;4&quot;);//使用包装类中的valueOf方法</pre>\r\r<ul>\r	<li>包装对象----&gt;基本数值</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/729964105.png" style="width: 600px; height: 49px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rint num = i.intValue();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(755, 'shuzhi.png', 'shuzhi-png', 1531137543, 1531137543, 'a:5:{s:4:"name";s:10:"shuzhi.png";s:4:"path";s:35:"/usr/uploads/2018/07/3320877726.png";s:4:"size";i:21660;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 754, 0),
(756, 'valueof.png', 'valueof-png', 1531137631, 1531137631, 'a:5:{s:4:"name";s:11:"valueof.png";s:4:"path";s:35:"/usr/uploads/2018/07/1070919988.png";s:4:"size";i:23394;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 754, 0),
(757, 'duixiang.png', 'duixiang-png', 1531137847, 1531137847, 'a:5:{s:4:"name";s:12:"duixiang.png";s:4:"path";s:34:"/usr/uploads/2018/07/729964105.png";s:4:"size";i:7869;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 754, 0),
(758, '自动装箱与拆箱', '758', 1531138380, 1531139446, '<p>本文记录Java学习过程中遇到的自动装箱与拆箱～</p>\r<!--more-->\r\r<p>在需要的情况下，基本类型与包装类型可以通用。有些时候我们必须使用引用数据类型时，可以传入基本数据类型。</p>\r\r<p>基本类型可以使用运算符直接进行计算，但是引用类型不可以。而基本类型包装类作为引用类型的一种却可以计算，原因在于，Java&rdquo;偷偷地&rdquo;自动地进行了对象向基本数据类型的转换。</p>\r\r<p>相对应的，引用数据类型变量的值必须是new出来的内存空间地址值，而我们可以将一个基本类型的值赋值给一个基本类型包装类的引用。原因同样在于Java又&rdquo;偷偷地&rdquo;自动地进行了基本数据类型向对象的转换。</p>\r\r<ul>\r	<li>自动拆箱：对象转成基本数值</li>\r	<li>自动装箱：基本数值转成对象</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ri = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; 加法运算完成后，再次装箱，把基本数值转成对象。</pre>\r\r<p>注意：当数值在范围之内时，进行自动装箱，不会新创建对象空间而是使用医来已有的空间。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rInteger a = new Integer(3);\rInteger b = new Integer(3);\rSystem.out.println(a==b);//false\rSystem.out.println(a.equals(b));//true\r\rSystem.out.println(&quot;---------------------&quot;);\rInteger x = 127;\rInteger y = 127;\r//在jdk1.5自动装箱时，如果数值在byte范围之内，不会新创建对象空间而是使用原来已有的空间。\rSystem.out.println(x==y); //true\rSystem.out.println(x.equals(y)); //true</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(759, 'System类', '759', 1531190700, 1531190788, '<p>本文记录Java学习过程中遇到的System类～</p>\r<!--more-->\r\r<p>在API中System类介绍的比较简单，我们给出定义，System中代表程序所在系统，提供了对应的一些系统属性信息和一些系统操作。</p>\r\r<p>System类不能手动创建对象，因为构造方法被private修饰，阻止外界创建对象。</p>\r\r<p>System类中的都是static方法，类名访问即可。当然，在JDK中，有许多这样的类。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(760, 'System类常用方法', '760', 1531190820, 1531191526, '<p>本文记录Java学习过程中遇到的System类的常用方法～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/331793780.png" style="width: 600px; height: 167px;" /></p>\r\r<p>1. currentTimeMillis()</p>\r\r<p>获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>\r\r<p>示例代码（验证for循环打印数字1-9999所需要使用的时间）：</p>\r\r<pre class="brush:java;">\rlong start = System.currentTimeMillis();\r	for (int i=0; i&lt;10000; i++) {\r         System.out.println(i);\r}\rlong end = System.currentTimeMillis();\rSystem.out.println(&quot;共耗时毫秒：&quot; + (end-start) );</pre>\r\r<p>2. exit(int status)</p>\r\r<p>用来结束正在运行的Java程序。参数传入一个数字即可。通常传入0记为正常状态，其他为异常状态</p>\r\r<p>示例代码（循环生成100-999之间的的三位数并进行打印该数，当该数能被10整除时，结束运行的程序）：</p>\r\r<pre class="brush:java;">\rRandom random = new Random();\r    while(true){\r        int number = random.nextInt(900)+100; //0-899 + 100\r        if (nmumber % 10 == 0) {\r            System.exit(0);\r        }\r}</pre>\r\r<p>3. gc()</p>\r\r<p>用来运行JVM中的垃圾回收器，完成内存中垃圾的清除</p>\r\r<p>4. getProperty(String key)</p>\r\r<p>用来获取指定键(字符串名称)中所记录的系统属性信息</p>\r\r<p>常用的系统属性信息如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3554833371.png" style="width: 600px; height: 734px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3240646723.png" style="width: 600px; height: 95px;" /></p>\r\r<p>5. arraycopy方法</p>\r\r<p>用来实现将源数组部分元素复制到目标数组的指定位置</p>\r\r<p>示例代码（将src数组中前3个元素，复制到dest数组的前3个位置上）：</p>\r\r<pre class="brush:java;">\rint[] src = new int[]{1,2,3,4,5};\rint[] dest = new int[]{6,7,8,9,10};\rSystem.arraycopy( src, 0, dest, 0, 3);\r代码运行后：两个数组中的元素发生了变化\rsrc数组元素[1,2,3,4,5]\rdest数组元素[1,2,3,9,10]</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(761, 'system01.png', 'system01-png', 1531190969, 1531190969, 'a:5:{s:4:"name";s:12:"system01.png";s:4:"path";s:34:"/usr/uploads/2018/07/331793780.png";s:4:"size";i:33655;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 760, 0),
(762, 'system02.png', 'system02-png', 1531191144, 1531191144, 'a:5:{s:4:"name";s:12:"system02.png";s:4:"path";s:35:"/usr/uploads/2018/07/3554833371.png";s:4:"size";i:138092;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 760, 0),
(763, 'system03.png', 'system03-png', 1531191236, 1531191236, 'a:5:{s:4:"name";s:12:"system03.png";s:4:"path";s:35:"/usr/uploads/2018/07/3240646723.png";s:4:"size";i:35892;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 760, 0),
(764, 'Math类', '764', 1531202280, 1531202398, '<p>本文记录Java学习过程中遇到的Math类～</p>\r<!--more-->\r\r<p>Math类是包含用于执行基本数学运算的方法的数学工具类，如初等指数、对数、平方根和三角函数。</p>\r\r<p>类似这样的工具类，其所有方法均为静态方法，并且一般不会创建对象。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(765, 'Math类常用方法', '765', 1531208040, 1531208404, '<p>本文记录Java学习过程中遇到的Math类的常用方法～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3428686.png" style="width: 600px; height: 272px;" /></p>\r\r<ul>\r	<li>abs方法,结果都为正数</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdouble d1 = Math.abs(-5); // d1的值为5\rdouble d2 = Math.abs(5); // d2的值为5</pre>\r\r<ul>\r	<li>ceil方法，结果为比参数值大的最小整数的double值</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdouble d1 = Math.ceil(3.3); //d1的值为4.0\rdouble d2 = Math.ceil(-3.3); //d2的值为-3.0\rdouble d3 = Math.ceil(5.1); // d3的值为6.0</pre>\r\r<ul>\r	<li>floor方法，结果为比参数值小的最大整数的double值</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdouble d1 = Math.floor(3.3); //d1的值为3.0\rdouble d2 = Math.floor(-3.3); //d2的值为-4.0\rdouble d3 = Math.floor(5.1); //d3的值为5.0</pre>\r\r<ul>\r	<li>max方法，返回两个参数值中较大的值</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdouble d1 = Math.max(3.3, 5.5); //d1的值为5.5\rdouble d2 = Math.max(-3.3, -5.5); //d2的值为-3.3</pre>\r\r<ul>\r	<li>min方法，返回两个参数值中较小的值</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdouble d1 = Math.min(3.3, 5.5); //d1的值为3.3\rdouble d2 = Math.max(-3.3, -5.5); //d2的值为-5.5</pre>\r\r<ul>\r	<li>pow方法，返回第一个参数的第二个参数次幂的值</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdouble d1 = Math.pow(2.0, 3.0); //d1的值为8.0\rdouble d2 = Math.pow(3.0, 3.0); //d2的值为27.0</pre>\r\r<ul>\r	<li>round方法，返回参数值四舍五入的结果</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdouble d1 = Math.round(5.5); //d1的值为6.0\rdouble d2 = Math.round(5.4); //d2的值为5.0</pre>\r\r<ul>\r	<li>random方法，产生一个大于等于0.0且小于1.0的double小数</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdouble d1 = Math.random();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 115),
(766, 'math.png', 'math-png', 1531208120, 1531208120, 'a:5:{s:4:"name";s:8:"math.png";s:4:"path";s:32:"/usr/uploads/2018/07/3428686.png";s:4:"size";i:80041;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 765, 0),
(767, 'Arrays类', '767', 1531209720, 1531210124, '<p>本文记录Java学习过程中遇到的Arrays类～</p>\r<!--more-->\r\r<p>此类包含用来操作数组（比如排序和搜索）的各种方法。</p>\r\r<p>但需要注意的是，如果指定数组引用为null，则访问此类中的方法都会抛出空指针异常NullPointerException。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(768, 'Arrays类常用方法', '768', 1531210200, 1531210449, '<p>本文记录Java学习过程中遇到的Arrays类的常用方法～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4274572640.png" style="width: 600px; height: 121px;" /></p>\r\r<ul>\r	<li>sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序）</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//源arr数组元素{1,5,9,3,7}, 进行排序后arr数组元素为{1,3,5,7,9}\rint[] arr = {1,5,9,3,7};\rArrays.sort( arr );</pre>\r\r<ul>\r	<li>toString方法，用来返回指定数组元素内容的字符串形式</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rint[] arr = {1,5,9,3,7};\rString str = Arrays.toString(arr); // str的值为[1, 3, 5, 7, 9]</pre>\r\r<ul>\r	<li>binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-1。该要求该数组必须是个有序的数组。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rint[] arr = {1,3,4,5,6};\rint index = Arrays.binarySearch(arr, 4); //index的值为2\rint index2= Arrasy.binarySearch(arr, 2); //index2的值为-1</pre>\r\r<p>示例代码（找出考试分数最低的后三名考试分数）：</p>\r\r<pre class="brush:java;">\rpublic static int[] method(double[] arr){\r    Arrays.sort(arr); //进行数组元素排序（元素值从小到大进行排序）\r    int[] result = new int[3]; //存储后三名考试分数\r    System.arraycopy(arr, 0, result, 0, 3);//把arr数组前3个元素复制到result数组中\r    return result;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(769, 'array.png', 'array-png', 1531210246, 1531210246, 'a:5:{s:4:"name";s:9:"array.png";s:4:"path";s:35:"/usr/uploads/2018/07/4274572640.png";s:4:"size";i:28909;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 768, 0),
(770, 'BigInteger类', '770', 1531221060, 1531221378, '<p>本文记录Java学习过程中遇到的BigInteger类～</p>\r<!--more-->\r\r<p>Java中long型为最大整数类型，对于超过long型的数据如何去表示呢？在Java的世界中，超过long型的整数已经不能被称为整数了，它们被封装成BigInteger对象。在BigInteger类中，实现四则运算都是方法来实现，并不是采用运算符。</p>\r\r<p>BigInteger类的构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4123043024.png" style="width: 600px; height: 214px;" /></p>\r\r<p>在使用构造方法时，常常采用字符串的形式给出整数。</p>\r\r<p>示例代码（四则运算）：</p>\r\r<pre class="brush:java;">\r//大数据封装为BigInteger对象\rBigInteger big1 = new BigInteger(&quot;12345678909876543210&quot;);\rBigInteger big2 = new BigInteger(&quot;98765432101234567890&quot;);\r//add实现加法运算\rBigInteger bigAdd = big1.add(big2);\r//subtract实现减法运算\rBigInteger bigSub = big1.subtract(big2);\r//multiply实现乘法运算\rBigInteger bigMul = big1.multiply(big2);\r//divide实现除法运算\rBigInteger bigDiv = big2.divide(big1);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(771, 'biginteger.png', 'biginteger-png', 1531221216, 1531221216, 'a:5:{s:4:"name";s:14:"biginteger.png";s:4:"path";s:35:"/usr/uploads/2018/07/4123043024.png";s:4:"size";i:57860;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 770, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(772, 'BigDecimal类', '772', 1531221420, 1531221899, '<p>本文记录Java学习过程中遇到的BigDecimal类～</p>\r<!--more-->\r\r<p>double和float类型在运算中很容易丢失精度，造成数据的不准确性，Java为我们提供了BigDecimal类来实现浮点数据的高精度运算。</p>\r\r<p>BigDecimal类的构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3884999976.png" style="width: 600px; height: 411px;" /></p>\r\r<p>建议浮点数据以字符串形式给出，因为参数结果是可以预知的。</p>\r\r<p>示例代码（加减乘法）：</p>\r\r<pre class="brush:java;">\r//大数据封装为BigDecimal对象\rBigDecimal big1 = new BigDecimal(&quot;0.09&quot;);\rBigDecimal big2 = new BigDecimal(&quot;0.01&quot;);\r//add实现加法运算\rBigDecimal bigAdd = big1.add(big2);\r         \rBigDecimal big3 = new BigDecimal(&quot;1.0&quot;);\rBigDecimal big4 = new BigDecimal(&quot;0.32&quot;);\r//subtract实现减法运算\rBigDecimal bigSub = big3.subtract(big4);\r          \rBigDecimal big5 = new BigDecimal(&quot;1.105&quot;);\rBigDecimal big6 = new BigDecimal(&quot;100&quot;);\r//multiply实现乘法运算\rBigDecimal bigMul = big5.multiply(big6);</pre>\r\r<p>对于浮点数据的除法运算，和整数不同，可能出现无限不循环小数，因此需要对所需要的位数进行保留和选择舍入模式。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4264073543.png" style="width: 600px; height: 59px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2127519682.png" style="width: 600px; height: 318px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(773, 'bigdecimal.png', 'bigdecimal-png', 1531221604, 1531221604, 'a:5:{s:4:"name";s:14:"bigdecimal.png";s:4:"path";s:35:"/usr/uploads/2018/07/3884999976.png";s:4:"size";i:180776;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 772, 0),
(774, 'divide.png', 'divide-png', 1531221828, 1531221828, 'a:5:{s:4:"name";s:10:"divide.png";s:4:"path";s:35:"/usr/uploads/2018/07/4264073543.png";s:4:"size";i:13480;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 772, 0),
(775, 'ziduan.png', 'ziduan-png', 1531221879, 1531221879, 'a:5:{s:4:"name";s:10:"ziduan.png";s:4:"path";s:35:"/usr/uploads/2018/07/2127519682.png";s:4:"size";i:103250;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 772, 0),
(776, '集合', '776', 1531319400, 1531319550, '<p>本文记录Java学习过程中遇到的集合～</p>\r<!--more-->\r\r<p>集合，集合是java中提供的一种容器，可以用来存储多个数据。</p>\r\r<p>在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？</p>\r\r<ol>\r	<li>数组的长度是固定的，而集合的长度是可变的；</li>\r	<li>集合中存储的元素必须是引用类型数据。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(777, '使用ArrayList集合存储元素', '777', 1531319640, 1531319795, '<p>本文通过几个小例子来说明如何使用ArrayList集合存储元素～</p>\r<!--more-->\r\r<p>示例代码（ArrayList集合存储5个int类型元素）：</p>\r\r<pre class="brush:java;">\rArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\rlist.add(111);\rlist.add(222);\rlist.add(333);\rlist.add(444);\rlist.add(555);\rfor(int i=0; i&lt;list.size(); i++){\r    System.out.println(list.get(i));\r}</pre>\r\r<p>示例代码（ArrayList集合存储5个Person类型元素）：</p>\r\r<pre class="brush:java;">\rArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;();\rlist.add(new Person(&quot;小强&quot;));\rlist.add(new Person(&quot;老王&quot;));\rlist.add(new Person(&quot;小虎&quot;));\rlist.add(new Person(&quot;小泽&quot;));\rlist.add(new Person(&quot;小红&quot;));\rfor(int i=0; i&lt;list.size(); i++){\r&nbsp;&nbsp;&nbsp;&nbsp;Person p = list.get(i);\r    System.out.println(p);\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 107),
(778, '集合的继承实现关系', '778', 1531319820, 1531320800, '<p>本文记录Java学习过程中遇到的集合的继承实现关系～</p>\r<!--more-->\r\r<p>查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。Collection接口为最顶层集合接口了。</p>\r\r<p>源代码：</p>\r\r<pre class="brush:java;">\rinterface List extends Collection {\r}\rpublic class ArrayList extends AbstractList implements List{\r}</pre>\r\r<p>这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。</p>\r\r<ul>\r	<li>Collection接口常用的子接口有：List接口、Set接口</li>\r	<li>List接口常用的子类有：ArrayList类、LinkedList类</li>\r	<li>Set接口常用的子类有：HashSet类、LinkedHashSet类</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3152939303.png" style="width: 600px; height: 215px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(779, 'jicheng.png', 'jicheng-png', 1531320775, 1531320775, 'a:5:{s:4:"name";s:11:"jicheng.png";s:4:"path";s:35:"/usr/uploads/2018/07/3152939303.png";s:4:"size";i:57326;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 778, 0),
(780, 'Collection接口', '780', 1531320900, 1531320956, '<p>本文记录Java学习过程中遇到的Collection接口～</p>\r<!--more-->\r\r<p>既然Collection接口是集合中的顶层接口，那么它中定义的所有功能子类都可以使用。</p>\r\r<p>查阅API中描述的Collection接口。Collection层次结构中的根接口。</p>\r\r<p>Collection&nbsp;表示一组对象，这些对象也称为collection&nbsp;的元素。</p>\r\r<p>一些collection&nbsp;允许有重复的元素，而另一些则不允许。</p>\r\r<p>一些collection&nbsp;是有序的，而另一些则是无序的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(781, 'Collection接口常用方法 ', '781', 1531321020, 1553999867, '<p>本文记录Java学习过程中遇到的Collection接口的常用方法～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/369081835.png" style="width: 600px; height: 232px;" /></p>\r\r<p>这里我们不关心具体创建的Collection中的那个子类对象，重点是Collection接口中的方法。</p>\r\r<p>创建集合的格式：</p>\r\r<pre class="brush:java;">\rCollection&lt;元素类型&gt; 变量名= new ArrayList&lt;元素类型&gt;();\rCollection 变量名= new ArrayList();</pre>\r\r<p>方式1创建的集合，只能存储&lt;&gt;中指定的元素类型，该方式为常用方式；<br />\r方式2创建的集合，集合的元素类型默认为Object类型，即任何类型的元素都可以存储。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建集合\rCollection coll = new ArrayList();\r&nbsp;\r//1,往集合中添加对象元素。add(E e)方法，E代表创建集合时所指定的数据类型如&lt;String&gt;，那么，E就代表String类型；创建集合时若没有指定数据类型，那么，E就代表Object类型。\rcoll.add(&quot;itcast1&quot;);\rcoll.add(&quot;itcast2&quot;);\rcoll.add(&quot;itcast3&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r//把集合打印一下。\rSystem.out.println(coll); //打印结果为：[itcast1, itcast2, itcast3]\rSystem.out.println(coll.toString()); //打印结果为：[itcast1, itcast2, itcast3]\r&nbsp;\r//2,从集合中删除元素。remove(Object o)方法\rcoll.remove(&quot;itcast2&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r//删除后，集合元素为[itcast1, itcast3]\r&nbsp;\r//3,判断集合中是否包含指定元素。contains(Object o)方法\rSystem.out.println(coll.contains(&quot;itcast1&quot;));\r//打印结果为true\rSystem.out.println(coll.contains(&quot;itcast2&quot;));\r//打印结果为false\r&nbsp;&nbsp;&nbsp;&nbsp;\r//4,获取集合元素个数。size()方法\rSystem.out.println(coll.size());\r//打印结果为2\r&nbsp;\r//5,返回包含集合中所有元素的数组。toArray()方法\rString[] array = coll.toArray();\r//数组中的元素为{&quot;itcast1&quot;, &quot;itcast3&quot;}\r&nbsp;\r//6,清除集合元素。remove()方法\rcoll.clear();\r//清空后，集合元素为[]，代表没有元素</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 134),
(782, 'fangfa.png', 'fangfa-png-2', 1531352768, 1531352768, 'a:5:{s:4:"name";s:10:"fangfa.png";s:4:"path";s:34:"/usr/uploads/2018/07/369081835.png";s:4:"size";i:165149;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 781, 0),
(783, 'Iterator迭代器', '783', 1531410540, 1554000020, '<p>本文记录Java学习过程中遇到的Iterator迭代器～</p>\r<!--more-->\r\r<p>Java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</p>\r\r<p>Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断是否还有，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p>\r\r<p>集合中把这种取元素的方式描述在Iterator接口中。</p>\r\r<p>Iterator接口的常用方法如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2109148421.png" style="width: 600px; height: 134px;" /></p>\r\r<ul>\r	<li>hasNext()方法：用来判断集合中是否有下一个元素可以迭代，如果返回true，说明可以迭代。&nbsp;</li>\r	<li>next()方法：用来返回迭代的下一个元素，并把指针向后移动一位。</li>\r</ul>\r\r<p>迭代集合元素图解：&nbsp;</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4213871698.png" style="width: 600px; height: 220px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 122),
(784, 'iterator.png', 'iterator-png', 1531439378, 1531439378, 'a:5:{s:4:"name";s:12:"iterator.png";s:4:"path";s:35:"/usr/uploads/2018/07/2109148421.png";s:4:"size";i:27313;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 783, 0),
(785, 'tujie.png', 'tujie-png', 1531439528, 1531439528, 'a:5:{s:4:"name";s:9:"tujie.png";s:4:"path";s:35:"/usr/uploads/2018/07/4213871698.png";s:4:"size";i:160125;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 783, 0),
(786, 'Iterator迭代方式', '786', 1531439760, 1531439921, '<p>本文记录Java学习过程中遇到的Iterator的迭代方式～</p>\r<!--more-->\r\r<p>在Collection接口描述了一个抽象方法iterator方法，所有Collection子类都实现了这个方法，并且有自己的迭代形式。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/423557699.png" style="width: 600px; height: 51px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//1，创建集合对象。\rCollection&lt;String&gt; coll = new ArrayList&lt;String&gt;();\rcoll.add(&quot;abc1&quot;);\rcoll.add(&quot;abc2&quot;);\rcoll.add(&quot;abc3&quot;);\rcoll.add(&quot;abc4&quot;);\r&nbsp;\r//2.获取容器的迭代器对象。通过iterator方法。\rIterator it = coll.iterator();\r&nbsp;\r//3,使用具体的迭代器对象获取集合中的元素。参阅迭代器的方法\rwhile(it.hasNext()){\r&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(it.next());\r}\r&nbsp;\r/*\r迭代器for循环的形式的使用\rfor (Iterator it = coll.iterator(); it.hasNext(); ) {\r&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(it.next());\r}\r*/</pre>\r\r<p>注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(787, 'daimatixian.png', 'daimatixian-png', 1531439834, 1531439834, 'a:5:{s:4:"name";s:15:"daimatixian.png";s:4:"path";s:34:"/usr/uploads/2018/07/423557699.png";s:4:"size";i:19054;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 786, 0),
(788, '集合元素的向下转型', '788', 1531439940, 1554007159, '<p>本文记录Java学习过程中遇到的集合元素的向下转型～</p>\r<!--more-->\r\r<p>集合中可以存储任何对象，那么存放进去的数据都是还是原来类型吗？不是，提升成了Object。</p>\r\r<p>在使用集合时，我们需要注意以下几点：</p>\r\r<ul>\r	<li>集合中存储其实都是对象的地址。</li>\r	<li>集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。因为出现了基本类型包装类，它提供了自动装箱操作（基本类型&agrave;对象），这样，集合中的元素就是基本数值的包装类对象。</li>\r	<li>存储时提升了Object。取出时要使用元素的特有内容，必须向下转型。&nbsp;</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rCollection coll = new ArrayList();\rcoll.add(&quot;abc&quot;);\rcoll.add(&quot;aabbcc&quot;);\rcoll.add(&quot;shitcast&quot;);\rIterator it = coll.iterator();\rwhile (it.hasNext()) {\r//由于元素被存放进集合后全部被提升为Object类型\r//当需要使用子类对象特有方法时，需要向下转型\r&nbsp;&nbsp;&nbsp;&nbsp;String str = (String) it.next();\r&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str.length());\r}</pre>\r\r<p>注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。</p>\r\r<p>提示：Iterator接口也可以使用范型&lt;T&gt;来控制迭代元素的类型的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rCollection&lt;String&gt; coll = new ArrayList&lt;String&gt;();\rcoll.add(&quot;abc&quot;);\rcoll.add(&quot;aabbcc&quot;);\rcoll.add(&quot;shitcast&quot;);\rIterator&lt;String&gt; it = coll.iterator();\rwhile (it.hasNext()) {\r&nbsp;&nbsp;&nbsp;&nbsp;String str = it.next();\r    //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型\r&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str.length());\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(789, '增强for循环', '789', 1531440240, 1531440502, '<p>本文记录Java学习过程中遇到的增强for循环～</p>\r<!--more-->\r\r<p>增强for循环是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\rfor(元素的数据类型 变量 : Collection集合or数组){\r}</pre>\r\r<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>\r\r<p>示例代码（遍历数组）：</p>\r\r<pre class="brush:java;">\rint[] arr = new int[]{11,22,33};\rfor (int n : arr) {//变量n代表被遍历到的数组元素\r&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(n);\r}</pre>\r\r<p>示例代码（遍历集合）：</p>\r\r<pre class="brush:java;">\rCollection&lt;String&gt; coll = new ArrayList&lt;String&gt;();\rcoll.add(&quot;itcast1&quot;);\rcoll.add(&quot;itcast2&quot;);\rcoll.add(&quot;itcast3&quot;);\rcoll.add(&quot;itcast4&quot;);\rfor(String str : coll){//变量Str代表被遍历到的集合元素\r&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str);\r}</pre>\r\r<p>增强for循环和老式的for循环有什么区别？</p>\r\r<ul>\r	<li>增强for循环必须有被遍历的目标，目标只能是Collection或者是数组。</li>\r</ul>\r\r<p>建议：遍历数组时，如果仅为遍历，可以使用增强for如果要对数组的元素进行操作，使用老式for循环可以通过角标操作。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 124),
(790, '泛型的由来', '790', 1531556940, 1531557195, '<p>本文记录Java学习过程中遇到的泛型的由来～</p>\r<!--more-->\r\r<p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rList list = new ArrayList();\rlist.add(&quot;abc&quot;);\rlist.add(&quot;itcast&quot;);\rlist.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放\rIterator it = list.iterator();\rwhile(it.hasNext()){\r&nbsp;&nbsp;&nbsp;&nbsp;//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型\r&nbsp;&nbsp;&nbsp;&nbsp;String str = (String) it.next();\r&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str.length());\r}</pre>\r\r<pre class="brush:java;">\r程序在运行时发生了问题java.lang.ClassCastException\r为什么会发生类型转换异常呢？我们来分析下：\r由于集合中什么类型的元素都可以存储。导致取出时，如果出现强转就会引发运行时 ClassCastException。怎么来解决这个问题呢？使用集合时，必须明确集合中元素的类型。这种明确元素类型的方式称为泛型。</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 94),
(791, '泛型的定义与使用', '791', 1531557240, 1531558343, '<p>本文记录Java学习过程中遇到的泛型的定义和使用～</p>\r<!--more-->\r\r<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>\r\r<ul>\r	<li>含有泛型的类</li>\r</ul>\r\r<p>定义格式为：</p>\r\r<pre class="brush:java;">\r修饰符 class 类名&lt;代表泛型的变量&gt; { }</pre>\r\r<p>示例代码（API中的ArrayList集合）：</p>\r\r<pre class="brush:java;">\rclass ArrayList&lt;E&gt;{\rpublic boolean add(E&nbsp;e){ }\r&nbsp;&nbsp;&nbsp;&nbsp;public E get(int&nbsp;index){ }\r}</pre>\r\r<p>使用格式为：</p>\r\r<pre class="brush:java;">\r创建对象时，确定泛型的类型</pre>\r\r<p>示例代码（创建String类型的ArrayList）：</p>\r\r<pre class="brush:java;">\rArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); </pre>\r\r<p>此时，变量E的值就是String类型。</p>\r\r<pre class="brush:java;">\rclass ArrayList&lt;String&gt;{\rpublic boolean add(String&nbsp;e){ }\r&nbsp;&nbsp;&nbsp;&nbsp;public String get(int&nbsp;index){ }\r}</pre>\r\r<p>示例代码（创建Interger类型的ArrayList）：</p>\r\r<pre class="brush:java;">\rArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); </pre>\r\r<p>此时，变量E的值就是Integer类型。</p>\r\r<pre class="brush:java;">\rclass ArrayList&lt;Integer&gt;{\rpublic boolean add(Integer&nbsp;e){ }\r&nbsp;&nbsp;&nbsp;&nbsp;public Integer get(int&nbsp;index){ }\r}</pre>\r\r<ul>\r	<li>含有泛型的方法</li>\r</ul>\r\r<p>定义格式为：</p>\r\r<pre class="brush:java;">\r修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ }</pre>\r\r<p>示例代码（API中的ArrayList集合中的toArray方法）：</p>\r\r<pre class="brush:java;">\rpublic &lt;T&gt; T[] toArray(T[]&nbsp;a){ }\r//该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组</pre>\r\r<p>使用格式为：</p>\r\r<pre class="brush:java;">\r调用方法时，确定泛型的类型</pre>\r\r<p>示例代码（Sting类型的ArrayList调用toArray方法）：</p>\r\r<pre class="brush:java;">\rArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); \rString[] arr = new String[100]; String[] result = list.toArray(arr); </pre>\r\r<p>此时，变量T的值就是String类型。</p>\r\r<pre class="brush:java;">\rpublic &lt;String&gt; String[] toArray(String[]&nbsp;a){ }</pre>\r\r<p>示例代码（Sting类型的ArrayList调用toArray方法）：</p>\r\r<pre class="brush:java;">\rArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); \rInteger[] arr = new Integer[100]; \rInteger [] result = list.toArray(arr); </pre>\r\r<p>此时，变量T的值就是Integer类型。</p>\r\r<pre class="brush:java;">\rpublic &lt;Integer&gt; Integer[] toArray(Integer[]&nbsp;a){ }</pre>\r\r<ul>\r	<li>含有泛型的接口</li>\r</ul>\r\r<p>定义格式为：</p>\r\r<pre class="brush:java;">\r修饰符 interface接口名&lt;代表泛型的变量&gt; { }</pre>\r\r<p>示例代码（API中的Iterator迭代器接口）：</p>\r\r<pre class="brush:java;">\rpublic interface Iterator&lt;E&gt; {\r&nbsp;&nbsp;&nbsp;&nbsp;public abstract E next();\r}</pre>\r\r<p>使用格式为：</p>\r\r<p>1. 定义类时确定泛型的类型</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic final class Scanner implements Iterator&lt;String&gt; {\rpublic String next(){ }\r}</pre>\r\r<p>此时，变量E的值就是String类型。</p>\r\r<p>2.&nbsp;始终不确定泛型的类型，直到创建对象时，确定泛型的类型</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); \rIterator&lt;String&gt; it = list.iterator(); </pre>\r\r<p>此时，变量E的值就是String类型。</p>\r\r<pre class="brush:java;">\rpublic interface Iterator&lt;String&gt; {\r&nbsp;&nbsp;&nbsp;&nbsp;public abstract String next();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(793, '使用泛型的好处', '793', 1531558740, 1531559010, '<p>本文记录Java学习中遇到的泛型的好处～</p>\r<!--more-->\r\r<p>将运行时期的ClassCastException，转移到了编译时期变成了编译失败，巧妙地避免了类型强转的麻烦。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class GenericDemo {\r&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; list = new ArrayList&lt;String&gt;();\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(&quot;abc&quot;);\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(&quot;itcast&quot;);\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//list.add(5);//当集合明确类型后，存放类型不一致就会编译报错\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;String&gt; it = list.iterator();\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(it.hasNext()){\r&nbsp;&nbsp;&nbsp;&nbsp;        String str = it.next();\r            //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str.length());\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r&nbsp;&nbsp;&nbsp;&nbsp;}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(794, '泛型中的通配符', '794', 1531559100, 1531559511, '<p>本文记录Java学习过程中遇到的泛型的通配符～</p>\r<!--more-->\r\r<p>泛型是在限定数据类型，当在集合或者其他地方使用到泛型后，那么这时一旦明确泛型的数据类型，那么在使用的时候只能给其传递和数据类型匹配的类型，否则就会报错。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//定义迭代集合元素的方法 \rpublic static void printCollection(Collection&lt;Person&gt; list) {\r&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;Person&gt; it = list.iterator();\r&nbsp;&nbsp;&nbsp;&nbsp;while (it.hasNext()) {\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(it.next());\r&nbsp;&nbsp;&nbsp;&nbsp;}\r}\r//调用方法 \rCollection&lt;Student&gt; list = new ArrayList&lt;Student&gt;();\rprintCollection(list);</pre>\r\r<p>上面调用方法语句属于语法错误，因为泛型限定不一致。方法要的是Collection&lt;Person&gt;类型，传入的是Collection&lt;Student&gt;，二者类型不匹配。</p>\r\r<p>上述定义的printCollection方法中，由于定义的是打印集合的功能，应该是可以打印任意集合中元素的。但定义方法时，根本无法确定具体集合中的元素类型是什么。为了解决这个&quot;无法确定具体集合中的元素类型&quot;问题，java中，为我们提供了泛型的通配符&lt;?&gt;。</p>\r\r<p>示例代码（修改后）：</p>\r\r<pre class="brush:java;">\rpublic static void printCollection(Collection&lt;?&gt; list) {\r&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;?&gt; it = list.iterator();\r&nbsp;&nbsp;&nbsp;&nbsp;while (it.hasNext()) {\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(it.next());\r&nbsp;&nbsp;&nbsp;&nbsp;}\r}</pre>\r\r<p>总结：当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(796, '泛型限定', '796', 1531559580, 1531559915, '<p>本文记录Java学习过程中遇到的泛型的限定～</p>\r<!--more-->\r\r<p>如果想要对被打印的集合中的元素类型进行限制，只在指定的一些类型，进行打印。怎么做呢？</p>\r\r<p>要解决这个问题，我们就要学习泛型的限定。</p>\r\r<ul>\r	<li>限定泛型的上限：&nbsp;</li>\r</ul>\r\r<pre class="brush:java;">\r? extends E</pre>\r\r<p>上面的?代表接收E类型或者E的子类型的元素&nbsp;</p>\r\r<p>例如，泛型限定为：? extends Person&nbsp;则?&nbsp;代表接收Person类型或者Person子类型的元素。</p>\r\r<ul>\r	<li>限定泛型的下限：&nbsp;</li>\r</ul>\r\r<pre class="brush:java;">\r? super E</pre>\r\r<p>上面的?代表接收E类型或者E的父类型的元素&nbsp;</p>\r\r<p>例如，泛型限定为：? super Student&nbsp;则?&nbsp;代表接收Student类型或者Student父类型的元素。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(797, 'List接口', '797', 1531620480, 1531620819, '<p>本文记录Java学习过程中遇到的List接口～</p>\r<!--more-->\r\r<p>查阅API，看List的介绍。有序的collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。与set&nbsp;不同，列表通常允许重复的元素。</p>\r\r<p>看完API，我们总结一下：</p>\r\r<p>List接口：</p>\r\r<ul>\r	<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>\r	<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>\r	<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>\r</ul>\r\r<p>List接口的常用子类有：</p>\r\r<ul>\r	<li>ArrayList集合</li>\r	<li>LinkedList集合</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 102),
(798, 'List接口常用方法', '798', 1531620840, 1531621147, '<p>本文记录Java学习过程中遇到的List接口中常用的方法～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2140747698.png" style="width: 600px; height: 242px;" /></p>\r\r<p>增加元素方法：</p>\r\r<ul>\r	<li>add(Object e)：向集合末尾处，添加指定的元素</li>\r	<li>add(int index, Object e)：向集合指定索引处，添加指定的元素，原有元素依次后移</li>\r</ul>\r\r<p>删除元素方法：</p>\r\r<ul>\r	<li>remove(Object e)：将指定元素对象，从集合中删除，返回值为被删除的元素</li>\r	<li>remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素</li>\r</ul>\r\r<p>替换元素方法：</p>\r\r<ul>\r	<li>set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素</li>\r</ul>\r\r<p>查询元素方法：</p>\r\r<ul>\r	<li>get(int index)：获取指定索引处的元素，并返回该元素</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rList&lt;String&gt; list = new ArrayList&lt;String&gt;();\r//1,添加元素。\rlist.add(&quot;小红&quot;);\rlist.add(&quot;小梅&quot;);\rlist.add(&quot;小强&quot;);\r//2,插入元素。插入元素前的集合[&quot;小红&quot;,&quot;小梅&quot;,&quot;小强&quot;]\rlist.add(1, &quot;老王&quot;); //插入元素后的集合[&quot;小红&quot;,&quot;老王&quot;,&quot;小梅&quot;,&quot;小强&quot;]\r//3,删除元素。\rlist.remove(2);// 删除元素后的集合[&quot;小红&quot;,&quot;老王&quot;,&quot;小强&quot;]\r//4,修改元素。\rlist.set(1, &quot;隔壁老王&quot;);// 修改元素后的集合[&quot;小红&quot;,&quot;隔壁老王&quot;,&quot;小强&quot;]\r\rIterator&lt;String&gt; it = list.iterator();\rwhile (it.hasNext()) {\r	String str = it.next();\r	System.out.println(str);\r}</pre>\r\r<p>由于List集合拥有索引，因此List集合迭代方式除了使用迭代器之外，还可以使用索引进行迭代。</p>\r\r<pre class="brush:java;">\rfor (int i = 0; i &lt; list.size(); i++) {\r	String str = list.get(i);\r	System.out.println(str);			\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 125),
(799, 'list.png', 'list-png', 1531620921, 1531620921, 'a:5:{s:4:"name";s:8:"list.png";s:4:"path";s:35:"/usr/uploads/2018/07/2140747698.png";s:4:"size";i:58845;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 798, 0),
(800, 'Iterator的并发修改异常', '800', 1531626300, 1531626455, '<p>本文记录Java学习过程中遇到的Iterator迭代器的并发修改异常～</p>\r<!--more-->\r\r<p>在list集合迭代元素中，对元素进行判断，一旦条件满足就添加一个新元素。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建List集合\rList&lt;String&gt; list = new ArrayList&lt;String&gt;();\r//给集合中添加元素\rlist.add(&quot;abc1&quot;);\rlist.add(&quot;abc2&quot;);\rlist.add(&quot;abc3&quot;);\rlist.add(&quot;abc4&quot;);\r//迭代集合，当有元素为&quot;abc2&quot;时，集合加入新元素&quot;itcast&quot;\rIterator&lt;String&gt; it = list.iterator();\rwhile(it.hasNext()){\r	String str = it.next();\r	//判断取出的元素是否是&quot;abc2&quot;，是就添加一个新元素\r	if(&quot;abc2&quot;.equals(str)){\r		list.add(&quot;itcast&quot;);// 该操作会导致程序出错\r	}\r}\r//打印容器中的元素\rSystem.out.println(list);</pre>\r\r<p>运行上述代码发生了错误java.util.ConcurrentModificationException，这是什么原因呢？</p>\r\r<p>在迭代过程中，使用了集合的方法对元素进行操作。导致迭代器并不知道集合中的变化，容易引发数据的不确定性。</p>\r\r<p>并发修改异常解决办法：在迭代时，不要使用集合的方法操作元素。</p>\r\r<p>那么想要在迭代时对元素操作咋办？通过ListIterator迭代器操作元素是可以的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 144),
(801, 'List集合的数据结构', '801', 1531626540, 1531627013, '<p>本文记录Java学习过程中遇到的List集合的存储数据的结构～</p>\r<!--more-->\r\r<p>List接口下有很多个集合，它们存储元素所采用的结构方式是不同的，这样就导致了这些集合有它们各自的特点，供给我们在不同的环境下进行使用。数据存储的常用结构有：堆栈、队列、数组、链表。</p>\r\r<p>我们分别来了解一下：</p>\r\r<p>1. 堆栈，采用该结构的集合，对元素的存取有如下的特点：</p>\r\r<ul>\r	<li>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</li>\r	<li>栈的入口、出口的都是栈的顶端位置</li>\r	<li>压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>\r	<li>弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3072079505.png" style="width: 600px; height: 627px;" /></p>\r\r<p>2. 队列，采用该结构的集合，对元素的存取有如下的特点：</p>\r\r<ul>\r	<li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，安检。排成一列，每个人依次检查，只有前面的人全部检查完毕后，才能排到当前的人进行检查。</li>\r	<li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/803247204.png" style="width: 600px; height: 541px;" /></p>\r\r<p>3. 数组，采用该结构的集合，对元素的存取有如下的特点：</p>\r\r<ul>\r	<li>查找元素快：通过索引，可以快速访问指定位置的元素</li>\r	<li>增删元素慢：</li>\r</ul>\r\r<ol>\r	<li>指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图</li>\r	<li>指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。</li>\r</ol>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1984597127.png" style="width: 600px; height: 650px;" /></p>\r\r<p>4. 链表，采用该结构的集合，对元素的存取有如下的特点：</p>\r\r<ul>\r	<li>多个节点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</li>\r	<li>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</li>\r	<li>增删元素快：</li>\r</ul>\r\r<ol>\r	<li>增加元素：操作如下图，只需要修改连接下个元素的地址即可。</li>\r	<li>删除元素：操作如下图，只需要修改连接下个元素的地址即可。</li>\r</ol>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4189819441.png" style="width: 600px; height: 459px;" /></p>\r\r<p>&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(802, 'zhan.png', 'zhan-png', 1531626678, 1531626678, 'a:5:{s:4:"name";s:8:"zhan.png";s:4:"path";s:35:"/usr/uploads/2018/07/3072079505.png";s:4:"size";i:38122;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 801, 0),
(803, 'queue.png', 'queue-png', 1531626757, 1531626757, 'a:5:{s:4:"name";s:9:"queue.png";s:4:"path";s:34:"/usr/uploads/2018/07/803247204.png";s:4:"size";i:32773;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 801, 0),
(804, 'array.png', 'array-png-1', 1531626877, 1531626877, 'a:5:{s:4:"name";s:9:"array.png";s:4:"path";s:35:"/usr/uploads/2018/07/1984597127.png";s:4:"size";i:68776;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 801, 0),
(805, 'linkedlist.png', 'linkedlist-png', 1531626987, 1531626987, 'a:5:{s:4:"name";s:14:"linkedlist.png";s:4:"path";s:35:"/usr/uploads/2018/07/4189819441.png";s:4:"size";i:133134;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 801, 0),
(806, 'ArrayList集合', '806', 1531627119, 1531627119, '<p>本文记录Java学习过程中遇到的ArrayList集合～</p>\r\r<!--more-->\r\r<p>ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</p>\r\r<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 94),
(807, 'LinkedList集合', '807', 1531627140, 1531627385, '<p>本文记录Java学习过程中遇到的LinkedList集合～</p>\r<!--more-->\r\r<p>LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2246207014.png" style="width: 800px; height: 658px;" /></p>\r\r<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rLinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();\r//添加元素\rlink.addFirst(&quot;abc1&quot;);\rlink.addFirst(&quot;abc2&quot;);\rlink.addFirst(&quot;abc3&quot;);\r//获取元素\rSystem.out.println(link.getFirst());\rSystem.out.println(link.getLast());\r//删除元素\rSystem.out.println(link.removeFirst());\rSystem.out.println(link.removeLast());\r\rwhile(!link.isEmpty()){ //判断集合是否为空\r	System.out.println(link.pop()); //弹出集合中的栈顶元素\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 117),
(808, 'LinkedList.png', 'LinkedList-png-1', 1531627277, 1531627277, 'a:5:{s:4:"name";s:14:"LinkedList.png";s:4:"path";s:35:"/usr/uploads/2018/07/2246207014.png";s:4:"size";i:86985;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 807, 0),
(809, 'Vector集合', '809', 1531627500, 1531627788, '<p>本文记录Java学习过程中遇到的Vector集合～</p>\r<!--more-->\r\r<p>Vector集合数据存储的结构是数组结构，为JDK中最早提供的集合。Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。此接口Enumeration的功能与Iterator&nbsp;接口的功能是类似的。Vector集合已被ArrayList替代。枚举Enumeration已被迭代器Iterator替代。</p>\r\r<p>Vector常见的方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/955897842.png" style="width: 800px; height: 194px;" /></p>\r\r<p>Enumeration枚举常见的方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/402777478.png" style="width: 800px; height: 113px;" /></p>\r\r<p>Vector集合对ArrayList集合使用的对比：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1838510468.png" style="width: 800px; height: 281px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(810, 'vector-function.png', 'vector-function-png', 1531627611, 1531627611, 'a:5:{s:4:"name";s:19:"vector-function.png";s:4:"path";s:34:"/usr/uploads/2018/07/955897842.png";s:4:"size";i:34564;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 809, 0),
(811, 'Enumeration-function.png', 'Enumeration-function-png', 1531627692, 1531627692, 'a:5:{s:4:"name";s:24:"Enumeration-function.png";s:4:"path";s:34:"/usr/uploads/2018/07/402777478.png";s:4:"size";i:22314;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 809, 0),
(812, 'compare.png', 'compare-png-1', 1531627762, 1531627762, 'a:5:{s:4:"name";s:11:"compare.png";s:4:"path";s:35:"/usr/uploads/2018/07/1838510468.png";s:4:"size";i:117518;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 809, 0),
(813, 'Set接口', '813', 1531640940, 1531641006, '<p>本文记录Java学习过程中遇到的Set接口～</p>\r<!--more-->\r\r<p>学习Collection接口时，记得Collection中可以存放重复元素，也可以不存放重复元素，那么我们知道List中是可以存放重复元素的。那么不重复元素给哪里存放呢？那就是Set接口，它里面的集合，所存储的元素就是不重复的。</p>\r\r<p>查阅Set集合的API介绍，通过元素的equals方法，来判断是否为重复元素。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(814, 'HashSet集合', '814', 1531641060, 1531641093, '<p>本文记录Java学习过程中遇到的HashSet集合～</p>\r<!--more-->\r\r<p>查阅HashSet集合的API介绍：此类实现Set接口，由哈希表支持（实际上是一个HashMap集合）。HashSet集合不能保证的迭代顺序与元素存储顺序相同。</p>\r\r<p>HashSet集合，采用哈希表结构存储数据，保证元素唯一性的方式依赖于：hashCode()与equals()方法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(815, 'HashSet集合的数据结构', '815', 1531641120, 1531641265, '<p>本文记录Java学习过程中遇到的HashSet集合存储数据的结构～</p>\r<!--more-->\r\r<p>HashSet集合底层使用的数据结构是哈希表，那么什么是哈希表呢？</p>\r\r<p>哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表。</p>\r\r<p>当向哈希表中存放元素时，需要根据元素的特有数据结合相应的算法，这个算法其实就是Object类中的hashCode方法。由于任何对象都是Object类的子类，所以任何对象有拥有这个方法。即就是在给哈希表中存放对象时，会调用对象的hashCode方法，算出对象在表中的存放位置，这里需要注意，如果两个对象hashCode方法算出结果一样，这样现象称为哈希冲突，这时会调用对象的equals方法，比较这两个对象是不是同一个对象，如果equals方法返回的是true，那么就不会把第二个对象存放在哈希表中，如果返回的是false，就会把这个值存放在哈希表中。</p>\r\r<p>总结：保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2201580486.png" style="width: 800px; height: 380px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 102),
(816, 'hashset.png', 'hashset-png', 1531641242, 1531641242, 'a:5:{s:4:"name";s:11:"hashset.png";s:4:"path";s:35:"/usr/uploads/2018/07/2201580486.png";s:4:"size";i:148289;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 815, 0),
(817, 'HashSet存储JavaAPI中的类型元素', '817', 1531641420, 1531641578, '<p>本文记录Java学习过程中遇到的使用HashSet存储JavaAPI中的类型元素～</p>\r<!--more-->\r\r<p>给HashSet中存储JavaAPI中提供的类型元素时，不需要重写元素的hashCode和equals方法，因为这两个方法，在JavaAPI的每个类中已经重写完毕，如String类、Integer类等。</p>\r\r<p>示例代码（创建HashSet集合，存储String对象）：</p>\r\r<pre class="brush:java;">\r//创建HashSet对象\rHashSet&lt;String&gt; hs = new HashSet&lt;String&gt;();\r//给集合中添加自定义对象\rhs.add(&quot;zhangsan&quot;);\rhs.add(&quot;lisi&quot;);\rhs.add(&quot;wangwu&quot;);\rhs.add(&quot;zhangsan&quot;);\r//取出集合中的每个元素\rIterator&lt;String&gt; it = hs.iterator();\rwhile(it.hasNext()){\r	String s = it.next();\r	System.out.println(s);\r}</pre>\r\r<p>输出结果如下，说明集合中不能存储重复元素：</p>\r\r<pre class="brush:java;">\rwangwu\rlisi\rzhangsan</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(818, 'HashSet存储自定义类型元素', '818', 1531641660, 1531641882, '<p>本文记录Java学习过程中遇到的使用HashSet存储自定义类型元素～</p>\r<!--more-->\r\r<p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p>\r\r<p>示例代码（自定义对象Student）：</p>\r\r<pre class="brush:java;">\rpublic class Student {\r	private String name;\r	private int age;\r	public Student(String name, int age) {\r		super();\r		this.name = name;\r		this.age = age;\r	}\r	public String getName() {\r		return name;\r	}\r	public void setName(String name) {\r		this.name = name;\r	}\r	public int getAge() {\r		return age;\r	}\r	public void setAge(int age) {\r		this.age = age;\r	}\r	@Override\r	public String toString() {\r		return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;\r	}\r	@Override\r	public int hashCode() {\r		final int prime = 31;\r		int result = 1;\r		result = prime * result + age;\r		result = prime * result + ((name == null) ? 0 : name.hashCode());\r		return result;\r	}\r	@Override\r	public boolean equals(Object obj) {\r		if (this == obj)\r			return true;\r		if(!(obj instanceof Student)){\r			System.out.println(&quot;类型错误&quot;);\r			return false;\r		}\r		Student other = (Student) obj;\r		return this.age ==  other.age &amp;&amp; this.name.equals(other.name);\r	}\r}</pre>\r\r<p>示例代码（使用HashSet集合存储Student对象）：</p>\r\r<pre class="brush:java;">\r//创建HashSet对象\rHashSet hs = new HashSet();\r//给集合中添加自定义对象\rhs.add(new Student(&quot;zhangsan&quot;,21));\rhs.add(new Student(&quot;lisi&quot;,22));\rhs.add(new Student(&quot;wangwu&quot;,23));\rhs.add(new Student(&quot;zhangsan&quot;,21));\r//取出集合中的每个元素\rIterator it = hs.iterator();\rwhile(it.hasNext()){\r	Student s = (Student)it.next();\r	System.out.println(s);\r}</pre>\r\r<p>输出结果如下，说明集合中不能存储重复元素：</p>\r\r<pre class="brush:java;">\rStudent [name=lisi, age=22]\rStudent [name=zhangsan, age=21]\rStudent [name=wangwu, age=23]</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 157),
(819, 'LinkedHashSet集合', '819', 1531642080, 1531642217, '<p>本文记录Java学习过程中遇到的LinkedHashSet集合～</p>\r<!--more-->\r\r<p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p>\r\r<p>在HashSet下面有一个子类LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rSet&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();\rset.add(&quot;bbb&quot;);\rset.add(&quot;aaa&quot;);\rset.add(&quot;abc&quot;);\rset.add(&quot;bbc&quot;);\rIterator it = set.iterator();\rwhile (it.hasNext()) {\r	System.out.println(it.next());\r}</pre>\r\r<p>输出结果如下，LinkedHashSet集合保证元素的存入和取出的顺序：</p>\r\r<pre class="brush:java;">\rbbb\raaa\rabc\rbbc</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(820, '判断集合元素唯一的原理', '820', 1531650300, 1531650587, '<p>本文记录Java学习过程中遇到的判断集合元素唯一的原理～</p>\r<!--more-->\r\r<ul>\r	<li>ArrayList的contains方法</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2223135462.png" style="width: 800px; height: 84px;" /></p>\r\r<p>ArrayList的contains方法会使用调用方法时，传入的元素的equals方法依次与集合中的旧元素所比较，从而根据返回的布尔值判断是否有重复元素。此时，当ArrayList存放自定义类型时，由于自定义类型在未重写equals方法前，判断是否重复的依据是地址值，所以如果想根据内容判断是否为重复元素，需要重写元素的equals方法。</p>\r\r<p>HashSet的add/contains等方法</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3337286604.png" style="width: 800px; height: 142px;" /></p>\r\r<p>Set集合不能存放重复元素，其添加方法在添加时会判断是否有重复元素，有重复不添加，没重复则添加。</p>\r\r<p>HashSet集合由于是无序的，其判断唯一的依据是元素类型的hashCode与equals方法的返回结果。规则如下：</p>\r\r<p>先判断新元素与集合内已经有的旧元素的HashCode值</p>\r\r<ul>\r	<li>如果不同，说明是不同元素，添加到集合。</li>\r	<li>如果相同，再判断equals比较结果。返回true则相同元素；返回false则不同元素，添加到集合。</li>\r</ul>\r\r<p>所以，使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，则判断重复时，使用的是地址值，如果想通过内容比较元素是否相同，需要重写该元素类的hashcode与equals方法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 161),
(821, 'arraylist.png', 'arraylist-png', 1531650427, 1531650427, 'a:5:{s:4:"name";s:13:"arraylist.png";s:4:"path";s:35:"/usr/uploads/2018/07/2223135462.png";s:4:"size";i:13345;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 820, 0),
(822, 'hashset.png', 'hashset-png-1', 1531650541, 1531650541, 'a:5:{s:4:"name";s:11:"hashset.png";s:4:"path";s:35:"/usr/uploads/2018/07/3337286604.png";s:4:"size";i:25419;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 820, 0),
(823, 'Map接口', '823', 1531754220, 1554008288, '<p>本文记录Java学习过程中遇到的Map接口～</p>\r<!--more-->\r\r<p>我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同。</p>\r\r<ul>\r	<li>Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储；</li>\r	<li>Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值；</li>\r	<li>Collection中的集合称为单列集合，Map中的集合称为双列集合；</li>\r	<li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值；</li>\r	<li>Map中常用的集合为HashMap集合、LinkedHashMap集合。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2443837852.png" style="width: 800px; height: 343px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(825, 'map.png', 'map-png', 1531787098, 1531787098, 'a:5:{s:4:"name";s:7:"map.png";s:4:"path";s:35:"/usr/uploads/2018/07/2443837852.png";s:4:"size";i:71207;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 823, 0),
(826, 'Map接口常用集合', '826', 1531787280, 1531787378, '<p>本文记录Java学习过程中遇到的Map接口中的常用集合～</p>\r<!--more-->\r\r<p>通过查看Map接口的API描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p>\r\r<ul>\r	<li>HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>\r	<li>LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>\r	<li>注意：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(827, 'Map接口常用方法', '827', 1531787520, 1531788068, '<p>本文记录Java学习过程中遇到的Map接口中的常用方法～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1781056921.png" style="width: 800px; height: 189px;" /></p>\r\r<p>1. put方法：将指定的键与值对应起来，并添加到集合中，方法返回值为键所对应的值</p>\r\r<ul>\r	<li>使用方法时，若指定的键在集合中没有，则没有这个键对应的值，返回，并把指定的键值添加到集合中；</li>\r	<li>使用put方法时，若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</li>\r</ul>\r\r<p>2. get方法：获取指定键(key)所对应的值(value)</p>\r\r<p>3. remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value)。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建Map对象\rMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();\r//给map中添加元素\rmap.put(&quot;星期一&quot;, &quot;Monday&quot;);\rmap.put(&quot;星期日&quot;, &quot;Sunday&quot;);\rSystem.out.println(map); // {星期日=Sunday, 星期一=Monday}\r\r//当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null\rSystem.out.println(map.put(&quot;星期一&quot;, &quot;Mon&quot;)); // Monday\rSystem.out.println(map); // {星期日=Sunday, 星期一=Mon}\r\r//根据指定的key获取对应的value\rString en = map.get(&quot;星期日&quot;);\rSystem.out.println(en); // Sunday\r		\r//根据key删除元素,会返回key对应的value值\rString value = map.remove(&quot;星期日&quot;);\rSystem.out.println(value); // Sunday\rSystem.out.println(map); // {星期一=Mon}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(828, 'map.png', 'map-png-1', 1531787802, 1531787802, 'a:5:{s:4:"name";s:7:"map.png";s:4:"path";s:35:"/usr/uploads/2018/07/1781056921.png";s:4:"size";i:57102;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 827, 0),
(829, 'Map集合遍历方式（一）', '829', 1531788300, 1532012199, '<p>本文记录Java学习过程中遇到的Map集合的遍历方式～</p>\r<!--more-->\r\r<p>键找值方式：即通过元素中的键，获取键所对应的值。</p>\r\r<p>操作步骤与图解：</p>\r\r<p>1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2537919308.png" style="width: 800px; height: 83px;" /></p>\r\r<p>2.遍历键的Set集合，得到每一个键</p>\r\r<p>3.根据键，获取键所对应的值</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1915432426.png" style="width: 800px; height: 704px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建Map对象\rMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();\r//给map中添加元素\rmap.put(&quot;邓超&quot;, &quot;孙俪&quot;);\rmap.put(&quot;李晨&quot;, &quot;范冰冰&quot;);\rmap.put(&quot;刘德华&quot;, &quot;柳岩&quot;);\r//获取Map中的所有key\rSet&lt;String&gt; keySet = map.keySet();\r//遍历存放所有key的Set集合\rIterator&lt;String&gt; it =keySet.iterator();\rwhile(it.hasNext()){\r	//得到每一个key\r	String key = it.next();\r	//通过key获取对应的value\r	String value = map.get(key);\r	System.out.println(key+&quot;=&quot;+value);\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(831, 'keyset.png', 'keyset-png', 1531788417, 1531788417, 'a:5:{s:4:"name";s:10:"keyset.png";s:4:"path";s:35:"/usr/uploads/2018/07/2537919308.png";s:4:"size";i:16229;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 829, 0),
(832, 'fangshi01.png', 'fangshi01-png', 1531788512, 1531788512, 'a:5:{s:4:"name";s:13:"fangshi01.png";s:4:"path";s:35:"/usr/uploads/2018/07/1915432426.png";s:4:"size";i:140386;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 829, 0),
(833, 'Entry键值对', '833', 1531788720, 1531789096, '<p>本文记录Java学习过程中遇到的Entry键值对对象～</p>\r<!--more-->\r\r<p>在Map类设计时，提供了一个嵌套接口：Entry。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1124624621.png" style="width: 800px; height: 171px;" /></p>\r\r<p>Entry是Map接口中提供的一个静态内部嵌套接口。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/172675926.png" style="width: 800px; height: 237px;" /></p>\r\r<ul>\r	<li>getKey()方法：获取Entry对象中的键</li>\r	<li>getValue()方法：获取Entry对象中的值</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3475342007.png" style="width: 800px; height: 172px;" /></p>\r\r<ul>\r	<li>entrySet()方法：用于返回Map集合中所有的键值对(Entry)对象，以Set集合形式返回。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 151),
(835, 'interface.png', 'interface-png', 1531788910, 1531788910, 'a:5:{s:4:"name";s:13:"interface.png";s:4:"path";s:35:"/usr/uploads/2018/07/1124624621.png";s:4:"size";i:38182;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 833, 0),
(836, 'map-entry.png', 'map-entry-png', 1531788966, 1531788966, 'a:5:{s:4:"name";s:13:"map-entry.png";s:4:"path";s:34:"/usr/uploads/2018/07/172675926.png";s:4:"size";i:45298;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 833, 0),
(837, 'map-kv.png', 'map-kv-png', 1531789060, 1531789060, 'a:5:{s:4:"name";s:10:"map-kv.png";s:4:"path";s:35:"/usr/uploads/2018/07/3475342007.png";s:4:"size";i:41206;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 833, 0),
(839, 'Map集合遍历方式（二）', '839', 1532012220, 1532012706, '<p>本文记录Java学习过程中遇到的Map集合的遍历键值对的方式～</p>\r<!--more-->\r\r<p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>\r\r<p>操作步骤与图解：</p>\r\r<p>1.获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回；</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2700794487.png" style="width: 800px; height: 79px;" /></p>\r\r<p>2.遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象；</p>\r\r<p>3.通过键值对(Entry)对象，获取Entry对象中的键与值。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4073651008.png" style="width: 800px; height: 143px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3188056373.png" style="width: 800px; height: 756px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建Map对象\rMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();\r//给map中添加元素\rmap.put(&quot;邓超&quot;, &quot;孙俪&quot;);\rmap.put(&quot;李晨&quot;, &quot;范冰冰&quot;);\rmap.put(&quot;刘德华&quot;, &quot;柳岩&quot;);\r//获取Map中的所有key与value的对应关系\rSet&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();\r//遍历Set集合\rIterator&lt;Map.Entry&lt;String,String&gt;&gt; it =entrySet.iterator();\rwhile(it.hasNext()){\r	//得到每一对对应关系\r	Map.Entry&lt;String,String&gt; entry = it.next();\r	//通过每一对对应关系获取对应的key\r	String key = entry.getKey();\r	//通过每一对对应关系获取对应的value\r	String value = entry.getValue();\r	System.out.println(key+&quot;=&quot;+value);\r}</pre>\r\r<p>注意：Map集合不能直接使用迭代器或者foreach进行遍历，但是转成Set之后就可以使用了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(840, 'bianli01.png', 'bianli01-png', 1532012426, 1532012426, 'a:5:{s:4:"name";s:12:"bianli01.png";s:4:"path";s:35:"/usr/uploads/2018/07/2700794487.png";s:4:"size";i:21523;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 839, 0),
(841, 'bianli02.png', 'bianli02-png', 1532012520, 1532012520, 'a:5:{s:4:"name";s:12:"bianli02.png";s:4:"path";s:35:"/usr/uploads/2018/07/4073651008.png";s:4:"size";i:22241;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 839, 0),
(842, 'bianli03.png', 'bianli03-png', 1532012581, 1532012581, 'a:5:{s:4:"name";s:12:"bianli03.png";s:4:"path";s:35:"/usr/uploads/2018/07/3188056373.png";s:4:"size";i:165186;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 839, 0),
(843, '使用HashMap存储自定义类型键值', '843', 1532014200, 1532014374, '<p>本文记录Java学习过程中遇到的使用HashMap存储自定义类型的键值对～</p>\r<!--more-->\r\r<p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键,&nbsp;家庭住址作为值。</p>\r\r<p>注意，学生姓名相同并且年龄相同视为同一名学生。</p>\r\r<p>示例代码（学生类）：</p>\r\r<pre class="brush:java;">\rpublic class Student {\r	private String name;\r	private int age;\r\r	//编写构造方法，这里省略\r	//编写get,set方法，这里省略\r	//编写toString方法，这里省略\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\rpublic class HashMapTest {\r	public static void main(String[] args) {\r		//1,创建hashmap集合对象。\r		Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;();\r		\r		//2,添加元素。\r		map.put(new Student(&quot;lisi&quot;,28), &quot;上海&quot;);\r		map.put(new Student(&quot;wangwu&quot;,22), &quot;北京&quot;);\r		map.put(new Student(&quot;zhaoliu&quot;,24), &quot;成都&quot;);\r		map.put(new Student(&quot;zhouqi&quot;,25), &quot;广州&quot;);\r		map.put(new Student(&quot;wangwu&quot;,22), &quot;南京&quot;);\r		\r		//3,取出元素。键找值方式\r		Set&lt;Student&gt; keySet = map.keySet();\r		for(Student key : keySet){\r			String value = map.get(key);\r			System.out.println(key.toString()+&quot;.....&quot;+value);\r		}\r		\r		//取出元素。键值对方式\r		Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet();\r		for (Map.Entry&lt;Student, String&gt; entry : entrySet) {\r			Student key = entry.getKey();\r			String value = entry.getValue();\r			System.out.println(key.toString()+&quot;.....&quot;+value);\r		}\r	}\r}</pre>\r\r<ul>\r	<li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li>\r	<li>如果要保证map中存放的key和取出的顺序一致，可以使用LinkedHashMap集合来存放。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 248),
(844, '静态导入', '844', 1532014440, 1532015100, '<p>本文记录Java学习过程中遇到的静态导入～</p>\r<!--more-->\r\r<p>在导包的过程中我们可以直接导入静态部分，这样某个类的静态成员就可以直接使用了。在源码中经常会出现静态导入。</p>\r\r<p>静态导入格式：</p>\r\r<pre class="brush:java;">\rimport static XXX.YYY;   导入后YYY可直接使用。 </pre>\r\r<p>示例代码（Map.Entry的访问，简化后为Entry）：</p>\r\r<pre class="brush:java;">\rimport static java.util.Map.Entry;\rpublic class HashMapTest {\r	public static void main(String[] args) {\r		//1,创建hashmap集合对象。\r		Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;();\r\r		//取出元素。键值对方式\r		//Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet();\r		Set&lt;Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet();\r\r		//for (Map.Entry&lt;Student, String&gt; entry : entrySet) {\r		for (Entry&lt;Student, String&gt; entry : entrySet) {\r			Student key = entry.getKey();\r			String value = entry.getValue();\r			System.out.println(key.toString()+&quot;.....&quot;+value);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(845, '可变参数', '845', 1532137080, 1532137301, '<p>本文记录Java学习过程中遇到的可变参数～</p>\r<!--more-->\r\r<p>在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>\r\r<pre class="brush:java;">\r修饰符 返回值类型 方法名(参数类型... 形参名){  }</pre>\r\r<p>其实这个书写完全等价于：</p>\r\r<pre class="brush:java;">\r修饰符 返回值类型 方法名(参数类型[] 形参名){  }</pre>\r\r<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>\r\r<p>jdk1.5以后。出现了简化操作。...用在参数上，称之为可变参数。</p>\r\r<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ParamDemo {\r	public static void main(String[] args) {\r		int[] arr = {21,89,32};\r		int sum = add(arr);\r		System.out.println(sum);\r		sum = add(21,89,32);//可变参数调用形式\r		System.out.println(sum);\r		\r	}\r\r	//JDK1.5之后写法\r	public static int add(int...arr){\r		int sum = 0;\r		for (int i = 0; i &lt; arr.length; i++) {\r			sum += arr[i];\r		}\r		return sum;\r	}\r\r	//原始写法\r	/*\r	public static int add(int[] arr) {\r		int sum = 0;\r		for (int i = 0; i &lt; arr.length; i++) {\r			sum += arr[i];\r		}\r		return sum;\r	}\r	*/\r}</pre>\r\r<ul>\r	<li>上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</li>\r</ul>\r\r<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(846, 'Collections集合工具类', '846', 1532137380, 1532137570, '<p>本文记录Java学习过程中的Collections集合工具类～</p>\r<!--more-->\r\r<p>Collections是集合工具类，用来对集合进行操作。</p>\r\r<p>部分方法如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2844023611.png" style="width: 800px; height: 117px;" /></p>\r\r<ul>\r	<li>public static &lt;T&gt; void sort(List&lt;T&gt; list) //&nbsp;集合元素排序</li>\r</ul>\r\r<pre class="brush:java;">\r//排序前元素list集合元素 [33,11,77,55]\rCollections.sort( list );\r//排序后元素list集合元素 [11,33,55,77]</pre>\r\r<ul>\r	<li>public static void shuffle(List&lt;?&gt; list) //&nbsp;&nbsp;集合元素存储位置打乱</li>\r</ul>\r\r<pre class="brush:java;">\r//list集合元素 [11,33,55,77]\rCollections.shuffle( list );\r//使用shuffle方法后，集合中的元素为[77,33,11,55]，每次执行该方法，集合中存储的元素位置都会随机打乱</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 92),
(847, 'collections.png', 'collections-png', 1532137459, 1532137459, 'a:5:{s:4:"name";s:15:"collections.png";s:4:"path";s:35:"/usr/uploads/2018/07/2844023611.png";s:4:"size";i:31828;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 846, 0),
(848, '集合嵌套', '848', 1532139660, 1532139817, '<p>本文记录Java学习过程中遇到的集合嵌套～</p>\r<!--more-->\r\r<p>集合嵌套并不是一个新的知识点，仅仅是集合内容又是集合，如Collection集合嵌套、Collection集合与Map集合相互嵌套、Map集合嵌套。</p>\r\r<ul>\r	<li>ArrayList嵌套ArrayList</li>\r</ul>\r\r<pre class="brush:java;">\rArrayList&lt; ArrayList&lt;String&gt; &gt;\rCollection&lt; ArrayList&lt;Integer&gt; &gt;</pre>\r\r<ul>\r	<li>Map嵌套ArrayList</li>\r</ul>\r\r<pre class="brush:java;">\rHashMap&lt;String, ArrayList&lt;Person&gt;&gt;\rArrayList&lt; HashMap&lt;String, String&gt;&gt;</pre>\r\r<ul>\r	<li>Map集合嵌套</li>\r</ul>\r\r<pre class="brush:java;">\rHashMap&lt;String, HashMap&lt;String,String&gt;&gt;\rHashMap&lt;String, HashMap&lt;Person,String&gt;&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(849, '集合继承体系的面向对象思想', '849', 1532139840, 1532139982, '<p>本文记录Java学习过程中遇到的集合继承体系的面向对象思想～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/955334500.png" style="width: 800px; height: 346px;" /></p>\r\r<ul>\r	<li>接口：用来明确所有集合中该具有的功能，相当于在定义集合功能标准；</li>\r	<li>抽象类：把多个集合中功能实现方式相同的方法，抽取到抽象类实现，具体集合不再遍写，继承使用即可；</li>\r	<li>具体类：继承抽象类，实现接口，重写所有抽象方法，达到具备指定功能的集合。每个具体集合类，根据自身的数据存储结构方式，对接口中的功能方法，进行不同方式的实现。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(850, 'object-oriented.png', 'object-oriented-png', 1532139930, 1532139930, 'a:5:{s:4:"name";s:19:"object-oriented.png";s:4:"path";s:34:"/usr/uploads/2018/07/955334500.png";s:4:"size";i:77489;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 849, 0),
(851, '异常', '851', 1532174640, 1532174680, '<p>本文记录Java学习过程中遇到的异常～</p>\r<!--more-->\r\r<p>什么是异常？Java代码在运行时期发生的问题就是异常。</p>\r\r<p>在Java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 91),
(852, '异常的继承体系', '852', 1532174700, 1532175078, '<p>本文记录Java学习过程中遇到的异常的继承体系～</p>\r<!--more-->\r\r<p>在Java中使用Exception类来描述异常。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3669039007.png" style="width: 800px; height: 103px;" /></p>\r\r<p>查看API中Exception的描述，Exception&nbsp;类及其子类是Throwable&nbsp;的一种形式，它用来表示java程序中可能会产生的异常，并要求对产生的异常进行合理的异常处理。</p>\r\r<p>继续观察，我们可以发现Exception有继承关系，它的父类是Throwable。Throwable是Java&nbsp;语言中所有错误或异常的超类，即祖宗类。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3745979647.png" style="width: 800px; height: 349px;" /></p>\r\r<p>另外，在异常Exception类中，有一个子类要特殊说明一下，RuntimeException子类，RuntimeException及其它的子类只能在Java程序运行过程中出现。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2015463877.png" style="width: 800px; height: 118px;" /></p>\r\r<p>我们再来观察Throwable类，能够发现与异常Exception平级的有一个Error，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误。解决办法只有一个，修改代码避免Error错误的产生。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1135746532.png" style="width: 800px; height: 111px;" /></p>\r\r<p>异常继承体系总结：</p>\r\r<pre class="brush:java;">\rThrowable: 它是所有错误与异常的超类（祖宗类）\r		|- Error 错误\r		|- Exception 编译期异常,进行编译JAVA程序时出现的问题\r			|- RuntimeException 运行期异常, JAVA程序运行过程中出现的问题</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(853, 'jicheng01.png', 'jicheng01-png', 1532174802, 1532174802, 'a:5:{s:4:"name";s:13:"jicheng01.png";s:4:"path";s:35:"/usr/uploads/2018/07/3669039007.png";s:4:"size";i:16114;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 852, 0),
(854, 'jicheng02.png', 'jicheng02-png', 1532174885, 1532174885, 'a:5:{s:4:"name";s:13:"jicheng02.png";s:4:"path";s:35:"/usr/uploads/2018/07/3745979647.png";s:4:"size";i:59363;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 852, 0),
(855, 'jicheng03.png', 'jicheng03-png', 1532174947, 1532174947, 'a:5:{s:4:"name";s:13:"jicheng03.png";s:4:"path";s:35:"/usr/uploads/2018/07/2015463877.png";s:4:"size";i:18617;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 852, 0),
(856, 'jicheng04.png', 'jicheng04-png', 1532175013, 1532175013, 'a:5:{s:4:"name";s:13:"jicheng04.png";s:4:"path";s:35:"/usr/uploads/2018/07/1135746532.png";s:4:"size";i:16777;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 852, 0),
(857, '异常与错误的区别', '857', 1532175120, 1532175533, '<p>本文记录Java学习过程中遇到的异常与错误的区别～</p>\r<!--more-->\r\r<p>异常：指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。若不处理异常，程序将会结束运行。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rint[] arr = new int[3];\rSystem.out.println(arr[0]);\rSystem.out.println(arr[3]);\r// 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，由于没有处理异常，导致程序无法继续执行，程序结束。\rSystem.out.println(&quot;over&quot;); // 由于上面代码发生了异常，此句代码不会执行</pre>\r\r<p>错误：指程序在运行期间发生了某种错误(XxxError)，Error错误通常没有具体的处理方式，程序将会结束运行。Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。我们无法针对处理，只能修正代码。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rint[] arr = new int[1024*1024*100];\r//该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 87),
(858, '异常的产生过程', '858', 1532175660, 1532176098, '<p>本文记录Java学习过程中遇到的一个完整的异常的产生过程～</p>\r<!--more-->\r\r<p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p>\r\r<p>示例代码（工具类）：</p>\r\r<pre class="brush:java;">\rclass ArrayTools{\r    //对给定的数组通过给定的角标获取元素。\r    public static int getElement(int[] arr,int index)	{\r	    int element = arr[index];\r	    return element;\r    }\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\rint[] arr = {34,12,67};\rint num = ArrayTools.getElement(arr,4)\rSystem.out.println(&quot;num=&quot;+num);\rSystem.out.println(&quot;over&quot;);</pre>\r\r<p>程序执行过程图解：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/143012925.png" style="width: 800px; height: 441px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(859, 'process.png', 'process-png', 1532176073, 1532176073, 'a:5:{s:4:"name";s:11:"process.png";s:4:"path";s:34:"/usr/uploads/2018/07/143012925.png";s:4:"size";i:184328;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 858, 0),
(860, '抛出异常throw', '860', 1532183160, 1554009068, '<p>本文记录Java学习过程中遇到的抛出异常throw关键字～</p>\r<!--more-->\r\r<p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>\r\r<p>在Java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>\r\r<ul>\r	<li>创建一个异常对象。封装一些提示信息(信息可以自己编写)；</li>\r	<li>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw&nbsp;异常对象；</li>\r	<li>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</li>\r</ul>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\rthrow new 异常类名(参数);</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rthrow new NullPointerException(&quot;要访问的arr数组不存在&quot;);\rthrow new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;);</pre>\r\r<p>下面是异常类ArrayIndexOutOfBoundsException与NullPointerException的构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4080334285.png" style="width: 800px; height: 360px;" /></p>\r\r<p>示例代码（编写工具类，提供获取数组指定索引处的元素值）：</p>\r\r<pre class="brush:java;">\rclass ArrayTools{\r	//通过给定的数组，返回给定的索引对应的元素值。\r	public static int getElement(int[] arr,int index)	{\r		/*\r		若程序出了异常，JVM它会打包异常对象并抛出。但是它所提供的信息不够给力。想要更清晰，需要自己抛出异常信息。\r下面判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。\r		*/\r		if(arr==null){\r			throw new NullPointerException(&quot;arr指向的数组不存在&quot;);\r		}\r		if(index&lt;0 || index&gt;=arr.length){\r			throw new ArrayIndexOutOfBoundsException(&quot;错误的角标，&quot;+index+&quot;索引在数组中不存在&quot;);\r		}\r		int element = arr[index];\r		return element;\r	}\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\rclass ExceptionDemo3 {\r	public static void main(String[] args) {\r		int[] arr = {34,12,67}; //创建数组\r		int num = ArrayTools.getElement(null,2);// 调用方法，获取数组中指定索引处元素\r                //int num = ArrayTools.getElement(arr,5);// 调用方法，获取数组中指定索引处元素\r		System.out.println(&quot;num=&quot;+num);//打印获取到的元素值\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130),
(861, 'gouzao.png', 'gouzao-png-1', 1532183392, 1532183392, 'a:5:{s:4:"name";s:10:"gouzao.png";s:4:"path";s:35:"/usr/uploads/2018/07/4080334285.png";s:4:"size";i:78172;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 860, 0),
(862, '声明异常throws', '862', 1532183580, 1532183746, '<p>本文记录Java学习过程中遇到的声明异常throws关键字～</p>\r<!--more-->\r\r<p>声明：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>\r\r<p>声明异常格式：</p>\r\r<pre class="brush:java;">\r修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2&hellip; {   }</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Demo{\r	/*\r	如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明。\r	*/\r	public void show(int x)throws Exception	{\r		if(x&gt;0){\r			throw new Exception();\r		} else {\r			System.out.println(&quot;show run&quot;);\r         }\r	}\r}</pre>\r\r<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>\r\r<p>示例代码（多个异常）：</p>\r\r<pre class="brush:java;">\rpublic static int getElement(int[] arr,int index) throws NullPointerException, ArrayIndexOutOfBoundsException {\r	if(arr==null){\r		throw new NullPointerException(&quot;arr指向的数组不存在&quot;);\r	}\r	if(index&lt;0 || index&gt;=arr.length){\r		throw new ArrayIndexOutOfBoundsException(&quot;错误的角标，&quot;+index+&quot;索引在数组中不存在&quot;);\r	}\r	int element = arr[index];\r	return element;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(863, '捕获异常try…catch…finally', '863', 1532183760, 1554009221, '<p>本文记录Java学习过程中遇到的捕获异常try&hellip;catch&hellip;finally语句～</p>\r<!--more-->\r\r<p>捕获：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</p>\r\r<p>捕获异常格式：</p>\r\r<pre class="brush:java;">\rtry {\r	//需要被检测的语句。\r} catch(异常类 变量) { //参数。\r	//异常的处理语句。\r} finally {\r	//一定会被执行的语句。\r}</pre>\r\r<p>try：该代码块中编写可能产生异常的代码。</p>\r\r<p>catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>\r\r<p>finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rtry {\r       int[] arr = new int[3];\r	System.out.println( arr[5] );// 会抛出ArrayIndexOutOfBoundsException\r	当产生异常时，必须有处理方式。要么捕获，要么声明。\r} catch (ArrayIndexOutOfBoundsException e) { //括号中需要定义什么呢？try中抛出的是什么异常，在括号中就定义什么异常类型。 \r	System.out.println(&quot;异常发生了&quot;);\r} finally {\r        arr = null; //把数组指向null，通过垃圾回收器，进行内存垃圾的清除\r}\rSystem.out.println(&quot;程序运行结果&quot;);</pre>\r\r<ul>\r	<li>try catch finally组合：检测异常，并传递给catch处理，并在finally中进行资源释放。</li>\r	<li>try catch组合:&nbsp;对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rvoid show(){ //不用throws \r        try{\r	        throw new Exception();//产生异常，直接捕获处理\r        }catch(Exception e){\r                //处理方式	\r	}\r}</pre>\r\r<ul>\r	<li>一个try&nbsp;多个catch组合:&nbsp;对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rvoid show(){ //不用throws \r	try{\r		throw new Exception();//产生异常，直接捕获处理\r	}catch(XxxException e){\r                //处理方式	\r	}catch(YyyException e){\r               //处理方式	\r	}catch(ZzzException e){\r                //处理方式	\r	}\r}</pre>\r\r<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>\r\r<ul>\r	<li>try finally&nbsp;组合:&nbsp;对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rvoid show(){//需要throws \r	try{\r	        throw new Exception();\r	}finally {\r		//释放资源\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 117),
(864, '运行时异常', '864', 1532185320, 1532185412, '<p>本文记录Java学习过程中遇到的运行时异常～</p>\r<!--more-->\r\r<p>RuntimeException和他的所有子类异常,都属于运行时期异常。NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.</p>\r\r<p>运行时期异常的特点：</p>\r\r<ul>\r	<li>方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常</li>\r	<li>运行时期异常一旦发生,需要程序人员修改源代码.</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass ExceptionDemo{\r    public static void main(String[] args){\r         method();\r    }\r    public static void method(){\r        throw new RuntimeException();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(865, '异常在方法重写中细节', '865', 1532185500, 1554009396, '<p>本文记录Java学习过程中遇到的异常在方法重写中的一些注意事项～</p>\r<!--more-->\r\r<ul>\r	<li>子类覆盖父类方法时，如果父类的方法声明异常，子类只能声明父类异常或者该异常的子类，或者不声明。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu {\r	public void method () throws RuntimeException {\r}\r}\rclass Zi extends Fu {\r	public void method() throws RuntimeException { }  //抛出父类一样的异常\r	//public void method() throws NullPointerException{ } //抛出父类子异常\r}</pre>\r\r<ul>\r	<li>当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu {\r	public void method () throws NullPointerException, ClassCastException{\r}\r}\rclass Zi extends Fu {\r	public void method()throws NullPointerException, ClassCastException { }  		public void method() throws NullPointerException{ } //抛出父类异常中的一部分\r	public void method() throws ClassCastException { } //抛出父类异常中的一部分\r}</pre>\r\r<ul>\r	<li>当被覆盖的方法没有异常声明时，子类覆盖时无法声明异常的。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Fu {\r	public void method (){\r}\r}\rclass Zi extends Fu {\r	public void method() throws Exception { }//错误的方式\r}</pre>\r\r<p>举例：父类中会存在下列这种情况，接口也有这种情况</p>\r\r<p>问：接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？</p>\r\r<p>答：无法进行throws声明，只能catch的捕获。万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rinterface Inter {\r	public abstract void method();\r}\rclass Zi implements Inter {\r	public void method(){ //无法声明 throws Exception\r		int[] arr = null;\r		if (arr == null) {\r			//只能捕获处理\r			try{\r                                throw new Exception(&ldquo;哥们，你定义的数组arr是空的!&rdquo;);\r                        } catch(Exception e){\r                                System.out.println(&ldquo;父方法中没有异常抛出，子类中不能抛出Exception异常&rdquo;);\r	                         //我们把异常对象e，采用RuntimeException异常方式抛出\r		                 throw new RuntimeException(e);\r                        }\r                  }\r          }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(866, '异常中常用方法', '866', 1532185860, 1554009491, '<p>本文记录Java学习过程中遇到的异常中的常用方法～</p>\r<!--more-->\r\r<p>在Throwable类中为我们提供了很多操作异常对象的方法，常用的如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3659647602.png" style="width: 800px; height: 221px;" /></p>\r\r<ul>\r	<li>getMessage方法：返回该异常的详细信息字符串，即异常提示信息；</li>\r	<li>toString方法：返回该异常的名称与详细信息字符串；</li>\r	<li>printStackTrace方法：在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rtry {\r	Person p= null;\r	if (p==null) {\r		throw new NullPointerException(&ldquo;出现空指针异常了，请检查对象是否为null&rdquo;);\r}\r} catch (NullPointerException e) {\r	String message = e.getMesage();\r	System.out.println(message ); \r	\r	String result = e.toString();\r	System.out.println(result);	\r	\r	e.printStackTrace(); \r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 132),
(867, 'throwable.png', 'throwable-png', 1532185960, 1532185960, 'a:5:{s:4:"name";s:13:"throwable.png";s:4:"path";s:35:"/usr/uploads/2018/07/3659647602.png";s:4:"size";i:33533;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 866, 0),
(868, '自定义异常', '868', 1532186220, 1532186601, '<p>本文记录Java学习过程中遇到的自定义异常～</p>\r<!--more-->\r\r<p>这些异常都是JDK内部定义好的，并且这些异常不好找。书写时也很不方便，那么能不能自己定义异常呢？</p>\r\r<p>之前的几个异常都是java通过类进行的描述。并将问题封装成对象，异常就是将问题封装成了对象。这些异常不好认，书写也很不方便，能不能定义一个符合我的程序要求的异常名称。既然JDK中是使用类在描述异常信息，那么我们也可以模拟Java的这种机制，我们自己定义异常的信息，异常的名字，让异常更符合自己程序的阅读。准确对自己所需要的异常进行类的描述。</p>\r\r<p>通过阅读异常源代码：发现java中所有的异常类，都是继承Throwable，或者继承Throwable的子类。这样该异常才可以被throw抛出。</p>\r\r<p>说明这个异常体系具备一个特有的特性：可抛性：即可以被throw关键字操作。</p>\r\r<p>并且查阅异常子类源码，发现每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，让父类帮我们进行异常信息的封装。</p>\r\r<p>示例代码（NullPointerException异常类）：</p>\r\r<pre class="brush:java;">\rpublic class NullPointerException extends RuntimeException {\r    public NullPointerException() {\r        super();//调用父类构造方法\r    }\r    public NullPointerException(String s) {\r        super(s);//调用父类具有异常信息的构造方法\r    }\r}</pre>\r\r<p>现在，我们来定义个自己的异常，即自定义异常。格式：</p>\r\r<pre class="brush:java;">\rClass 异常名 extends Exception{ //或继承RuntimeException\r	public 异常名(){\r       \r       }\r	public 异常名(String s){ \r               super(s); \r        }\r}</pre>\r\r<p>示例代码（自定义异常继承Exception）：</p>\r\r<pre class="brush:java;">\rclass MyException extends Exception{\r	/*\r	为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。\r	*/\r	public MyException(){\r		super();\r	}\r	public MyException(String message)	{\r		super(message);// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。\r	}\r}</pre>\r\r<p>示例代码（自定义异常继承RuntimeException）：</p>\r\r<pre class="brush:java;">\rclass MyException extends RuntimeException{\r	/*\r	为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。\r	*/\r	MyException(){\r		super();\r	}\r	MyException(String message)	{\r		super(message);// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 138),
(869, 'IO', '869', 1532440380, 1532440443, '<p>本文记录Java学习过程中遇到的IO～</p>\r<!--more-->\r\r<p>回想之前写过的程序，数据都是在内存中，一旦程序运行结束，这些数据都没有了，等下次再想使用这些数据，可是已经没有了。那怎么办呢？能不能把运算完的数据都保存下来，下次程序启动的时候，再把这些数据读出来继续使用呢？其实要把数据持久化存储，就需要把内存中的数据存储到内存以外的其他持久化设备(硬盘、光盘、U盘等)上。</p>\r\r<p>当需要把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作。</p>\r\r<p>当把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作。</p>\r\r<p>因此我们把这种输入和输出动作称为IO操作。</p>\r\r<p>简单了解IO是怎么一回事之后，接下来就要进一步做系统了解。</p>\r\r<p>在我们操作系统中，数据都保存在文件中，而文件存放相应的文件夹中。那么Java中是如何描述这些的呢？</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(870, 'File类', '870', 1532441760, 1532441803, '<p>本文记录Java学习过程中遇到的File类～</p>\r<!--more-->\r\r<p>打开API，搜索File类。阅读其描述：File文件和目录路径名的抽象表示形式。即，Java中把文件或者目录（文件夹）都封装成File对象。也就是说如果我们要去操作硬盘上的文件，或者文件夹只要找到File这个类即可。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 107);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(871, 'File类常用方法', '871', 1532442240, 1532474520, '<p>本文记录Java学习过程中遇到的File类的常用方法～</p>\r<!--more-->\r\r<ul>\r	<li>构造函数</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/874636661.png" style="width: 800px; height: 178px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//File构造函数演示\rString pathName = &quot;e:\\\\java_code\\\\day22e\\\\hello.java&quot;;\rFile f1 = new File(pathName);//将Test22文件封装成File对象。注意；有可以封装不存在文件或者文件夹，变成对象。\rSystem.out.println(f1);\r		\rFile f2 = new File(&quot;e:\\\\java_code\\\\day22e&quot;,&quot;hello.java&quot;);\rSystem.out.println(f2);\r		\r//将parent封装成file对象。\rFile dir = new File(&quot;e:\\\\java_code\\\\day22e&quot;);\rFile f3 = new File(dir,&quot;hello.java&quot;);\rSystem.out.println(f3);</pre>\r\r<ul>\r	<li>获取文件相关信息</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1765863794.png" style="width: 800px; height: 304px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建文件对象\rFile file = new File(&quot;Test22.java&quot;);\r//获取文件的绝对路径，即全路径\rString absPath = file.getAbsolutePath();\r//File中封装的路径是什么获取到的就是什么。\rString path = file.getPath();\r//获取文件名称\rString filename = file.getName();\r//获取文件大小\rlong size = file.length();\r		\rSystem.out.println(&quot;absPath=&quot;+absPath);\rSystem.out.println(&quot;path=&quot;+path);\rSystem.out.println(&quot;filename=&quot;+filename);\rSystem.out.println(&quot;size=&quot;+size);</pre>\r\r<ul>\r	<li>文件和文件夹的创建删除等</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/582719769.png" style="width: 800px; height: 284px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 对文件或者文件加进行操作。\rFile file = new File(&quot;e:\\\\file.txt&quot;);\r// 创建文件，如果文件不存在，创建 true 如果文件存在，则不创建 false。 如果路径错误，IOException。\rboolean b1 = file.createNewFile();\rSystem.out.println(&quot;b1=&quot; + b1);\r//-----------删除文件操作-------注意：不去回收站。慎用------\r boolean b2 = file.delete();\r System.out.println(&quot;b2=&quot;+b2);\r\r//-----------需要判断文件是否存在------------\r boolean b3 = file.exists();\r System.out.println(&quot;b3=&quot;+b3);\r\r//-----------对目录操作 创建，删除，判断------------\rFile dir = new File(&quot;e:\\\\abc&quot;);\r//mkdir()创建单个目录。//dir.mkdirs();创建多级目录\rboolean b4 = dir.mkdir();\rSystem.out.println(&quot;b4=&quot;+b4);\r//删除目录时，如果目录中有内容，无法直接删除。\rboolean b5 = dir.delete();\r//只有将目录中的内容都删除后，保证该目录为空。这时这个目录才可以删除。\rSystem.out.println(&quot;b5=&quot; + b5);\r\r//-----------判断文件，目录------------\rFile f = new File(&quot;e:\\\\javahaha&quot;);// 要判断是否是文件还是目录，必须先判断存在。\r// f.mkdir();//f.createNewFile();\rSystem.out.println(f.isFile());\rSystem.out.println(f.isDirectory());</pre>\r\r<ul>\r	<li>文件列表显示</li>\r</ul>\r\r<p>文件都存放在目录（文件夹）中，那么如何获取一个目录中的所有文件或者目录中的文件夹呢？那么我们先想想，一个目录中可能有多个文件或者文件夹，那么如果File中有功能获取到一个目录中的所有文件和文件夹，那么功能得到的结果要么是数组，要么是集合。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/686381997.png" style="width: 800px; height: 105px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rFile dir = new File(&quot;e:\\\\java_code&quot;);\r//获取的是目录下的当前的文件以及文件夹的名称。\rString[] names = dir.list();\rfor(String name : names){\r	System.out.println(name);\r}\r//获取目录下当前文件以及文件对象，只要拿到了文件对象，那么就可以获取其中想要的信息\rFile[] files = dir.listFiles();\rfor(File file : files){\r	System.out.println(file);\r}</pre>\r\r<p>注意：在获取指定目录下的文件或者文件夹时必须满足下面两个条件</p>\r\r<ol>\r	<li>指定的目录必须是存在的，</li>\r	<li>指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(872, 'gouzao.png', 'gouzao-png-2', 1532442387, 1532442387, 'a:5:{s:4:"name";s:10:"gouzao.png";s:4:"path";s:34:"/usr/uploads/2018/07/874636661.png";s:4:"size";i:46570;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 871, 0),
(873, 'huoqu.png', 'huoqu-png', 1532443834, 1532443834, 'a:5:{s:4:"name";s:9:"huoqu.png";s:4:"path";s:35:"/usr/uploads/2018/07/1765863794.png";s:4:"size";i:52173;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 871, 0),
(874, 'create-delete.png', 'create-delete-png', 1532473747, 1532473747, 'a:5:{s:4:"name";s:17:"create-delete.png";s:4:"path";s:34:"/usr/uploads/2018/07/582719769.png";s:4:"size";i:63574;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 871, 0),
(875, 'list.png', 'list-png-1', 1532474407, 1532474407, 'a:5:{s:4:"name";s:8:"list.png";s:4:"path";s:34:"/usr/uploads/2018/07/686381997.png";s:4:"size";i:22406;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 871, 0),
(876, '文件过滤器', '876', 1532474700, 1532524288, '<p>本文记录Java学习过程中遇到的文件过滤器～</p>\r<!--more-->\r\r<p>通过listFiles()方法，我们可以获取到一个目录下的所有文件和文件夹，但能不能对其进行过滤呢？比如我们只想要一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹呢？</p>\r\r<p>我们是可以先把一个目录下的所有文件和文件夹获取到，并遍历当前获取到所有内容，遍历过程中在进行筛选，但是这个动作有点麻烦，Java给我们提供相应的功能来解决这个问题。</p>\r\r<p>查阅File类的API，在查阅时发现File类中重载的listFiles方法，并且接受指定的过滤器。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/659291696.png" style="width: 800px; height: 49px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3700824842.png" style="width: 800px; height: 147px;" /></p>\r\r<p>示例代码（自定类继承FilenameFilter过滤器接口）：</p>\r\r<pre class="brush:java;">\rclass MyFileFilter implements FilenameFilter{\r	public boolean accept(File dir, String name) {\r		return name.endsWith(&quot;.java&quot;);\r	}\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r//获取扩展名为.java所有文件\r//创建File对象\rFile file = new File(&quot;E:\\\\code\\\\day11_code&quot;);\r//获取指定扩展名的文件,由于要对所有文件进行扩展名筛选，因此调用方法需要传递过滤器\rFile[] files = file.listFiles(new MyFileFilter());\r//遍历获取到的所有符合条件的文件\rfor (File f : files) {\r	System.out.println(f);\r}</pre>\r\r<p>在查阅API时，我们发现，在listFiles(FileFilter filter)&nbsp;也可以接受一个FileFilter过滤器，它和我们讲的FilenameFilter有啥区别呢？</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1711668034.png" style="width: 800px; height: 149px;" /></p>\r\r<p>FilenameFilter过滤器中的accept方法接受两个参数，一个当前文件或文件夹所在的路径，一个是当前文件或文件夹对象的名称。</p>\r\r<p>FileFilter&nbsp;过滤器中的accept方法接受一个参数，这个参数就当前文件或文件夹对象</p>\r\r<p>当我们需要过滤文件名称时就可以使用FilenameFilter这个过滤器，当我们想对当前文件或文件夹进行过滤，就可以使用FileFilter&nbsp;，比如需要当前目录下的所有文件夹，就可以使用FileFilter&nbsp;过滤器。</p>\r\r<p>示例代码（自定义类继承FileFilter过滤器接口）：</p>\r\r<pre class="brush:java;">\rclass FileFileterByDir implements FileFilter{\r	public boolean accept(File pathname) {\r		return pathname.isDirectory();\r	}\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r//获取扩展名为.java所有文件\r//创建File对象\rFile file = new File(&quot;E:\\\\code\\\\day11_code&quot;);\r//获取指定目录下的文件夹\rFile[] files = file.listFiles(new FileFileterByDir());\r//遍历获取到的所有符合条件的文件\rfor (File f : files) {\r	System.out.println(f);\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(877, 'file.png', 'file-png', 1532474884, 1532474884, 'a:5:{s:4:"name";s:8:"file.png";s:4:"path";s:34:"/usr/uploads/2018/07/659291696.png";s:4:"size";i:19807;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 876, 0),
(878, 'accept.png', 'accept-png', 1532475034, 1532475034, 'a:5:{s:4:"name";s:10:"accept.png";s:4:"path";s:35:"/usr/uploads/2018/07/3700824842.png";s:4:"size";i:60649;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 876, 0),
(879, 'filefilter.png', 'filefilter-png', 1532524101, 1532524101, 'a:5:{s:4:"name";s:14:"filefilter.png";s:4:"path";s:35:"/usr/uploads/2018/07/1711668034.png";s:4:"size";i:55911;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 876, 0),
(880, '递归', '880', 1532525160, 1532525530, '<p>本文记录Java学习过程中遇到的递归～</p>\r<!--more-->\r\r<p>递归，指在当前方法内调用自己的这种现象。</p>\r\r<p>示例代码（最简单的递归）：</p>\r\r<pre class="brush:java;">\rpublic void method(){\r	System.out.println(&ldquo;递归的演示&rdquo;);\r	//在当前方法内调用自己\r	method();\r}</pre>\r\r<p>递归分为两种，直接递归和间接递归。</p>\r\r<p>直接递归称为方法自身调用自己。间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</p>\r\r<p>示例代码（计算1-n的和）：</p>\r\r<pre class="brush:java;">\rpublic class DiGuiDemo {\r	public static void main(String[] args) {\r		//计算1~num的和，使用递归完成\r		int n = 5;\r		int sum = getSum(n);\r		System.out.println(sum);\r		\r	}\r	public static int getSum(int n) {\r		if(n == 1){\r			return 1;\r		}\r		return n + getSum(n-1);\r	}\r}</pre>\r\r<p>程序流程图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1163778234.png" style="width: 800px; height: 522px;" /></p>\r\r<p>注意：</p>\r\r<ol>\r	<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li>\r	<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(881, 'digui.png', 'digui-png', 1532525475, 1532525475, 'a:5:{s:4:"name";s:9:"digui.png";s:4:"path";s:35:"/usr/uploads/2018/07/1163778234.png";s:4:"size";i:178235;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 880, 0),
(882, '字节输出流OutputStream', '882', 1532761620, 1532761822, '<p>本文记录Java学习过程中遇到的字节输出流OutputStream抽象类～</p>\r<!--more-->\r\r<p>OutputStream抽象类，是表示输出字节流的所有类的超类。操作的数据都是字节，定义了输出字节流的基本共性功能方法。</p>\r\r<p>输出流中定义都是写write方法，如下图:</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3426932876.png" style="width: 800px; height: 290px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(883, 'outputstream.png', 'outputstream-png', 1532761749, 1532761749, 'a:5:{s:4:"name";s:16:"outputstream.png";s:4:"path";s:35:"/usr/uploads/2018/07/3426932876.png";s:4:"size";i:59520;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 882, 0),
(884, 'FileOutputStream类', '884', 1532762280, 1532762580, '<p>本文记录Java学习过程中遇到的FileOutputStream类～</p>\r<!--more-->\r\r<p>OutputStream有很多子类，其中子类FileOutputStream可用来写入数据到文件。</p>\r\r<p>FileOutputStream类，即文件输出流，是用于将数据写入File的输出流。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/312665485.png" style="width: 800px; height: 147px;" /></p>\r\r<p>构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2259185879.png" style="width: 800px; height: 150px;" /></p>\r\r<p>示例代码（将数据写到文件中）：</p>\r\r<pre class="brush:java;">\r//需求：将数据写入到文件中。\r//创建存储数据的文件。\rFile file = new File(&quot;c:\\\\file.txt&quot;);\r//创建一个用于操作文件的字节输出流对象。一创建就必须明确数据存储目的地。\r//输出流目的是文件，会自动创建。如果文件存在，则覆盖。\rFileOutputStream fos = new FileOutputStream(file);\r//调用父类中的write方法。\rbyte[] data = &quot;abcde&quot;.getBytes();\rfos.write(data);\r//关闭流资源。\rfos.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(885, 'fileoutputstream.png', 'fileoutputstream-png', 1532762359, 1532762359, 'a:5:{s:4:"name";s:20:"fileoutputstream.png";s:4:"path";s:34:"/usr/uploads/2018/07/312665485.png";s:4:"size";i:22088;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 884, 0),
(886, 'gouzao.png', 'gouzao-png-3', 1532762450, 1532762450, 'a:5:{s:4:"name";s:10:"gouzao.png";s:4:"path";s:35:"/usr/uploads/2018/07/2259185879.png";s:4:"size";i:25053;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 884, 0),
(887, 'FileOutputStream续写和换行', '887', 1532762640, 1532762781, '<p>本文记录Java学习过程中遇到的FileOutputStream类的续写和换行～</p>\r<!--more-->\r\r<p>我们直接newFileOutputStream(file)这样创建对象，写入数据，会覆盖原有的文件，那么我们想在原有的文件中续写内容怎么办呢？</p>\r\r<p>继续查阅FileOutputStream的API。发现在FileOutputStream的构造函数中，可以接受一个boolean类型的值，如果值true，就会在文件末位继续添加。</p>\r\r<p>构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/235941709.png" style="width: 800px; height: 135px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rFile file = new File(&quot;c:\\\\file.txt&quot;);\rFileOutputStream fos = new FileOutputStream(file, true);\rString str = &quot;\\r\\n&quot;+&quot;itcast&quot;;\rfos.write(str.getBytes());\rfos.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 118),
(888, 'append.png', 'append-png', 1532762721, 1532762721, 'a:5:{s:4:"name";s:10:"append.png";s:4:"path";s:34:"/usr/uploads/2018/07/235941709.png";s:4:"size";i:26833;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 887, 0),
(889, 'IO异常的处理', '889', 1532762820, 1532763741, '<p>本文记录Java学习过程中遇到的IO异常的处理～</p>\r<!--more-->\r\r<p>在前面的示例代码中都发生了IO的异常，而且在实际的开发中，我们也不得不处理IO异常。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rFile file = new File(&quot;c:\\\\file.txt&quot;);\r//定义FileOutputStream的引用\rFileOutputStream fos = null;\rtry {\r	//创建FileOutputStream对象\r	fos = new FileOutputStream(file);\r	//写出数据\r	fos.write(&quot;abcde&quot;.getBytes());\r} catch (IOException e) {\r	System.out.println(e.toString() + &quot;----&quot;);\r} finally {\r	//一定要判断fos是否为null，只有不为null时，才可以关闭资源\rif (fos != null) {\r		try {\r			fos.close();\r		} catch (IOException e) {\r			throw new RuntimeException(&quot;&quot;);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(890, '字节输入流InputStream', '890', 1532766840, 1554010531, '<p>本文记录Java学习过程中遇到的字符输入流抽象类InputStream～</p>\r<!--more-->\r\r<p>通过前面的学习，我们可以把内存中的数据写出到文件中，那如何想把内存中的数据读到内存中，我们通过InputStream可以实现。InputStream此抽象类，是表示字节输入流的所有类的超类。，定义了字节输入流的基本共性功能方法。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3372901401.png" style="width: 800px; height: 129px;" /></p>\r\r<ul>\r	<li>int read():读取一个字节并返回，没有字节返回-1.</li>\r	<li>int read(byte[]):&nbsp;读取一定量的字节数，并存储到字节数组中，返回读取到的字节数。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(891, 'inputstream.png', 'inputstream-png', 1532766941, 1532766941, 'a:5:{s:4:"name";s:15:"inputstream.png";s:4:"path";s:35:"/usr/uploads/2018/07/3372901401.png";s:4:"size";i:26620;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 890, 0),
(892, 'FileInputStream类', '892', 1532767020, 1532774221, '<p>本文记录Java学习过程中遇到的FileInputStream类～</p>\r<!--more-->\r\r<p>InputStream有很多子类，其中子类FileInputStream可用来读取文件内容。</p>\r\r<p>FileInputStream&nbsp;从文件系统中的某个文件中获得输入字节。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1344690239.png" style="width: 800px; height: 150px;" /></p>\r\r<p>构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2738879752.png" style="width: 800px; height: 90px;" /></p>\r\r<p>在读取文件中的数据时，调用read方法，实现从文件中读取数据：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/2666560110.png" style="width: 800px; height: 65px;" /></p>\r\r<p>示例代码（从文件中读取数据）：</p>\r\r<pre class="brush:java;">\rFile file = new File(&quot;c:\\\\file.txt&quot;);\r//创建一个字节输入流对象,必须明确数据源，其实就是创建字节读取流和数据源相关联。\rFileInputStream fis = new FileInputStream(file);\r//读取数据。使用 read();一次读一个字节。\rint ch = 0;\rwhile((ch=fis.read())!=-1){\r	System.out.print ln(&quot;ch=&quot;+(char)ch);		\r}\r// 关闭资源。\rfis.close();</pre>\r\r<p>在读取文件中的数据时，调用read方法，每次只能读取一个，太麻烦了，于是我们可以定义数组作为临时的存储容器，这时可以调用重载的read方法，一次可以读取多个字符。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/1510689219.png" style="height: 67px; width: 800px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/*\r * 演示第二个读取方法， read(byte[]);\r */\rFile file = new File(&quot;c:\\\\file.txt&quot;);\r// 创建一个字节输入流对象,必须明确数据源，其实就是创建字节读取流和数据源相关联。\rFileInputStream fis = new FileInputStream(file);		\r//创建一个字节数组。\rbyte[] buf = new byte[1024];//长度可以定义成1024的整数倍。		\rint len = 0;\rwhile((len=fis.read(buf))!=-1){\r	System.out.println(new String(buf,0,len));\r}\rfis.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(893, 'fileinputstream.png', 'fileinputstream-png', 1532767249, 1532767249, 'a:5:{s:4:"name";s:19:"fileinputstream.png";s:4:"path";s:35:"/usr/uploads/2018/07/1344690239.png";s:4:"size";i:21873;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 892, 0),
(894, 'newgouzao.png', 'newgouzao-png', 1532767331, 1532767331, 'a:5:{s:4:"name";s:13:"newgouzao.png";s:4:"path";s:35:"/usr/uploads/2018/07/2738879752.png";s:4:"size";i:26298;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 892, 0),
(895, 'read.png', 'read-png', 1532767399, 1532767399, 'a:5:{s:4:"name";s:8:"read.png";s:4:"path";s:35:"/usr/uploads/2018/07/2666560110.png";s:4:"size";i:11813;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 892, 0),
(896, 'read_new.png', 'read_new-png', 1532767561, 1532767561, 'a:5:{s:4:"name";s:12:"read_new.png";s:4:"path";s:35:"/usr/uploads/2018/07/1510689219.png";s:4:"size";i:14131;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 892, 0),
(897, '字符编码表', '897', 1532779800, 1532780233, '<p>本文记录Java学习过程中遇到的字符编码表～</p>\r<!--more-->\r\r<p>我们知道计算机底层数据存储的都是二进制数据，而我们生活中的各种各样的数据，如何才能和计算机中存储的二进制数据对应起来呢？</p>\r\r<p>这时老美他们就把每一个字符和一个整数对应起来，就形成了一张编码表，老美他们的编码表就是ASCII表。其中就是各种英文字符对应的编码。</p>\r\r<p>编码表：其实就是生活中字符和计算机二进制的对应关系表。</p>\r\r<p>1、ascii：一个字节中的7位就可以表示。对应的字节都是正数。0-xxxxxxx</p>\r\r<p>2、iso-8859-1:拉丁码表latin，用了一个字节用的8位。1-xxxxxxx&nbsp;&nbsp;负数。</p>\r\r<p>3、GB2312:简体中文码表。包含6000-7000中文和符号。用两个字节表示。两个字节第一个字节是负数,第二个字节可能是正数</p>\r\r<p>4、GBK:目前最常用的中文码表，2万的中文和符号。用两个字节表示，其中的一部分文字，第一个字节开头是1，第二字节开头是0</p>\r\r<p>5、GB18030：最新的中文码表，目前还没有正式使用。</p>\r\r<p>6、unicode：国际标准码表:无论是什么文字，都用两个字节存储。</p>\r\r<p>Java中的char类型用的就是这个码表。char c = &#39;a&#39;;占两个字节。<br />\rJava中的字符串是按照系统默认码表来解析的。简体中文版 字符串默认的码表是GBK。</p>\r\r<p>7、UTF-8:基于unicode，一个字节就可以存储数据，不要用两个字节存储，而且这个码表更加的标准化，在每一个字节头加入了编码信息(后期到api中查找)。</p>\r\r<p>能识别中文的码表：GBK、UTF-8；正因为识别中文码表不唯一，涉及到了编码解码问题。</p>\r\r<p>对于我们开发而言；常见的编码GBK&nbsp;&nbsp;UTF-8&nbsp;&nbsp;ISO-8859-1</p>\r\r<p>文字---&gt;(数字)&nbsp;：编码。&ldquo;abc&rdquo;.getBytes()&nbsp;&nbsp;byte[]</p>\r\r<p>(数字)---&gt;文字&nbsp;&nbsp;:&nbsp;解码。byte[] b={97,98,99}&nbsp;&nbsp;new String(b)&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 88),
(898, '字符输入流Reader', '898', 1532780280, 1532780416, '<p>本文记录Java学习过程中遇到的字符输入流Reader～</p>\r<!--more-->\r\r<p>我们读取拥有中文的文件时，使用的字节流在读取，那么我们读取到的都是一个一个字节。只要把这些字节去查阅对应的编码表，就能够得到与之对应的字符。API中是否给我们已经提供了读取相应字符的功能流对象，Reader，读取字符流的抽象超类。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/102430123.png" style="width: 800px; height: 180px;" /></p>\r\r<ul>\r	<li>read():读取单个字符并返回</li>\r	<li>read(char[]):将数据读取到数组中，并返回读取的个数。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(899, 'reader.png', 'reader-png', 1532780376, 1532780376, 'a:5:{s:4:"name";s:10:"reader.png";s:4:"path";s:34:"/usr/uploads/2018/07/102430123.png";s:4:"size";i:13919;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 898, 0),
(900, 'FileReader类', '900', 1532780520, 1532780696, '<p>本文记录Java学习过程中遇到的FileReader类～</p>\r<!--more-->\r\r<p>查阅FileInputStream的API，发现FileInputStream&nbsp;用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用FileReader。</p>\r\r<p>打开FileReader的API介绍。用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。</p>\r\r<p>构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/189834681.png" style="width: 800px; height: 145px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class CharStreamDemo {\r	public static void main(String[] args) throws IOException {\r		//给文件中写中文\r		writeCNText();\r		//读取文件中的中文\r		readCNText();\r	}	\r	//读取中文\r	public static void readCNText() throws IOException {\r		FileReader fr = new FileReader(&quot;D:\\\\test\\\\cn.txt&quot;);\r		int ch = 0;\r		while((ch = fr.read())!=-1){\r			//输出的字符对应的编码值\r			System.out.println(ch);\r			//输出字符本身\r			System.out.println((char)ch);\r		}\r	}\r	//写中文\r	public static void writeCNText() throws IOException {\r		FileOutputStream fos = new FileOutputStream(&quot;D:\\\\test\\\\cn.txt&quot;);\r		fos.write(&quot;a百度欢迎你&quot;.getBytes());\r		fos.close();\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 91),
(901, 'filereader.png', 'filereader-png', 1532780600, 1532780600, 'a:5:{s:4:"name";s:14:"filereader.png";s:4:"path";s:34:"/usr/uploads/2018/07/189834681.png";s:4:"size";i:24279;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 900, 0),
(902, '字符输出流Writer', '902', 1532780760, 1532780946, '<p>本文记录Java学习过程中遇到的字符输出流Writer～</p>\r<!--more-->\r\r<p>既然有专门用于读取字符的流对象，那么肯定也有写的字符流对象，查阅API，发现有一个Writer类，Writer是写入字符流的抽象类。其中描述了相应的写的动作。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/3073035178.png" style="width: 800px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(903, 'writer.png', 'writer-png', 1532780859, 1532780859, 'a:5:{s:4:"name";s:10:"writer.png";s:4:"path";s:35:"/usr/uploads/2018/07/3073035178.png";s:4:"size";i:44161;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 902, 0),
(904, 'FileWriter类', '904', 1532781120, 1532781575, '<p>本文记录Java学习过程中遇到的FileWriter类～</p>\r<!--more-->\r\r<p>查阅FileOutputStream的API，发现FileOutputStream&nbsp;用于写入诸如图像数据之类的原始字节的流。要写入字符流，请考虑使用FileWriter。</p>\r\r<p>打开FileWriter的API介绍。用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。</p>\r\r<p>构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/520886107.png" style="width: 800px; height: 213px;" /></p>\r\r<p>示例代码（写入中文到文件中）：</p>\r\r<pre class="brush:java;">\rpublic class FileWriterDemo {\r	public static void main(String[] args) throws IOException {\r		//演示FileWriter 用于操作文件的便捷类。\r		FileWriter fw = new FileWriter(&quot;d：\\\\text\\\\fw.txt&quot;);\r		fw.write(&quot;你好谢谢再见&quot;);//这些文字都要先编码。都写入到了流的缓冲区中。\r		fw.flush();\r		fw.close();\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(905, 'filewriter.png', 'filewriter-png', 1532781441, 1532781441, 'a:5:{s:4:"name";s:14:"filewriter.png";s:4:"path";s:34:"/usr/uploads/2018/07/520886107.png";s:4:"size";i:47709;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 904, 0),
(906, 'flush()和close()的区别', '906', 1532781780, 1532781899, '<p>本文记录Java学习过程中遇到的flush()和close()的区别～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/454669159.png" style="width: 800px; height: 143px;" /></p>\r\r<ul>\r	<li>flush():将流中的缓冲区缓冲的数据刷新到目的地中，刷新后，流还可以继续使用。</li>\r	<li>close():关闭资源，但在关闭前会将缓冲区中的数据先刷新到目的地，否则丢失数据，然后在关闭流。流不可以使用。如果写入数据多，一定要一边写一边刷新，最后一次可以不刷新，由close完成刷新并关闭。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(907, 'flush-and-close.png', 'flush-and-close-png', 1532781862, 1532781862, 'a:5:{s:4:"name";s:19:"flush-and-close.png";s:4:"path";s:34:"/usr/uploads/2018/07/454669159.png";s:4:"size";i:19561;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 906, 0),
(908, 'OutputStreamWriter类', '908', 1532865420, 1554011405, '<p>本文记录Java学习过程中遇到的OutputStreamWriter类～</p>\r<!--more-->\r\r<p>查阅OutputStreamWriter的API介绍，OutputStreamWriter&nbsp;是字符流通向字节流的桥梁：可使用指定的字符编码表，将要写入流中的字符编码成字节。它的作用的就是，将字符串按照指定的编码表转成字节，再使用字节流将这些字节写出去。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/452885209.png" style="width: 800px; height: 139px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建与文件关联的字节输出流对象\rFileOutputStream fos = new FileOutputStream(&quot;c:\\\\cn8.txt&quot;);\r//创建可以把字符转成字节的转换流对象，并指定编码\rOutputStreamWriter osw = new OutputStreamWriter(fos,&quot;utf-8&quot;);\r//调用转换流，把文字写出去，其实是写到转换流的缓冲区中\rosw.write(&quot;你好&quot;);//写入缓冲区。\rosw.close();</pre>\r\r<p>OutputStreamWriter流对象，它到底如何把字符转成字节输出的呢？</p>\r\r<p>其实在OutputStreamWriter流中维护自己的缓冲区，当我们调用OutputStreamWriter对象的write方法时，会拿着字符到指定的码表中进行查询，把查到的字符编码值转成字节数存放到OutputStreamWriter缓冲区中。然后再调用刷新功能，或者关闭流，或者缓冲区存满后会把缓冲区中的字节数据使用字节流写到指定的文件中。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(909, 'outputstreamwriter.png', 'outputstreamwriter-png', 1532865537, 1532865537, 'a:5:{s:4:"name";s:22:"outputstreamwriter.png";s:4:"path";s:34:"/usr/uploads/2018/07/452885209.png";s:4:"size";i:33414;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 908, 0),
(910, 'InputStreamReader类', '910', 1532865780, 1532865931, '<p>本文记录Java学习过程中遇到的InputStreamReader类～</p>\r<!--more-->\r\r<p>查阅InputStreamReader的API介绍，InputStreamReader&nbsp;是字节流通向字符流的桥梁：它使用指定的字符编码表读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/07/4290280641.png" style="width: 800px; height: 145px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建读取文件的字节流对象\rInputStream in = new FileInputStream(&quot;c:\\\\cn8.txt&quot;);\r//创建转换流对象 \r//InputStreamReader isr = new InputStreamReader(in);这样创建对象，会用本地默认码表读取，将会发生错误解码的错误\rInputStreamReader isr = new InputStreamReader(in,&quot;utf-8&quot;);\r//使用转换流去读字节流中的字节\rint ch = 0;\rwhile((ch = isr.read())!=-1){\r	System.out.println((char)ch);\r}\r//关闭流\risr.close();</pre>\r\r<p>注意：在读取指定的编码的文件时，一定要指定编码格式，否则就会发生解码错误，而发生乱码现象。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(911, 'inputstreamreader.png', 'inputstreamreader-png', 1532865851, 1532865851, 'a:5:{s:4:"name";s:21:"inputstreamreader.png";s:4:"path";s:35:"/usr/uploads/2018/07/4290280641.png";s:4:"size";i:32898;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 910, 0),
(912, '转换流与子类区别', '912', 1532866020, 1532866363, '<p>本文记录Java学习过程中遇到的转换流与子类的区别～</p>\r<!--more-->\r\r<p>查看API发现有如下继承关系：</p>\r\r<pre class="brush:java;">\rOutputStreamWriter:\r		|--FileWriter:\rInputStreamReader:\r                |--FileReader;</pre>\r\r<p>父类和子类的功能有什么区别呢？</p>\r\r<p>OutputStreamWriter和InputStreamReader是字符和字节的桥梁：也可以称之为字符转换流。字符转换流原理：字节流+编码表。</p>\r\r<p>FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。</p>\r\r<pre class="brush:java;">\rInputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));//默认字符集。\rInputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;GBK&quot;);//指定GBK字符集。\rFileReader fr = new FileReader(&quot;a.txt&quot;);</pre>\r\r<p>这三句代码的功能是一样的，其中第三句最为便捷。</p>\r\r<p>注意：一旦要指定其他编码时，绝对不能用子类，必须使用字符转换流。</p>\r\r<p>使用子类的条件：</p>\r\r<ol>\r	<li>操作的是文件；</li>\r	<li>使用默认编码。</li>\r</ol>\r\r<p>总结：</p>\r\r<ul>\r	<li>字节---&gt;字符：看不懂的---&gt;看的懂的。&nbsp;&nbsp;需要读。输入流。InputStreamReader</li>\r	<li>字符---&gt;字节：看的懂的---&gt;看不懂的。&nbsp;&nbsp;需要写。输出流。OutputStreamWriter</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 118),
(913, 'BufferedOutputStream类', '913', 1532866860, 1554012301, '<p>本文记录Java学习过程中遇到的字节缓冲输出流BufferedOutputStream～</p>\r<!--more-->\r\r<p>通过字节缓冲输出流进行文件的读写操作和写数据到文件的操作。</p>\r\r<p>构造方法：</p>\r\r<ul>\r	<li>public BufferedOutputStream(OutputStream out)创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建基本的字节输出流\rFileOutputStream fileOut = new FileOutputStream(&quot;abc.txt&quot;);\r//使用高效的流，把基本的流进行封装，实现速度的提升\rBufferedOutputStream out = new BufferedOutputStream(fileOut);\r//写数据\rout.write(&quot;hello&quot;.getBytes());\r//关闭流\rout.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(915, 'BufferedWriter类', '915', 1532869200, 1554012749, '<p>本文记录Java学习过程中遇到的字符缓冲输出流BufferedWriter～</p>\r<!--more-->\r\r<p>将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</p>\r\r<p>方法：</p>\r\r<ul>\r	<li>void newLine()&nbsp;根据当前的系统，写入一个换行符</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建流\r//基本字符输出流\rFileWriter fileOut = new FileWriter(&quot;file.txt&quot;);\r//把基本的流进行包装\rBufferedWriter out = new BufferedWriter(fileOut);\r//写数据\rfor (int i=0; i&lt;5; i++) {\r	out.write(&quot;hello&quot;);\r	out.newLine();\r}\r//关闭流\rout.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(914, 'BufferedInputStream类', '914', 1532867100, 1532867256, '<p>本文记录Java学习过程中遇到的字节缓冲输入流BufferedInputStream～</p>\r<!--more-->\r\r<p>刚刚我们学习了输出流实现了向文件中写数据的操作，那么，现在我们完成读取文件中数据的操作。</p>\r\r<p>构造方法：</p>\r\r<ul>\r	<li>public BufferedInputStream(InputStream in)&nbsp;</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//1,创建缓冲流对象\rFileInputStream fileIn = new FileInputStream(&quot;abc.txt&quot;);\r//把基本的流包装成高效的流\rBufferedInputStream in = new BufferedInputStream(fileIn);\r//2，读数据\rint ch = -1;\rwhile ( (ch = in.read()) != -1 ) {\r	//打印\r	System.out.print((char)ch);\r}\r//3，关闭\rin.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(916, 'BufferedReader类', '916', 1532869380, 1554013042, '<p>本文记录Java学习过程中遇到的字符缓冲输入流BufferedReader～</p>\r<!--more-->\r\r<p>从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</p>\r\r<p>方法：</p>\r\r<ul>\r	<li>public&nbsp;String readLine()读取一个文本行，包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回null。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建流\rBufferedReader in = new BufferedReader(new FileReader(&quot;file.txt&quot;));\r//读数据\r//一次一个字符\r//一次一个字符数组\r//一次读取文本中一行的字符串内容\rString line = null;\rwhile( (line = in.readLine()) != null ){\r	System.out.println(line);\r}\r\r//关闭流\rin.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(917, '流的操作规律', '917', 1532874300, 1532874488, '<p>本文记录Java学习过程中遇到的流的操作规律～</p>\r<!--more-->\r\r<p>IO流中对象很多，解决问题(处理设备上的数据时)到底该用哪个对象呢？</p>\r\r<p>把IO流进行了规律的总结(四个明确)：</p>\r\r<p>明确一：要操作的数据是数据源还是数据目的。</p>\r\r<p>源：InputStream&nbsp;&nbsp;&nbsp;&nbsp;Reader</p>\r\r<p>目的：OutputStream Writer</p>\r\r<p>先根据需求明确要读，还是要写。</p>\r\r<p>明确二：要操作的数据是字节还是文本呢？</p>\r\r<p>源：</p>\r\r<p>字节：InputStream</p>\r\r<p>文本：Reader</p>\r\r<p>目的：</p>\r\r<p>字节：OutputStream</p>\r\r<p>文本：Writer</p>\r\r<p>已经明确到了具体的体系上。</p>\r\r<p>明确三：明确数据所在的具体设备。</p>\r\r<p>源设备：</p>\r\r<p>硬盘：文件&nbsp;&nbsp;File开头。</p>\r\r<p>内存：数组，字符串。</p>\r\r<p>键盘：System.in;</p>\r\r<p>网络：Socket</p>\r\r<p>目的设备：</p>\r\r<p>硬盘：文件&nbsp;&nbsp;File开头。</p>\r\r<p>内存：数组，字符串。</p>\r\r<p>屏幕：System.out</p>\r\r<p>网络：Socket</p>\r\r<p>完全可以明确具体要使用哪个流对象。</p>\r\r<p>明确四：是否需要额外功能呢？</p>\r\r<p>额外功能：</p>\r\r<p>转换吗？转换流。InputStreamReader OutputStreamWriter</p>\r\r<p>高效吗？缓冲区对象。BufferedXXX</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(918, 'Properties类', '918', 1533218040, 1554013843, '<p>本文记录Java学习过程中遇到的Properties类～</p>\r<!--more-->\r\r<p>Properties类表示了一个持久的属性集。</p>\r\r<p>Properties可保存在流中或从流中加载。</p>\r\r<p>属性列表中每个键及其对应值都是一个字符串。</p>\r\r<p>特点：</p>\r\r<ol>\r	<li>Hashtable的子类，Map集合中的方法都可以用；</li>\r	<li>该集合没有泛型，键值都是字符串；</li>\r	<li>它是一个可以持久化的属性集。键值可以存储到集合中，也可以存储到持久化的设备(硬盘、U盘、光盘)上。键值的来源也可以是持久化的设备；</li>\r	<li>有和流技术相结合的方法。</li>\r</ol>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1903487829.png" style="width: 1016px; height: 381px;" /></p>\r\r<ul>\r	<li>load(InputStream)&nbsp;&nbsp;把指定流所对应的文件中的数据，读取出来，保存到Propertie集合中</li>\r	<li>load(Reader) &nbsp;也是把指定流所对应的文件中的数据，读取出来，保存到Propertie集合中</li>\r	<li>store(OutputStream,commonts)把集合中的数据，保存到指定的流所对应的文件中，参数commonts代表对描述信息</li>\r	<li>stroe(Writer,comments)&nbsp;也是把集合中的数据，保存到指定的流所对应的文件中，参数commonts代表对描述信息</li>\r</ul>\r\r<p>示例代码（遍历properties）：</p>\r\r<pre class="brush:java;">\r//创建集合对象\rProperties prop = new Properties();\r//添加元素到集合\r//prop.put(key, value);\rprop.setProperty(&quot;周迅&quot;, &quot;张学友&quot;);\rprop.setProperty(&quot;李小璐&quot;, &quot;贾乃亮&quot;);\rprop.setProperty(&quot;杨幂&quot;, &quot;刘恺威&quot;);\r\r//System.out.println(prop);//测试的使用\r//遍历集合\rSet&lt;String&gt; keys = prop.stringPropertyNames();\rfor (String key : keys) {\r	//通过键 找值\r	//prop.get(key)\r	String value = prop.getProperty(key);\r	System.out.println(key+&quot;==&quot; +value);\r}</pre>\r\r<p>示例代码（将集合中内容存储到文件）：</p>\r\r<pre class="brush:java;">\r//1，创建Properties集合\rProperties prop = new Properties();\r//2，添加元素到集合\rprop.setProperty(&quot;周迅&quot;, &quot;张学友&quot;);\rprop.setProperty(&quot;李小璐&quot;, &quot;贾乃亮&quot;);\rprop.setProperty(&quot;杨幂&quot;, &quot;刘恺威&quot;);\r\r//3，创建流\rFileWriter out = new FileWriter(&quot;prop.properties&quot;);\r//4，把集合中的数据存储到流所对应的文件中\rprop.store(out, &quot;save data&quot;);\r//5，关闭流\rout.close();</pre>\r\r<p>示例代码（读取文件中的数据，并保存到集合）：</p>\r\r<pre class="brush:java;">\r//1，创建集合\rProperties prop = new Properties();\r//2，创建流对象\rFileInputStream in = new FileInputStream(&quot;prop.properties&quot;);\r//FileReader in = new FileReader(&quot;prop.properties&quot;);\r//3,把流所对应文件中的数据 读取到集合中\rprop.load(in);\r//4,关闭流\rin.close();\r//5,显示集合中的数据\rSystem.out.println(prop);</pre>\r\r<p>注意：使用字符流FileReader就可以完成文件中的中文读取操作了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(919, 'properties.png', 'properties-png', 1533218341, 1533218341, 'a:5:{s:4:"name";s:14:"properties.png";s:4:"path";s:35:"/usr/uploads/2018/08/1903487829.png";s:4:"size";i:92068;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 918, 0),
(920, '对象序列化流ObjectOutputStream', '920', 1533219600, 1533220569, '<p>本文记录Java学习过程中遇到的对象序列化流ObjectOutputStream类～</p>\r<!--more-->\r\r<p>ObjectOutputStream将Java&nbsp;对象的基本数据类型和图形写入OutputStream。可以使用ObjectInputStream&nbsp;读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。</p>\r\r<p>注意：只能将支持java.io.Serializable&nbsp;接口的对象写入流中。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1666064395.png" style="width: 800px;" /></p>\r\r<p>示例代码（测试代码）：</p>\r\r<pre class="brush:java;">\r//1,明确存储对象的文件。\rFileOutputStream fos = new FileOutputStream(&quot;tempfile\\\\obj.object&quot;);\r//2，给操作文件对象加入写入对象功能。\rObjectOutputStream oos = new ObjectOutputStream(fos);\r//3，调用了写入对象的方法。\roos.writeObject(new Person(&quot;wangcai&quot;,20));\r//关闭资源。\roos.close();</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\rpublic class Person implements Serializable {\r	private String name;\r	private int age;\r	public Person() {\r		super();\r	}\r	public Person(String name, int age) {\r		super();\r		this.name = name;\r		this.age = age;\r	}\r\r	public String getName() {\r		return name;\r	}\r	public void setName(String name) {\r		this.name = name;\r	}\r	public int getAge() {\r		return age;\r	}\r	public void setAge(int age) {\r		this.age = age;\r	}\r	@Override\r	public String toString() {\r		return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 92),
(921, 'objectoutputstream.png', 'objectoutputstream-png', 1533220308, 1533220308, 'a:5:{s:4:"name";s:22:"objectoutputstream.png";s:4:"path";s:35:"/usr/uploads/2018/08/1666064395.png";s:4:"size";i:63194;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 920, 0),
(922, '对象反序列化流ObjectInputStream', '922', 1533220560, 1533220893, '<p>本文记录Java学习过程中遇到的对象反序列化流ObjectInputStream～</p>\r<!--more-->\r\r<p>ObjectInputStream&nbsp;对以前使用ObjectOutputStream&nbsp;写入的基本数据和对象进行反序列化。</p>\r\r<p>注意：支持java.io.Serializable接口的对象才能从流读取。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1365356142.png" style="opacity: 0.9; width: 800px; height: 281px;" /></p>\r\r<p>示例代码（测试代码）：</p>\r\r<pre class="brush:java;">\r//1,定义流对象关联存储了对象文件。\rFileInputStream fis = new FileInputStream(&quot;tempfile\\\\obj.object&quot;);\r\r//2,建立用于读取对象的功能对象。\rObjectInputStream ois = new ObjectInputStream(fis);\r		\rPerson obj = (Person)ois.readObject();\rSystem.out.println(obj.toString());</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 87),
(923, 'objectintputstream.png', 'objectintputstream-png', 1533220831, 1533220831, 'a:5:{s:4:"name";s:22:"objectintputstream.png";s:4:"path";s:35:"/usr/uploads/2018/08/1365356142.png";s:4:"size";i:61626;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 922, 0),
(924, '序列化接口', '924', 1533220920, 1533221182, '<p>本文记录Java学习过程中遇到的序列化接口Serializable～</p>\r<!--more-->\r\r<p>当一个对象要能被序列化，这个对象所属的类必须实现Serializable接口。否则会发生异常NotSerializableException异常。</p>\r\r<p>同时当反序列化对象时，如果对象所属的class文件在序列化之后进行的修改，那么进行反序列化也会发生异常InvalidClassException。发生这个异常的原因如下：</p>\r\r<ul>\r	<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配</li>\r	<li>该类包含未知数据类型</li>\r	<li>该类没有可访问的无参数构造方法</li>\r</ul>\r\r<p>Serializable标记接口。该接口给需要序列化的类，提供了一个序列版本号。serialVersionUID.&nbsp;该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class Person implements Serializable {\r	//给类显示声明一个序列版本号。\r	private static final long serialVersionUID = 1L;\r	private String name;\r	private int age;\r	public Person() {\r		super();\r		\r	}\r	public Person(String name, int age) {\r		super();\r		this.name = name;\r		this.age = age;\r	}\r\r	public String getName() {\r		return name;\r	}\r	public void setName(String name) {\r		this.name = name;\r	}\r	public int getAge() {\r		return age;\r	}\r	public void setAge(int age) {\r		this.age = age;\r	}\r	@Override\r	public String toString() {\r		return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(925, '瞬态关键字transient', '925', 1533221220, 1533221333, '<p>本文记录Java学习过程中遇到的瞬态关键字transient～</p>\r<!--more-->\r\r<p>当一个类的对象需要被序列化时，某些属性不需要被序列化，这时不需要序列化的属性可以使用关键字transient修饰。只要被transient修饰了，序列化时这个属性就不会琲序列化了。</p>\r\r<p>同时静态修饰也不会被序列化，因为序列化是把对象数据进行持久化存储，而静态的属于类加载时的数据，不会被序列化。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class Person implements Serializable {\r	/*\r	 * 给类显示声明一个序列版本号。\r	 */\r	private static final long serialVersionUID = 1L;\r	private static String name;\r	private transient/*瞬态*/ int age;\r	\r	public Person() {\r		super();\r		\r	}\r	\r	public Person(String name, int age) {\r		super();\r		this.name = name;\r		this.age = age;\r	}\r\r	public String getName() {\r		return name;\r	}\r	public void setName(String name) {\r		this.name = name;\r	}\r	public int getAge() {\r		return age;\r	}\r	public void setAge(int age) {\r		this.age = age;\r	}\r\r	@Override\r	public String toString() {\r		return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(926, '打印流', '926', 1533222240, 1554022277, '<p>本文记录Java学习过程中遇到的打印流～</p>\r<!--more-->\r\r<p>打印流根据流的分类：</p>\r\r<ul>\r	<li>字节打印流&nbsp;&nbsp;&nbsp;PrintStream</li>\r	<li>字符打印流&nbsp;&nbsp;&nbsp;PrintWriter</li>\r</ul>\r\r<p>方法：</p>\r\r<ul>\r	<li>void print(String&nbsp;str):&nbsp;输出任意类型的数据；</li>\r	<li>void&nbsp;println(String&nbsp;str):&nbsp;输出任意类型的数据，自动写入换行操作。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建流\r//PrintWriter out = new PrintWriter(new FileWriter(&quot;printFile.txt&quot;));\rPrintWriter out = new PrintWriter(&quot;printFile.txt&quot;);\r//写数据\rfor (int i=0; i&lt;5; i++) {\r	out.println(&quot;helloWorld&quot;);\r}\r//关闭流\rout.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(927, '打印流自动刷新', '927', 1533222420, 1533222540, '<p>本文记录Java学习过程中遇到的打印流的自动刷新～</p>\r<!--more-->\r\r<p>可以通过构造方法，完成文件数据的自动刷新功能。</p>\r\r<p>构造方法：</p>\r\r<ul>\r	<li>public PrintWriter(OutputStream out, boolean autoFlush)</li>\r	<li>public PrintWriter(Writer out, boolean autoFlush)</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//创建流\rPrintWriter out = new PrintWriter(new FileWriter(&quot;printFile.txt&quot;), true);\r//2，写数据\rfor (int i=0; i&lt;5; i++) {\r	out.println(&quot;helloWorld&quot;);\r}\r//3,关闭流\rout.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(928, 'FilenameUtils工具类', '928', 1533222720, 1533379045, '<p>本文记录Java学习过程中遇到的commons-IO工具包中的FilenameUtils工具类～</p>\r<!--more-->\r\r<p>这个工具类是用来处理文件名（译者注：包含文件路径）的，他可以轻松解决不同操作系统文件名称规范不同的问题</p>\r\r<p>常用方法：</p>\r\r<ul>\r	<li>getExtension(String path)：获取文件的扩展名；</li>\r	<li>getName()：获取文件名；</li>\r	<li>isExtension(String fileName,String ext)：判断fileName是否是ext后缀名；</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 94),
(929, 'FileUtils工具类', '929', 1533222900, 1533223188, '<p>本文记录Java学习过程中遇到的commons-IO工具包中的FileUtils工具类～</p>\r<!--more-->\r\r<p>提供文件操作（移动文件，读取文件，检查文件是否存在等等）的方法。</p>\r\r<p>常用方法：</p>\r\r<ul>\r	<li>readFileToString(File file)：读取文件内容，并返回一个String；</li>\r	<li>writeStringToFile(File file，String content)：将内容content写入到file中；</li>\r	<li>copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制</li>\r	<li>copyFile(File srcFile,File destFile);文件夹复制</li>\r</ul>\r\r<p>示例代码（文件和文件夹的复制）：</p>\r\r<pre class="brush:java;">\r//通过Commons-IO完成了文件复制的功能\rFileUtils.copyFile(new File(&quot;D:\\\\test.avi&quot;), new File(&quot;D:\\\\copy.avi&quot;));\r		\r//通过Commons-IO完成了文件夹复制的功能\r//D:\\基础班 复制到 C:\\\\abc文件夹下\rFileUtils.copyDirectoryToDirectory(new File(&quot;D:\\\\基础班&quot;), new File(&quot;C:\\\\abc&quot;));</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(930, '多线程', '930', 1533378360, 1533378492, '<p>本文记录Java学习过程中遇到的多线程～</p>\r<!--more-->\r\r<p>学习多线程之前，我们先要了解几个关于多线程有关的概念。</p>\r\r<p>进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>\r\r<p>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>\r\r<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</p>\r\r<p>什么是多线程呢？即就是一个程序中有多个线程在同时执行。</p>\r\r<p>通过下图来区别单线程程序与多线程程序的不同：</p>\r\r<ul>\r	<li>单线程程序：即，若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。如，去网吧上网，网吧只能让一个人上网，当这个人下机后，下一个人才能上网。</li>\r	<li>多线程程序：即，若有多个任务可以同时执行。如，去网吧上网，网吧能够让多个人同时上网。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(931, 'CPU的两种调度方式', '931', 1533378540, 1533378983, '<p>本文记录Java学习过程中遇到的CPU的两种调度方式～</p>\r<!--more-->\r\r<ul>\r	<li>分时调度</li>\r</ul>\r\r<p>所有线程轮流使用CPU&nbsp;的使用权，平均分配每个线程占用CPU&nbsp;的时间。</p>\r\r<ul>\r	<li>抢占式调度</li>\r</ul>\r\r<p>优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1332057873.png" style="width: 800px;" /></p>\r\r<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，&rdquo;感觉这些软件好像在同一时刻运行着&ldquo;。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/338576376.png" style="width: 800px;" /></p>\r\r<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。</p>\r\r<p>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97),
(932, 'diaodu01.png', 'diaodu01-png', 1533378694, 1533378694, 'a:5:{s:4:"name";s:12:"diaodu01.png";s:4:"path";s:35:"/usr/uploads/2018/08/1332057873.png";s:4:"size";i:181226;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 931, 0),
(933, 'diaodu02.png', 'diaodu02-png', 1533378957, 1533378957, 'a:5:{s:4:"name";s:12:"diaodu02.png";s:4:"path";s:34:"/usr/uploads/2018/08/338576376.png";s:4:"size";i:123569;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 931, 0),
(934, '主线程', '934', 1533379080, 1533380356, '<p>本文记录Java学习过程中遇到的主线程～</p>\r<!--more-->\r\r<p>回想我们以前学习中写过的代码，当我们在dos命令行中输入java空格类名回车后，启动JVM，并且加载对应的class文件。虚拟机并会从main方法开始执行我们的程序代码，一直把main方法的代码执行结束。如果在执行过程遇到循环时间比较长的代码，那么在循环之后的其他代码是不会被马上执行的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass Demo{\r	String name;\r	Demo(String name){\r		this.name = name;\r	}\r	void show()	{\r		for (int i=1;i&lt;=10000 ;i++ )		{\r			System.out.println(&quot;name=&quot;+name+&quot;,i=&quot;+i);\r		}\r	}\r}\r\rclass ThreadDemo {\r	public static void main(String[] args) 	{\r	    Demo d = new Demo(&quot;小强&quot;);\r         Demo d2 = new Demo(&quot;旺财&quot;);\r		d.show();		\r		d2.show();\r		System.out.println(&quot;Hello World!&quot;);\r	}\r}</pre>\r\r<p>若在上述代码中show方法中的循环执行次数很多，这时在d.show();下面的代码是不会马上执行的，并且在dos窗口会看到不停的输出name=小强,i=值，这样的语句。为什么会这样呢？</p>\r\r<p>原因是：jvm启动后，必然有一个执行路径(线程)从main方法开始的，一直执行到main方法结束，这个线程在java中称之为主线程。当程序的主线程执行时，如果遇到了循环而导致程序在指定位置停留时间过长，则无法马上执行下面的程序，需要等待循环结束后能够执行。</p>\r\r<p>那么，能否实现一个主线程负责执行其中一个循环，再由另一个线程负责其他代码的执行，最终实现多部分代码同时执行的效果？</p>\r\r<p>能够实现同时执行，通过Java中的多线程技术来解决该问题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(935, 'Thread类', '935', 1533380460, 1533381070, '<p>本文记录Java学习过程中遇到的Thread类～</p>\r<!--more-->\r\r<p>该如何创建线程呢？通过API中搜索，查到Thread类。通过阅读Thread类中的描述。Thread是程序中的执行线程。Java&nbsp;虚拟机允许应用程序并发地运行多个执行线程。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1577477785.png" style="width: 800px; height: 222px;" /></p>\r\r<p>构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2017710839.png" style="width: 800px; height: 143px;" /></p>\r\r<p>常用方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/4015566118.png" style="width: 800px; height: 198px;" /></p>\r\r<p>继续阅读，发现创建新执行线程有两种方法。</p>\r\r<ul>\r	<li>一种方法是将类声明为Thread&nbsp;的子类。该子类应重写Thread&nbsp;类的run&nbsp;方法。创建对象，开启线程。run方法相当于其他线程的main方法。</li>\r	<li>另一种方法是声明一个实现Runnable&nbsp;接口的类。该类然后实现run&nbsp;方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 85),
(936, 'thread01.png', 'thread01-png', 1533380666, 1533380666, 'a:5:{s:4:"name";s:12:"thread01.png";s:4:"path";s:35:"/usr/uploads/2018/08/1577477785.png";s:4:"size";i:21991;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 935, 0),
(937, 'thread02.png', 'thread02-png', 1533380751, 1533380751, 'a:5:{s:4:"name";s:12:"thread02.png";s:4:"path";s:35:"/usr/uploads/2018/08/2017710839.png";s:4:"size";i:18558;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 935, 0),
(938, 'thread03.png', 'thread03-png', 1533380970, 1533380970, 'a:5:{s:4:"name";s:12:"thread03.png";s:4:"path";s:35:"/usr/uploads/2018/08/4015566118.png";s:4:"size";i:48674;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 935, 0),
(939, '创建线程方式一——继承Thread类', '939', 1533381840, 1533382347, '<p>本文记录Java学习过程中遇到的创建线程的方式之一&mdash;&mdash;继承Thread类～</p>\r<!--more-->\r\r<p>创建线程的步骤：</p>\r\r<ol>\r	<li>1&nbsp;定义一个类继承Thread。</li>\r	<li>2&nbsp;重写run方法。</li>\r	<li>3&nbsp;创建子类对象，就是创建线程对象。</li>\r	<li>4&nbsp;调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法。</li>\r</ol>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r//创建自定义线程对象\rMyThread mt = new MyThread(&quot;新的线程！&quot;);\r//开启新线程\rmt.start();\r//在主方法中执行for循环\rfor (int i = 0; i &lt; 10; i++) {\r	System.out.println(&quot;main线程！&quot;+i);\r}</pre>\r\r<p>示例代码（自定义线程类）：</p>\r\r<pre class="brush:java;">\rpublic class MyThread extends Thread {\r	//定义指定线程名称的构造方法\r	public MyThread(String name) {\r		//调用父类的String参数的构造方法，指定线程的名称\r		super(name);\r	}\r	/**\r	 * 重写run方法，完成该线程执行的逻辑\r	 */\r	@Override\r	public void run() {\r		for (int i = 0; i &lt; 10; i++) {\r			System.out.println(getName()+&quot;：正在执行！&quot;+i);\r		}\r	}\r}</pre>\r\r<p>思考：线程对象调用run方法和调用start方法区别？</p>\r\r<p>线程对象调用run方法不开启线程。仅是对象调用方法。线程对象调用start开启线程，并让jvm调用run方法在开启的线程中执行。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(940, '继承Thread类原理', '940', 1533382440, 1533382525, '<p>本文记录Java学习过程中遇到的继承Thread类创建线程的原理～</p>\r<!--more-->\r\r<p>我们为什么要继承Thread类，并调用其的start方法才能开启线程呢？</p>\r\r<p>继承Thread类：因为Thread类用来描述线程，具备线程应该有功能。那为什么不直接创建Thread类的对象呢？</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rThread t1 = new Thread();\rt1.start();//这样做没有错，但是该start调用的是Thread类中的run方法，而这个run方法没有做什么事情，更重要的是这个run方法中并没有定义我们需要让线程执行的代码。</pre>\r\r<p>创建线程的目的是什么？</p>\r\r<p>是为了建立程序单独的执行路径，让多部分代码实现同时执行。也就是说线程创建并执行需要给定线程要执行的任务。</p>\r\r<p>对于之前所讲的主线程，它的任务定义在main函数中。自定义线程需要执行的任务都定义在run方法中。</p>\r\r<p>Thread类run方法中的任务并不是我们所需要的，只有重写这个run方法。既然Thread类已经定义了线程任务的编写位置（run方法），那么只要在编写位置（run方法）中定义任务代码即可。所以进行了重写run方法动作。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 86),
(941, '多线程的内存图解', '941', 1533382620, 1533382859, '<p>本文记录Java学习过程中遇到的多线程的内存图解～</p>\r<!--more-->\r\r<p>多线程执行时，到底在内存中是如何运行的呢？</p>\r\r<p>以上个程序为例，进行图解说明：</p>\r\r<p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1647259648.png" style="width: 800px; height: 621px;" /></p>\r\r<p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(942, 'tujie.png', 'tujie-png-1', 1533382785, 1533382785, 'a:5:{s:4:"name";s:9:"tujie.png";s:4:"path";s:35:"/usr/uploads/2018/08/1647259648.png";s:4:"size";i:81191;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 941, 0),
(943, '获取线程名称', '943', 1533383280, 1533383292, '<p>本文记录Java学习过程中遇到的获取进程名称～</p>\r<!--more-->\r\r<p>开启的线程都会有自己的独立运行栈内存，那么这些运行的线程的名字是什么呢？该如何获取呢？既然是线程的名字，按照面向对象的特点，是哪个对象的属性和谁的功能，那么我们就去找那个对象就可以了。查阅Thread类的API文档发现有个方法是获取当前正在运行的线程对象。还有个方法是获取当前线程对象的名称。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/463739234.png" style="width: 800px; height: 156px;" /></p>\r\r<ul>\r	<li>Thread.currentThread()获取当前线程对象</li>\r	<li>Thread.currentThread().getName();获取当前线程对象的名称</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass MyThread extends Thread {  //继承Thread\r	MyThread(String name){\r		super(name);\r	}\r	//复写其中的run方法\r	public void run(){\r		for (int i=1;i&lt;=20 ;i++ ){\r			System.out.println(Thread.currentThread().getName()+&quot;,i=&quot;+i);\r		}\r	}\r}\rclass ThreadDemo {\r	public static void main(String[] args) 	{\r		//创建两个线程任务\r		MyThread d = new MyThread();\r		MyThread d2 = new MyThread();\r		d.run();//没有开启新线程, 在主线程调用run方法\r		d2.start();//开启一个新线程，新线程调用run方法\r	}\r}</pre>\r\r<p>通过结果观察，原来主线程的名称：main；自定义的线程：Thread-0，线程多个时，数字顺延。如Thread-1......</p>\r\r<p>进行多线程编程时，不要忘记了Java程序运行是从主线程开始，main方法就是主线程的线程执行内容。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(945, 'getname.png', 'getname-png', 1533383133, 1533383133, 'a:5:{s:4:"name";s:11:"getname.png";s:4:"path";s:34:"/usr/uploads/2018/08/463739234.png";s:4:"size";i:21632;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 943, 0),
(946, '创建线程方式二——实现Runnable接口', '946', 1533383460, 1533384869, '<p>本文记录Java学习过程中遇到的创建线程的方式之一&mdash;&mdash;实现Runnable接口～</p>\r<!--more-->\r\r<p>创建线程的另一种方法是声明实现Runnable&nbsp;接口的类。该类然后实现run&nbsp;方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</p>\r\r<p>为何要实现Runnable接口，Runable是啥玩意呢？继续API搜索。</p>\r\r<p>查看Runnable接口说明文档：Runnable接口用来指定每个线程要执行的任务。包含了一个run&nbsp;的无参数抽象方法，需要由接口实现类重写该方法。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/595629316.png" style="width: 800px; height: 153px;" /></p>\r\r<p>接口中的方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3595952558.png" style="width: 800px; height: 75px;" /></p>\r\r<p>Thread类构造方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/4170837723.png" style="width: 800px; height: 104px;" /></p>\r\r<p>创建线程的步骤：</p>\r\r<ol>\r	<li>1、定义类实现Runnable接口。</li>\r	<li>2、覆盖接口中的run方法。。</li>\r	<li>3、创建Thread类的对象</li>\r	<li>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。</li>\r	<li>5、调用Thread类的start方法开启线程。</li>\r</ol>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r//创建线程执行目标类对象\rRunnable runn = new MyRunnable();\r//将Runnable接口的子类对象作为参数传递给Thread类的构造函数\rThread thread = new Thread(runn);\rThread thread2 = new Thread(runn);\r//开启线程\rthread.start();\rthread2.start();\rfor (int i = 0; i &lt; 10; i++) {\r	System.out.println(&quot;main线程：正在执行！&quot;+i);\r}</pre>\r\r<p>示例代码（自定义线程类）：</p>\r\r<pre class="brush:java;">\rpublic class MyRunnable implements Runnable{\r\r	//定义线程要执行的run方法逻辑\r	@Override\r	public void run() {\r		\r		for (int i = 0; i &lt; 10; i++) {\r			System.out.println(&quot;我的线程：正在执行！&quot;+i);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(947, 'runnable01.png', 'runnable01-png', 1533383761, 1533383761, 'a:5:{s:4:"name";s:14:"runnable01.png";s:4:"path";s:34:"/usr/uploads/2018/08/595629316.png";s:4:"size";i:20758;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 946, 0),
(948, 'runnable02.png', 'runnable02-png', 1533383851, 1533383851, 'a:5:{s:4:"name";s:14:"runnable02.png";s:4:"path";s:35:"/usr/uploads/2018/08/3595952558.png";s:4:"size";i:21760;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 946, 0),
(949, 'runnable03.png', 'runnable03-png', 1533383924, 1533383924, 'a:5:{s:4:"name";s:14:"runnable03.png";s:4:"path";s:35:"/usr/uploads/2018/08/4170837723.png";s:4:"size";i:23785;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 946, 0),
(950, '实现Runnable原理', '950', 1533384120, 1533384275, '<p>本文记录Java学习过程中遇到的实现Runnable接口创建线程的原理～</p>\r<!--more-->\r\r<p>为什么需要定一个类去实现Runnable接口呢？继承Thread类和实现Runnable接口有啥区别呢？</p>\r\r<p>实现Runnable接口，避免了继承Thread类的单继承局限性。覆盖Runnable接口中的run方法，将线程任务代码定义到run方法中。</p>\r\r<p>创建Thread类的对象，只有创建Thread类的对象才可以创建线程。线程任务已被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要运行的线程的任务。</p>\r\r<p>实现Runnable的好处：第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分线程对象，一部分线程任务。继承Thread类，线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，既是线程对象，有又有线程任务。实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(951, '线程的匿名内部类', '951', 1533384300, 1533384526, '<p>本文记录Java学习过程中遇到的线程的匿名内部类～</p>\r<!--more-->\r\r<p>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作：</p>\r\r<ul>\r	<li>方式1：创建线程对象时，直接重写Thread类中的run方法：</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rnew Thread() {\r	public void run() {\r		for (int x = 0; x &lt; 40; x++) {\r			System.out.println(Thread.currentThread().getName()\r					+ &quot;...X....&quot; + x);\r		}\r	}\r}.start();</pre>\r\r<ul>\r	<li>方式2：使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rRunnable r = new Runnable() {\r	public void run() {\r		for (int x = 0; x &lt; 40; x++) {\r			System.out.println(Thread.currentThread().getName()\r					+ &quot;...Y....&quot; + x);\r		}\r	}\r};\rnew Thread(r).start();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 83),
(952, '线程池', '952', 1533384600, 1554024223, '<p>本文记录Java学习过程中遇到的线程池～</p>\r<!--more-->\r\r<p>线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1862273705.png" style="width: 800px; height: 491px;" /></p>\r\r<p>我们详细的解释一下为什么要使用线程池？</p>\r\r<p>在Java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个JVM里创建太多的线程，可能会使系统由于过度消耗内存或&ldquo;切换过度&rdquo;而导致系统资源不足。为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。</p>\r\r<p>线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(953, 'thread-pool.png', 'thread-pool-png', 1533384776, 1533384776, 'a:5:{s:4:"name";s:15:"thread-pool.png";s:4:"path";s:35:"/usr/uploads/2018/08/1862273705.png";s:4:"size";i:69657;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 952, 0),
(954, '使用线程池方式一——Runnable接口', '954', 1533385380, 1533386805, '<p>本文记录Java学习过程中遇到的线程池的使用方式之一&mdash;&mdash;Runnable接口～</p>\r<!--more-->\r\r<p>通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。</p>\r\r<p>Executors：线程池创建工厂类</p>\r\r<ul>\r	<li>public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象</li>\r</ul>\r\r<p>ExecutorService：线程池类</p>\r\r<ul>\r	<li>Future&lt;?&gt;&nbsp;submit(Runnable&nbsp;task)：获取线程池中的某一个线程对象，并执行</li>\r</ul>\r\r<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用</p>\r\r<p>使用线程池中线程对象的步骤：</p>\r\r<ol>\r	<li>创建线程池对象</li>\r	<li>创建Runnable接口子类对象</li>\r	<li>提交Runnable接口子类对象</li>\r	<li>关闭线程池</li>\r</ol>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r//创建线程池对象\rExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象\r//创建Runnable实例对象\rMyRunnable r = new MyRunnable();\r		\r//自己创建线程对象的方式\r//Thread t = new Thread(r);\r//t.start(); ---&gt; 调用MyRunnable中的run()\r		\r//从线程池中获取线程对象,然后调用MyRunnable中的run()\rservice.submit(r);\r//再获取个线程对象，调用MyRunnable中的run()\rservice.submit(r);\rservice.submit(r);\r//注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中\r\r//关闭线程池\r//service.shutdown();</pre>\r\r<p>示例代码（Runnable接口实现类）：</p>\r\r<pre class="brush:java;">\rpublic class MyRunnable implements Runnable {\r	@Override\r	public void run() {\r		System.out.println(&quot;我要一个教练&quot;);\r		\r		try {\r			Thread.sleep(2000);\r		} catch (InterruptedException e) {\r			e.printStackTrace();\r		}\r		System.out.println(&quot;教练来了： &quot; +Thread.currentThread().getName());\r		System.out.println(&quot;教我游泳,交完后，教练回到了游泳池&quot;);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130),
(955, '使用线程池方式二——Callable接口', '955', 1533386040, 1533386590, '<p>本文记录Java学习过程中遇到的线程池的使用方式之一&mdash;&mdash;Callable接口～</p>\r<!--more-->\r\r<p>Callable接口：与Runnable接口功能相似，用来指定线程的任务。其中的call()方法，用来返回线程任务执行完毕后的结果，call方法可抛出异常。</p>\r\r<p>ExecutorService：线程池类</p>\r\r<ul>\r	<li>&lt;T&gt; Future&lt;T&gt;&nbsp;submit(Callable&lt;T&gt;&nbsp;task)：获取线程池中的某一个线程对象，并执行线程中的call()方法</li>\r</ul>\r\r<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用</p>\r\r<p>使用线程池中线程对象的步骤：</p>\r\r<ol>\r	<li>创建线程池对象</li>\r	<li>创建Callable接口子类对象</li>\r	<li>提交Callable接口子类对象</li>\r	<li>关闭线程池</li>\r</ol>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r//创建线程池对象\rExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象\r//创建Callable对象\rMyCallable c = new MyCallable();\r		\r//从线程池中获取线程对象,然后调用MyRunnable中的run()\rservice.submit(c);\r	\r//再获取个教练\rservice.submit(c);\rservice.submit(c);\r//注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中\r\r//关闭线程池\r//service.shutdown();</pre>\r\r<p>示例代码（Callable接口实现类）：</p>\r\r<pre class="brush:java;">\rpublic class MyCallable implements Callable {\r	@Override\r	public Object call() throws Exception {\r		System.out.println(&quot;我要一个教练:call&quot;);\r		Thread.sleep(2000);\r		System.out.println(&quot;教练来了： &quot; +Thread.currentThread().getName());\r		System.out.println(&quot;教我游泳,交完后,教练回到了游泳池&quot;);\r		return null;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(956, '线程安全', '956', 1534059360, 1534059699, '<p>本文记录Java学习过程中遇到的线程安全～</p>\r<!--more-->\r\r<p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>\r\r<p>我们通过一个案例，演示线程的安全问题：</p>\r\r<p>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是&ldquo;功夫熊猫3&rdquo;，本次电影的座位共100个(本场电影只能卖100张票)。我们来模拟电影院的售票窗口，实现多个窗口同时卖&ldquo;功夫熊猫3&rdquo;这场电影票(多个窗口一起卖这100张票)。需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟。</p>\r\r<p>示例代码（模拟票）：</p>\r\r<pre class="brush:java;">\rpublic class Ticket implements Runnable {\r	//共100票\r	int ticket = 100;\r\r	@Override\r	public void run() {\r		//模拟卖票\r		while(true){\r			if (ticket &gt; 0) {\r				//模拟选坐的操作\r				try {\r					Thread.sleep(1);\r				} catch (InterruptedException e) {\r					e.printStackTrace();\r				}\r				System.out.println(Thread.currentThread().getName() + &quot;正在卖票:&quot; + ticket--);\r			}\r		}\r	}\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r//创建票对象\rTicket ticket = new Ticket();\r\r//创建3个窗口\rThread t1  = new Thread(ticket, &quot;窗口1&quot;);\rThread t2  = new Thread(ticket, &quot;窗口2&quot;);\rThread t3  = new Thread(ticket, &quot;窗口3&quot;);\r		\rt1.start();\rt2.start();\rt3.start();</pre>\r\r<p>运行结果：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2106282124.png" style="width: 800px; height: 132px;" /></p>\r\r<p>运行结果发现：上面程序出现了问题</p>\r\r<ul>\r	<li>票出现了重复的票</li>\r	<li>错误的票0、-1</li>\r</ul>\r\r<p>其实，线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(957, '线程安全.png', '线程安全-png', 1534059646, 1534059646, 'a:5:{s:4:"name";s:16:"线程安全.png";s:4:"path";s:35:"/usr/uploads/2018/08/2106282124.png";s:4:"size";i:17099;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 956, 0),
(958, '线程同步', '958', 1534059720, 1534060207, '<p>本文记录Java学习过程中遇到的线程同步～</p>\r<!--more-->\r\r<p>Java中提供了线程同步机制，它能够解决上述的线程安全问题。</p>\r\r<p>线程同步的方式有两种：</p>\r\r<ul>\r	<li>方式1：同步代码块</li>\r	<li>方式2：同步方法</li>\r</ul>\r\r<h3><strong>一、同步代码块</strong></h3>\r\r<ul>\r	<li>同步代码块:&nbsp;在代码块声明上加上synchronized</li>\r</ul>\r\r<pre class="brush:java;">\rsynchronized (锁对象) {\r	可能会产生线程安全问题的代码\r}</pre>\r\r<p>同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。</p>\r\r<p>示例代码（使用同步代码块修改后的电影院卖票）：</p>\r\r<pre class="brush:java;">\rpublic class Ticket implements Runnable {\r	//共100票\r	int ticket = 100;\r	//定义锁对象\r	Object lock = new Object();\r	@Override\r	public void run() {\r		//模拟卖票\r		while(true){\r			//同步代码块\r			synchronized (lock){\r				if (ticket &gt; 0) {\r					//模拟电影选坐的操作\r					try {\r						Thread.sleep(10);\r					} catch (InterruptedException e) {\r						e.printStackTrace();\r					}\r					System.out.println(Thread.currentThread().getName() + &quot;正在卖票:&quot; + ticket--);\r				}\r			}\r		}\r	}\r}</pre>\r\r<p>当使用了同步代码块后，上述的线程的安全问题，解决了。</p>\r\r<h3><strong>二、同步方法</strong></h3>\r\r<ul>\r	<li>同步方法：在方法声明上加上synchronized</li>\r</ul>\r\r<pre class="brush:java;">\rpublic synchronized void method(){\r   	//可能会产生线程安全问题的代码\r}</pre>\r\r<p>同步方法中的锁对象是this。</p>\r\r<p>示例代码（使用同步方法修改后的电影院卖票）：</p>\r\r<pre class="brush:java;">\rpublic class Ticket implements Runnable {\r	//共100票\r	int ticket = 100;\r	//定义锁对象\r	Object lock = new Object();\r	@Override\r	public void run() {\r		//模拟卖票\r		while(true){\r			//同步方法\r			method();\r		}\r	}\r\r//同步方法,锁对象this\r	public synchronized void method(){\r		if (ticket &gt; 0) {\r			//模拟选坐的操作\r			try {\r				Thread.sleep(10);\r			} catch (InterruptedException e) {\r				e.printStackTrace();\r			}\r			System.out.println(Thread.currentThread().getName() + &quot;正在卖票:&quot; + ticket--);\r		}\r	}\r}</pre>\r\r<ul>\r	<li>静态同步方法:&nbsp;在方法声明上加上static synchronized</li>\r</ul>\r\r<pre class="brush:java;">\rpublic static synchronized void method(){\r    //可能会产生线程安全问题的代码\r}</pre>\r\r<p>静态同步方法中的锁对象是类名.class。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(959, '死锁', '959', 1534060260, 1534060418, '<p>本文记录Java学习过程中遇到的死锁～</p>\r<!--more-->\r\r<p>同步锁使用的弊端：当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。</p>\r\r<pre class="brush:java;">\rsynchronzied(A锁){\r	synchronized(B锁){\r         \r        }\r}</pre>\r\r<p>示例代码（锁对象类）：</p>\r\r<pre class="brush:java;">\rpublic class MyLock {\r	public static final Object lockA = new Object();\r	public static final Object lockB = new Object();\r}</pre>\r\r<p>示例代码（线程任务类）：</p>\r\r<pre class="brush:java;">\rpublic class ThreadTask implements Runnable {\r	int x = new Random().nextInt(1);//0,1\r	//指定线程要执行的任务代码\r	@Override\r	public void run() {\r		while(true){\r			if (x%2 ==0) {\r				//情况一\r				synchronized (MyLock.lockA) {\r					System.out.println(&quot;if-LockA&quot;);\r					synchronized (MyLock.lockB) {\r						System.out.println(&quot;if-LockB&quot;);\r						System.out.println(&quot;if大口吃肉&quot;);\r					}\r				}\r			} else {\r				//情况二\r				synchronized (MyLock.lockB) {\r					System.out.println(&quot;else-LockB&quot;);\r					synchronized (MyLock.lockA) {\r						System.out.println(&quot;else-LockA&quot;);\r						System.out.println(&quot;else大口吃肉&quot;);\r					}\r				}\r			}\r			x++;\r		}\r	}\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r//创建线程任务类对象\rThreadTask task = new ThreadTask();\r//创建两个线程\rThread t1 = new Thread(task);\rThread t2 = new Thread(task);\r//启动线程\rt1.start();\rt2.start();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 107),
(960, 'Lock接口', '960', 1534060440, 1534061170, '<p>本文记录Java学习过程中遇到的Lock接口～</p>\r<!--more-->\r\r<p>查阅API，查阅Lock接口描述，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。</p>\r\r<p>Lock接口中的常用方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2444300138.png" style="width: 800px; height: 138px;" /></p>\r\r<p>Lock提供了一个更加面对对象的锁，在该锁中提供了更多的操作锁的功能。</p>\r\r<p>示例代码（电影院卖票）：</p>\r\r<pre class="brush:java;">\rpublic class Ticket implements Runnable {\r	//共100票\r	int ticket = 100;\r	\r	//创建Lock锁对象\r	Lock ck = new ReentrantLock();\r	\r	@Override\r	public void run() {\r		//模拟卖票\r		while(true){\r			//synchronized (lock){\r			ck.lock();\r				if (ticket &gt; 0) {\r					//模拟选坐的操作\r					try {\r						Thread.sleep(10);\r					} catch (InterruptedException e) {\r						e.printStackTrace();\r					}\r					System.out.println(Thread.currentThread().getName() + &quot;正在卖票:&quot; + ticket--);\r				}\r			ck.unlock();\r			//}\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(961, 'lock.png', 'lock-png', 1534061066, 1534061066, 'a:5:{s:4:"name";s:8:"lock.png";s:4:"path";s:35:"/usr/uploads/2018/08/2444300138.png";s:4:"size";i:12077;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 960, 0),
(962, '等待与唤醒', '962', 1534061220, 1534061631, '<p>本文记录Java学习过程中遇到的等待与唤醒机制～</p>\r<!--more-->\r\r<p>在开始讲解等待唤醒机制之前，有必要搞清一个概念&mdash;&mdash;线程之间的通信：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。通过一定的手段使各个线程能有效的利用资源,而这种手段j就是等待与唤醒机制。</p>\r\r<p>该机制所涉及到的方法：</p>\r\r<ul>\r	<li>wait（）:等待，将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。</li>\r	<li>notify（）：唤醒，唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。</li>\r	<li>notifyAll（）： 唤醒全部：可以将线程池中的所有wait()&nbsp;线程都唤醒。</li>\r</ul>\r\r<p>其实，所谓唤醒的意思就是让线程池中的线程具备执行资格。必须注意的是，这些方法都是在同步中才有效。同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。</p>\r\r<p>仔细查看JavaAPI之后，发现这些方法并不定义在Thread中，也没定义在Runnable接口中，却被定义在了Object类中，为什么这些操作线程的方法定义在Object类中？</p>\r\r<p>因为这些方法在使用时，必须要标明所属的锁，而锁又可以是任意对象。能被任意对象调用的方法一定定义在Object类中。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/4268070977.png" style="width: 800px; height: 153px;" /></p>\r\r<p>接下里，我们先从一个简单的示例入手：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/984192037.png" style="width: 800px; height: 282px;" /></p>\r\r<p>如上图说示，输入线程向Resource中输入name ,sex ,&nbsp;输出线程从资源中输出，先要完成的任务是：</p>\r\r<ol>\r	<li>当input发现Resource中没有数据时，开始输入，输入完成后，叫output来输出。如果发现有数据，就wait();</li>\r	<li>当output发现Resource中没有数据时，就wait()&nbsp;；当发现有数据时，就输出，然后，叫醒input来输入数据。</li>\r</ol>\r\r<p>示例代码（模拟资源类）：</p>\r\r<pre class="brush:java;">\rpublic class Resource {\r	private String name;\r	private String sex;\r	private boolean flag = false;\r\r	public synchronized void set(String name, String sex) {\r		if (flag)\r			try {\r				wait();\r			} catch (InterruptedException e) {\r				e.printStackTrace();\r			}\r		// 设置成员变量\r		this.name = name;\r		this.sex = sex;\r		// 设置之后，Resource中有值，将标记该为 true ,\r		flag = true;\r		// 唤醒output\r		this.notify();\r	}\r\r	public synchronized void out() {\r		if (!flag)\r			try {\r				wait();\r			} catch (InterruptedException e) {\r				e.printStackTrace();\r			}\r		// 输出线程将数据输出\r		System.out.println(&quot;姓名: &quot; + name + &quot;，性别: &quot; + sex);\r		// 改变标记，以便输入线程输入数据\r		flag = false;\r		// 唤醒input，进行数据输入\r		this.notify();\r	}\r}</pre>\r\r<p>示例代码（输入线程类）：</p>\r\r<pre class="brush:java;">\rpublic class Input implements Runnable {\r	private Resource r;\r\r	public Input(Resource r) {\r		this.r = r;\r	}\r\r	@Override\r	public void run() {\r		int count = 0;\r		while (true) {\r			if (count == 0) {\r				r.set(&quot;小明&quot;, &quot;男生&quot;);\r			} else {\r				r.set(&quot;小花&quot;, &quot;女生&quot;);\r			}\r			// 在两个数据之间进行切换\r			count = (count + 1) % 2;\r		}\r	}\r}</pre>\r\r<p>示例代码（输出线程类）：</p>\r\r<pre class="brush:java;">\rpublic class Output implements Runnable {\r	private Resource r;\r\r	public Output(Resource r) {\r		this.r = r;\r	}\r\r	@Override\r	public void run() {\r		while (true) {\r			r.out();\r		}\r	}\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\rpublic class ResourceDemo {\r	public static void main(String[] args) {\r		// 资源对象\r		Resource r = new Resource();\r		// 任务对象\r		Input in = new Input(r);\r		Output out = new Output(r);\r		// 线程对象\r		Thread t1 = new Thread(in);\r		Thread t2 = new Thread(out);\r		// 开启线程\r		t1.start();\r		t2.start();\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(963, 'fangfa.png', 'fangfa-png-3', 1534061363, 1534061363, 'a:5:{s:4:"name";s:10:"fangfa.png";s:4:"path";s:35:"/usr/uploads/2018/08/4268070977.png";s:4:"size";i:26806;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 962, 0),
(964, 'resource-input-output.png', 'resource-input-output-png', 1534061434, 1534061434, 'a:5:{s:4:"name";s:25:"resource-input-output.png";s:4:"path";s:34:"/usr/uploads/2018/08/984192037.png";s:4:"size";i:30614;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 962, 0),
(965, '数据库', '965', 1534079160, 1534079399, '<p>本文记录MySQL学习过程中遇到的数据库概述～</p>\r<!--more-->\r\r<ul>\r	<li>什么是数据库</li>\r</ul>\r\r<p>数据库就是存储数据的仓库，其本质是一个文件系统，数据按照特定的格式将数据存储起来，用户可以对数据库中的数据进行增加，修改，删除及查询操作。</p>\r\r<ul>\r	<li>什么是数据库管理系统</li>\r</ul>\r\r<p>数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中表内的数据。</p>\r\r<ul>\r	<li>常见的数据库管理系统</li>\r</ul>\r\r<p>MYSQL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。</p>\r\r<p>Oracle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。</p>\r\r<p>DB2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：IBM公司的数据库产品,收费的。常应用在银行系统中.</p>\r\r<p>SQLServer：MicroSoft&nbsp;公司收费的中型的数据库。C#、.net等语言常使用。</p>\r\r<p>SyBase&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。</p>\r\r<p>SQLite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;嵌入式的小型数据库，应用在手机端。</p>\r\r<p>Java相关的数据库：MYSQL，Oracle．</p>\r\r<p>这里使用MySQL数据库。MySQL中可以有多个数据库，数据库是真正存储数据的地方。</p>\r\r<ul>\r	<li>数据库与数据库管理系统的关系</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3231916695.png" style="width: 796px; height: 455px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 87),
(966, 'relation.png', 'relation-png', 1534079295, 1534079295, 'a:5:{s:4:"name";s:12:"relation.png";s:4:"path";s:35:"/usr/uploads/2018/08/3231916695.png";s:4:"size";i:73325;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 965, 0),
(967, '数据库表', '967', 1534079460, 1554024767, '<p>本文记录MySQL学习过程中遇到的数据库表～</p>\r<!--more-->\r\r<p>数据库中以表为组织单位存储数据。</p>\r\r<p>表类似我们的Java类，每个字段都有对应的数据类型。</p>\r\r<p>那么用我们熟悉的java程序来与关系型数据对比，就会发现以下对应关系：</p>\r\r<pre class="brush:java;">\r类----------表\r\r类中属性-----表中字段\r\r对象--------记录</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(968, '记录', '968', 1534079580, 1534079807, '<p>本文记录MySQL学习过程中遇到的记录～</p>\r<!--more-->\r\r<p>根据表字段所规定的数据类型，我们可以向其中填入一条条的数据，而表中的每条数据类似类的实例对象。表中的一行一行的信息我们称之为记录。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2410543293.png" /></p>\r\r<p>表记录与java类对象的对应关系：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1402704827.png" style="width: 800px; height: 405px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 86),
(969, 'record.png', 'record-png', 1534079702, 1534079702, 'a:5:{s:4:"name";s:10:"record.png";s:4:"path";s:35:"/usr/uploads/2018/08/2410543293.png";s:4:"size";i:54971;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 968, 0),
(970, 'compare.png', 'compare-png-2', 1534079788, 1534079788, 'a:5:{s:4:"name";s:11:"compare.png";s:4:"path";s:35:"/usr/uploads/2018/08/1402704827.png";s:4:"size";i:143236;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 968, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(971, 'MySQL的安装', '971', 1534085880, 1534087417, '<p>本文记录MySQL学习过程中遇到的MySQL的安装～</p>\r<!--more-->\r\r<p>1. 打开下载的mysql安装文件mysql-5.5.27-win32.zip，双击解压缩，运行&ldquo;setup.exe&rdquo;。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1182129454.png" style="width: 800px; height: 550px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3611129534.png" style="width: 800px; height: 559px;" /></p>\r\r<p>2.&nbsp;选择安装类型，有&ldquo;Typical（默认）&rdquo;、&ldquo;Complete（完全）&rdquo;、&ldquo;Custom（用户自定义）&rdquo;三个选项，选择&ldquo;Custom&rdquo;，按&ldquo;next&rdquo;键继续。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1309712160.png" style="width: 800px; height: 572px;" /></p>\r\r<p>3.&nbsp;点选&ldquo;Browse&rdquo;，手动指定安装目录。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3876227872.png" style="width: 800px; height: 563px;" /></p>\r\r<p>4.&nbsp;填上安装目录，我的是&ldquo;F:\\Server\\MySQL\\MySQL Server 5.0&rdquo;，也建议不要放在与操作系统同一分区，这样可以防止系统备份还原的时候，数据被清空。按&ldquo;OK&rdquo;继续。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1547881195.png" style="width: 800px; height: 557px;" /></p>\r\r<p>确认一下先前的设置，如果有误，按&ldquo;Back&rdquo;返回重做。按&ldquo;Install&rdquo;开始安装。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/4220319539.png" style="width: 800px; height: 563px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2731315072.png" style="width: 800px; height: 560px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3082193221.png" style="width: 800px; height: 559px;" /></p>\r\r<p>5.&nbsp;正在安装中，请稍候，直到出现下面的界面,&nbsp;则完成MYSQL的安装。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2103468547.png" style="width: 800px; height: 556px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(972, '001.png', '001-png-8', 1534086087, 1534086087, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2018/08/1182129454.png";s:4:"size";i:202536;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(973, '002.png', '002-png-4', 1534086151, 1534086151, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/08/3611129534.png";s:4:"size";i:190607;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(974, '003.png', '003-png-4', 1534086282, 1534086282, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:35:"/usr/uploads/2018/08/1309712160.png";s:4:"size";i:136937;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(975, '004.png', '004-png-2', 1534086386, 1534086386, 'a:5:{s:4:"name";s:7:"004.png";s:4:"path";s:35:"/usr/uploads/2018/08/3876227872.png";s:4:"size";i:174327;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(976, '005.png', '005-png-3', 1534086521, 1534086521, 'a:5:{s:4:"name";s:7:"005.png";s:4:"path";s:35:"/usr/uploads/2018/08/1547881195.png";s:4:"size";i:99533;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(977, '006.png', '006-png-2', 1534086725, 1534086725, 'a:5:{s:4:"name";s:7:"006.png";s:4:"path";s:35:"/usr/uploads/2018/08/4220319539.png";s:4:"size";i:172369;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(978, '007.png', '007-png-2', 1534086782, 1534086782, 'a:5:{s:4:"name";s:7:"007.png";s:4:"path";s:35:"/usr/uploads/2018/08/2731315072.png";s:4:"size";i:89128;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(979, '008.png', '008-png-1', 1534086832, 1534086832, 'a:5:{s:4:"name";s:7:"008.png";s:4:"path";s:35:"/usr/uploads/2018/08/3082193221.png";s:4:"size";i:79487;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 8, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(980, '009.png', '009-png-1', 1534086977, 1534086977, 'a:5:{s:4:"name";s:7:"009.png";s:4:"path";s:35:"/usr/uploads/2018/08/2103468547.png";s:4:"size";i:191325;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 9, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 971, 0),
(981, 'MySQL的配置', '981', 1534087440, 1534090809, '<p>本文记录MySQL学习过程中遇到的MySQL的安装～​</p>\r<!--more-->\r\r<p>1.&nbsp;安装完成了，出现如下界面将进入mysql配置向导。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3330047777.png" style="width: 800px; height: 537px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1380244851.png" style="width: 800px; height: 553px;" /></p>\r\r<p>2.&nbsp;选择配置方式，&ldquo;Detailed Configuration（手动精确配置）&rdquo;、&ldquo;Standard Configuration（标准配置）&rdquo;，我们选择&ldquo;Detailed Configuration&rdquo;，方便熟悉配置过程。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2439731243.png" style="width: 800px; height: 541px;" /></p>\r\r<p>3.&nbsp;选择服务器类型，&ldquo;Developer Machine（开发测试类，mysql占用很少资源）&rdquo;、&ldquo;Server Machine（服务器类型，mysql占用较多资源）&rdquo;、&ldquo;Dedicated MySQL Server Machine（专门的数据库服务器，mysql占用所有可用资源）&rdquo;。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2249671847.png" style="width: 800px; height: 550px;" /></p>\r\r<p>4.&nbsp;选择mysql数据库的大致用途，&ldquo;Multifunctional Database（通用多功能型，好）&rdquo;、&ldquo;Transactional Database Only（服务器类型，专注于事务处理，一般）&rdquo;、&ldquo;Non-Transactional Database Only（非事务处理型，较简单，主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional），按&ldquo;Next&rdquo;继续。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2638646960.png" style="width: 800px; height: 547px;" /></p>\r\r<p>5.&nbsp;选择网站并发连接数，同时连接的数目，&ldquo;Decision Support(DSS)/OLAP（20个左右）&rdquo;、&ldquo;Online Transaction Processing(OLTP)（500个左右）&rdquo;、&ldquo;Manual Setting（手动设置，自己输一个数）&rdquo;。&nbsp;</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2414272719.png" style="width: 800px; height: 547px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3335153089.png" style="width: 800px; height: 552px;" /></p>\r\r<p>6.&nbsp;是否启用TCP/IP连接，设定端口，如果不启用，就只能在自己的机器上访问mysql数据库了，在这个页面上，您还可以选择&ldquo;启用标准模式&rdquo;（Enable Strict Mode），这样MySQL就不会允许细小的语法错误。如果是新手，建议您取消标准模式以减少麻烦。但熟悉MySQL以后，尽量使用标准模式，因为它可以降低有害数据进入数据库的可能性。按&ldquo;Next&rdquo;继续。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2850692956.png" style="width: 800px; height: 545px;" /></p>\r\r<p>7.&nbsp;就是对mysql默认数据库语言编码进行设置（重要），一般选UTF-8，按&ldquo;Next&rdquo;继续。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/758587349.png" style="width: 800px; height: 553px;" /></p>\r\r<p>8.&nbsp;选择是否将mysql安装为windows服务，还可以指定Service Name（服务标识名称），是否将mysql的bin目录加入到Windows PATH（加入后，就可以直接使用bin下的文件，而不用指出目录名，比如连接，&ldquo;mysql.exe -uusername -ppassword;&rdquo;就可以了，不用指出mysql.exe的完整地址，很方便），我这里全部打上了勾，Service Name不变。按&ldquo;Next&rdquo;继续。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2578603525.png" style="width: 800px; height: 537px;" /></p>\r\r<p>9.&nbsp;询问是否要修改默认root用户（超级管理）的密码。&ldquo;Enable root access from remote machines（是否允许root用户在其它的机器上登陆，如果要安全，就不要勾上，如果要方便，就勾上它）&rdquo;。最后&ldquo;Create An Anonymous Account（新建一个匿名用户，匿名用户可以连接数据库，不能操作数据，包括查询）&rdquo;，一般就不用勾了，设置完毕，按&ldquo;Next&rdquo;继续。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1699236513.png" style="width: 800px; height: 549px;" /></p>\r\r<p>10.&nbsp;确认设置无误，按&ldquo;Execute&rdquo;使设置生效，即完成MYSQL的安装和配置。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2735055631.png" style="width: 800px; height: 541px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2872551656.png" style="width: 800px; height: 543px;" /></p>\r\r<p>注意：设置完毕，按&ldquo;Finish&rdquo;后有一个比较常见的错误，就是不能&ldquo;Start service&rdquo;，一般出现在以前有安装mysql的服务器上，解决的办法，先保证以前安装的mysql服务器彻底卸载掉了；不行的话，检查是否按上面一步所说，之前的密码是否有修改，照上面的操作；如果依然不行，将mysql安装目录下的data文件夹备份，然后删除，在安装完成后，将安装生成的data文件夹删除，备份的data文件夹移回来，再重启mysql服务就可以了，这种情况下，可能需要将数据库检查一下，然后修复一次，防止数据出错。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(982, '001.png', '001-png-9', 1534087626, 1534087626, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2018/08/3330047777.png";s:4:"size";i:191657;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(983, '002.png', '002-png-5', 1534087675, 1534087675, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/08/1380244851.png";s:4:"size";i:187614;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(984, '003.png', '003-png-5', 1534087805, 1534087805, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:35:"/usr/uploads/2018/08/2439731243.png";s:4:"size";i:177318;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(985, '004.png', '004-png-3', 1534087883, 1534087883, 'a:5:{s:4:"name";s:7:"004.png";s:4:"path";s:35:"/usr/uploads/2018/08/2249671847.png";s:4:"size";i:248091;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(986, '005.png', '005-png-4', 1534087982, 1534087982, 'a:5:{s:4:"name";s:7:"005.png";s:4:"path";s:35:"/usr/uploads/2018/08/2638646960.png";s:4:"size";i:241791;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(987, '006.png', '006-png-3', 1534088054, 1534088054, 'a:5:{s:4:"name";s:7:"006.png";s:4:"path";s:35:"/usr/uploads/2018/08/2414272719.png";s:4:"size";i:154274;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(988, '007.png', '007-png-3', 1534088133, 1534088133, 'a:5:{s:4:"name";s:7:"007.png";s:4:"path";s:35:"/usr/uploads/2018/08/3335153089.png";s:4:"size";i:233642;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(989, '008.png', '008-png-2', 1534090365, 1534090365, 'a:5:{s:4:"name";s:7:"008.png";s:4:"path";s:35:"/usr/uploads/2018/08/2850692956.png";s:4:"size";i:197585;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 8, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(990, '009.png', '009-png-2', 1534090456, 1534090456, 'a:5:{s:4:"name";s:7:"009.png";s:4:"path";s:34:"/usr/uploads/2018/08/758587349.png";s:4:"size";i:202437;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 9, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(991, '010.png', '010-png-1', 1534090556, 1534090556, 'a:5:{s:4:"name";s:7:"010.png";s:4:"path";s:35:"/usr/uploads/2018/08/2578603525.png";s:4:"size";i:213989;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 10, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(992, '011.png', '011-png-1', 1534090637, 1534090637, 'a:5:{s:4:"name";s:7:"011.png";s:4:"path";s:35:"/usr/uploads/2018/08/1699236513.png";s:4:"size";i:181592;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 11, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(993, '012.png', '012-png-1', 1534090709, 1534090709, 'a:5:{s:4:"name";s:7:"012.png";s:4:"path";s:35:"/usr/uploads/2018/08/2735055631.png";s:4:"size";i:114882;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 12, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(994, '013.png', '013-png-1', 1534090760, 1534090760, 'a:5:{s:4:"name";s:7:"013.png";s:4:"path";s:35:"/usr/uploads/2018/08/2872551656.png";s:4:"size";i:151239;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 13, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 981, 0),
(995, 'MySQL的启动', '995', 1534209060, 1534209203, '<p>本文记录MySQL学习过程中遇到的MySQL的启动～</p>\r<!--more-->\r\r<p>安装后，MySQL会以windows服务的方式为我们提供数据存储功能。开启和关闭服务的操作：右键点击我的电脑&rarr;管理&rarr;服务&rarr;可以找到MySQL服务开启或停止。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3695441401.png" style="width: 800px; height: 582px;" /></p>\r\r<p>也可以在DOS窗口，通过命令完成MySQL服务的启动和停止（必须以管理运行cmd命令窗口）:</p>\r\r<pre class="brush:java;">\rnet start mysql\rnet stop mysql</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(996, '001.png', '001-png-10', 1534209138, 1534209138, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2018/08/3695441401.png";s:4:"size";i:235338;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 995, 0),
(997, 'MySQL的登录', '997', 1534209360, 1534210011, '<p>本文记录MySQL学习过程中遇到的MySQL的登录～</p>\r<!--more-->\r\r<p>MySQL是一个需要账户名密码登录的数据库，登陆后使用，它提供了一个默认的root账号，使用安装时设置的密码即可登录。</p>\r\r<p>登录格式1:</p>\r\r<pre class="brush:java;">\rmysql &ndash;u用户名 &ndash;p密码</pre>\r\r<p>示例命令：</p>\r\r<pre class="brush:java;">\rmysql -uroot &ndash;proot</pre>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3490030856.png" style="width: 800px; height: 320px;" /></p>\r\r<p>登录格式2:</p>\r\r<pre class="brush:java;">\rmysql --host=ip地址 --user=用户名 --password=密码</pre>\r\r<p>示例命令：</p>\r\r<pre class="brush:java;">\rmysql --host=127.0.0.1  --user=root --password=root</pre>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3294917331.png" style="width: 800px; height: 324px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(999, '002.png', '002-png-6', 1534209890, 1534209890, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/08/3490030856.png";s:4:"size";i:66928;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 997, 0),
(1000, '003.png', '003-png-6', 1534209994, 1534209994, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:35:"/usr/uploads/2018/08/3294917331.png";s:4:"size";i:73625;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 997, 0),
(1001, 'SQL语句', '1001', 1534344540, 1554025161, '<p>本文记录MySQL学习过程中遇到的SQL语句～</p>\r<!--more-->\r\r<p>数据库是不认识Java语言的，但是我们同样要与数据库交互，这时需要使用到数据库认识的语言SQL语句，它是数据库的代码。</p>\r\r<p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>\r\r<p>创建数据库、创建数据表、向数据表中添加一条条数据信息均需要使用SQL语句。</p>\r\r<p>SQL分类：</p>\r\r<ul>\r	<li>数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等；</li>\r	<li>数据操作语言：简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert，delete，update等；</li>\r	<li>数据控制语言：简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户等；</li>\r	<li>数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(1002, 'SQL通用语法', '1002', 1534344720, 1534345013, '<p>本文记录MySQL学习过程中遇到的SQL通用语法～</p>\r<!--more-->\r\r<ul>\r	<li>SQL语句可以单行或多行书写，以分号结尾</li>\r	<li>可使用空格和缩进来增强语句的可读性</li>\r	<li>MySQL数据库的SQL语句不区分大小写，建议使用大写，例如：SELECT * FROM user。</li>\r	<li>同样可以使用/**/的方式完成注释</li>\r	<li>MySQL中的我们常使用的数据类型如下：</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/777563315.png" style="width: 800px; height: 153px;" /></p>\r\r<p>详细的数据类型如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2223501055.png" style="width: 800px; height: 726px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 132),
(1003, 'tongyongyufa.png', 'tongyongyufa-png', 1534344843, 1534344843, 'a:5:{s:4:"name";s:16:"tongyongyufa.png";s:4:"path";s:34:"/usr/uploads/2018/08/777563315.png";s:4:"size";i:33484;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1002, 0),
(1004, 'xiangxi.png', 'xiangxi-png', 1534344988, 1534344988, 'a:5:{s:4:"name";s:11:"xiangxi.png";s:4:"path";s:35:"/usr/uploads/2018/08/2223501055.png";s:4:"size";i:250048;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1002, 0),
(1005, '数据库相关操作', '1005', 1534345200, 1534345604, '<p>本文记录MySQL学习过程中遇到的数据库相关操作～</p>\r<!--more-->\r\r<ul>\r	<li>创建数据库</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\rcreate database 数据库名;\rcreate database 数据库名 character set 字符集;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\r#创建数据库 数据库中数据的编码采用的是安装数据库时指定的默认编码 utf8\rCREATE DATABASE day21_1; \r#创建数据库 并指定数据库中数据的编码\rCREATE DATABASE day21_2 CHARACTER SET utf8;</pre>\r\r<ul>\r	<li>查看数据库</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\r#查看数据库MySQL服务器中的所有的数据库\rshow databases;\r#查看某个数据库的定义的信息\rshow create database 数据库名;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rshow create database day21_1;</pre>\r\r<ul>\r	<li>删除数据库</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\rdrop database 数据库名称;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rdrop database day21_2;</pre>\r\r<ul>\r	<li>切换数据库</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\ruse 数据库名;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\ruse day21_1;</pre>\r\r<ul>\r	<li>查看正在使用的数据库</li>\r</ul>\r\r<pre class="brush:java;">\rselect database();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 126),
(1006, '数据表相关操作', '1006', 1534345980, 1554025291, '<p>本文记录MySQL学习过程中遇到的数据表相关操作～</p>\r<!--more-->\r\r<ul>\r	<li>创建表</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:sql;">\rcreate table 表名(\r   字段名 类型(长度) 约束,\r   字段名 类型(长度) 约束\r);</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\r###创建分类表\rCREATE TABLE sort (\r  sid INT, #分类ID \r  sname VARCHAR(100) #分类名称\r);</pre>\r\r<ul>\r	<li>主键约束</li>\r</ul>\r\r<p>主键是用于标识当前记录的字段。它的特点是非空，唯一。在开发中一般情况下主键是不具备任何含义，只是用于标识当前记录。</p>\r\r<p>格式：</p>\r\r<p>1.在创建表时创建主键，在字段后面加上primary key；</p>\r\r<pre class="brush:java;">\rcreate table tablename(	\r        id int primary key,\r        .......\r);</pre>\r\r<p>2.在创建表时创建主键，在表创建的最后来指定主键；</p>\r\r<pre class="brush:java;">\rcreate table tablename(						\r    id int，\r    .......，\r    primary key(id)\r);</pre>\r\r<p>3.删除主键：alter table&nbsp;表名drop primary key;</p>\r\r<pre class="brush:java;">\ralter table sort drop primary key;</pre>\r\r<p>4.主键自动增长：一般主键是自增长的字段，不需要指定（实现添加自增长语句,主键字段后加auto_increment只适用MySQL）。</p>\r\r<pre class="brush:java;">\r###创建分类表\rCREATE TABLE sort (\r  sid INT PRIMARY KEY auto_increment, #分类ID \r  sname VARCHAR(100) #分类名称\r);</pre>\r\r<p>其他约束：其他约束还有如外键、唯一、非空等。</p>\r\r<ul>\r	<li>查看表</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\r#查看数据库中的所有表：\rshow tables;\r#查看表结构：\rdesc 表名;\r</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rdesc sort;</pre>\r\r<ul>\r	<li>删除表</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\rdrop table 表名;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rdrop table sort;</pre>\r\r<ul>\r	<li>修改表结构</li>\r</ul>\r\r<p>1.&nbsp;修改表添加列，alter table&nbsp;表名add&nbsp;列名 类型(长度)&nbsp;约束; &nbsp;&nbsp;</p>\r\r<pre class="brush:java;">\r为分类表添加一个新的字段为 分类描述 varchar(20)\rALTER TABLE sort ADD sdesc VARCHAR(20);</pre>\r\r<p>2. 修改表修改列的类型长度及约束，alter table&nbsp;表名modify&nbsp;列名类型(长度)&nbsp;约束；</p>\r\r<pre class="brush:java;">\r为分类表的分类名称字段进行修改，类型varchar(50) 添加约束 not null\rALTER TABLE sort MODIFY sname VARCHAR(50) NOT NULL;</pre>\r\r<p>3.&nbsp;修改表修改列名，alter table&nbsp;表名change&nbsp;旧列名新列名类型(长度)&nbsp;约束;</p>\r\r<pre class="brush:java;">\r为分类表的分类名称字段进行更换 更换为 snamesname varchar(30)\rALTER TABLE sort CHANGE sname snamename VARCHAR(30);</pre>\r\r<p>4.&nbsp;修改表删除列，alter table&nbsp;表名drop&nbsp;列名;</p>\r\r<pre class="brush:java;">\r删除分类表中snamename这列\rALTER TABLE sort DROP snamename;</pre>\r\r<p>5.&nbsp;修改表名，rename table&nbsp;表名to&nbsp;新表名;</p>\r\r<pre class="brush:java;">\r为分类表sort 改名成 category\rRENAME TABLE sort TO category;</pre>\r\r<p>6.&nbsp;修改表的字符集，alter table&nbsp;表名character set&nbsp;字符集;</p>\r\r<pre class="brush:java;">\r为分类表 category 的编码表进行修改，修改成 gbk\rALTER TABLE category CHARACTER SET gbk;</pre>\r\r<ul>\r	<li>插入表记录</li>\r</ul>\r\r<p>语法：</p>\r\r<pre class="brush:java;">\rinsert into 表 (列名1,列名2,列名3..) values  (值1,值2,值3..); -- 向表中插入某些列\rinsert into 表 values (值1,值2,值3..); --向表中插入所有列</pre>\r\r<p>注意：</p>\r\r<ul>\r	<li>插入的数据应与字段的数据类型相同</li>\r	<li>数据的大小应该在列的长度范围内</li>\r	<li>在values中列出的数据位置必须与被加入列的排列位置相对应。</li>\r	<li>除了数值类型外，其它的字段类型的值必须使用引号引起。</li>\r	<li>如果要插入空值，可以不写字段，或者插入null。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>\r	<li>对于自动增长的列在操作时，直接插入null值即可。</li>\r</ul>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rINSERT INTO sort(sid,sname) VALUES(&#39;s001&#39;, &#39;电器&#39;);\rINSERT INTO sort(sid,sname) VALUES(&#39;s002&#39;, &#39;服饰&#39;);\rINSERT INTO sort VALUES(&#39;s003&#39;, &#39;化妆品&#39;);\rINSERT INTO sort VALUES(&#39;s004&#39;,&#39;书籍&#39;);</pre>\r\r<ul>\r	<li>更新表记录</li>\r</ul>\r\r<p>用来修改指定条件的数据，将满足条件的记录指定列修改为指定值。</p>\r\r<p>语法：</p>\r\r<pre class="brush:java;">\rupdate 表名 set 字段名=值,字段名=值;\rupdate 表名 set 字段名=值,字段名=值 where 条件;</pre>\r\r<p>注意；</p>\r\r<ul>\r	<li>列名的类型与修改的值要一致.</li>\r	<li>修改值得时候不能超过最大长度.</li>\r	<li>值如果是字符串或者日期需要加&rsquo;&rsquo;.</li>\r</ul>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\r#1，将指定的sname字段中的值 修改成 日用品\rUPDATE sort SET sname=&#39;日用品&#39;;\r#2, 将sid为s002的记录中的sname改成 日用品\rUPDATE sort SET sname=&#39;日用品&#39; WHERE sid=&#39;s002&#39;;\rUPDATE sort SET sname=&#39;日用品&#39; WHERE sid=&#39;s003&#39;;</pre>\r\r<ul>\r	<li>删除表记录</li>\r</ul>\r\r<p>语法：</p>\r\r<pre class="brush:java;">\rdelete from 表名 [where 条件];\r或者\rtruncate table 表名;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rDELETE FROM sort WHERE sname=&#39;日用品&#39;;\r#表数据清空\rDELETE FROM sort;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 159),
(1007, '数据乱码问题', '1007', 1534433760, 1534434212, '<p>本文记录MySQL学习过程中遇到的数据乱码问题～</p>\r<!--more-->\r\r<p>在dos命令行操作中文时，经常会报错，例如：</p>\r\r<pre class="brush:java;">\rinsert into user(username,password) values(&lsquo;张三&rsquo;,&rsquo;123&rsquo;);		\rERROR 1366 (HY000): Incorrect string value: &#39;\\xD5\\xC5\\xC8\\xFD&#39; for column &#39;username&#39; at row 1</pre>\r\r<p>原因：MySQL的客户端编码的问题。我们的是utf-8，而系统的cmd窗口编码是gbk。</p>\r\r<p>解决方案（临时解决方案）:修改mysql客户端编码。</p>\r\r<pre class="brush:java;">\rshow variables like &#39;character%&#39;; 查看所有mysql的编码</pre>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3289536160.png" style="width: 800px; height: 248px;" /></p>\r\r<p>在图中与客户端有关的编码设置:</p>\r\r<p>client connetion result&nbsp;和客户端相关</p>\r\r<p>database server system&nbsp;和服务器端相关</p>\r\r<p>将客户端编码修改为gbk.</p>\r\r<pre class="brush:java;">\rset character_set_results=gbk; / set names gbk;</pre>\r\r<p>以上操作，只针对当前窗口有效果，如果关闭了服务器便失效。如果想要永久修改，通过以下方式:</p>\r\r<p>在mysql安装目录下有my.ini文件</p>\r\r<pre class="brush:java;">\rdefault-character-set=gbk 客户端编码设置                        \rcharacter-set-server=utf8 服务器端编码设置</pre>\r\r<p>注意:修改完成配置文件，重启服务</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 140),
(1008, 'bianma.png', 'bianma-png', 1534434148, 1534434148, 'a:5:{s:4:"name";s:10:"bianma.png";s:4:"path";s:35:"/usr/uploads/2018/08/3289536160.png";s:4:"size";i:39164;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1007, 0),
(1009, 'SQL查询语法', '1009', 1534518420, 1534518916, '<p>本文记录MySQL学习过程中遇到的SQL查询语法～</p>\r<!--more-->\r\r<ul>\r	<li>查询指定字段信息</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\rselect 字段1,字段2,...from 表名;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rselect id,name from zhangwu;</pre>\r\r<ul>\r	<li>查询表中所有字段</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\rselect * from 表名; </pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rselect * from zhangwu;</pre>\r\r<p>注意：使用&quot;*&quot;在练习、学习过程中可以使用，在实际开发中，不推荐使用。原因，要查询的字段信息不明确，若字段数量很多，会导致查询速度很慢。</p>\r\r<ul>\r	<li>distinct用于去除重复记录</li>\r</ul>\r\r<p>语法：</p>\r\r<pre class="brush:java;">\rselect distinct 字段 from 表名;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rselect distinct money from zhangwu;</pre>\r\r<ul>\r	<li>别名查询（使用as关键字，as可以省略）</li>\r</ul>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\r表别名格式: \rselect * from 表名 as 别名;\r或\rselect * from 表名 别名;\r列别名格式：\rselect 字段名 as 别名 from 表名;\r或\rselect 字段名 别名 from 表名;</pre>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\r表别名：\r	select * from zhangwu as zw;\r列别名：\r	select money as m from zhangwu;\r	或\r	select money m from zhangwu;</pre>\r\r<ul>\r	<li>直接对列进行数值运算</li>\r</ul>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\r将所有账务的金额+10000元进行显示.\rselect pname,price+10000 from product;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(1010, 'SQL条件查询', '1010', 1534519140, 1534519342, '<p>本文记录MySQL学习过程中遇到的SQL条件查询～</p>\r<!--more-->\r\r<p>where语句表示条件过滤。满足条件操作，不满足不操作，多用于数据的查询与修改。</p>\r\r<p>格式：</p>\r\r<pre class="brush:java;">\rselect 字段  from 表名  where 条件;  </pre>\r\r<p>while条件的种类如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1194825600.png" style="width: 800px; height: 460px;" /></p>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\r查询所有吃饭支出记录\rSELECT * FROM zhangwu WHERE name = &#39;吃饭支出&#39;;\r\r查询出金额大于1000的信息\rSELECT * FROM zhangwu WHERE money &gt;1000;\r\r查询出金额在2000-5000之间的账务信息\rSELECT * FROM zhangwu WHERE money &gt;=2000 AND money &lt;=5000;\r或\rSELECT * FROM zhangwu WHERE money BETWEEN 2000 AND 5000;\r\r查询出金额是1000或5000或3500的商品信息\rSELECT * FROM zhangwu WHERE money =1000 OR money =5000 OR money =3500;\r或\rSELECT * FROM zhangwu WHERE money IN(1000,5000,3500);\r\r查询出账务名称包含&rdquo;支出&rdquo;的账务信息。\rSELECT * FROM zhangwu WHERE name LIKE &quot;%支出%&quot;;\r\r查询出账务名称中是无五个字的账务信息\rSELECT * FROM gjp_ledger WHERE ldesc LIKE &quot;_____&quot;; -- 五个下划线_\r\r查询出账务名称不为null账务信息\rSELECT * FROM zhangwu WHERE name IS NOT NULL;\rSELECT * FROM zhangwu WHERE NOT (name IS NULL);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(1011, 'where.png', 'where-png', 1534519288, 1534519288, 'a:5:{s:4:"name";s:9:"where.png";s:4:"path";s:35:"/usr/uploads/2018/08/1194825600.png";s:4:"size";i:130387;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1010, 0),
(1012, 'JDBC', '1012', 1534600200, 1534600251, '<p>本文记录Java学习过程中遇到的JDBC～</p>\r<!--more-->\r\r<p>JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范</p>\r\r<p>JDBC提供了一种基准,据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</p>\r\r<p>JDBC需要连接驱动，驱动是两个设备要进行通信，满足一定通信数据格式，数据格式由设备提供商规定，设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 133),
(1013, 'JDBC原理', '1013', 1534600320, 1534600488, '<p>本文记录Java学习过程中遇到的JDBC的原理～</p>\r<!--more-->\r\r<p>Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3540010251.png" style="width: 800px; height: 339px;" /></p>\r\r<p>JDBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库。每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 117),
(1014, 'jdbc.png', 'jdbc-png', 1534600426, 1534600426, 'a:5:{s:4:"name";s:8:"jdbc.png";s:4:"path";s:35:"/usr/uploads/2018/08/3540010251.png";s:4:"size";i:40146;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1013, 0),
(1015, 'JDBC开发步骤', '1015', 1534600620, 1534601247, '<p>本文记录Java学习过程中遇到的JDBC的开发步骤～</p>\r<!--more-->\r\r<p><!--[if !supportLists]--><strong>1.&nbsp;<!--[endif]-->导入驱动jar包</strong></p>\r\r<p>创建lib目录，用于存放当前项目需要的所有jar包</p>\r\r<p>选择jar包，右键执行build path / Add to Build Path</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/279287701.png" style="width: 800px; height: 278px;" /></p>\r\r<p><strong>2. 注册驱动</strong></p>\r\r<p>JDBC规范定义驱动接口：java.sql.Driver，MySql驱动包提供了实现类：com.mysql.jdbc.Driver</p>\r\r<p>DriverManager工具类，提供注册驱动的方法registerDriver()，方法的参数是java.sql.Driver，所以我们可以通过如下语句进行注册:</p>\r\r<p>DriverManager.registerDriver(new com.mysql.jdbc.Driver());</p>\r\r<p>以上代码不推荐使用，存在两方面不足</p>\r\r<p>硬编码，后期不易于程序扩展和维护<br />\r驱动被注册两次。</p>\r\r<p>通常开发我们使用Class.forName()&nbsp;加载一个使用字符串描述的驱动类。</p>\r\r<pre class="brush:java;">\rClass.forName(&quot;com.mysql.jdbc.Driver&quot;);</pre>\r\r<p>如果使用Class.forName()将类加载到内存，该类的静态代码将自动执行。</p>\r\r<p>通过查询com.mysql.jdbc.Driver源码，我们发现Driver类&ldquo;主动&rdquo;将自己进行注册。</p>\r\r<p>代码如下：</p>\r\r<pre class="brush:java;">\rpublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\r	static {\r		try {\r			java.sql.DriverManager.registerDriver(new Driver());\r		} catch (SQLException E) {\r			throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);\r		}\r	}\r&hellip;&hellip;\r}</pre>\r\r<p><strong>3.&nbsp;获得链接</strong></p>\r\r<pre class="brush:java;">\rConnection con = DriverManager.getConnection (&ldquo;jdbc:mysql://localhost:3306/mydb&rdquo;,&rdquo;root&rdquo;,&rdquo;root&rdquo;);</pre>\r\r<p>获取连接需要方法DriverManager.getConnection(url,username,password)，三个参数分别表示，url&nbsp;需要连接数据库的位置（网址）user用户名&nbsp;&nbsp;password&nbsp;密码</p>\r\r<p>url比较复杂，下面是mysql的url：</p>\r\r<pre class="brush:java;">\rjdbc:mysql://localhost:3306/mydb\rJDBC规定url的格式由三部分组成，每个部分中间使用冒号分隔。\r     第一部分是jdbc，这是固定的；\r     第二部分是数据库名称，那么连接mysql数据库，第二部分当然是mysql了；\r     第三部分是由数据库厂商规定的，我们需要了解每个数据库厂商的要求，mysql的第三部分分别由数据库服务器的IP地址（localhost）、端口号（3306），以及DATABASE名称(mydb)组成。</pre>\r\r<p><strong>4.&nbsp;获得语句执行平台</strong></p>\r\r<pre class="brush:java;">\rString sql = &quot;某SQL语句&quot;;\r获取Statement语句执行平台：Statement stmt = con.createStatement();</pre>\r\r<p>常用方法：</p>\r\r<ul>\r	<li>int executeUpdate(String sql); --执行insert update delete语句.</li>\r	<li>ResultSet executeQuery(String sql); --执行select语句.</li>\r	<li>boolean execute(String sql); --执行select返回true&nbsp;执行其他的语句返回false.</li>\r</ul>\r\r<p><strong>5.&nbsp;处理结果集（select语句）</strong></p>\r\r<p>ResultSet实际上就是一张二维的表格，我们可以调用其boolean next()方法指向某行记录，当第一次调用next()方法时，便指向第一行记录的位置，这时就可以使用ResultSet提供的getXXX(int col)方法(与索引从0开始不同个，列从1开始)来获取指定列的数据：</p>\r\r<pre class="brush:java;">\rrs.next();//指向第一行\rrs.getInt(1);//获取第一行第一列的数据</pre>\r\r<p>常用方法：</p>\r\r<ul>\r	<li>Object getObject(int index) / Object getObject(String name)&nbsp;获得任意对象</li>\r	<li>String getString(int index) / Object getObject(String name)&nbsp;获得字符串</li>\r	<li>int getInt(int index) / Object getObject(String name)&nbsp;获得整形</li>\r	<li>double getDouble(int index) / Object getObject(String name)&nbsp;获得双精度浮点型</li>\r</ul>\r\r<p><strong>6.&nbsp;释放资源</strong></p>\r\r<p>与IO流一样，使用后的东西都需要关闭！关闭的顺序是先得到的后关闭，后得到的先关闭。</p>\r\r<pre class="brush:java;">\rrs.close();\rstmt.close();\rcon.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 153),
(1016, 'import.png', 'import-png', 1534600730, 1534600730, 'a:5:{s:4:"name";s:10:"import.png";s:4:"path";s:34:"/usr/uploads/2018/08/279287701.png";s:4:"size";i:73826;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1015, 0),
(1017, 'SQL注入问题', '1017', 1534602180, 1534602260, '<p>本文记录Java学习过程中遇到的SQL注入问题～</p>\r<!--more-->\r\r<p>假设有登录案例SQL语句如下:</p>\r\r<pre class="brush:java;">\rSELECT * FROM 用户表WHERE NAME = 用户输入的用户名AND PASSWORD = 用户输的密码;</pre>\r\r<p>此时，当用户输入正确的账号与密码后，查询到了信息则让用户登录。但是当用户输入的账号为XXX&nbsp;密码为：XXX&rsquo;&nbsp;&nbsp;OR &lsquo;a&rsquo;=&rsquo;a时，则真正执行的代码变为：</p>\r\r<pre class="brush:java;">\rSELECT * FROM 用户表WHERE NAME = &lsquo;XXX&rsquo; AND PASSWORD =&rsquo; XXX&rsquo;  OR &rsquo;a&rsquo;=&rsquo;a&rsquo;;</pre>\r\r<p>此时，上述查询语句时永远可以查询出结果的。那么用户就直接登录成功了，显然我们不希望看到这样的结果，这便是SQL注入问题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 102),
(1018, '预处理对象', '1018', 1534602300, 1534602994, '<p>本文记录Java学习过程中遇到的预处理对象～</p>\r<!--more-->\r\r<p>对于SQL注入问题，我们可以使用PreparedStatement预处理对象来解决。</p>\r\r<p>使用PreparedStatement预处理对象时，建议每条sql语句所有的实际参数，都使用逗号分隔。</p>\r\r<pre class="brush:java;">\rString sql = &quot;insert into sort(sid,sname) values(?,?)&quot;;;\rPreparedStatement预处理对象代码：\rPreparedStatement psmt = conn.prepareStatement(sql);</pre>\r\r<p>常用方法：</p>\r\r<ul>\r	<li>int executeUpdate(); --执行insert update delete语句.</li>\r	<li>ResultSet executeQuery(); --执行select语句.</li>\r	<li>boolean execute(); --执行select返回true&nbsp;执行其他的语句返回false.</li>\r	<li>void&nbsp;setXxx(int index, Xxx&nbsp;xx)&nbsp;将指定参数设置为给定Java的xx值。在将此值发送到数据库时，驱动程序将它转换成一个SQL&nbsp;Xxx类型值。</li>\r</ul>\r\r<p>例如：</p>\r\r<pre class="brush:java;">\rsetString(2, &quot;家用电器&quot;) 把SQL语句中第2个位置的占位符？替换成实际参数&quot;家用电器&quot;</pre>\r\r<p><strong>executeUpdate方法</strong></p>\r\r<ul>\r	<li>插入记录：insert(实现向分类表中插入指定的新分类)</li>\r</ul>\r\r<pre class="brush:java;">\r// 1注册驱动\rClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\r// 2获取连接\rConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb&quot;, &quot;root&quot;, &quot;root&quot;);\r// 3获得预处理对象\rString sql = &quot;insert into sort(sname) values(?)&quot;;\rPreparedStatement stat = conn.prepareStatement(sql);\r// 4 SQL语句占位符设置实际参数\rstat.setString(1, &quot;奢侈品&quot;);\r// 5执行SQL语句\rint line = stat.executeUpdate();\rSystem.out.println(&quot;新添加记录数：&quot; + line);\r// 6释放资源\rstat.close();\rconn.close();</pre>\r\r<ul>\r	<li>更新记录：update（实现更新分类表中指定分类ID所对应记录的分类名称）</li>\r</ul>\r\r<pre class="brush:java;">\r// 1注册驱动\rClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\r// 2获取连接\rConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb&quot;, &quot;root&quot;, &quot;root&quot;);\r// 3获得预处理对象中\rString sql = &quot;update sort set sname=? where sid=?&quot;;\rPreparedStatement stat = conn.prepareStatement(sql);\r// 4 SQL语句占位符设置实际参数\rstat.setString(1, &quot;数码产品&quot;);\rstat.setInt(2, 1);\r// 5执行SQL语句\rint line = stat.executeUpdate();\rSystem.out.println(&quot;更新记录数：&quot; + line);\r// 6释放资源\rstat.close();\rconn.close();</pre>\r\r<ul>\r	<li>删除记录：delete（实现删除分类表中指定分类ID的记录）</li>\r</ul>\r\r<pre class="brush:java;">\r// 1注册驱动\rClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\r// 2获取连接\rConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb&quot;, &quot;root&quot;, &quot;root&quot;);\r// 3获得预处理对象\rString sql = &quot;delete from sort where sid=?&quot;;\rPreparedStatement stat = conn.prepareStatement(sql);\r// 4 SQL语句占位符设置实际参数\rstat.setInt(1, 1);\r// 5执行SQL语句\rint line = stat.executeUpdate();\rSystem.out.println(&quot;删除记录数：&quot; + line);\r// 6释放资源\rstat.close();\rconn.close();</pre>\r\r<p><strong>executeQuery方法</strong></p>\r\r<ul>\r	<li>查询记录：select（实现查询分类表所有记录）</li>\r</ul>\r\r<pre class="brush:java;">\r// 1注册驱动\rClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\r// 2获取连接\rConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb&quot;, &quot;root&quot;, &quot;root&quot;);\r// 3获得预处理对象\rString sql = &quot;select * from sort&quot;;\rPreparedStatement stat = conn.prepareStatement(sql);\r// 4 SQL语句占位符设置实际参数\r// 5执行SQL语句\rResultSet rs = stat.executeQuery();\r// 6处理结果集(遍历结果集合)\rwhile( rs.next() ){\r	//获取当前行的分类ID\r	String sid = rs.getString(&quot;sid&quot;);//方法参数为数据库表中的列名\r	//获取当前行的分类名称\r	String sname = rs.getString(&quot;sname&quot;);\r	//显示数据\r	System.out.println(sid+&quot;-----&quot;+sname);\r}\r// 7释放资源\rrs.close();\rstat.close();\rconn.close();</pre>\r\r<ul>\r	<li>查询记录：select（实现查询分类表中指定分类名称的记录）</li>\r</ul>\r\r<pre class="brush:java;">\r// 1注册驱动\rClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\r// 2获取连接\rConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb&quot;, &quot;root&quot;, &quot;root&quot;);\r// 3获得预处理对象\rString sql = &quot;select * from sort where sname=?&quot;;\rPreparedStatement stat = conn.prepareStatement(sql);\r// 4 SQL语句占位符设置实际参数\rstat.setString(1, &quot;奢侈品&quot;);\r// 5执行SQL语句\rResultSet rs = stat.executeQuery();\r// 6处理结果集(遍历结果集合)\rwhile( rs.next() ){\r	//获取当前行的分类ID\r	String sid = rs.getString(&quot;sid&quot;);//方法参数为数据库表中的列名\r	//获取当前行的分类名称\r	String sname = rs.getString(&quot;sname&quot;);\r	//显示数据\r	System.out.println(sid+&quot;-----&quot;+sname);\r}\r// 7释放资源\rrs.close();\rstat.close();\rconn.close();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 149),
(1019, 'JDBC工具类', '1019', 1534603140, 1534603240, '<p>本文记录Java学习过程中遇到的JDBC工具类～</p>\r<!--more-->\r\r<p>&ldquo;获得数据库连接&rdquo;操作，将在以后的增删改查所有功能中都存在，可以封装工具类JDBCUtils。提供获取连接对象的方法，从而达到代码的重复利用。</p>\r\r<p>该工具类提供方法：</p>\r\r<pre class="brush:java;">\rpublic static Connection getConn ()</pre>\r\r<p>代码如下：</p>\r\r<pre class="brush:java;">\r/*\r * JDBC工具类\r */\rpublic class JDBCUtils {\r	public static final  String DRIVERNAME = &quot;com.mysql.jdbc.Driver&quot;;\r	public static final  String URL = &quot;jdbc:mysql://localhost:3306/mydb&quot;;\r	public static final  String USER = &quot;root&quot;;\r	public static final  String PASSWORD = &quot;root&quot;;\r\r	static {\r		try {\r			Class.forName(DRIVERNAME);\r		} catch (ClassNotFoundException e) {\r			System.out.println(&quot;数据库驱动注册失败！&quot;);\r		}\r	}\r	//提供获取连接的方法\r	public static Connection getConn() throws Exception {\r		// 2. 获得连接\r		Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);\r		// 返回连接\r		return conn;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 139);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1020, 'properties配置文件', '1020', 1534690140, 1534690383, '<p>本文记录Java学习JDBC过程中遇到的properties配置文件～</p>\r<!--more-->\r\r<p>开发中获得连接的4个参数（驱动、URL、用户名、密码）通常都存在配置文件中，方便后期维护，程序如果需要更换数据库，只需要修改配置文件即可。</p>\r\r<p>通常情况下，我们习惯使用properties文件，此文件我们将做如下要求：</p>\r\r<ol>\r	<li>文件位置：任意，建议src下</li>\r	<li>文件名称：任意，扩展名为properties</li>\r	<li>文件内容：一行一组数据，格式是&ldquo;key=value&rdquo;.</li>\r</ol>\r\r<ul>\r	<li>key命名自定义，如果是多个单词，习惯使用点分隔。例如：jdbc.driver</li>\r	<li>value值不支持中文，如果需要使用非英文字符，将进行unicode转换。</li>\r</ul>\r\r<p>在项目跟目录下，创建文件，输入&ldquo;db.properties&rdquo;文件名。</p>\r\r<p>内容如下：</p>\r\r<pre class="brush:java;">\rdriver=com.mysql.jdbc.Driver\rurl=jdbc:mysql://localhost:3306/mydb\ruser=root\rpassword=root</pre>\r\r<p>对应properties文件处理，开发中也使用Properties对象进行。我们将采用加载properties文件获得流，然后使用Properties对象进行处理。</p>\r\r<p>示例代码（使用properties配置文件重构的JDBCUtils）：</p>\r\r<pre class="brush:java;">\rpublic class JDBCUtils {\r\r	private static String driver;\r	private static String url;\r	private static String user;\r	private static String password;\r	// 静态代码块\r	static {\r		try {\r			// 1 使用Properties处理流\r			// 使用load()方法加载指定的流\r			Properties props = new Properties();\r			Reader is = new FileReader(&quot;db.properties&quot;);\r			props.load(is);\r			// 2 使用getProperty(key)，通过key获得需要的值，\r			driver = props.getProperty(&quot;driver&quot;);\r			url = props.getProperty(&quot;url&quot;);\r			user = props.getProperty(&quot;user&quot;);\r			password = props.getProperty(&quot;password&quot;);\r		} catch (Exception e) {\r			throw new RuntimeException(e);\r		}\r	}\r\r	/**\r	 * 获得连接\r	 */\r	public static Connection getConnection() {\r		try {\r			// 1 注册驱动\r			Class.forName(driver);\r			// 2 获得连接\r			Connection conn = DriverManager.getConnection(url, user, password);\r			return conn;\r		} catch (Exception e) {\r			throw new RuntimeException(e);\r		}\r	}\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\rpublic class Demo {\r	@Test\r	public void insert(){\r		try{\r			//1,获取连接对象\r			Connection conn = JDBCUtils.getConnection();\r			//2,指定要执行的SQL语句\r			String sql = &quot;INSERT INTO zhangwu(name,money,parent) VALUES(?,?,?)&quot;;\r			//4，获取SQL语句的执行对象 PreparedStatement\r			PreparedStatement ppstat = conn.prepareStatement(sql);\r			//5,执行SQL语句\r			ppstat.setString(1, &quot;股票收入&quot;);\r			ppstat.setDouble(2, 5000);\r			ppstat.setString(3, &quot;收入&quot;);\r			int line = ppstat.executeUpdate();\r			//6,处理结果集\r			System.out.println(&quot;line=&quot; + line);\r			//7,关闭连接\r			ppstat.close();\r			conn.close();\r		} catch(SQLException e){\r			throw new RuntimeException(e);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 138),
(1021, 'DBUtils', '1021', 1535114220, 1535114317, '<p>本文记录Java学习过程中遇到的DBUtils类～</p>\r<!--more-->\r\r<p>如果只使用JDBC进行开发，我们会发现冗余代码过多，为了简化JDBC开发，本案例我们讲采用apache commons组件一个成员：DBUtils。</p>\r\r<p>DBUtils就是JDBC的简化开发工具包。需要项目导入commons-dbutils-1.6.jar才能够正常使用DBUtils工具。</p>\r\r<p>DBUtils是java编程中的数据库操作实用工具，小巧简单实用。</p>\r\r<p>DBUtils封装了对JDBC的操作，简化了JDBC操作，可以少写代码。</p>\r\r<p>Dbutils三个核心功能：</p>\r\r<ul>\r	<li>QueryRunner中提供对sql语句操作的API.</li>\r	<li>ResultSetHandler接口，用于定义select操作后，怎样封装结果集.</li>\r	<li>DbUtils类，它就是一个工具类,定义了关闭资源与事务处理的方法</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 128),
(1022, 'QueryRunner实现增删改', '1022', 1535114460, 1535116065, '<p>本文记录Java学习过程中遇到的QueryRunner如何实现增删改～</p>\r<!--more-->\r\r<ul>\r	<li>update(Connection conn, String sql, Object...&nbsp;params)&nbsp;，用来完成表数据的增加、删除、更新操作</li>\r</ul>\r\r<p>示例代码（添加）：</p>\r\r<pre class="brush:java;">\rpublic void insert(){\r	try {\r		//获取一个用来执行SQL语句的对象   QueryRunner\r		QueryRunner qr = new QueryRunner();\r		\r		String sql = &quot;INSERT INTO zhangwu(name,money,parent) VALUES(?,?,?)&quot;;\r		Object[] params = {&quot;股票收入&quot;, 5500, &quot;收入&quot;};\r		Connection conn = JDBCUtils.getConnection();\r		int line = qr.update(conn,sql,params);// 用来完成表数据的增加、删除、更新操作\r		//结果集处理\r		System.out.println(&quot;line = &quot; + line);\r		\r	} catch (SQLException e) {\r		throw new RuntimeException(e);\r	}\r}</pre>\r\r<p>示例代码（更新）：</p>\r\r<pre class="brush:java;">\rpublic void update(){\r	try {\r		//创建一个QueryRunner对象，用来完成SQL语句的执行\r		QueryRunner qr = new QueryRunner();\r		//执行SQL语句\r		String sql = &quot;UPDATE zhangwu SET money = money+1000 WHERE name=?&quot;;\r		Object[] params = {&quot;股票收入&quot;};\r		Connection conn = JDBCUtils.getConnection();\r		int line = qr.update(conn, sql, params);\r		//结果集的处理\r		System.out.println(&quot;line=&quot;+line);\r		\r	} catch (SQLException e) {\r		throw new RuntimeException(e);\r	}\r}</pre>\r\r<p>示例代码（删除）：</p>\r\r<pre class="brush:java;">\rpublic void delete(){\r	try {\r		//创建一个QueryRunner对象，用来完成SQL语句的执行\r		QueryRunner qr = new QueryRunner();\r		//执行SQL语句\r		String sql = &quot;DELETE FROM zhangwu WHERE name = ?&quot;;\r		Object[] params = {&quot;股票收入&quot;};\r		Connection conn = JDBCUtils.getConnection();\r		int line = qr.update(conn, sql, params);\r		//结果集的处理\r		System.out.println(&quot;line=&quot;+line);\r		\r	} catch (SQLException e) {\r		throw new RuntimeException(e);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 125),
(1024, 'QueryRunner实现查询操作', '1024', 1535116260, 1535117034, '<p>本文记录Java学习过程中遇到的QueryRunner实现查询操作～</p>\r<!--more-->\r\r<ul>\r	<li>query(Connection conn,&nbsp;String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)&nbsp;，用来完成表数据的查询操作</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3910959279.png" style="width: 800px; height: 331px;" /></p>\r\r<ul>\r	<li>JavaBean</li>\r</ul>\r\r<p>JavaBean就是一个类，在开发中常用封装数据。具有如下特性</p>\r\r<ol>\r	<li>需要实现接口：java.io.Serializable，通常实现接口这步骤省略了，不会影响程序。</li>\r	<li>提供私有字段：private&nbsp;类型字段名;</li>\r	<li>提供getter/setter方法：</li>\r	<li>提供无参构造</li>\r</ol>\r\r<p>示例代码（账务类）：</p>\r\r<pre class="brush:java;">\rpublic class ZhangWu {\r	private int id;\r	private String name;\r	private double money;\r	private String parent;\r\r	public ZhangWu() {\r		super();\r	}\r	public int getId() {\r		return id;\r	}\r	public void setId(int id) {\r		this.id = id;\r	}\r	public String getName() {\r		return name;\r	}\r	public void setName(String name) {\r		this.name = name;\r	}\r	public double getMoney() {\r		return money;\r	}\r	public void setMoney(double money) {\r		this.money = money;\r	}\r	public String getParent() {\r		return parent;\r	}\r	public void setParent(String parent) {\r		this.parent = parent;\r	}\r\r	@Override\r	public String toString() { //该方法可以省略\r		return &quot;ZhangWu [id=&quot; + id + &quot;, name=&quot; + name + &quot;, money=&quot; + money + &quot;, parent=&quot; + parent + &quot;]&quot;;\r	}\r}</pre>\r\r<ul>\r	<li>ArrayHandler：将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值</li>\r</ul>\r\r<p>示例代码（ArrayHandler）：</p>\r\r<pre class="brush:java;">\rpublic class ArrayHandlerDemo {\r	\r	@Test\r	public void method(){\r		try {\r			//获取QueryRunner对象\r			QueryRunner qr = new QueryRunner();\r			//执行SQL语句\r			String sql = &quot;SELECT * FROM zhangwu&quot;;\r			Object[] params = {};\r			Connection conn = JDBCUtils.getConnection();\r			Object[] objArray = qr.query(conn, sql, new ArrayHandler(), params);\r			//结果集的处理\r			System.out.println( Arrays.toString(objArray) );\r			\r			conn.close();\r		} catch (SQLException e) {\r			e.printStackTrace();\r		}\r	}\r}</pre>\r\r<ul>\r	<li>ArrayListHandler：将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。</li>\r</ul>\r\r<p>示例代码（ArrayListHandler）：</p>\r\r<pre class="brush:java;">\rpublic class ArrayListHandlerDemo {\r	@Test\r	public void method(){\r		try {\r			//获取QueryRunner对象\r			QueryRunner qr = new QueryRunner();\r			//执行SQL语句\r			String sql = &quot;SELECT * FROM zhangwu WHERE money&gt;?&quot;;\r			Object[] params = {2000};\r			Connection conn = JDBCUtils.getConnection();\r			 List&lt;Object[]&gt; list = qr.query(conn, sql, new ArrayListHandler(), params);\r			//结果集的处理\r			 for (Object[] objArray : list) {\r				System.out.println(  Arrays.toString(objArray) );\r			}\r			\r			conn.close();\r		} catch (SQLException e) {\r			e.printStackTrace();\r		}\r	}\r}</pre>\r\r<ul>\r	<li>BeanHandler&nbsp;&nbsp;：将结果集中第一条记录封装到一个指定的javaBean中。</li>\r</ul>\r\r<p>示例代码（BeanHandler）：</p>\r\r<pre class="brush:java;">\rpublic class BeanHandlerDemo {\r	@Test\r	public void method(){\r		try{\r			//获取QueryRunner \r			QueryRunner qr = new QueryRunner();\r			//执行SQL语句\r			String sql = &quot;SELECT * FROM zhangwu WHERE id=?&quot;;\r			Object[] params = {1};\r			Connection conn = JDBCUtils.getConnection();\r			ZhangWu zw = qr.query(conn, sql, new BeanHandler&lt;ZhangWu&gt;(ZhangWu.class), params);\r			//结果集处理\r			System.out.println(zw);\r			\r			conn.close();\r		} catch(SQLException e){\r			throw new RuntimeException(e);\r		}\r	}\r}</pre>\r\r<ul>\r	<li>BeanListHandler&nbsp;&nbsp;：将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中。</li>\r</ul>\r\r<p>示例代码（BeanListHandler）：</p>\r\r<pre class="brush:java;">\rpublic class BeanListHandlerDemo {\r	@Test\r	public void method(){\r		try{\r			//获取QueryRunner \r			QueryRunner qr = new QueryRunner();\r			//执行SQL语句\r			String sql = &quot;SELECT * FROM zhangwu WHERE money&gt;?&quot;;\r			Object[] params = {2000};\r			Connection conn = JDBCUtils.getConnection();\r			List&lt;ZhangWu&gt; list = qr.query(conn, sql, new BeanListHandler&lt;ZhangWu&gt;(ZhangWu.class), params);\r			//结果集处理\r			for (ZhangWu zw : list) {\r				System.out.println(zw);\r			}\r			\r			conn.close();\r		} catch(SQLException e){\r			throw new RuntimeException(e);\r		}\r	}\r}</pre>\r\r<ul>\r	<li>ColumnListHandler：将结果集中指定的列的字段值，封装到一个List集合中。</li>\r</ul>\r\r<p>示例代码（ColumnListHandler）：</p>\r\r<pre class="brush:java;">\rpublic class ColumnListHandlerDemo {\r	@Test\r	public void method(){\r		try {\r			//获取QueryRunner对象\r			QueryRunner qr = new QueryRunner();\r			//执行SQL语句\r			String sql = &quot;SELECT name FROM zhangwu WHERE money&gt;?&quot;;\r			Object[] params = {2000};\r			Connection conn = JDBCUtils.getConnection();\r			List&lt;String&gt; list = qr.query(conn, sql, new ColumnListHandler&lt;String&gt;(), params); \r			//结果集的处理\r			for (String str : list) {\r				System.out.println(str);\r			}\r\r			conn.close();\r		} catch (SQLException e) {\r			e.printStackTrace();\r		}\r	}\r}</pre>\r\r<ul>\r	<li>ScalarHandler：它是用于单数据，例如select count(*) from&nbsp;表操作。</li>\r</ul>\r\r<p>示例代码（ScalarHandler）：</p>\r\r<pre class="brush:java;">\rpublic class ScalarHandlerDemo {\r	@Test\r	public void method(){\r		try {\r			//获取QueryRunner对象\r			QueryRunner qr = new QueryRunner();\r			\r			//执行SQL语句\r			String sql = &quot;SELECT MAX(money) FROM zhangwu&quot;;\r			Object[] params = {};\r			Connection conn = JDBCUtils.getConnection();\r			Double max = qr.query(conn, sql, new ScalarHandler&lt;Double&gt;(), params);\r			//结果集的处理\r			System.out.println(&quot;max=&quot; + max);\r			\r			conn.close();\r		} catch (SQLException e) {\r			e.printStackTrace();\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 565),
(1026, 'ResultSetHandler.png', 'ResultSetHandler-png', 1535116279, 1535116279, 'a:5:{s:4:"name";s:20:"ResultSetHandler.png";s:4:"path";s:35:"/usr/uploads/2018/08/3910959279.png";s:4:"size";i:170029;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1024, 0),
(1027, '连接池', '1027', 1535164980, 1535165131, '<p>本文记录Java学习过程中遇到的连接池～</p>\r<!--more-->\r\r<p>实际开发中&ldquo;获得连接&rdquo;或&ldquo;释放资源&rdquo;是非常消耗系统资源的两个过程，为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection。这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池。</p>\r\r<p>用池来管理Connection，这样可以重复使用Connection。有了池，所以我们就不用自己来创建Connection，而是通过池来获取Connection对象。当使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection&ldquo;归还&rdquo;给池。池就可以再利用这个Connection对象了。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2046563701.png" style="width: 800px; height: 260px;" /></p>\r\r<p>Java为数据库连接池提供了公共的接口：javax.sql.DataSource，各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池！</p>\r\r<p>常见的连接池：DBCP、C3P0。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(1028, 'connection.png', 'connection-png', 1535165095, 1535165095, 'a:5:{s:4:"name";s:14:"connection.png";s:4:"path";s:35:"/usr/uploads/2018/08/2046563701.png";s:4:"size";i:29290;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1027, 0),
(1029, 'DBCP连接池', '1029', 1535165160, 1535165578, '<p>本文记录Java学习过程中遇到的DBCP连接池～</p>\r<!--more-->\r\r<p>DBCP也是一个开源的连接池，是Apache Common成员之一，在企业开发中也比较常见，tomcat内置的连接池。</p>\r\r<p>导入jar包</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1284509616.png" style="width: 800px; height: 280px;" /></p>\r\r<p>连接数据库表的工具类,&nbsp;采用DBCP连接池的方式来完成，Java中提供了一个连接池的规则接口：</p>\r\r<p>DataSource :&nbsp;它是java中提供的连接池，作为DriverManager工具的替代项。在DBCP包中提供了DataSource接口的实现类，我们要用的具体的连接池BasicDataSource类。</p>\r\r<p>示例代码（工具类）：</p>\r\r<pre class="brush:java;">\rpublic class JDBCUtils {\r	public static final String DRIVER = &quot;com.mysql.jdbc.Driver&quot;;\r	public static final String URL = &quot;jdbc:mysql://localhost:3306/daydb&quot;;\r	public static final String USERNAME = &quot;root&quot;;\r	public static final String PASSWORD = &quot;root&quot;;\r	/*\r	 * 创建连接池BasicDataSource\r	 */\r	public static BasicDataSource dataSource = new BasicDataSource();\r	//静态代码块\r	static {\r		//对连接池对象 进行基本的配置\r		dataSource.setDriverClassName(DRIVER); // 这是要连接的数据库的驱动\r		dataSource.setUrl(URL); //指定要连接的数据库地址\r		dataSource.setUsername(USERNAME); //指定要连接数据的用户名\r		dataSource.setPassword(PASSWORD); //指定要连接数据的密码\r	}\r	/*\r	 * 返回连接池对象\r	 */\r	public static DataSource getDataSource(){\r		return dataSource;\r	}\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\r/*\r * 演示使用DBUtils工具  完成数据库表的增加操作\r */\rpublic class Demo {\r	// 插入功能 \r	@Test\r	public void insert(){\r		try {\r			//获取一个用来执行SQL语句的对象   QueryRunner\r			QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());\rString sql = &quot;INSERT INTO zhangwu(name,money,parent) VALUES(?,?,?)&quot;;\r			Object[] params = {&quot;股票收入&quot;, 5500, &quot;收入&quot;};	\r		     int line = qr.update(sql,params);\r			//结果集处理\r			System.out.println(&quot;line = &quot; + line);\r			\r		} catch (SQLException e) {\r			throw new RuntimeException(e);\r		}\r	}\r	\r	//删除功能\r	@Test\r	public void delete(){\r		try {\r			//创建一个QueryRunner对象，用来完成SQL语句的执行\r			QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());\r			//执行SQL语句\r			String sql = &quot;DELETE FROM zhangwu WHERE name = ?&quot;;\r			Object[] params = {&quot;股票收入&quot;};\r			int line = qr.update(sql, params);\r			//结果集的处理\r			System.out.println(&quot;line=&quot;+line);\r			\r		} catch (SQLException e) {\r			throw new RuntimeException(e);\r		}\r	}\r	\r	//更新功能\r	@Test\r	public void update(){\r		try {\r			//创建一个QueryRunner对象，用来完成SQL语句的执行\r			QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());\r			//执行SQL语句\r			String sql = &quot;UPDATE zhangwu SET money = money+1000 WHERE name=?&quot;;\r			Object[] params = {&quot;股票收入&quot;};\r			int line = qr.update(sql, params);\r			//结果集的处理\r			System.out.println(&quot;line=&quot;+line);\r			\r		} catch (SQLException e) {\r			throw new RuntimeException(e);\r		}\r	}\r	\r	//查询功能,将结果集中第一条记录封装到一个指定的javaBean中。\r	@Test\r	public void search(){\r		try{\r			//获取QueryRunner \r			QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());\r			//执行SQL语句\r			String sql = &quot;SELECT * FROM zhangwu&quot;;\r			Object[] params = {};\r			Product p = qr.query(sql, new BeanHandler&lt;Product&gt;(Product.class), params);\r			//结果集处理\r			System.out.println(p);\r			\r		} catch(SQLException e){\r			throw new RuntimeException(e);\r		}\r	}\r}</pre>\r\r<ul>\r	<li>常见配置项</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/4189619173.png" style="width: 800px; height: 256px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 136),
(1030, 'import.png', 'import-png-1', 1535165285, 1535165285, 'a:5:{s:4:"name";s:10:"import.png";s:4:"path";s:35:"/usr/uploads/2018/08/1284509616.png";s:4:"size";i:78829;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1029, 0),
(1031, 'properties.png', 'properties-png-1', 1535165564, 1535165564, 'a:5:{s:4:"name";s:14:"properties.png";s:4:"path";s:35:"/usr/uploads/2018/08/4189619173.png";s:4:"size";i:69859;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1029, 0),
(1032, '网络通信协议', '1032', 1535288340, 1535288758, '<p>本文记录TCP/IP学习过程中遇到的网络通信协议～</p>\r<!--more-->\r\r<p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p>\r\r<p>网络通信协议有很多种，目前应用最广泛的是TCP/IP协议(Transmission Control Protocal/Internet Protoal传输控制协议/英特网互联协议)，它是一个包括TCP协议和IP协议，UDP（User Datagram Protocol）协议和其它一些协议的协议组，在学习具体协议之前首先了解一下TCP/IP协议组的层次结构。</p>\r\r<p>在进行数据传输时，要求发送的数据与收到的数据完全一样，这时，就需要在原有的数据上添加很多信息，以保证数据在传输过程中数据格式完全一致。TCP/IP协议的层次结构比较简单，共分为四层，如图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3708958047.png" style="width: 800px; height: 224px;" /></p>\r\r<p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。</p>\r\r<p>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</p>\r\r<p>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</p>\r\r<p>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</p>\r\r<p>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 120),
(1033, 'net.png', 'net-png', 1535288701, 1535288701, 'a:5:{s:4:"name";s:7:"net.png";s:4:"path";s:35:"/usr/uploads/2018/08/3708958047.png";s:4:"size";i:26616;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1032, 0),
(1034, '地址和端口号', '1034', 1535290320, 1535290817, '<p>本文记录TCP/IP学习过程中遇到的地址和端口号～</p>\r<!--more-->\r\r<p>要想使网络中的计算机能够进行通信，必须为每台计算机指定一个标识号，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。</p>\r\r<p>在TCP/IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，每个字节用一个十进制数字(0-255)表示，数字间用符号&ldquo;.&rdquo;分开，如&ldquo;192.168.1.100&rdquo;。</p>\r\r<p>随着计算机网络规模的不断扩大，对IP地址的需求也越来越多，IPV4这种用4个字节表示的IP地址面临枯竭，因此IPv6&nbsp;便应运而生了，IPv6使用16个字节表示IP地址，它所拥有的地址容量约是IPv4的8&times;1028倍，达到2128个（算上全零的），这样就解决了网络地址资源数量不够的问题。</p>\r\r<p>通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0~65535，其中，0~1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。</p>\r\r<p>接下来通过一个图例来描述IP地址和端口号的作用，如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2242179506.png" style="width: 800px; height: 213px;" /></p>\r\r<p>从上图中可以清楚地看到，位于网络中一台计算机可以通过IP地址去访问另一台计算机，并通过端口号访问目标计算机中的某个应用程序。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 142),
(1035, 'address.png', 'address-png', 1535290787, 1535290787, 'a:5:{s:4:"name";s:11:"address.png";s:4:"path";s:35:"/usr/uploads/2018/08/2242179506.png";s:4:"size";i:88201;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1034, 0),
(1036, 'InetAddress', '1036', 1535291160, 1535292706, '<p>本文记录Java学习过程中遇到的InetAddress类～</p>\r<!--more-->\r\r<p>JDK中提供了一个InetAdderss类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法，下表中列出了InetAddress类的一些常用方法。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2279698463.png" style="width: 800px; height: 248px;" /></p>\r\r<p>上图中，列举了InetAddress的四个常用方法。其中，前两个方法用于获得该类的实例对象，第一个方法用于获得表示指定主机的InetAddress对象，第二个方法用于获得表示本地的InetAddress对象。通过InetAddress对象便可获取指定主机名，IP地址等。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rInetAddress local = InetAddress.getLocalHost();\rInetAddress remote = InetAddress.getByName(&quot;www..oliver.ren&quot;);\rSystem.out.println(&quot;本机的IP地址：&quot; + local.getHostAddress());\rSystem.out.println(&quot;oliver的IP地址：&quot; + remote.getHostAddress());\rSystem.out.println(&quot;oliver的主机名为：&quot; + remote.getHostName());</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 140),
(1037, 'inetaddress.png', 'inetaddress-png', 1535291485, 1535291485, 'a:5:{s:4:"name";s:15:"inetaddress.png";s:4:"path";s:35:"/usr/uploads/2018/08/2279698463.png";s:4:"size";i:46387;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1036, 0),
(1038, 'UDP协议', '1038', 1535294220, 1535294291, '<p>本文记录TCP/IP学习过程中遇到的UDP协议～</p>\r<!--more-->\r\r<p>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>\r\r<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>\r\r<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/4057324217.png" style="width: 800px; height: 135px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130),
(1039, 'udp.png', 'udp-png', 1535294276, 1535294276, 'a:5:{s:4:"name";s:7:"udp.png";s:4:"path";s:35:"/usr/uploads/2018/08/4057324217.png";s:4:"size";i:48738;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1038, 0),
(1040, 'TCP协议', '1040', 1535294340, 1535294459, '<p>本文记录TCP/IP学习过程中遇到的TCP协议～</p>\r<!--more-->\r\r<p>TCP协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过&ldquo;三次握手&rdquo;。第一次握手，客户端向服务器端发出连接请求，等待服务器确认，第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求，第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/357237673.png" style="width: 800px; height: 380px;" /></p>\r\r<p>由于TCP协议的面向连接特性，它可以保证传输数据的安全性，所以是一个被广泛采用的协议，例如在下载文件时，如果数据接收不完整，将会导致文件数据丢失而不能被打开，因此，下载文件时必须采用TCP协议。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 144),
(1041, 'tcp.png', 'tcp-png', 1535294431, 1535294431, 'a:5:{s:4:"name";s:7:"tcp.png";s:4:"path";s:34:"/usr/uploads/2018/08/357237673.png";s:4:"size";i:162726;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1040, 0),
(1042, 'DatagramPacket', '1042', 1535385540, 1535385829, '<p>本文记录Java学习过程中遇到的DatagramPacket～</p>\r<!--more-->\r\r<p>UDP是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用&ldquo;集装箱&rdquo;进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。</p>\r\r<p>想要创建一个DatagramPacket对象，首先需要了解一下它的构造方法。在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址和端口号。</p>\r\r<p>接下来根据API文档的内容，对DatagramPacket的构造方法进行逐一详细地讲解。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/98995351.png" style="width: 800px; height: 65px;" /></p>\r\r<p>使用该构造方法在创建DatagramPacket对象时，指定了封装数据的字节数组和数据的大小，没有指定IP地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地(ip地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1633402858.png" style="width: 800px; height: 72px;" /></p>\r\r<p>使用该构造方法在创建DatagramPacket对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标IP地址（addr）和端口号（port）。该对象通常用于发送端，因为在发送数据时必须指定接收端的IP地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。</p>\r\r<p>上面我们讲解了DatagramPacket的构造方法，接下来对DatagramPacket类中的常用方法进行详细地讲解，如下表所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/4144555813.png" style="width: 800px; height: 192px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(1043, 'datagrampacket01.png', 'datagrampacket01-png', 1535385697, 1535385697, 'a:5:{s:4:"name";s:20:"datagrampacket01.png";s:4:"path";s:33:"/usr/uploads/2018/08/98995351.png";s:4:"size";i:12609;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1042, 0),
(1044, 'datagrampacket02.png', 'datagrampacket02-png', 1535385753, 1535385753, 'a:5:{s:4:"name";s:20:"datagrampacket02.png";s:4:"path";s:35:"/usr/uploads/2018/08/1633402858.png";s:4:"size";i:16523;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1042, 0),
(1045, 'datagrampacket03.png', 'datagrampacket03-png', 1535385814, 1535385814, 'a:5:{s:4:"name";s:20:"datagrampacket03.png";s:4:"path";s:35:"/usr/uploads/2018/08/4144555813.png";s:4:"size";i:38102;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1042, 0),
(1046, 'DatagramSocket', '1046', 1535385840, 1535386163, '<p>本文记录Java学习过程中遇到的DatagramSocket～</p>\r<!--more-->\r\r<p>DatagramPacket数据包的作用就如同是&ldquo;集装箱&rdquo;，可以将发送端或者接收端的数据封装起来。然而运输货物只有&ldquo;集装箱&rdquo;是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包，发送数据的过程如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3666112694.png" style="width: 800px; height: 217px;" /></p>\r\r<p>在创建发送端和接收端的DatagramSocket对象时，使用的构造方法也有所不同，下面对DatagramSocket类中常用的构造方法进行讲解。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1946213527.png" style="width: 800px; height: 76px;" /></p>\r\r<p>该构造方法用于创建发送端的DatagramSocket对象，在创建DatagramSocket对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/2886467804.png" style="width: 800px; height: 75px;" /></p>\r\r<p>该构造方法既可用于创建接收端的DatagramSocket对象，又可以创建发送端的DatagramSocket对象，在创建接收端的DatagramSocket对象时，必须要指定一个端口号，这样就可以监听指定的端口。</p>\r\r<p>上面我们讲解了DatagramSocket的构造方法，接下来对DatagramSocket类中的常用方法进行详细地讲解。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/777157159.png" style="width: 800px; height: 126px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 125),
(1047, 'datagramsocket.png', 'datagramsocket-png', 1535385941, 1535385941, 'a:5:{s:4:"name";s:18:"datagramsocket.png";s:4:"path";s:35:"/usr/uploads/2018/08/3666112694.png";s:4:"size";i:103333;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1046, 0),
(1048, 'datagramsocket01.png', 'datagramsocket01-png', 1535385994, 1535385994, 'a:5:{s:4:"name";s:20:"datagramsocket01.png";s:4:"path";s:35:"/usr/uploads/2018/08/1946213527.png";s:4:"size";i:13645;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1046, 0),
(1049, 'datagramsocket02.png', 'datagramsocket02-png', 1535386065, 1535386065, 'a:5:{s:4:"name";s:20:"datagramsocket02.png";s:4:"path";s:35:"/usr/uploads/2018/08/2886467804.png";s:4:"size";i:14075;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1046, 0),
(1050, 'datagramsocket03.png', 'datagramsocket03-png', 1535386149, 1535386149, 'a:5:{s:4:"name";s:20:"datagramsocket03.png";s:4:"path";s:34:"/usr/uploads/2018/08/777157159.png";s:4:"size";i:21112;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1046, 0),
(1051, 'UDP网络程序', '1051', 1535386260, 1535386442, '<p>本文记录Java学习过程中遇到的UDP网络程序～</p>\r<!--more-->\r\r<p>下图为UDP发送端与接收端交互图解：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/575508805.png" style="width: 800px; height: 441px;" /></p>\r\r<p>要实现UDP通信需要创建一个发送端程序和一个接收端程序，很明显，在通信时只有接收端程序先运行，才能避免因发送端发送的数据无法接收，而造成数据丢失。因此，首先需要来完成接收端程序的编写。</p>\r\r<p>示例代码（发送端）：</p>\r\r<pre class="brush:java;">\rpublic class UDPSend {\r	public static void main(String[] args) throws IOException {\r		//1,创建DatagramSocket对象\r		DatagramSocket sendSocket = new DatagramSocket();\r		//2，创建DatagramPacket对象，并封装数据\r		//public DatagramPacket(byte[] buf, int length, InetAddress address,  int port)\r		//构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。\r		byte[] buffer = &quot;hello,UDP&quot;.getBytes();\r		DatagramPacket dp = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(&quot;192.168.75.58&quot;), 12306);\r		//3，发送数据\r		//public void send(DatagramPacket p) 从此套接字发送数据报包\r		sendSocket.send(dp);\r		//4，释放流资源\r		sendSocket.close();\r	}\r}</pre>\r\r<p>示例代码（接收端）：</p>\r\r<pre class="brush:java;">\rpublic class UDPReceive {\r	public static void main(String[] args) throws IOException {\r		//1,创建DatagramSocket对象,并指定端口号\r		DatagramSocket receiveSocket = new DatagramSocket(12306);\r		//2,创建DatagramPacket对象, 创建一个空的仓库\r		byte[] buffer = new byte[1024];\r		DatagramPacket dp = new DatagramPacket(buffer, 1024);\r		//3,接收数据存储到DatagramPacket对象中\r		receiveSocket.receive(dp);\r		//4,获取DatagramPacket对象的内容\r		//谁发来的数据  getAddress()\r		InetAddress ipAddress = dp.getAddress();\r		String ip = ipAddress.getHostAddress();//获取到了IP地址\r		//发来了什么数据  getData()\r		byte[] data = dp.getData();\r		//发来了多少数据 getLenth()\r		int length = dp.getLength();\r		//显示收到的数据\r		String dataStr = new String(data,0,length);\r		System.out.println(&quot;IP地址：&quot;+ip+ &quot;数据是&quot;+ dataStr);\r		//5,释放流资源\r		receiveSocket.close();\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(1052, 'udp-program.png', 'udp-program-png', 1535386328, 1535386328, 'a:5:{s:4:"name";s:15:"udp-program.png";s:4:"path";s:34:"/usr/uploads/2018/08/575508805.png";s:4:"size";i:136661;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1051, 0),
(1053, 'ServerSocket', '1053', 1535471280, 1535471575, '<p>本文记录Java学习过程中遇到的ServerSocket类～</p>\r<!--more-->\r\r<p>TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。</p>\r\r<p>区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。</p>\r\r<p>而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。</p>\r\r<p>在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。</p>\r\r<p>通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。</p>\r\r<p>JDK的java.net包中提供了一个ServerSocket类，该类的实例对象可以实现一个服务器段的程序。通过查阅API文档可知，ServerSocket类提供了多种构造方法，接下来就对ServerSocket的构造方法进行逐一地讲解。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1222050138.png" style="width: 800px; height: 79px;" /></p>\r\r<p>使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上（参数port就是端口号）。</p>\r\r<p>接下来学习一下ServerSocket的常用方法，如表所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1382085284.png" style="width: 800px; height: 176px;" /></p>\r\r<p>ServerSocket对象负责监听某台计算机的某个端口号，在创建ServerSocket对象后，需要继续调用该对象的accept()方法，接收来自客户端的请求。当执行了accept()方法之后，服务器端程序会发生阻塞，直到客户端发出连接请求，accept()方法才会返回一个Scoket对象用于和客户端实现通信，程序才能继续向下执行。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 108),
(1054, 'serversocket.png', 'serversocket-png', 1535471460, 1535471460, 'a:5:{s:4:"name";s:16:"serversocket.png";s:4:"path";s:35:"/usr/uploads/2018/08/1222050138.png";s:4:"size";i:33467;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1053, 0),
(1055, 'serversocket1.png', 'serversocket1-png', 1535471541, 1535471541, 'a:5:{s:4:"name";s:17:"serversocket1.png";s:4:"path";s:35:"/usr/uploads/2018/08/1382085284.png";s:4:"size";i:90761;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1053, 0),
(1056, 'Socket', '1056', 1535471820, 1535472194, '<p>本文记录Java学习过程中遇到的Socket类～</p>\r<!--more-->\r\r<p>ServerSocket对象可以实现服务端程序，但只实现服务器端程序还不能完成通信，此时还需要一个客户端程序与之交互，为此JDK提供了一个Socket类，用于实现TCP客户端程序。</p>\r\r<p>通过查阅API文档可知Socket类同样提供了多种构造方法，接下来就对Socket的常用构造方法进行详细讲解。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/4129834327.png" style="width: 800px; height: 68px;" /></p>\r\r<p>使用该构造方法在创建Socket对象时，会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数host接收的是一个字符串类型的IP地址。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/1106650878.png" style="width: 800px; height: 74px;" /></p>\r\r<p>该方法在使用上与第二个构造方法类似，参数address用于接收一个InetAddress类型的对象，该对象用于封装一个IP地址。</p>\r\r<p>在以上Socket的构造方法中，最常用的是第一个构造方法。</p>\r\r<p>接下来学习一下Socket的常用方法，如表所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/3213207188.png" style="width: 800px; height: 387px;" /></p>\r\r<p>在Socket类的常用方法中，getInputStream()和getOutStream()方法分别用于获取输入流和输出流。当客户端和服务端建立连接后，数据是以IO流的形式进行交互的，从而实现通信。</p>\r\r<p>接下来通过一张图来描述服务器端和客户端的数据传输，如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/08/843510635.png" style="width: 800px; height: 233px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(1057, 'socket01.png', 'socket01-png', 1535471959, 1535471959, 'a:5:{s:4:"name";s:12:"socket01.png";s:4:"path";s:35:"/usr/uploads/2018/08/4129834327.png";s:4:"size";i:37993;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1056, 0),
(1058, 'socket02.png', 'socket02-png', 1535472019, 1535472019, 'a:5:{s:4:"name";s:12:"socket02.png";s:4:"path";s:35:"/usr/uploads/2018/08/1106650878.png";s:4:"size";i:41700;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1056, 0),
(1059, 'socket03.png', 'socket03-png', 1535472099, 1535472099, 'a:5:{s:4:"name";s:12:"socket03.png";s:4:"path";s:35:"/usr/uploads/2018/08/3213207188.png";s:4:"size";i:389869;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1056, 0),
(1060, 'socket04.png', 'socket04-png', 1535472180, 1535472180, 'a:5:{s:4:"name";s:12:"socket04.png";s:4:"path";s:34:"/usr/uploads/2018/08/843510635.png";s:4:"size";i:166746;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1056, 0),
(1061, 'TCP网络程序', '1061', 1535549040, 1535549594, '<p>本文记录Java学习过程中遇到的TCP网络程序～</p>\r<!--more-->\r\r<p>了解了ServerSocket、Socket类的基本用法，为了让大家更好地掌握这两个类的使用，接下来通过一个TCP通信的案例来进一步学习。</p>\r\r<p>要实现TCP通信需要创建一个服务器端程序和一个客户端程序，为了保证数据传输的安全性，首先需要实现服务器端程序。</p>\r\r<p>示例代码（TCP服务端）：</p>\r\r<pre class="brush:java;">\rpublic class TCPServer {\r	public static void main(String[] args) throws IOException {\r		//1,创建服务器ServerSocket对象（指定服务器端口号）\r		ServerSocket ss = new ServerSocket(8888);\r		//2，开启服务器了，等待客户端的连接，当客户端连接后，可以获取到连接服务器的客户端Socket对象\r		Socket s = ss.accept();\r		//3,给客户端反馈信息\r		/*\r		 * a,获取客户端的输出流\r		 * b,在服务端端，通过客户端的输出流写数据给客户端\r		 */\r		//a,获取客户端的输出流\r		OutputStream out = s.getOutputStream();\r		//b,在服务端端，通过客户端的输出流写数据给客户端\r		out.write(&quot;你已经连接上了服务器&quot;.getBytes());\r		//4,关闭流资源\r		out.close();\r		s.close();\r		//ss.close();  服务器流 通常都是不关闭的\r	}\r}</pre>\r\r<p>示例代码（TCP客户端）：</p>\r\r<pre class="brush:java;">\rpublic class TCPClient {\r	public static void main(String[] args) throws IOException {\r		//1，创建客户端Socket对象,（指定要连接的服务器地址与端口号）\r		Socket s = new Socket(&quot;192.168.74.58&quot;, 8888);\r		//2,获取服务器端的反馈回来的信息\r		InputStream in = s.getInputStream();\r		//获取获取流中的数据\r		byte[] buffer = new byte[1024];\r		//把流中的数据存储到数组中，并记录读取字节的个数\r		int length = in.read(buffer);\r		//显示数据\r		System.out.println( new String(buffer, 0 , length) );\r		//3,关闭流资源\r		in.close();\r		s.close();\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 122),
(1062, '类加载器', '1062', 1535764680, 1535764995, '<p>本文记录Java学习过程中遇到的类加载器～</p>\r<!--more-->\r\r<p><strong>类的加载</strong></p>\r\r<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</p>\r\r<ul>\r	<li>加载</li>\r</ul>\r\r<p>就是指将class文件读入内存，并为之创建一个Class对象。</p>\r\r<p>任何类被使用时系统都会建立一个Class对象</p>\r\r<ul>\r	<li>连接</li>\r</ul>\r\r<p>验证是否有正确的内部结构，并和其他类协调一致</p>\r\r<p>准备负责为类的静态成员分配内存，并设置默认初始化值</p>\r\r<p>解析将类的二进制数据中的符号引用替换为直接引用</p>\r\r<ul>\r	<li>初始化</li>\r</ul>\r\r<p>就是我们以前讲过的初始化步骤</p>\r\r<p><strong>类初始化时机</strong></p>\r\r<ol>\r	<li>创建类的实例；</li>\r	<li>类的静态变量，或者为静态变量赋值；</li>\r	<li>类的静态方法；</li>\r	<li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象；</li>\r	<li>初始化某个类的子类；</li>\r	<li>直接使用java.exe命令来运行某个主类。</li>\r</ol>\r\r<p><strong>类加载器</strong></p>\r\r<ul>\r	<li>负责将.class文件加载到内在中，并为之生成对应的Class对象。</li>\r	<li>虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行</li>\r</ul>\r\r<p><strong>类加载器的组成</strong></p>\r\r<ul>\r	<li>Bootstrap ClassLoader&nbsp;根类加载器</li>\r</ul>\r\r<p>也被称为引导类加载器，负责Java核心类的加载</p>\r\r<p>比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</p>\r\r<ul>\r	<li>Extension ClassLoader&nbsp;扩展类加载器</li>\r</ul>\r\r<p>负责JRE的扩展目录中jar包的加载。</p>\r\r<p>在JDK中JRE的lib目录下ext目录</p>\r\r<ul>\r	<li>System ClassLoader&nbsp;系统类加载器</li>\r</ul>\r\r<p>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。</p>\r\r<p>通过这些描述就可以知道我们常用的类，都是由谁来加载完成的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1063, '反射', '1063', 1535765160, 1535765198, '<p>本文记录Java学习过程中遇到的反射～</p>\r<!--more-->\r\r<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(1064, 'Class类', '1064', 1535765220, 1535765487, '<p>本文记录Java学习过程中遇到的Class类～</p>\r<!--more-->\r\r<p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。</p>\r\r<p>阅读API的Class类得知，Class没有公共构造方法。Class对象是在加载类时由Java&nbsp;虚拟机以及通过调用类加载器中的defineClass方法自动构造的。</p>\r\r<p>获取Class对象的三种方式：</p>\r\r<p>方式一：通过Object类中的getObject()方法</p>\r\r<pre class="brush:java;">\rPerson p = new Person();\rClass c = p.getClass();</pre>\r\r<p>方式二:&nbsp;通过类名.class&nbsp;获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单）。</p>\r\r<pre class="brush:java;">\rClass c2 = Person.class;</pre>\r\r<p>方式三:&nbsp;通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可）。</p>\r\r<pre class="brush:java;">\rClass c3 = Class.forName(&quot;Person&quot;);</pre>\r\r<p>注意：第三种和前两种的区别</p>\r\r<ul>\r	<li>前两种你必须明确Person类型.</li>\r	<li>后面是指定这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/*\r * 获取.class字节码文件对象的方式\r * 		1：通过Object类中的getObject()方法\r * 		2: 通过 类名.class 获取到字节码文件对象\r * 		3: 反射中的方法,\r * 			public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException\r * 			返回与带有给定字符串名的类或接口相关联的 Class 对象 \r */\rpublic class ReflectDemo {\r	public static void main(String[] args) throws ClassNotFoundException {\r		// 1： 通过Object类中的getObject()方法\r		// Person p1 = new Person();\r		// Class c1 = p1.getClass();\r		// System.out.println(&quot;c1 = &quot;+ c1);\r\r		// 2: 通过 类名.class 获取到字节码文件对象\r		// Class c2 = Person.class;\r		// System.out.println(&quot;c2 = &quot;+ c2);\r\r		// 3: 反射中的方法\r		Class c3 = Class.forName(&quot;ren.oliver.Person&quot;);// 包名.类名\r		System.out.println(&quot;c3 = &quot; + c3);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(1065, '通过反射获取构造方法并使用', '1065', 1535765580, 1535765991, '<p>本文记录Java学习过程中遇到的通过反射获取构造方法并使用～</p>\r<!--more-->\r\r<p>在反射机制中，把类中的成员（构造方法、成员方法、成员变量）都封装成了对应的类进行表示。其中，构造方法使用类Constructor表示。可通过Class类中提供的方法获取构造方法：</p>\r\r<p>返回一个构造方法：</p>\r\r<ul>\r	<li>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)&nbsp;获取public修饰,&nbsp;指定参数类型所对应的构造方法</li>\r	<li>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)&nbsp;获取指定参数类型所对应的构造方法(包含私有的)</li>\r</ul>\r\r<p>返回多个构造方法：</p>\r\r<ul>\r	<li>public Constructor&lt;?&gt;[] getConstructors()&nbsp;获取所有的public&nbsp;修饰的构造方法</li>\r	<li>public Constructor&lt;?&gt;[] getDeclaredConstructors()&nbsp;获取所有的构造方法(包含私有的)</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ReflectDemo {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\r		//获取Class对象\r		Class c = Class.forName(&quot;ren.oliver.Person&quot;);//包名.类名\r		\r		//获取所有的构造方法\r		//Constructor[] cons = c.getConstructors();\r		Constructor[] cons = c.getDeclaredConstructors();\r		for (Constructor con : cons) {\r			System.out.println(con);\r		}\r		\r		System.out.println(&quot;------------------------&quot;);\r		//获取一个构造方法\r		//public Person() \r		Constructor con1 = c.getConstructor(null);\r		System.out.println(con1);\r		\r		//public Person(String name)\r		Constructor con2 = c.getConstructor(String.class);\r		System.out.println(con2);\r		\r		//private Person(String name, int age)\r		Constructor con3 = c.getDeclaredConstructor(String.class, int.class);\r		System.out.println(con3);\r		\r		//public Person(String name, int age, String address)\r		Constructor con4 = c.getDeclaredConstructor(String.class, int.class, String.class);\r		System.out.println(con4);\r	}\r}</pre>\r\r<ul>\r	<li>通过反射方式，获取构造方法，创建对象</li>\r</ul>\r\r<p>获取构造方法，步骤如下：</p>\r\r<p>1.&nbsp;获取到Class对象</p>\r\r<p>2.&nbsp;获取指定的构造方法</p>\r\r<p>3.&nbsp;通过构造方法类Constructor中的方法，创建对象</p>\r\r<p>public T newInstance(Object... initargs)</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ConstructorDemo {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\r		//1,获取到Class对象\r		Class c = Class.forName(&quot;ren.oliver.Person&quot;);//包名.类名\r		//2,获取指定的构造方法\r		//public Person()\r		//Constructor con = c.getConstructor(null);\r		\r		//public Person(String name, int age, String address)\r		Constructor con = c.getConstructor(String.class, int.class, String.class);\r		\r		//3,通过构造方法类中Constructor的方法，创建对象\r		//Object obj = con.newInstance(null);\r		Object obj = con.newInstance(&quot;小明&quot;, 22, &quot;哈尔滨&quot;);\r		\r		//显示\r		System.out.println(obj);\r	}\r}</pre>\r\r<ul>\r	<li>通过反射方式，获取私有构造方法，创建对象</li>\r</ul>\r\r<p>AccessibleObject类是Field、Method&nbsp;和Constructor&nbsp;对象的父类。它提供了将反射的对象标记为在使用时取消默认Java&nbsp;语言访问控制检查的能力。</p>\r\r<p>对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用Field、Method&nbsp;或Constructor&nbsp;对象来设置或获取字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查。常用方法如下：</p>\r\r<ul>\r	<li>public void&nbsp;setAccessible(boolean&nbsp;flag) throws&nbsp;SecurityException</li>\r</ul>\r\r<p>参数值为true则指示反射的对象在使用时应该取消Java&nbsp;语言访问检查。参数值为false则指示反射的对象应该实施Java&nbsp;语言访问检查。</p>\r\r<p>获取私有构造方法，步骤如下：</p>\r\r<p>1.&nbsp;获取到Class对象</p>\r\r<p>2.&nbsp;获取指定的构造方法</p>\r\r<p>3.&nbsp;暴力访问,&nbsp;通过setAccessible(boolean&nbsp;flag)方法</p>\r\r<p>4.&nbsp;通过构造方法类Constructor中的方法，创建对象</p>\r\r<p>public T newInstance(Object... initargs)</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ConstructorDemo {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\r		//1,获取到Class对象\r		Class c = Class.forName(&quot;ren.oliver.Person&quot;);//包名.类名\r		\r		//2,获取指定的构造方法\r		//private Person(String name, int age)\r		Constructor con = c.getDeclaredConstructor(String.class, int.class);\r		\r		//3,暴力反射 \r		con.setAccessible(true);//取消 Java 语言访问检查\r		\r		//4,通过构造方法类中的功能，创建对象\r		Object obj = con.newInstance(&quot;小明&quot;, 23);\r		System.out.println(obj);\r		\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(1066, '通过反射获取成员变量并使用', '1066', 1535766060, 1554036042, '<p>本文记录Java学习过程中遇到的通过反射获取成员变量并使用～</p>\r<!--more-->\r\r<p>在反射机制中，把类中的成员变量使用类Field表示。可通过Class类中提供的方法获取成员变量：</p>\r\r<ul>\r	<li>返回一个成员变量\r	<ul style="list-style-type:square;">\r		<li>public Field getField(String name)&nbsp;获取指定的public修饰的变量</li>\r		<li>public Field getDeclaredField(String name)&nbsp;获取指定的任意变量</li>\r	</ul>\r	</li>\r	<li>返回多个成员变量\r	<ul style="list-style-type:square;">\r		<li>public Field[] getFields()&nbsp;获取所有public&nbsp;修饰的变量</li>\r		<li>public Field[] getDeclaredFields()&nbsp;获取所有的变量(包含私有)</li>\r	</ul>\r	</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class FieldDemo {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException {\r		//获取Class对象\r		Class c = Class.forName(&quot;ren.oliver.Person&quot;);\r		\r		//获取成员变量\r		//多个变量\r		//Field[] fields = c.getFields();\r		Field[] fields =  c.getDeclaredFields();\r		for (Field field : fields) {\r			System.out.println(field);\r		}\r		System.out.println(&quot;-----------------&quot;);\r		//一个变量\r		//public int age;\r		Field ageField = c.getField(&quot;age&quot;);\r		System.out.println(ageField);\r		\r		//private String address\r		Field addressField = c.getDeclaredField(&quot;address&quot;);\r		System.out.println(addressField);\r	}\r}</pre>\r\r<ul>\r	<li>通过反射，创建对象，获取指定的成员变量，进行赋值与获取值操作</li>\r</ul>\r\r<p>获取成员变量，步骤如下：</p>\r\r<p>1.&nbsp;获取Class对象</p>\r\r<p>2.&nbsp;获取构造方法</p>\r\r<p>3.&nbsp;通过构造方法，创建对象</p>\r\r<p>4.&nbsp;获取指定的成员变量（私有成员变量，通过setAccessible(boolean&nbsp;flag)方法暴力访问）</p>\r\r<p>5.&nbsp;通过方法，给指定对象的指定成员变量赋值或者获取值</p>\r\r<ul>\r	<li>public void set(Object obj, Object value)</li>\r</ul>\r\r<p>在指定对象obj中，将此Field&nbsp;对象表示的成员变量设置为指定的新值</p>\r\r<ul>\r	<li>public Object get(Object obj)</li>\r</ul>\r\r<p>返回指定对象obj中，此Field&nbsp;对象表示的成员变量的值</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class FieldDemo {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException {\r		//1,获取Class对象\r		Class c = Class.forName(&quot;cn.itcast_01_Reflect.Person&quot;);\r		//2，获取构造方法\r		//public Person(String name) \r		Constructor con = c.getConstructor(String.class);\r		//3，通过构造方法，创建对象\r		Object obj = con.newInstance(&quot;小明&quot;);\r		//4，获取指定的成员变量\r		//public String name;\r		Field nameField = c.getField(&quot;name&quot;);\r		//public int age;\r		Field ageField = c.getField(&quot;age&quot;);\r		//private String address;\r		Field addressField = c.getDeclaredField(&quot;address&quot;);\r		addressField.setAccessible(true); //取消 Java 语言访问检查\r		\r		//5，通过方法，给指定对象的指定成员变量赋值或者获取值\r		System.out.println(&quot;name = &quot;+ nameField.get(obj));\r		System.out.println(&quot;age = &quot;+ ageField.get(obj));\r		System.out.println(&quot;address = &quot;+ addressField.get(obj));\r		\r		//赋值\r		ageField.set(obj, 23);\r		addressField.set(obj, &quot;凯利广场&quot;);\r		\r		System.out.println(&quot;------------------------&quot;);\r		System.out.println(&quot;name = &quot;+ nameField.get(obj));\r		System.out.println(&quot;age = &quot;+ ageField.get(obj));\r		System.out.println(&quot;address = &quot;+ addressField.get(obj));\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 135),
(1067, '通过反射获取成员方法并使用', '1067', 1535769480, 1535772315, '<p>本文记录Java学习过程中遇到的通过反射获取成员方法并使用～</p>\r<!--more-->\r\r<p>在反射机制中，把类中的成员方法使用类Method表示。可通过Class类中提供的方法获取成员方法：</p>\r\r<ul>\r	<li>返回获取一个方法：</li>\r</ul>\r\r<p>public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</p>\r\r<p>获取public&nbsp;修饰的方法</p>\r\r<p>public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</p>\r\r<p>获取任意的方法，包含私有的</p>\r\r<p>参数1: name&nbsp;要查找的方法名称；参数2：parameterTypes&nbsp;该方法的参数类型</p>\r\r<ul>\r	<li>返回获取多个方法：</li>\r</ul>\r\r<p>public Method[] getMethods()&nbsp;获取本类与父类中所有public&nbsp;修饰的方法</p>\r\r<p>public Method[] getDeclaredMethods()&nbsp;获取本类中所有的方法(包含私有的)</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class MethodDemo {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\r		//获取Class对象\r		Class c = Class.forName(&quot;ren.oliver.Person&quot;);\r		\r		//获取多个方法\r		//Method[] methods = c.getMethods();\r		Method[] methods = c.getDeclaredMethods();\r		for (Method method : methods) {\r			System.out.println(method);\r		}\r		\r		System.out.println(&quot;-----------------------&quot;);\r		//获取一个方法：\r		//public void method1()\r		Method method = c.getMethod(&quot;method1&quot;, null);\r		System.out.println(method);\r		//public String method4(String name){\r		method = c.getMethod(&quot;method4&quot;, String.class);\r		System.out.println(method);\r		//私有方法\r		//private void method5()\r		method = c.getDeclaredMethod(&quot;method5&quot;, null);\r		System.out.println(method);\r	}\r}</pre>\r\r<ul>\r	<li>通过反射，创建对象，调用指定的方法</li>\r</ul>\r\r<p>获取成员方法，步骤如下：</p>\r\r<ol>\r	<li>获取Class对象</li>\r	<li>获取构造方法</li>\r	<li>通过构造方法，创建对象</li>\r	<li>获取指定的方法</li>\r	<li>执行找到的方法</li>\r</ol>\r\r<p>public Object invoke(Object obj,&nbsp;&nbsp;Object... args)&nbsp;</p>\r\r<p>执行指定对象obj中，当前Method对象所代表的方法，方法要传入的参数通过args指定。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class MethodDemo2 {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\r		//1， 获取Class对象\r		Class c = Class.forName(&quot;renoliver.Person&quot;);\r		//2,获取构造方法\r		//public Person(String name, int age, String address){\r		Constructor con = c.getConstructor(String.class, int.class, String.class);\r		//3，通过构造方法，创建对象\r		Object obj = con.newInstance(&quot;小明&quot;, 23, &quot;哈尔滨&quot;);\r		//4，获取指定的方法\r		//public void method1()  没有返回值没有参数的方法\r		//Method m1 = c.getMethod(&quot;method1&quot;, null);\r		\r		//public String method4(String name)\r		Method m4 = c.getMethod(&quot;method4&quot;, String.class);\r		\r		//5，执行找到的方法\r		//m1.invoke(obj, null);\r		\r		Object result = m4.invoke(obj, &quot;itcast&quot;);\r		System.out.println(&quot;result = &quot; + result);\r	}\r}</pre>\r\r<ul>\r	<li>通过反射，创建对象，调用指定的private&nbsp;方法</li>\r</ul>\r\r<p>获取私有成员方法，步骤如下：</p>\r\r<ol>\r	<li>获取Class对象</li>\r	<li>获取构造方法</li>\r	<li>通过构造方法，创建对象</li>\r	<li>获取指定的方法</li>\r	<li>开启暴力访问</li>\r	<li>执行找到的方法</li>\r</ol>\r\r<pre class="brush:java;">\rpublic Object invoke(Object obj,  Object... args)\r执行指定对象obj中，当前Method对象所代表的方法，方法要传入的参数通过args指定。</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class MethodDemo {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\r		//1， 获取Class对象\r		Class c = Class.forName(&quot;ren.oliver.Person&quot;);\r		//2,获取构造方法\r		//public Person(String name, int age, String address){\r		Constructor con = c.getConstructor(String.class, int.class, String.class);\r		//3，通过构造方法，创建对象\r		Object obj = con.newInstance(&quot;小明&quot;, 23, &quot;哈尔滨&quot;);\r		//4，获取指定的方法\r		//private void method5(){\r		Method m5 = c.getDeclaredMethod(&quot;method5&quot;, null);\r		//5,开启暴力访问\r		m5.setAccessible(true);\r		//6，执行找到的方法\r		m5.invoke(obj, null);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 102),
(1068, '泛型擦除', '1068', 1535772420, 1535772500, '<p>本文记录Java学习过程中遇到的泛型擦出～</p>\r<!--more-->\r\r<p>思考，将已存在的ArrayList&lt;Integer&gt;集合中添加一个字符串数据，如何实现呢？</p>\r\r<p>告诉大家，其实程序编译后产生的.class文件中是没有泛型约束的，这种现象我们称为泛型的擦除。那么，我们可以通过反射技术，来完成向有泛型约束的集合中，添加任意类型的元素。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ReflectTest {\r	public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\r		ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\r		//添加元素到集合\r		list.add(new Integer(30));\r		list.add(new Integer(&quot;12345&quot;));\r		list.add(123);\r		//list.add(&quot;哈哈&quot;);//因为有泛型类型的约束\r		System.out.println(list);\r		\r		//通过反射技术，实现添加任意类型的元素\r		//1, 获取字节码文件对象\r		//Class c = list.getClass();\r		//Class c = ArrayList.class;\r		Class c = Class.forName(&quot;java.util.ArrayList&quot;);\r		\r		//2, 找到add()方法\r		// public boolean add(E e)\r		Method addMethod = c.getMethod(&quot;add&quot;, Object.class);\r		\r		//3，  执行add()方法\r		addMethod.invoke(list, &quot;哈哈&quot;);// list.add(&quot;哈哈&quot;);\r		System.out.println(list);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(1069, '反射配置文件', '1069', 1535772720, 1535772792, '<p>本文记录Java学习过程中遇到的反射配置文件～</p>\r<!--more-->\r\r<p>通过反射配置文件，运行配置文件中指定类的对应方法。</p>\r\r<p>读取Peoperties.txt文件中的数据，通过反射技术，来完成Person对象的创建</p>\r\r<p>Peoperties.txt文件内容如下：</p>\r\r<pre class="brush:java;">\rclassName=ren.oliver.Person\rmethodName=method5</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ReflectTest {\r	public static void main(String[] args)\r			throws FileNotFoundException, IOException, ClassNotFoundException, NoSuchMethodException, SecurityException,\r			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\r		// 通过Properties集合从文件中读取数据\r		Properties prop = new Properties();\r		// 读取文件中的数据到集合中\r		prop.load(new FileInputStream(&quot;properties.txt&quot;));\r		// 获取键所对应的值\r		String className = prop.getProperty(&quot;className&quot;);\r		System.out.println(className);\r\r		// 1，获取Person.class 字节码文件对象\r		Class c = Class.forName(className);\r		// 2，获取构造方法\r		// public Person(String name, int age, String address)\r		Constructor con = c.getConstructor(String.class, int.class, String.class);\r\r		// 3,创建对象\r		Object obj = con.newInstance(&quot;小明&quot;, 20, &quot;中国&quot;);\r		System.out.println(obj);\r\r		// 4，获取指定的方法\r		// private void method5(){}\r		String methodName = prop.getProperty(&quot;methodName&quot;);\r		Method m5 = c.getDeclaredMethod(methodName, null);\r		// 5,开启暴力访问\r		m5.setAccessible(true);\r		// 6，执行找到的方法\r		m5.invoke(obj, null);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(1070, 'HTML', '1070', 1535899560, 1535899844, '<p>本文记录WEB前端学习过程中遇到的HTML～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/09/2542499519.png" style="width: 800px; height: 260px;" /></p>\r\r<p>HTML：超级文本标记语言（Hyper Text Markup Language）</p>\r\r<ul>\r	<li>&ldquo;超文本&rdquo;就是指页面内可以包含图片、链接等非文字内容。</li>\r	<li>&ldquo;标记&rdquo;就是使用标签的方法将需要的内容包括起来。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;a&gt;www.oliver.ren&lt;/a&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(1071, 'html.png', 'html-png', 1535899652, 1535899652, 'a:5:{s:4:"name";s:8:"html.png";s:4:"path";s:35:"/usr/uploads/2018/09/2542499519.png";s:4:"size";i:153911;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1070, 0),
(1072, 'HTML的作用', '1072', 1535899920, 1535900297, '<p>本文记录WEB前端学习过程中遇到的HTML的作用～</p>\r<!--more-->\r\r<p>HTML用于编写网页。平时上网通过浏览器看到的大部分页面都是由HTML编写的。在浏览器访问网页时，可以通过&ldquo;邮件/查看网页源代码&rdquo;看到具体的HTML代码。</p>\r\r<p>网页内容包含：HTML代码、CSS代码、JavaScript代码等内容。</p>\r\r<ul>\r	<li>HTML代码：用于展示需要显示的数据。</li>\r	<li>CSS代码：使显示的数据更加好看。</li>\r	<li>JavaScript代码：使整个页面显示的数据具有动画效果。</li>\r</ul>\r\r<p>网页根据内容是否改变分为：静态页面和动态页面。</p>\r\r<ul>\r	<li>静态页面：编写之后在浏览器不再改变的网页，HTML就是用于编写静态网页的。</li>\r	<li>动态页面：会根据不同的情况展示不同的内容。例如：登录成功后右上角显示用户名。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(1073, 'HTML语言特点', '1073', 1535900400, 1535900822, '<p>本文记录WEB前端学习过程中遇到的HTML语言特点～</p>\r<!--more-->\r\r<p>HTML文件不需要编译，直接使用浏览器阅读即可；</p>\r\r<p>HTML文件的扩展名是*.html或*.htm；</p>\r\r<p>HTML结构都是由标签组成的：</p>\r\r<ul>\r	<li>标签名都是预先定义好的；</li>\r	<li>标签名不区分大小写；</li>\r	<li>标签通常由开始标签和结束标签组成；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;a&gt;www.oliver.ren&lt;/a&gt;</pre>\r\r<ul>\r	<li>如果没有结束标签，建议以/结尾；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;img src=&quot;http://www.oliver.ren/usr/themes/Bytecats2/img/favicon.ico&quot; /&gt;</pre>\r\r<p>HTML结构包括两部分：头head和体body。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 109),
(1074, '标题标签', '1074', 1535900880, 1535901127, '<p>本文记录WEB前端学习过程中遇到的标题标签～</p>\r<!--more-->\r\r<p>HTML提供&lt;hn&gt;系列标签，用于修饰标题，包含：&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;。</p>\r\r<p>&lt;h1&gt;定义最大的标题，&lt;h6&gt;定义最小的标题。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--标题标签--&gt;\r&lt;h1&gt;Oliver&#39;s Blog&lt;/h1&gt;\r&lt;h6&gt;檀香学习笔记&lt;/h6&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(1075, '分割线标签', '1075', 1535901240, 1535901516, '<p>本文记录WEB前端学习过程中遇到的分割线标签～</p>\r<!--more-->\r\r<p>&lt;hr /&gt;标签在HTML页面中会创建一条水平分割线，用于定义内容中的主题变化。</p>\r\r<ul>\r	<li>size属性：水平线的高度，单位是像素；</li>\r	<li>noshade属性：没有阴影，取值为noshade，表示纯色。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--水平线--&gt;\r&lt;hr /&gt;\r&lt;hr size=&quot;5&quot; /&gt;\r&lt;hr noshade=&quot;noshade&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 145),
(1076, '字体标签', '1076', 1535901660, 1535902208, '<p>本文记录WEB前端学习过程中遇到的字体标签～</p>\r<!--more-->\r\r<p>&lt;font&gt;用于设置字体尺寸和字体颜色等。</p>\r\r<ul>\r	<li>size属性：设置字体的大小，取值为1-7的数字，浏览器默认值是3.</li>\r	<li>color属性：设置字体的颜色。</li>\r</ul>\r\r<p>颜色的取值：#xxxxxx或者colorname，#xxxxxx表示使用红绿蓝三原色设置颜色，红绿蓝分别取值：00-FF，使用的是16进制。</p>\r\r<p>例如：</p>\r\r<pre class="brush:xml;">\r黑色：#000000\r白色：#FFFFFF\r红色：#FF0000\r绿色：#00FF00\r蓝色：#0000FF</pre>\r\r<p>注意：红绿蓝两位取值相同可以省略成一位。例如：#112233可以简写为#123。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--字体--&gt;\r&lt;font size=&quot;7&quot;&gt;7号字体&lt;/font&gt;\r&lt;font color=&quot;#FF0000&quot;&gt;红色字体&lt;/font&gt;\r&lt;font color=&quot;blue&quot;&gt;蓝色字体&lt;/font&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(1077, '格式化标签', '1077', 1535902200, 1535902451, '<p>本文记录WEB前端学习过程中遇到的格式化标签～</p>\r<!--more-->\r\r<p>格式化标签有两个：</p>\r\r<ul>\r	<li>粗体：&lt;b&gt;</li>\r	<li>斜体：&lt;i&gt;</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--格式化标签--&gt;\r&lt;b&gt;粗体字&lt;/b&gt;\r&lt;I&gt;斜体字&lt;/I&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(1078, '段落标签', '1078', 1535902500, 1535937339, '<p>本文记录WEB前端学习过程中遇到的段落标签～</p>\r<!--more-->\r\r<p>用来表示段落的标签有两个：</p>\r\r<ul>\r	<li>段落：&lt;p&gt;，它会自动在段落前后创建一些空白。</li>\r	<li>换行：插入单个换行。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(1079, '图片标签', '1079', 1535987940, 1535988293, '<p>本文记录WEB前端学习过程中遇到的图片标签～</p>\r<!--more-->\r\r<p>&lt;img&gt;在HTMl页面中表示引用一张图片，它有如下属性：</p>\r\r<ul>\r	<li>src：指定需要显示的图片的URL（路径）；</li>\r	<li>alt：图片无法显示时的替代文本；</li>\r	<li>width：设置图像的宽度；</li>\r	<li>height：设置图像的高度。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r&lt;img src=&quot;http://www.oliver.ren/usr/themes/Bytecats2/img/favicon.ico&quot; alt=&quot;Oliver&#39;s Blog&quot; width=&quot;200px&quot; height=&quot;200px&quot; title=&quot;图片标题&quot; /&gt;\r&lt;img src=&quot;http://www.oliver.ren/404.png&quot; alt=&quot;Oliver&#39;s Blog&quot; width=&quot;200px&quot; height=&quot;200px&quot; title=&quot;图片标题&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(1080, '列表标签', '1080', 1536077040, 1536077550, '<p>本文记录WEB前端学习过程中遇到的列表标签～</p>\r<!--more-->\r\r<p>&lt;ol&gt;：定义有序列表。</p>\r\r<ul>\r	<li>&nbsp;type：列表类型，取值为A、a、I、i、1等。</li>\r</ul>\r\r<p>&lt;ul&gt;：定义无需列表。</p>\r\r<ul>\r	<li>type：符号的类型，取值为disc实心圆、square方块、circle空心圆等。</li>\r</ul>\r\r<p>&lt;li&gt;：定义列表项，是&lt;ul&gt;和&lt;ol&gt;的子标签。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r&lt;!--空心圆--&gt;\r&lt;ul type=&quot;circle&quot;&gt;\r    &lt;li&gt;一&lt;/li&gt;\r    &lt;li&gt;二&lt;/li&gt;\r    &lt;li&gt;三&lt;/li&gt;\r&lt;/ul&gt;\r&lt;ol type=&quot;I&quot;&gt;\r    &lt;li&gt;一&lt;/li&gt;\r    &lt;li&gt;二&lt;/li&gt;\r    &lt;li&gt;三&lt;/li&gt;\r&lt;/ol&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(1081, '超链接标签', '1081', 1536077640, 1536077986, '<p>本文记录WEB前端学习过程中遇到的超链接标签～</p>\r<!--more-->\r\r<p>&lt;a&gt;是超链接标签，是在HTML页面提供一种可以访问其他闻之的实现方式。</p>\r\r<ul>\r	<li>href：用户确定需要显示页面的路径（URL）；</li>\r	<li>target：确定以何种方式打开href所设置的页面，常用取值：_blank、_self等。</li>\r</ul>\r\r<ol style="margin-left: 40px;">\r	<li>_blank表示在新窗口中打开href确定的页面；</li>\r	<li>_self是默认值，使用href确定的页面替换当前页面。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;a href=&quot;http://www.oliver.ren&quot; target=&quot;_self&quot; /&gt;\r&lt;a href=&quot;http://www.oliver.ren&quot; target=&quot;_blank&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 94),
(1082, '表格标签', '1082', 1536161340, 1536162502, '<p>本文记录WEB前端学习过程中遇到的表格标签～</p>\r<!--more-->\r\r<p>HTML表格是由&lt;table&gt;标签以及一个或多个&lt;tr&gt;、&lt;th&gt;或&lt;td&gt;标签组成。</p>\r\r<p>&lt;table&gt;是父标签，相当于整个表格的容器。</p>\r\r<ul>\r	<li>border：表格边框的宽度；</li>\r	<li>width：表格的宽度；</li>\r	<li>cellpadding：单元边沿与其内容之间的空白；</li>\r	<li>cellspacing：单元格之间的空白；</li>\r	<li>bgcolor：表格的背景颜色。</li>\r</ul>\r\r<p>&lt;tr&gt;标签用于定义行。</p>\r\r<p>&lt;td&gt;标签用于定义表格的单元格（一个列）。</p>\r\r<ul>\r	<li>colspan：单元格可横跨的列数；</li>\r	<li>rowspan：单元格可横跨的行数；</li>\r	<li>align：单元格内容的水平对齐方式，取值：left左、right右、center居中；</li>\r	<li>nowrap：单元格中的内容是否折行。</li>\r</ul>\r\r<p>&lt;th&gt;标签用于定义表头，单元格内的内容默认居中并加粗。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(1297, 'AJAX简介', '1297', 1546344180, 1546354335, '<p>本文记录WEB前端学习过程中遇到的AJAX～</p>\r<!--more-->\r\r<p>AJAX即&ldquo;Asynchronous JavaScript And XML&quot;（异步JavaScript和XML），可以使网页实现异步更新，就是不重新加载整个网页的情况下，对网页的某部分进行更新（局部刷新）。传统的网页（不使用AJAX），如果需要更新内容，必须重载整个网页页面。</p>\r\r<p>AJAX = 异步JavaScript和XML，是一种新的思想，整合之前的多种技术，用于创建快速交互式网页应用的网页开发技术。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 59),
(1083, '框架标签', '1083', 1536684840, 1536685620, '<p>本文记录WEB前端学习过程中遇到的框架标签～</p>\r<!--more-->\r\r<p>&lt;frameset&gt;标签，是多个窗口页面整合在一起的一个集合（框架集）。每一个页面（框架）都是单独文档，需要使用子标签&lt;frame&gt;来确定页面的位置。&lt;frameset&gt;通过行和列来确定整体布局，使用cols确定列数，使用rows确定行数。多个&lt;frameset&gt;可以嵌套使用。</p>\r\r<ul>\r	<li>&lt;frameset&gt;和&lt;body&gt;两个不能共存；</li>\r	<li>rows属性和cols属性取值：值1, 值2，值3...，一个值表示一行（列），多个值使用逗号分隔，值可以是10px、10%等，最后一个值如果不想计算可以使用*匹配剩余量。</li>\r</ul>\r\r<p>&lt;frame&gt;标签，用于设置&lt;frameset&gt;框架集中的一个页面（框架）。</p>\r\r<ul>\r	<li>src属性：确定页面的路径；</li>\r	<li>noresize属性：框架分隔先不能移动；</li>\r	<li>target属性：确定需要显示的页面在何处显示。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(1084, '表单标签', '1084', 1536686400, 1536686938, '<p>本文记录WEB前端学习过程中遇到的表单标签～</p>\r<!--more-->\r\r<p>&lt;form&gt;表单标签，在HTML页面中创建一个表单，表单标签在浏览器上没有任何显示。如果数据需要提交到服务器，负责搜集数据的标签必须存放在表单标签体内。</p>\r\r<ul>\r	<li>action属性：请求路径，确定表单提交到服务器的地址（路径）；</li>\r	<li>method属性：请求方式，常用的取值有get和post</li>\r</ul>\r\r<ol style="margin-left: 40px;">\r	<li>get：默认值，提交的数据追加在请求路径上。例如：/1.html？username=oliver&amp;password=123456，数据格式为键值对，追加是使用?连接，之后每一对数据使用&amp;连接。</li>\r	<li>post：提交的数据不在请求路径上追加（也不显示在地址栏上），提交的数据大小没有限制。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 117),
(1085, '输入域标签', '1085', 1536768480, 1536768531, '<p>本文记录WEB前端学习过程中遇到的输入域标签～</p>\r<!--more-->\r\r<p>&lt;input&gt;标签用于获得用户输入信息，type属性值不同，搜集方式不同。</p>\r\r<ul>\r	<li>type属性：用于表明输入标签的类型，常用的类型有：</li>\r</ul>\r\r<ol style="margin-left: 40px;">\r	<li>text：文本框，单行的输入字段，用户可在其中输入文本，默认宽度为20个字符；</li>\r	<li>password：密码框，表示密码字段，该字段中的字符以黑圈显示；</li>\r	<li>radio：单选框，表示一组互斥选项按钮的一个。当一个按钮被选中，之前选中的按钮就变为非选中的；</li>\r	<li>submit：提交按钮，它会把表单数据发送到服务器，一般不写name属性，写了会把&ldquo;提交&rdquo;两个字提交到服务器；</li>\r	<li>checkbox：复选框，用于从多个选项中选择数据；</li>\r	<li>file：文件上传组件，提供&ldquo;浏览&rdquo;按钮可以选择需要上传的文件；</li>\r	<li>hidden：隐藏字段，数据会被发送到服务器，但浏览器不现实；</li>\r	<li>reset：重置按钮，将表单恢复到默认值；</li>\r	<li>image：图形提交按钮，通过src给按钮设置图片；</li>\r	<li>button：普通按钮，常用于与JavaScript结合使用。</li>\r</ol>\r\r<ul>\r	<li>name属性：元素名称，如果需要表单数据提交到服务器，必须提供name属性值，服务器通过属性值获得提交的数据；</li>\r	<li>value属性：设置input标签的默认值。submit和reset按钮的value的值是按钮显示的数据；</li>\r	<li>size属性：大小；</li>\r	<li>checked属性：单选框或复选框是否被选中；</li>\r	<li>readonly属性：是否输入标签只读；</li>\r	<li>disabled属性：标签是否可用；</li>\r	<li>maxlength属性：允许输入的最大长度。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 121),
(1086, '下拉列表标签', '1086', 1536768660, 1536768970, '<p>本文记录WEB前端学习过程中遇到的下拉列表标签～</p>\r<!--more-->\r\r<p>&lt;select&gt;下拉列表标签，可以进行单选或多选，需要结合子标签&lt;option&gt;指定列表项，常用的属性有：</p>\r\r<ul>\r	<li>name属性：发送给服务器的名称；</li>\r	<li>multiple属性：不写该属性默认为单选，取值为&ldquo;multiple&rdquo;表示多选；</li>\r	<li>size属性：多选时，可以看到选项的数目；</li>\r</ul>\r\r<p>&lt;option&gt;子标签，表示下拉列表中的一个选项（一个条目），常用的属性有：</p>\r\r<ul>\r	<li>selected属性：勾选当前列表项；</li>\r	<li>value属性：发送给服务器的选项值。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(1087, '文本域标签', '1087', 1536769020, 1536769166, '<p>本文记录WEB前端学习过程中遇到的文本域标签～</p>\r<!--more-->\r\r<p>&lt;textarea&gt;文本域标签，是一个多行的文本输入控件，常用的属性有：</p>\r\r<ul>\r	<li>cols属性：文本域的列数；</li>\r	<li>rows属性：文本域的行数。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 124),
(1088, '按钮标签', '1088', 1536769200, 1536769330, '<p>本文记录WEB前端学习过程中遇到的按钮标签～</p>\r<!--more-->\r\r<p>&lt;button&gt;按钮标签，提供&ldquo;普通|重置|提交&rdquo;功能，只是不同浏览器默认值不同，常见的属性有一个：</p>\r\r<ul>\r	<li>type属性：用于表示button的类型，取值有button、reset和submit。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 134),
(1089, 'div简介', '1089', 1537081200, 1537081542, '<p>本文记录WEB前端学习过程中遇到的DIV～</p>\r<!--more-->\r\r<p>&lt;div&gt;是HTML中的一个普通标签，被用来进行区域的划分。它独自占一行，但不能独自实现复杂的效果，必须结合CSS样式进行渲染。</p>\r\r<ul>\r	<li>&lt;div&gt;通常是块级元素；</li>\r	<li>&lt;div&gt;可定义文档中的分区或节（division/section）；</li>\r	<li>&lt;div&gt;标签可以把文档分割为独立不同的部分，它可以被用作严格的组织工具，并且不使用任何格式与其关联；</li>\r	<li>如果用id或class来标记&lt;div&gt;，那么该标签的作用会变得更加有效。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 176),
(1090, 'CSS简介', '1090', 1537081620, 1537082399, '<p>本文记录WEB前端学习过程中遇到的CSS～</p>\r<!--more-->\r\r<p>CSS通常称为CSS样式或层叠样式表，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽度、边框样式、边距等）以及版面的布局等外观显示样式。</p>\r\r<p>CSS（Cascading Style Sheets）：层叠样式表。</p>\r\r<ul>\r	<li>样式：给HTML标签添加需要显示的效果；</li>\r	<li>层叠：使用不同的添加方式，给同一个HTML标签添加样式，最后所有的样式都叠加到一起，共同作用于该标签。</li>\r</ul>\r\r<p>CSS可以使HTML页面更好看，CSS色系的搭配可以让用户更舒服，CSS+DIV布局更加灵活，也更容易绘制出用户需要的结构。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 136),
(1091, 'CSS样式规则', '1091', 1537083720, 1537083797, '<p>本文记录WEB前端学习过程中遇到的CSS样式规则～</p>\r<!--more-->\r\r<p>使用HTML时，需要遵从一定的规范。CSS也一样，要想熟练的使用CSS对网页进行修饰，首先需要了解CSS的样式规则。<br />\r具体格式为：</p>\r\r<p>选择器{属性1:属性值;属性2:属性值;..}</p>\r\r<p>在上面的样式规则中，&ldquo;选择器&rdquo;用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。属性和属性值以键值对方式出现，使用英文冒号分隔，多个属性之间使用英文分号分隔。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:css;">\r&lt;style&gt;\r    h2{\r        color: red;\r        font-size: 100px;\r    }\r&lt;/style&gt;</pre>\r\r<p>初学者在书写CSS样式时，除了要遵循CSS样式规则，还必须注意CSS代码结构中的几个特点，具体如下：</p>\r\r<p>CSS样式选择器严格区分大小写，属性和属性值不区分大小写；<br />\r多个属性之间必须用英文分号隔开，最后一个属性后的分号可以省略，但为了便于增加新样式建议保留；<br />\r如果属性的值由多个单词组成且中间包含空格，则必须为这个属性值加上英文状态下的引号。例如：</p>\r\r<pre class="brush:css;">\rp{\r    font-family: &quot;Times New Roman&quot;;\r}</pre>\r\r<p>在编写CSS代码时，为了提高代码的可读性，通常会加上CSS注释，例如：</p>\r\r<pre class="brush:css;">\r/*CSS代码注释*/</pre>\r\r<p>在CSS代码中空格是不被解析的，花括号以及分号前后的空格可有可无。因此，可以使用空格键、Tab键、回车键等对样式代码进行排版，即所谓的格式化CSS代码，这样可以提高代码的可读性。</p>\r\r<p>注意：属性值与单位之间是不允许有空格的，否则浏览器解析时会报错。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 236),
(1092, 'CSS引入方式', '1092', 1537099680, 1537100630, '<p>本文记录WEB前端学习过程中遇到的CSS引入方式～</p>\r<!--more-->\r\r<p>CSS使用非常灵活，既可以嵌入在HTML文档中，也可以是一个单独的文件。如果是单独的文件，则必须以.css为扩展名。CSS常见的引入方式有三种：</p>\r\r<p>1.行内样式</p>\r\r<p>行内样式是通过style属性来设置元素的样式。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;a style=&quot;color: #F00; font-size: 30px;&quot; href=&quot;http://www.oliver.ren/&quot;&gt;Oliver&#39;s Blog&lt;/a&gt;</pre>\r\r<p>行内样式通过标签的属性来控制样式，这样并没有做到结构与表现（HTML展示结构和CSS显示效果）相分离，所以一般很少使用。</p>\r\r<p>2.内部样式</p>\r\r<p>内部样式又称为内嵌式，是将CSS代码集中写在HTML文档的&lt;head&gt;头部标签中，并且使用&lt;style&gt;标签定义。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;style type=&quot;text/css&quot;&gt;\r    body{\r        background-color: #DDD;\r    }\r&lt;/style&gt;</pre>\r\r<p>内嵌式CSS样式只对其所在的HTML页面有效，可以对多处标签统一设置样式。因此，单独设计一个页面时，使用内嵌式是个不错的选择。但是，如果是一个网站，不建议使用这种方式，因为他不能充分发挥CSS代码的重用优势。</p>\r\r<p>3.外部样式</p>\r\r<p>外部样式又称为链入式，是将所有的样式放在一个或多个以.css为扩展名的外部样式表文件中，通过&lt;link&gt;标签将样式连接到HTML文档中。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot; /&gt;</pre>\r\r<p>链入式最大的好处是同一个CSS样式表可以被不同的HTML页面链接使用，同时一个HTML页面也可以通过多个&lt;link&gt;标签链接多个CSS样式表。</p>\r\r<p>注意：优先级为1&gt;2&gt;3。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 91),
(1093, 'CSS选择器', '1093', 1537100640, 1537105907, '<p>本文记录WEB前端学习过程中遇到的CSS选择器～</p>\r<!--more-->\r\r<p>要想将CSS样式应用于特定的HTML元素，首先需要找到该目标元素。在CSS中，执行这一任务的样式规则部分被称为选择器，常见的选择器有3种，还有另外2种作为扩展，共5种：</p>\r\r<p>1.元素选择器</p>\r\r<p>元素选择器是指用HTML格式名称作为选择器，按标记名称分类，为页面中某一类标记指定统一的CSS样式。其基本语法格式如下：</p>\r\r<pre class="brush:java;">\r标记名{属性1:属性值1;属性2:属性值2;属性3:属性值3;}</pre>\r\r<p>该语法中，所有的HTML标记名都可以作为标记选择器，例如body、h1、p、strong等。用标记选择器定义的样式对页面中该类型的所有标记都有效。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\rh1{\r    color: #F00;\r    font-size: 50px;\r}\r\r&lt;h1&gt;Oliver&#39;s Blog&lt;/h1&gt;</pre>\r\r<p>标记选择器最大的优点是能够快速为页面中同类型的标记统一样式，同时这也是它的缺点，不能设计差异化样式。</p>\r\r<p>2.ID选择器</p>\r\r<p>ID选择器使用&ldquo;#&rdquo;进行标识，后面紧跟ID名，其基本语法格式为：</p>\r\r<pre class="brush:java;">\r#ID名{属性1:属性值1;属性2:属性值2;属性3:属性值3;}</pre>\r\r<p>该语法中，ID名即为HTML元素的ID属性值，大多数HTML元素都定义ID属性，元素的ID值是唯一的，只能对应于文档中某一个具体的元素。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r#code{\r    color: #0F0;\r}\r&lt;h1 id=&quot;code&quot;&gt;Oliver&#39;s Blog&lt;/h1&gt;</pre>\r\r<p>3.类选择器</p>\r\r<p>类选择器使用&ldquo;.&ldquo;（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：</p>\r\r<pre class="brush:java;">\r.类名{属性1:属性值1;属性2:属性值2;属性3:属性值3;}</pre>\r\r<p>该语法中，类名即为HTML元素的class属性值，大多数HTML元素都可以定义class属性。类选择器最大的优势是可以为元素对象定义单独或相同的样式。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r.codeClass{\r    font-size: 25px;\r}\r&lt;h1 class=&quot;codeClass&quot;&gt;Oliver&#39;s Blog&lt;/h1&gt;</pre>\r\r<p>类选择器的高级用法：给指定的标签设置class样式，语法为：</p>\r\r<pre class="brush:java;">\r标签.类名{属性1:属性值1;属性2:属性值2;属性3:属性值3;}</pre>\r\r<p>4.属性选择器</p>\r\r<p>属性选择器，在标签后面使用中括号标记，其基本语法格式如下：</p>\r\r<pre class="brush:xml;">\r标签名[标签属性=&lsquo;标签属性值&rsquo;]{属性1:属性值1;属性2:属性值2;属性3:属性值3;}</pre>\r\r<p>该选择器，是对&ldquo;元素选择器&rdquo;的扩展，对一组标签进一步过滤。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;style&gt;\r    input[type=&quot;text&quot;]{\r        background-color: yellow;\r    }\r\r    input[type=&quot;password&quot;]{\r        background-color: green;\r    }\r&lt;/style&gt;</pre>\r\r<p>5.包含选择器</p>\r\r<p>包含选择器，两个标签之间使用空格，给指定父标签的后代标签设置样式，可以方便在区域内编写样式，使用格式为：</p>\r\r<pre class="brush:xml;">\r父标签 后代标签{属性1:属性值1;属性2:属性值2;属性3:属性值3;}</pre>\r\r<p>该选择器，是对&ldquo;元素选择器&rdquo;的扩展，对一个标签内部所有后代标签进行过滤。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;style&gt;\r    #mark01 submark01{\r        color: red;\r    }\r&lt;/style&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1094, 'CSS常用样式', '1094', 1537106220, 1537200578, '<p>本文记录WEB前端学习过程中遇到的CSS常用样式～</p>\r<!--more-->\r\r<p>1.边框和尺寸：border、width和height</p>\r\r<p>border：设置边框的样式</p>\r\r<ul>\r	<li>格式：宽度、样式和颜色；</li>\r	<li>取值：solid实线，none无边和double双线等。</li>\r</ul>\r\r<p>width和height：用于设置标签的宽度和高度。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;style type=&quot;text/css&quot;&gt;\r    div{\r        border: 1px solid #000;\r        width: 200px;\r        herght: 200px;\r    }\r&lt;/style&gt;</pre>\r\r<p>2.布局：float和clear</p>\r\r<p>通常默认的排版方式，将页面中的元素从上到下一一罗列，而实际开发中，需要左右方式进行排版，就需要使用浮动，格式如下：</p>\r\r<pre class="brush:css;">\r选择器{float: 属性值;}</pre>\r\r<p>常用的属性值：</p>\r\r<ul>\r	<li>left：元素向左浮动；</li>\r	<li>right：元素向右浮动；</li>\r	<li>none：元素不浮动（默认值）。</li>\r</ul>\r\r<p>由于浮动元素不再占用原文档流的位置，所以它会对页面中的其他元素的排版产生影响。如果要避免影响，需要使用clear属性进行清除浮动，格式如下：</p>\r\r<pre class="brush:css;">\r选择器{clear: 属性值;}</pre>\r\r<p>常用属性值：</p>\r\r<ul>\r	<li>left：不允许左侧有浮动元素（清除左侧浮动的影响）；</li>\r	<li>right：不允许右侧有浮动元素（清除右侧浮动的影响）；</li>\r	<li>both：同时清除左右两侧的影响。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--默认上下布局--&gt;\r&lt;div&gt;\r    &lt;div&gt;区域1-1&lt;/div&gt;\r    &lt;div&gt;区域1-2&lt;/div&gt;\r&lt;/div&gt;\r\r&lt;hr /&gt;\r\r&lt;!--浮动左右布局--&gt;\r&lt;div&gt;\r    &lt;div style=&quot;float: left;&quot;&gt;区域2-1&lt;/div&gt;\r    &lt;div style=&quot;float: left;&quot;&gt;区域2-2&lt;/div&gt;\r&lt;/div&gt;\r\r&lt;!--取消浮动，另起一行布局--&gt;\r&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;\r&lt;hr /&gt;\r&lt;div&gt;\r    &lt;div style=&quot;float: left;&quot;&gt;区域3-1&lt;/div&gt;\r    &lt;div style=&quot;float: left;&quot;&gt;区域3-2&lt;/div&gt;\r    &lt;div style=&quot;float: left;&quot;&gt;区域3-3&lt;/div&gt;\r&lt;/div&gt;</pre>\r\r<p>3.转换：display</p>\r\r<p>HTML提供丰富的标签，这些标签被定义成了不同的类型，一般分为：块标签和行内标签。</p>\r\r<p>块标签：以区域块方式出现。每个块标签肚子占据一整行或多行。</p>\r\r<ul>\r	<li>常见的块标签：&lt;h1&gt;、&lt;div&gt;和&lt;ul&gt;等。</li>\r</ul>\r\r<p>行内元素：不必在新的一行开始，同时也不强迫其他元素在新的一行显示。</p>\r\r<ul>\r	<li>常见的行内元素：&lt;span&gt;和&lt;a&gt;等。</li>\r</ul>\r\r<p>在开发中，希望行内元素具有块元素的特性，需要使用display进行转换，使用格式为：</p>\r\r<pre class="brush:css;">\r选择器{display: 属性值}</pre>\r\r<p>常用的属性值：</p>\r\r<ul>\r	<li>inline：此元素将显示为行内元素（行内元素默认的display属性值）；</li>\r	<li>block：此元素将显示为块元素（块元素默认的display属性值）；</li>\r	<li>inline-block：将对象呈递为内联对象，但是对象的内容作为块对象呈递；</li>\r	<li>none：此元素将被隐藏，不显示，也不占用页面空间。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;html&gt;\r    &lt;head&gt;\r        &lt;meta charset=&quot;UTF-8&quot;&gt;\r        &lt;title&gt;&lt;/title&gt;\r        &lt;style type=&quot;text/css&quot;&gt;\r            span{\r                border: 1px solid #000;\r                width: 100px;\r                height: 40px;\r            }\r        &lt;/style&gt;\r    &lt;/head&gt;\r    &lt;body&gt;\r        &lt;!--默认显示一行，边框环绕，高宽没有作用--&gt;\r        &lt;span&gt;显示1-1&lt;/span&gt;\r        &lt;span&gt;显示1-1&lt;/span&gt;\r\r        &lt;!--每一行显示，高宽有作用--&gt;\r        &lt;span style=&quot;display: block;&quot;&gt;显示2-1&lt;/span&gt;\r        &lt;span style=&quot;display: block;&quot;&gt;显示2-2&lt;/span&gt;\r    &lt;/body&gt;\r&lt;html&gt;</pre>\r\r<p>4.字体：color和font-size</p>\r\r<ul>\r	<li>color：字体颜色；</li>\r	<li>font-size：字体大小。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;div style=&quot;height: 50px;width: 200px;border: 1px solid #000;&quot;&gt;\r    &lt;a href=&quot;http://www.oliver.ren/&quot;&gt;点击&lt;/a&gt;\r    &lt;a href=&quot;http://www.oliver.ren/&quot; style=&quot;text-decoration: none;&quot;&gt;点击&lt;/a&gt;\r&lt;/div&gt;\r&lt;div style=&quot;height: 50px;width: 200px;border: 1px solid #000;&quot;&gt;\r    &lt;a href=&quot;http://www.oliver.ren/&quot; style=&quot;line-height: 50px;&quot;&gt;点击&lt;/a&gt;\r    &lt;a href=&quot;http://www.oliver.ren/&quot; style=&quot;color: red;&quot;&gt;点击&lt;/a&gt;\r&lt;/div&gt;</pre>\r\r<p>5.背景色：background-color</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;ul style=&quot;background-color: #999;color: #FFF;&quot;&gt;\r    &lt;li&gt;Oliver&#39;s Blog&lt;/li&gt;\r    &lt;li&gt;Oliver&#39;s Blog&lt;/li&gt;\r    &lt;li style=&quot;background-color: #000;&quot;&gt;Oliver&#39;s Blog&lt;/li&gt;\r    &lt;li&gt;Oliver&#39;s Blog&lt;/li&gt;\r&lt;/ul&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 160),
(1095, 'CSS盒子模型', '1095', 1537200720, 1537201299, '<p>本文记录WEB前端学习过程中遇到的CSS盒子模型～</p>\r<!--more-->\r\r<p>CSS盒子模型（Box Model）规定了元素框处理内容、内边距、边框和外边距的方式。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/09/2604593521.png" style="width: 800px; height: 437px;" /></p>\r\r<p>1.内边距：padding；</p>\r\r<p>让所有h1元素的各边都有10px的内边距：</p>\r\r<pre class="brush:css;">\rh1{padding: 10px;}</pre>\r\r<p>按照上右下左的顺序分别设置各边的内边距(可以使用不同的单位或百分比值)：</p>\r\r<pre class="brush:css;">\rh1{padding: 10px 0.25em 2ex 20%;}</pre>\r\r<p>单边内边距属性：</p>\r\r<ul>\r	<li>padding-top；</li>\r	<li>padding-right；</li>\r	<li>padding-bottom；</li>\r	<li>padding-left。</li>\r</ul>\r\r<p>2.边框：border</p>\r\r<ul>\r	<li>border-top-style；</li>\r	<li>border-right-style；</li>\r	<li>border-bottom-style；</li>\r	<li>border-left-style。</li>\r</ul>\r\r<p>3.外边距：margin</p>\r\r<ul>\r	<li>margin-top；</li>\r	<li>margin-right；</li>\r	<li>margin-bottom；</li>\r	<li>margin-left。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 127),
(1097, 'CSS-Box.png', 'CSS-Box-png', 1537200800, 1537200800, 'a:5:{s:4:"name";s:11:"CSS-Box.png";s:4:"path";s:35:"/usr/uploads/2018/09/2604593521.png";s:4:"size";i:149118;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1095, 0),
(1098, 'JavaScript简介', '1098', 1537970400, 1537970470, '<p>本文记录WEB前端学习过程中遇到的JavaScript～</p>\r<!--more-->\r\r<p>JavaScript是WEB上一种功能强大的编程语言，用于开发交互式的WEB页面。它不需要进行编译，而是直接嵌入在HTML页面中，由浏览器执行，具有如下特性：</p>\r\r<ul>\r	<li>JavaScript被设计用来向HTML页面添加交互行为；</li>\r	<li>JavaScript是一种脚本语言（一种轻量级的编程语言）；</li>\r	<li>JavaScript由数行可执行代码组成；</li>\r	<li>JavaScript通常被直接嵌入HTML页面；</li>\r	<li>JavaScript是一种解释性语言（执行不进行预编译）。</li>\r</ul>\r\r<p>JavaScript的组成：</p>\r\r<ul>\r	<li>核心（ECMAScript）：语法和语句；</li>\r	<li>文档对象模型（DOM）：Document Object Model，操作文档中的元素和内容；</li>\r	<li>浏览器对象模型（BOM）：浏览器对象。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(1099, 'JavaScript作用', '1099', 1537970880, 1537971046, '<p>本文记录WEB前端学习过程中遇到的JavaScript的作用～</p>\r<!--more-->\r\r<p>使用JavaScript添加页面动画效果，提供用户操作体验。主要作用有：</p>\r\r<ul>\r	<li>嵌入动态文本于HTML页面；</li>\r	<li>对浏览器事件作出响应；</li>\r	<li>读写HTML元素；</li>\r	<li>验证提交功能；</li>\r	<li>检测用户的浏览器信息等。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(1100, 'JavaScript引入方式', '1100', 1537971684, 1537971684, '<p>本文记录WEB前端学习过程中遇到的JavaScript引入方式～</p>\r<!--more-->\r\r<p><br />\r在HTML文件中引入JavaScript有两种方式，一种是在HTML文档直接嵌入JavaScript脚本，称为内嵌式；另一种是链接外部JavaScript脚本文件，称为外联式。具体解释如下：</p>\r\r<p>1.内嵌式，在HTML文档中，通过&lt;script&gt;标签引入</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;script type=&quot;text/javascript&quot;&gt;\r//此处为JavaScript代码\r&lt;/script&gt;</pre>\r\r<p>2.外联式，在HTML文档中，通过&lt;script src=&quot;&quot;&gt;标签引入js文件</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;script src=&quot;javascript.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(1101, 'JavaScript变量', '1101', 1537972200, 1537972274, '<p>本文记录WEB前端学习过程中遇到的JavaScript变量～</p>\r<!--more-->\r\r<p>1.使用JavaScript时，需要遵循以下命名规范：</p>\r\r<ul>\r	<li>必须以字母或下划线开头，中间可以是数字、字符或者下划线；</li>\r	<li>变量名不能包含空格等符号；</li>\r	<li>不能使用JavaScript关键字作为变量名，例如：function；</li>\r	<li>JavaScript严格区分大小写。</li>\r</ul>\r\r<p>2.变量的声明</p>\r\r<pre class="brush:jscript;">\rvar 变量名; //JavaScript变量可以不声明，直接使用。默认值：undefined</pre>\r\r<p>3.变量的赋值</p>\r\r<pre class="brush:jscript;">\rvar 变量名 = 值; //JavaScript变量是弱类型，即同一个变量可以存放不同类型的数据</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(1102, 'JavaScript数据类型', '1102', 1537973750, 1537973750, '<p>本文记录WEB前端学习过程中遇到的JavaScript数据类型～</p>\r<!--more-->\r\r<p>基本类型：</p>\r\r<ul>\r	<li>undefined：undefined类型只有一个值，即undefined。当声明的变量未初始化时，该变量的默认值是undefined；</li>\r	<li>null：只有一个专用值null，表示空，一个占位符。值undefined实际上是从null派生过来的，因此ECMAScript把他们定义为相等；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//输出&ldquo;true&rdquo;，尽管这两个值相等，但它们的含义不同。\ralert(null==undefined)</pre>\r\r<ul>\r	<li>boolean：有两个值true和false；</li>\r	<li>number：表示任意数字；</li>\r	<li>string：字符串，由双引号或单引号声明的。JavaScript没有字符类型。</li>\r</ul>\r\r<p>引用类型：</p>\r\r<ul>\r	<li>引用类型通常叫做类（class），也就是说，遇到引用值，所处理的就是对象；</li>\r	<li>JavaScript是基于对象而不是面向对象，对象类型的默认值是null；</li>\r	<li>JavaScript提供众多预定义引用类型（内置对象）。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 83),
(1103, 'JavaScript运算符', '1103', 1537974180, 1537974729, '<p>本文记录WEB前端学习过程中遇到的JavaScript运算符～</p>\r<!--more-->\r\r<p>JavaScript运算符基本与Java运算符基本一致。</p>\r\r<p>算术运算符：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/09/122070665.png" style="width: 800px; height: 284px;" /></p>\r\r<p>赋值运算符：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/09/2956247506.png" style="width: 800px; height: 252px;" /></p>\r\r<p>比较运算符：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/09/4177875024.png" style="width: 800px; height: 297px;" /></p>\r\r<p>逻辑运算符：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/09/877752203.png" style="width: 800px; height: 153px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(1104, '001.png', '001-png-11', 1537974658, 1537974658, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:34:"/usr/uploads/2018/09/122070665.png";s:4:"size";i:81261;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1103, 0),
(1105, '002.png', '002-png-7', 1537974659, 1537974659, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/09/2956247506.png";s:4:"size";i:150133;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1103, 0),
(1106, '003.png', '003-png-7', 1537974660, 1537974660, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:35:"/usr/uploads/2018/09/4177875024.png";s:4:"size";i:124731;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1103, 0),
(1107, '004.png', '004-png-4', 1537974662, 1537974662, 'a:5:{s:4:"name";s:7:"004.png";s:4:"path";s:34:"/usr/uploads/2018/09/877752203.png";s:4:"size";i:49715;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1103, 0),
(1108, 'JavaScript基本操作', '1108', 1537974900, 1537974948, '<p>本文记录WEB前端学习过程中遇到的JavaScript基本操作～</p>\r<!--more-->\r\r<ul>\r	<li>alert()：向页面中弹出一个提示框；</li>\r	<li>innerHTML()：向页面的某个元素中写一段内容，将原有的东西覆盖；</li>\r	<li>document.write()：向页面中写内容。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(1109, 'JavaScript正则匹配', '1109', 1538456400, 1538456471, '<p>本文记录WEB前端学习过程中遇到的JavaScript正则匹配～</p>\r<!--more-->\r\r<p>JavaScript中有两种正则匹配方式：</p>\r\r<ul>\r	<li>使用String对象的match方法；</li>\r</ul>\r\r<pre class="brush:jscript;">\r&#39;cdbbdbsdbdbz&#39;.match(/d(b+)d/g)</pre>\r\r<ul>\r	<li>使用正则对象中的test方法。</li>\r</ul>\r\r<pre class="brush:jscript;">\rvar patt = /e/;\rpatt.test(&quot;The best things in life are free!&quot;);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 91),
(1110, 'JavaScript函数', '1110', 1538456520, 1538456826, '<p>本文记录WEB前端学习过程中遇到的JavaScript函数～</p>\r<!--more-->\r\r<p>函数：实现一定功能的代码块，类似于Java中的方法。关键字为function，函数名可以自定义。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;script type=&quot;text/javascript&quot;&gt;\r\r	//声明函数\r\r	function func1(){\r		alert(&quot;声明函数&quot;);\r	}\r\r	//调用函数\r	func1();\r\r	//匿名函数\r	var func2 = function(){\r		alert(&quot;匿名函数&quot;);\r	}\r\r	//调用函数\r	func2();\r\r&lt;/script&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 80),
(1111, 'JavaScript定时器setInterval', '1111', 1538457360, 1538457437, '<p>本文记录WEB前端学习过程中遇到的JavaScript定时器setInterval～</p>\r<!--more-->\r\r<p>setInterval定时器：按照指定的周期（间隔）来执行函数或代码片断。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:jscript;">\rwindow.setInterval(code, millisec)</pre>\r\r<ul>\r	<li>code：执行的函数名或执行的函数字符串；</li>\r	<li>millisec：时间间隔，单位为毫秒。</li>\r	<li>返回值：一个可以传递给window.clearInterval()使用，从而取消对code的周期性执行的值。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//函数名\rsetInterval(show, 100);\r\r//函数字符串\rsetInterval(&quot;show()&quot;, 100);</pre>\r\r<p>注意：window对象提供的都是全局函数，调用函数时window可以省略不写，window.setInterval()等同于setInterval()。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 92),
(1112, 'JavaScript定时器setTimeout', '1112', 1538461440, 1538461510, '<p>本文记录WEB前端学习过程中遇到的JavaScript定时器setTimeout～</p>\r<!--more-->\r\r<p>setTimeout定时器：在指定的毫秒数后调用函数或执行代码片断。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:jscript;">\rwindow.setTimeout(code, millisec)</pre>\r\r<ul>\r	<li>code：要调用的函数或要执行的代码字符串；</li>\r	<li>millisec：在执行代码前需等待的毫秒数；</li>\r	<li>返回值：返回值：一个可以传递给window.clearTimeout()使用，从而取消对code的周期性执行的值。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 86),
(1113, 'JavaScript获取修改CSS样式', '1113', 1538461560, 1538462124, '<p>本文记录WEB前端学习过程中遇到的JavaScript获取修改CSS样式～</p>\r<!--more-->\r\r<p>获取样式：</p>\r\r<pre class="brush:jscript;">\r//获取指定属性的值\robj.style.属性</pre>\r\r<p>设置样式：</p>\r\r<pre class="brush:jscript;">\r//给指定属性设置内容\robj.style.属性=值</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;div id=&quot;divId&quot; style=&quot;height: 100px; width: 100px; margin: 10px; padding: 20px;&quot;&gt;&lt;/div&gt;\r\r&lt;script type=&quot;text/javascript&quot;&gt;\r\r//获得div对象\rvar divObj = document.getElementById(&quot;divId&quot;);\r\r//获得高度\rvar height = window.parseInt(divObj.style.height);\r\r//将原始高度翻倍，再设置给div\rdivObj.style.height = height * 2 + &quot;px&quot;;\r\r&lt;/script&gt;</pre>\r\r<p>注意：如果属性由多个单词使用&ldquo;-&rdquo;连接，需要将&ldquo;-&rdquo;删除，并将后一个单词首字母大写。例如：background-color需要改成backgroundColor。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(1114, 'JavaScript的window对象', '1114', 1538463900, 1538465311, '<p>本文记录WEB前端学习过程中遇到的JavaScript的window对象～</p>\r<!--more-->\r\r<p>定时器：</p>\r\r<ul>\r	<li>setInterval()：按照指定的周期（单位：毫秒）来调用函数或计算表达式；</li>\r	<li>clearInterval()：取消由setInterval()设置的时间；</li>\r	<li>setTimeout()：在指定的毫秒数后调用函数或计算表达式；</li>\r	<li>clearTimeout()：取消由setTimeout()设置的时间。</li>\r</ul>\r\r<p>消息框：</p>\r\r<ul>\r	<li>alert()：显示带有一段消息和一个确认按钮的警告框；</li>\r	<li>confirm()：显示带有一段消息以及确认按钮和取消按钮的确认框，确认返回true，取消返回false；</li>\r	<li>prompt()：显示提示用户输入的提示框；</li>\r</ul>\r\r<p>Window尺寸：</p>\r\r<p>1.IE9（包含9及以上）、Chrome、Firefox等其他浏览器</p>\r\r<pre class="brush:jscript;">\r//浏览器窗口的内部高度\rwindow.innerHeight\r//浏览器窗口的内部宽度\rwindow.innerWidth</pre>\r\r<p>2.IE8及以下</p>\r\r<pre class="brush:jscript;">\r//浏览器窗口的内部高度\rdocument.documentElement.clientHeight或document.body.clientHeight\r//浏览器窗口的内部宽度\rdocument.documentElement.clientWidth或document.body.clientWidth</pre>\r\r<p>示例代码（兼容所有浏览器）：</p>\r\r<pre class="brush:jscript;">\r//获取宽度\rvar w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\r//获取高度\rvar h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(1115, 'JavaScript的location对象', '1115', 1538464860, 1538465427, '<p>本文记录WEB前端学习过程中遇到的JavaScript的location对象～</p>\r<!--more-->\r\r<p>常用的属性：</p>\r\r<ul>\r	<li>hash：设置或返回从井号(#)开始的URL(锚)；</li>\r	<li>host：设置或返回主机名和当前URL的端口号；</li>\r	<li>hostname：设置或返回当前URL的主机名；</li>\r	<li>href：设置或返回完整的URL；</li>\r	<li>pathname：设置或返回当前URL的路径部分；</li>\r	<li>port：设置或返回当前URL的端口号；</li>\r	<li>protocol：设置或返回当前URL的协议；</li>\r	<li>search：设置或返回从问号(?)开始的URL查询部分。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;script type=&quot;text/javascript&quot;&gt;\r\r	function change(){\r		location.href = &quot;http://www.oliver.ren/&quot;;\r	}\r\r&lt;/script&gt;\r\r&lt;input type=&quot;button&quot; value=&quot;点我&quot; onclick=&quot;change()&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 93),
(1121, 'JavaScript事件', '1121', 1538476560, 1538480780, '<p>本文记录WEB前端学习过程中遇到的JavaScript事件～</p>\r<!--more-->\r\r<p>常见事件：</p>\r\r<ul>\r	<li>onsubmit：提交按钮被点击；</li>\r	<li>onclick：鼠标单击某个对象；</li>\r	<li>ondblclick：鼠标双击某个对象；</li>\r	<li>onblur：元素失去焦点；</li>\r	<li>onfocus：元素获得焦点；</li>\r	<li>onchange：用户改变域的内容；</li>\r	<li>onkeydown：某个键盘的键被按下；</li>\r	<li>onkeypress：某个键盘的键被按下或按住；</li>\r	<li>onkeyup：某个键盘的健被松开；</li>\r	<li>onmousedown：某个鼠标按键被按下；</li>\r	<li>onmouseup：某个鼠标按键被松开；</li>\r	<li>onmouseover：鼠标移到某个元素之上；</li>\r	<li>onmouseout：鼠标从某个元素移开；</li>\r	<li>onmousemove：鼠标被移动。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;script type=&quot;text/javascript&quot;&gt;\r\r	//页面加载事件：当整个HTML页面加载成功调用\r	window.onload = function{\r\r		//文本框事件\r		var e01 = document.getElementById(&quot;e01&quot;);\r\r		e01.onfocus = function(){\r			html(&quot;textMsg&quot;,&quot;文本框获得焦点：focus&quot;);\r		}\r\r		e01.onblur = function(){\r			html(&quot;textMsg&quot;,&quot;文本框失去焦点：blur&quot;);\r		}\r\r		e01.onkeydown = function(){\r			html(&quot;textMsg&quot;,&quot;键盘按下：keydown&quot;);\r		}\r\r		e01.onkeypress = function(){\r			append(&quot;textMsg&quot;,&quot;键盘按：keypress&quot;);\r		}\r\r		e01.onkeyup = function(){\r			append(&quot;textMsg&quot;,&quot;键盘弹起：keyup&quot;);\r		}\r\r		//鼠标事件\r		var e02 = document.getElementById(&quot;e02&quot;);\r		var i = 0;\r\r		e02.onmouseover = function(){\r			html(&quot;divMsg&quot;, &quot;鼠标移上：mouseover&quot;);\r		}\r\r		e02.onmousemove = function(){\r			html(&quot;divMsg&quot;, &quot;鼠标移动：mouseover&quot; + i++);\r		}\r\r		e02.onmouseout = function(){\r			html(&quot;divMsg&quot;, &quot;鼠标移出：mouseout&quot;);\r		}\r\r		e02.onmousedown = function(){\r			html(&quot;divMsg&quot;, &quot;鼠标按下：mousedown&quot;);\r		}\r\r		e02.onmouseup = function(){\r			html(&quot;divMsg&quot;, &quot;鼠标弹起：mouseup&quot;);\r		}\r\r		//按钮事件\r		var e03 = document.getElementById(&quot;e03&quot;);\r\r		e03.onclick = function(){\r			html(&quot;buttonMsg&quot;, &quot;单击：click&quot;);\r		}\r\r		e03.ondblclick = function(){\r			html(&quot;buttonMsg&quot;, &quot;单击：dblclick&quot;);\r		}\r	}\r\r	/**\r	 *指定位置显示指定信息\r	 *@param objId，元素的id属性值\r	 *@param text，需要显示的文本信息\r	 */\r	function html(objId, text){\r		document.getElementById(objId).innerHTML = text;\r	}\r\r	/**\r	 *指定位置追加指定信息\r	 *@param objId，元素的id属性值\r	 *@param text，需要显示的文本信息\r	 */\r	function append(){\r		document.getElementById(objId).innerHTML += text;\r	}\r\r&lt;/script&gt;\r\r&lt;input id=&quot;e01&quot; type=&quot;text&quot; /&gt;\r&lt;span id=&quot;textMsg&quot;/&gt;\r\r&lt;hr/&gt;\r\r&lt;div id=&quot;e02&quot;/&gt;\r&lt;span id=&quot;divMsg&quot;/&gt;\r\r&lt;hr/&gt;\r\r&lt;input id=&quot;e03&quot; type=&quot;button&quot; value=&quot;可以点击&quot;/&gt;\r&lt;span id=&quot;buttonMsg&quot;/&gt;</pre>\r\r<p>event属性：</p>\r\r<ul>\r	<li>clientX：返回当事件被触发时，鼠标指针的水平坐标；</li>\r	<li>clientY：返回当事件被触发时，鼠标指针的垂直坐标；</li>\r	<li>keyCode：返回当事件被触发时，键盘输入ASCII码。</li>\r</ul>\r\r<p>event方法：</p>\r\r<ul>\r	<li>preventDefault()：阻止浏览器默认行为；</li>\r	<li>stopPropagation()：阻止事件的传播。</li>\r</ul>\r\r<p>示例代码（阻止浏览器默认行为）：</p>\r\r<pre class="brush:java;">\r&lt;a href=&quot;http://www.oliver.ren&quot; onclick=&quot;one()&quot;&gt;Oliver&#39;s Blog&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;http://he.oliver.ren&quot; onclick=&quot;return two()&quot;&gt;中南和网&lt;/a&gt;&lt;br/&gt;\r&lt;script type=&quot;text/javascript&quot;&gt;\r	function one(){\r		alert(&quot;我之后，将打开Oliver&#39;s Blog&quot;);\r	}\r\r	function two(event){\r		alert(&quot;我之后，中南和网不再访问&quot;);\r\r		//方式1\r		reture false;\r\r		//方式2\r		var event = event || window.event;\r		event.preventDefault();\r	}\r&lt;/script&gt;</pre>\r\r<p>示例代码（阻止事件的传播）：</p>\r\r<pre class="brush:xml;">\r&lt;!--区域1--&gt;\r&lt;div id=&quot;e1&quot; style=&quot;width: 200px; height: 200px; background-color: #F00;&quot;&gt;\r	&lt;div id=&quot;e2&quot; stype=&quot;width: 100px; height: 100px; background-color: #0F0;&quot;/&gt;\r&lt;/div&gt;\r\r&lt;hr/&gt;\r\r&lt;!--区域2--&gt;\r&lt;div id=&quot;e3&quot; style=&quot;width: 200px; height: 200px; background-color: #F00;&quot;&gt;\r	&lt;div id=&quot;e4&quot; stype=&quot;width: 100px; height: 100px; background-color: #0F0;&quot;/&gt;\r&lt;/div&gt;\r\r&lt;script type=&quot;text/javascript&quot;&gt;\r	var e1 = document.getElementById(&quot;e1&quot;);\r	var e2 = document.getElementById(&quot;e2&quot;);\r	var e3 = document.getElementById(&quot;e3&quot;);\r	var e4 = document.getElementById(&quot;e4&quot;);\r\r	//设置&ldquo;区域1&rdquo;事件\r	e1.onclick = function(){\r		alert(&quot;e1&quot;);\r	}\r\r	e2.onclick = function(){\r		alert(&quot;e2，同时e1也触发&quot;);\r	}\r\r	//设置&ldquo;区域1&rdquo;事件\r	e3.onclick = function(){\r		alert(&quot;e3&quot;);\r	}\r\r	e4.onclick = function(event){\r		alert(&quot;e4，e3不触发&quot;);\r		var event = event || window.event;\r		event.stopPropagation();\r	}\r&lt;/script&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(1119, 'JavaScript获取修改标签体内容', '1119', 1538466120, 1538476488, '<p>本文记录WEB前端学习过程中遇到的JavaScript获取修改标签体内容～</p>\r<!--more-->\r\r<p>innerHTML指的是HTML元素的内部内容。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//获取HTML元素内容\rvar content = document.getElementById(&quot;divId&quot;).innerHTML;\r\r//设置HTML元素内容\rdocument.getElementById(&quot;divId&quot;).innerHTML = &quot;...&quot;;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 152),
(1118, 'JavaScript的history对象', '1118', 1538465760, 1538465957, '<p>本文记录WEB前端学习过程中遇到的JavaScript的history对象～</p>\r<!--more-->\r\r<p>常用的方法：</p>\r\r<ul>\r	<li>back()：加载history列表中的前一个URL；</li>\r	<li>forward()：加载history列表中的下一个URL；</li>\r	<li>go()：加载history列表中的某个具体页面。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//加载前一个URL，等效back()\rgo(-1)\r//加载后一个URL，等效forward()\rgo(1)</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 77),
(1123, 'JavaScript关键字this', '1123', 1538572560, 1538572654, '<p>本文记录WEB前端学习过程中遇到的JavaScript的this关键字～</p>\r<!--more-->\r\r<p>在函数内部this关键字表示当前操作的元素。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r&lt;option value=&quot;value&quot; onclick=&quot;func(this.value)&quot;/&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 84),
(1124, 'JavaScript设置属性setAttribute', '1124', 1538572740, 1538573743, '<p>本文记录WEB前端学习过程中遇到的JavaScript设置属性函数setAttribute～</p>\r<!--more-->\r\r<div>setAttrbute可以给元素设置属性值。</div>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:xml;">\r&lt;option id=&quot;opt&quot; value=&quot;取值1&quot;/&gt;\r\r&lt;script type=&quot;text/javascript&quot;&gt;\r        document.getElementById.setAttribute(value,&quot;取值2&quot;);\r&lt;/script&gt;</pre>\r</div>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(1125, 'JavaScript的DOM', '1125', 1538574000, 1538574864, '<p>本文总结下WEB前端学习过程中遇到的JavaScript的DOM～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/612079273.png" style="width: 800px; height: 269px;" /></p>\r\r<p>常见的元素有：</p>\r\r<ul>\r	<li>Document：整个html文件都成为一个document文档；</li>\r	<li>Element：所有的标签都是Element元素；</li>\r	<li>Attribute：标签里面的属性；</li>\r	<li>Text：标签中间夹着的内容为text文本；</li>\r	<li>Node：document、element、attribute、text统称为节点node。</li>\r</ul>\r\r<h3>Document对象</h3>\r\r<p>每个载入浏览器的 HTML 文档都会成为 Document 对象。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/1810568537.png" style="width: 800px; height: 271px;" /></p>\r\r<p>注意：</p>\r\r<ol>\r	<li>后面的两个方法获取之后需要遍历；</li>\r	<li>以下两个方法很重要，尽管手册中没写。</li>\r</ol>\r\r<pre class="brush:jscript;">\r//创建文本节点\rdocument.createTextNode()\r//创建元素节点\rdocument.createElement()</pre>\r\r<h3>Element对象</h3>\r\r<p>我们所认知的html页面中所有的标签都是element元素，元素常用的方法有：</p>\r\r<pre class="brush:jscript;">\r//向元素添加新的子节点，作为最后一个子节点。\relement.appendChild()\r//返回元素的首个子节点。\relement.firstChild\r//返回元素节点的指定属性值。\relement.getAttribute()\r//设置或返回元素的内容。\relement.innerHTML\r//在指定的已有的子节点之前插入新节点。\relement.insertBefore()\r//返回元素的最后一个子元素。\relement.lastChild\r//把指定属性设置或更改为指定值。\relement.setAttribute()\r//从元素中移除子节点。\relement.removeChild()\r//替换元素中的子节点。\relement.replaceChild()\r</pre>\r\r<h3>Attribute对象</h3>\r\r<p>我们所认知的html页面中所有标签里面的属性都是attribute，常用的属性和方法有：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/145771336.png" style="width: 800px; height: 321px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 86),
(1126, 'dom.png', 'dom-png', 1538574109, 1538574109, 'a:5:{s:4:"name";s:7:"dom.png";s:4:"path";s:34:"/usr/uploads/2018/10/612079273.png";s:4:"size";i:50657;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1125, 0),
(1127, 'document.png', 'document-png', 1538574351, 1538574351, 'a:5:{s:4:"name";s:12:"document.png";s:4:"path";s:35:"/usr/uploads/2018/10/1810568537.png";s:4:"size";i:73837;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1125, 0),
(1128, 'attribute.png', 'attribute-png', 1538574814, 1538574814, 'a:5:{s:4:"name";s:13:"attribute.png";s:4:"path";s:34:"/usr/uploads/2018/10/145771336.png";s:4:"size";i:82038;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1125, 0),
(1129, 'JavaScript数组Array', '1129', 1538575860, 1538576079, '<p>本文记录WEB前端学习过程中遇到的JavaScript数组Array～</p>\r<!--more-->\r\r<p>数组的创建语法格式：</p>\r\r<pre class="brush:jscript;">\r//创建空数组\rnew Array();\r//创建size大小的数组，数组成员默认值undefined\rnew Array(size);\r//参数列表，为数组初始化数据\rnew Array(ele0, ele1, ..., eleN);</pre>\r\r<p>数组中的每一个成员没有类型限制，即可以存放任何类型。</p>\r\r<p>数组的长度可以自动修改，类似Java中的ArrayList集合。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 73),
(1130, 'JavaScript的Bollean对象', '1130', 1538628720, 1538628885, '<p>本文记录WEB前端学习过程中遇到的JavaScript的Bollean对象～</p>\r<!--more-->\r\r<p>创建Boolean对象的语法为：</p>\r\r<pre class="brush:jscript;">\r//构造函数\rnew Boolean(value);\r//转换函数\r//Boolean(value);</pre>\r\r<p>注意：如果value不写，那么默认创建的结果为false。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 72),
(1131, 'JavaScript全局函数', '1131', 1538628900, 1538629106, '<p>本文记录WEB前端学习过程中遇到的JavaScript全局函数～</p>\r<!--more-->\r\r<p>全局属性和函数可用于所有内建的 JavaScript 对象，常用的函数如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/2348655152.png" style="width: 800px; height: 582px;" /></p>\r\r<p>示例代码（编码和解码）：</p>\r\r<pre class="brush:xml;">\r&lt;script&gt;\r	var str = &ldquo;檀香&quot;;\r	//alert(encodeURI(str));//%E5%BC%A0%E4%B8%89\r	//alert(encodeURIComponent(str));//%E5%BC%A0%E4%B8%89\r	\r	//alert(decodeURI(encodeURI(str)));//张三\r	//alert(decodeURIComponent(encodeURIComponent(str)));//张三\r	\r	var str1 = &quot;http://www.oliver.ren&quot;;\r	//alert(encodeURI(str1));//http://www.oliver.ren\r	//alert(encodeURIComponent(str1));//http%3A%2F%2Fwww.oliver.ren\r	\r	//alert(decodeURI(encodeURI(str1)));//http://www.itheima.cn\r	//alert(decodeURIComponent(encodeURIComponent(str1)));//http://www.oliver.ren\r	\r	var str2 = &quot;alert(&#39;abc&#39;)&quot;;\r	//alert(str2);\r	eval(str2);\r&lt;/script&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 86),
(1132, '全局函数.png', '全局函数-png', 1538628999, 1538628999, 'a:5:{s:4:"name";s:16:"全局函数.png";s:4:"path";s:35:"/usr/uploads/2018/10/2348655152.png";s:4:"size";i:134165;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1131, 0),
(1133, 'jQuery简介', '1133', 1538646180, 1554039045, '<p>本文记录WEB前端学习过程中遇到的jQuery～</p>\r\r<!--more-->\r\r<p>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是&ldquo;write Less，Do More&rdquo;，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p>\r\r<p>jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 101),
(1526, 'Oracle查询语句——排序', '1526', 1554435240, 1554435298, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;排序～</p>\r<!--more-->\r\r<p>语句格式：</p>\r\r<pre class="brush:sql;">\rselect *|{olumn,...} from table order by column1 asc|desc, column2 asc|desc;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rselect * from emp order by sal;\rselect * from emp order by sal desc;\rselect * from emp order by sal asc, hiredate desc;</pre>\r\r<p>注意：order by语句要放到SQL的最后。</p>\r\r<p><strong>空值问题</strong></p>\r\r<p>当排序时，可能列的取值为null，这时可以使用nulls first，nulls last来指定null值显示的位置。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rselect * from emp order by sal nulls first;\rselect * from emp order by sal desc nulls last;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 33),
(1134, 'jQuery对象与DOM互转', '1134', 1538646360, 1554039081, '<p>本文记录WEB前端学习过程中遇到的jQuery对象与DOM互相转换～</p>\r<!--more-->\r\r<p>jQuery对象和DOM对象可以相互转换，但两个对象的函数不能彼此混搭使用。</p>\r\r<p>DOM转换成jQuery对象的语法为：</p>\r\r<pre class="brush:jscript;">\rjQuery(DOM对象);\r$(DOM对象);</pre>\r\r<p>jQuery对象转换成DOM对象的语法为：</p>\r\r<pre class="brush:jscript;">\r$jQuery[index]</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;script type=&quot;text/javascript&quot;&gt;\r	//原生JavaScript对象获取value值\r	var d1 = document.getElementById(&quot;demoId&quot;);\r	alert(d1.value);\r\r	//将JavaScript的DOM对象转换成jQuery对象\r	var $d2 = $(d1);\r	alert($d2.val());\r\r	//将jQuery对象转成DOM对象\r	var d3 = $d2[0];\r	alert(d3.value);\r&lt;/script&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 106),
(1135, 'jQuery基本选择器', '1135', 1538646840, 1538647065, '<p>本文记录WEB前端学习过程中遇到的jQuery基本选择器～</p>\r<!--more-->\r\r<p>jQuery常用的基本选择器有：</p>\r\r<ul>\r	<li>id选择器：$(&ldquo;#id名称&rdquo;);</li>\r	<li>元素选择器：$(&ldquo;元素名称&rdquo;);</li>\r	<li>类选择器：$(&ldquo;.类名&rdquo;);</li>\r	<li>通配符：*</li>\r	<li>多个选择器共用(并集)：用空格分隔</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;html&gt;\r	&lt;head&gt;\r		&lt;meta charset=&quot;UTF-8&quot;&gt;\r		&lt;title&gt;基本选择器&lt;/title&gt;\r		&lt;link rel=&quot;stylesheet&quot; href=&quot;../../css/style.css&quot; type=&quot;text/css&quot;/&gt;\r		&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery-1.8.3.js&quot; &gt;&lt;/script&gt;\r		&lt;script&gt;\r			$(function(){\r				$(&quot;#btn1&quot;).click(function(){\r					$(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn2&quot;).click(function(){\r					$(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn3&quot;).click(function(){\r					$(&quot;div&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn4&quot;).click(function(){\r					$(&quot;*&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn5&quot;).click(function(){\r					$(&quot;#two .mini&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r			});\r		&lt;/script&gt;		\r	&lt;/head&gt;\r	&lt;body&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;选择为one的元素&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;选择样式为mini的元素&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn3&quot; value=&quot;选择所有的div元素&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn4&quot; value=&quot;选择所有元素&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn5&quot; value=&quot;选择id为two并且样式为mini的元素&quot;/&gt;\r		&lt;hr/&gt;\r		&lt;div id=&quot;one&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				111\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;div id=&quot;two&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				222\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				333\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;div id=&quot;three&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				444\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				555\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				666\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;span id=&quot;four&quot;&gt;\r		&lt;/span&gt;\r	&lt;/body&gt;\r&lt;/html&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 94),
(1136, 'jQuery层级选择器', '1136', 1538647260, 1538649406, '<p>本文记录WEB前端学习过程中遇到的jQuery层级选择器～</p>\r<!--more-->\r\r<p>jQuery中常见的层级选择器有：</p>\r\r<ul>\r	<li>ancestor descendant: 在给定的祖先元素下匹配所有的后代元素(儿子、孙子、重孙子)；</li>\r	<li>parent &gt; child : 在给定的父元素下匹配所有的子元素(儿子)；</li>\r	<li>prev + next: 匹配所有紧接在 prev 元素后的 next 元素(紧挨着的，同桌)；</li>\r	<li>prev ~ siblings: 匹配 prev 元素之后的所有 siblings 元素(兄弟)。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;html&gt;\r	&lt;head&gt;\r		&lt;meta charset=&quot;UTF-8&quot;&gt;\r		&lt;title&gt;层级选择器&lt;/title&gt;\r		&lt;link rel=&quot;stylesheet&quot; href=&quot;../../css/style.css&quot; /&gt;\r		&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery-1.8.3.js&quot; &gt;&lt;/script&gt;\r		&lt;script&gt;\r			$(function(){\r				$(&quot;#btn1&quot;).click(function(){\r					$(&quot;body div&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn2&quot;).click(function(){\r					$(&quot;body&gt;div&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn3&quot;).click(function(){\r					$(&quot;#two+div&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn4&quot;).click(function(){\r					$(&quot;#one~div&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r			});\r		&lt;/script&gt;\r	&lt;/head&gt;\r	&lt;body&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;选择body中的所有的div元素&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;选择body中的第一级的孩子&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn3&quot; value=&quot;选择id为two的元素的下一个元素&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn4&quot; value=&quot;选择id为one的所有的兄弟元素&quot;/&gt;\r		&lt;hr/&gt;\r		&lt;div id=&quot;one&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				111\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;div id=&quot;two&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				222\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				333\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;div id=&quot;three&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				444\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				555\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				666\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;span id=&quot;four&quot;&gt;\r		&lt;/span&gt;\r	&lt;/body&gt;\r&lt;/html&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 79),
(1137, 'jQuery基本过滤选择器', '1137', 1538649480, 1538649993, '<p>本文记录WEB前端学习过程中遇到的jQuery基本过滤选择器～</p>\r<!--more-->\r\r<p>基本：</p>\r\r<ul>\r	<li>:first：第一个</li>\r	<li>:last：最后一个</li>\r	<li>:not：删除指定内容。例如：1234:not(3)--&gt;124</li>\r	<li>:even：偶数</li>\r	<li>:odd：奇数</li>\r	<li>:eq：指定第几个</li>\r	<li>:gt：大于几个</li>\r	<li>:lt：小于几个</li>\r	<li>:header：获得标题</li>\r	<li>:animated：获得动画</li>\r	<li>:focus：获得焦点</li>\r</ul>\r\r<p>内容：</p>\r\r<ul>\r	<li>:contains：包含</li>\r	<li>:empty：是否为空</li>\r	<li>:has：包含</li>\r	<li>:parent：父类</li>\r</ul>\r\r<p>可见性：</p>\r\r<ul>\r	<li>:hidden：隐藏</li>\r	<li>:visible：可见</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;html&gt;\r	&lt;head&gt;\r		&lt;meta charset=&quot;UTF-8&quot;&gt;\r		&lt;title&gt;基本过滤选择器&lt;/title&gt;\r		&lt;link rel=&quot;stylesheet&quot; href=&quot;../../css/style.css&quot; type=&quot;text/css&quot;/&gt;\r		&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery-1.8.3.js&quot; &gt;&lt;/script&gt;\r		&lt;script&gt;\r			$(function(){\r				$(&quot;#btn1&quot;).click(function(){\r					$(&quot;div:first&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn2&quot;).click(function(){\r					$(&quot;div:last&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn3&quot;).click(function(){\r					$(&quot;div:odd&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn4&quot;).click(function(){\r					$(&quot;div:even&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r			});\r		&lt;/script&gt;\r	&lt;/head&gt;\r	&lt;body&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;body中的第一个div元素&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;body中的最后一个div元素&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn3&quot; value=&quot;选择body中的奇数的div&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn4&quot; value=&quot;选择body中的偶数的div&quot;/&gt;\r		&lt;hr/&gt;\r		&lt;div id=&quot;one&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				111\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;div id=&quot;two&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				222\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				333\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;div id=&quot;three&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				444\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				555\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				666\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;span id=&quot;four&quot;&gt;\r		&lt;/span&gt;\r	&lt;/body&gt;\r&lt;/html&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 89),
(1138, 'jQuery属性选择器', '1138', 1538654220, 1538654859, '<p>本文记录WEB前端学习过程中遇到的jQuery属性选择器～</p>\r<!--more-->\r\r<p>jQuery中常见的属性选择器有：</p>\r\r<ul>\r	<li>[attribute]：获取含有对应属性的元素；</li>\r	<li>[attribute=value]：获取属性名的值为对应值的元素；</li>\r	<li>[attribute!=value]：获取属性名的值不为对应值的元素；</li>\r	<li>[attribute^=value]：获取属性名的值以对应的值开头的元素；</li>\r	<li>[attribute$=value]：获取属性名的值以对应的值结尾的元素；</li>\r	<li>[attribute*=value]：获取属性名的值含有对应的值的元素；</li>\r	<li>[attrSel1][attrSel2]...[attrSelN]：复合属性选择器，多个属性同时过滤。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;html&gt;\r	&lt;head&gt;\r		&lt;meta charset=&quot;UTF-8&quot;&gt;\r		&lt;title&gt;层级选择器&lt;/title&gt;\r		&lt;link rel=&quot;stylesheet&quot; href=&quot;../../css/style.css&quot;  type=&quot;text/css&quot;/&gt;\r		&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery-1.8.3.js&quot; &gt;&lt;/script&gt;\r		&lt;script&gt;\r			$(function(){\r				$(&quot;#btn1&quot;).click(function(){\r					$(&quot;div[id]&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn2&quot;).click(function(){\r					$(&quot;div[id=&#39;two&#39;]&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r			});\r		&lt;/script&gt;\r	&lt;/head&gt;\r	&lt;body&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;选择有id属性的div&quot;/&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;选择有id属性的值为two的div&quot;/&gt;\r		&lt;hr/&gt;\r		&lt;div id=&quot;one&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				111\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;div id=&quot;two&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				222\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				333\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;div id=&quot;three&quot;&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				444\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				555\r			&lt;/div&gt;\r			&lt;div class=&quot;mini&quot;&gt;\r				666\r			&lt;/div&gt;\r		&lt;/div&gt;\r		&lt;span id=&quot;four&quot;&gt;\r		&lt;/span&gt;\r	&lt;/body&gt;\r&lt;/html&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1139, 'jQuery表单选择器', '1139', 1538654940, 1538655463, '<p>本文记录WEB前端学习过程中遇到的jQuery表单选择器～</p>\r<!--more-->\r\r<p>表单类型选择器：</p>\r\r<ul>\r	<li>:input</li>\r	<li>:text</li>\r	<li>:password</li>\r	<li>:radio</li>\r	<li>:checkbox</li>\r	<li>:submit</li>\r	<li>:image</li>\r	<li>:reset</li>\r	<li>:button</li>\r	<li>:file</li>\r	<li>:hidden</li>\r</ul>\r\r<p>表单属性选择器：</p>\r\r<ul>\r	<li>:enabled：可用；</li>\r	<li>:disabled：不可用（disabled=&ldquo;disabled&rdquo;）；</li>\r	<li>:checked：选中（radio或者checkbox等）；</li>\r	<li>:selected：选择（select中的option等）。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;html&gt;\r	&lt;head&gt;\r		&lt;meta charset=&quot;UTF-8&quot;&gt;\r		&lt;title&gt;表单选择器&lt;/title&gt;\r		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../../css/style.css&quot;/&gt;\r		&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery-1.8.3.js&quot; &gt;&lt;/script&gt;\r		&lt;script&gt;\r			$(function(){\r				$(&quot;#btn1&quot;).click(function(){\r					$(&quot;:input&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r				$(&quot;#btn2&quot;).click(function(){\r					$(&quot;:text&quot;).css(&quot;background-color&quot;,&quot;pink&quot;);\r				});\r			});\r		&lt;/script&gt;\r	&lt;/head&gt;\r	&lt;body&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;选择所有input元素&quot; /&gt;\r		&lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;选择文本框&quot; /&gt;\r		&lt;br/&gt;\r		&lt;form&gt;\r			&lt;input type=&quot;text&quot; /&gt;&lt;br /&gt;\r			&lt;input type=&quot;checkbox&quot; /&gt;&lt;br /&gt;\r			&lt;input type=&quot;radio&quot; /&gt;&lt;br /&gt;\r			&lt;input type=&quot;image&quot; /&gt;&lt;br /&gt;\r			&lt;input type=&quot;file&quot; /&gt;&lt;br /&gt;\r			&lt;input type=&quot;submit&quot; /&gt;\r			&lt;input type=&quot;reset&quot; /&gt;&lt;br /&gt;\r			&lt;input type=&quot;password&quot; /&gt;&lt;br /&gt;\r			&lt;input type=&quot;button&quot; /&gt;&lt;br /&gt;\r			&lt;select&gt;&lt;option/&gt;&lt;/select&gt;&lt;br /&gt;\r			&lt;textarea&gt;&lt;/textarea&gt;&lt;br /&gt;\r			&lt;button&gt;&lt;/button&gt;\r		&lt;/form&gt;\r	&lt;/body&gt;\r&lt;/html&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 94),
(1140, 'jQuery动画效果', '1140', 1538655540, 1538656021, '<p>本文记录WEB前端学习过程中遇到的jQuery的动画效果～</p>\r<!--more-->\r\r<p>基本：</p>\r\r<ul>\r	<li>show(speed, fn)：显示。speed为显示速度，单位为毫秒。固定取值有：slow，normal和fast。fn为显示成功之后回掉函数；</li>\r	<li>hide()：隐藏；</li>\r	<li>toggle()：显示和隐藏之前切换。</li>\r</ul>\r\r<p>滑动：</p>\r\r<ul>\r	<li>slideDown()：显示，高度变大；</li>\r	<li>slideUp()：隐藏，高度变小；</li>\r	<li>slideToggle()：显示和隐藏之间切换。</li>\r</ul>\r\r<p>淡入淡出：</p>\r\r<ul>\r	<li>fadeIn()：显示；</li>\r	<li>fadeOut()：隐藏；</li>\r	<li>fadeToggle()：切换；</li>\r	<li>fadeTo(speed, opacity, [fn])：opacity指定显示的透明度，是一个0-1之前表示透明度的数字。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 89),
(1141, 'jQuery修改样式', '1141', 1538656980, 1538657347, '<p>本文记录WEB前端学习过程中遇到的jQuery修改样式～</p>\r<!--more-->\r\r<p>jQuery用于修改元素class属性的三个函数：</p>\r\r<ul>\r	<li>addClass(class|fn)：给指定标签的class属性追加样式；</li>\r	<li>removeClass([class|fn])：将标签指定的class属性移除；</li>\r	<li>toggleClass(class|fn[,sw])：切换class属性样式，即没有时添加，有时删除。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(1142, 'jQuery属性操作', '1142', 1538657880, 1538732880, '<p>本文记录WEB前端学习过程中遇到的jQuery属性操作～</p>\r<!--more-->\r\r<p>jQuery属性操作常见的方法有：</p>\r\r<ul>\r	<li>attr(name|pro|key,val|fn)：操作的标签的属性；</li>\r	<li>removeAttr(name)：移除操作的标签的属性；</li>\r	<li>prop(name|pro|key,val|fn)：操作的标签的属性。jQuery1.6新特性；</li>\r	<li>removeProp(name)：移除操作的标签的属性。</li>\r	<li>val()&nbsp; &nbsp; &nbsp;//获得value属性的值；</li>\r	<li>var(...)&nbsp; //给value属性设置值；</li>\r	<li>html()&nbsp; &nbsp; //获得html代码，如果有标签，一并获得；</li>\r	<li>html(...) //设置html代码，如果有标签，将进行解析；</li>\r	<li>text()&nbsp; &nbsp; //获得文本，如果有标签，忽略；</li>\r	<li>text(...) //设置文本，如果含有标签，不进行解析，原样输出。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(1143, 'jQuery遍历函数', '1143', 1538732940, 1538733486, '<p>本文记录WEB前端学习过程中遇到的jQuery遍历函数～</p>\r<!--more-->\r\r<pre class="brush:jscript;">\r//方式一\r$(ele)each(fn);\r\r//方式二\r$.each($ele, fn);</pre>\r\r<p>回掉函数fn：function(index, docEle)</p>\r\r<ul>\r	<li>index：遍历索引号；</li>\r	<li>docEle==this：遍历当前对象（DOM对象）。</li>\r</ul>\r\r<div>示例代码：</div>\r\r<div>&nbsp;</div>\r\r<div>\r<pre class="brush:jscript;">\r// each(fn)函数\r$(&quot;input:hidden&quot;).each(function(){\r//alert(this.value);\ralert($(this).val());\r});\r\r//$.each(对象,fn)函数\r$.each($(&quot;input:hidden&quot;), function(index, docEle){\ralert(index + &quot; -- &quot; + docEle.value);\r});</pre>\r</div>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 85),
(1144, 'jQuery文档处理-内部插入', '1144', 1538733660, 1538733847, '<p>本文记录WEB前端学习过程中遇到的jQuery文档处理的内部插入～</p>\r<!--more-->\r\r<ul>\r	<li>A.append(B)//将B插入到A内部后面</li>\r	<li>A.prepend(B)//将B插入到A内部前面</li>\r	<li>A.appendTo(B)//将A插入到B内部后面</li>\r	<li>A.prependTo(B)//将A插入到B内部前面</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 82),
(1145, 'jQuery常见事件', '1145', 1538734320, 1538734974, '<p>本文记录WEB前端学习过程中遇到的jQuery常见事件～</p>\r<!--more-->\r\r<p>jQuery常见的事件有：</p>\r\r<ul>\r	<li>blur([data],fn)：失去焦点；</li>\r	<li>change([[data],fn])：改变，例如select列表项改变；</li>\r	<li>click([[data],fn])：单击；</li>\r	<li>dbclick([[data],fn])：双击；</li>\r	<li>error([[data],fn])：页面加载错误；</li>\r	<li>focus([[data],fn])：获得焦点；</li>\r	<li>focusin([data],fn)：细化获得焦点；</li>\r	<li>focusout([data],fn)：细化获得焦点；</li>\r	<li>keydown([[data],fn])：键盘按下；</li>\r	<li>keypress([[data],fn])：键盘按；</li>\r	<li>keyup([[data],fn])：键盘弹起；</li>\r	<li>mousedown([[data],fn])：鼠标按下；</li>\r	<li>mouseenter([[data],fn])：细化鼠标按下；</li>\r	<li>mouseleave([[data],fn])：细化鼠标按下；</li>\r	<li>mousemove([[data],fn])：鼠标移动；</li>\r	<li>mouseout([[data],fn])：鼠标移出；</li>\r	<li>mouseover([data],fn)：鼠标移入；</li>\r	<li>mouseup([[data],fn])：鼠标弹起；</li>\r	<li>resize([[data],fn])：改变窗口大小；</li>\r	<li>scroll([[data],fn])：滚动；</li>\r	<li>select([[data],fn])：选中；</li>\r	<li>submit([[data],fn])：提交；</li>\r	<li>unload([[data],fn])：页面关闭。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(1146, 'jQuery事件切换', '1146', 1538735340, 1538735501, '<p>本文记录WEB前端学习过程中遇到的jQuery事件切换～</p>\r<!--more-->\r\r<ul>\r	<li>hover(over,out)：简化方法，A.hover(fn1, fn2)等效于A.mouseover(fn1).mouseout(fn2)；</li>\r	<li>toggle(fn1,fn2)：click事件增强版，轮回之行各个函数。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 84),
(1147, 'jQuery校验插件validation', '1147', 1538736120, 1538737106, '<p>本文记录WEB前端学习过程中遇到的jQuery校验插件validation～</p>\r<!--more-->\r\r<p>语法格式为：</p>\r\r<pre class="brush:jscript;">\r$(...).validate({\r	rules:{},\r	messages:{}}\r});</pre>\r\r<p>规则语法格式：</p>\r\r<pre class="brush:jscript;">\rrules:{\r	字段名: 校验器;\r	字段名: 校验器\r}</pre>\r\r<p>校验器语法格式：</p>\r\r<pre class="brush:jscript;">\r语法:{\r	校验器: 值,\r	校验器: 值\r}</pre>\r\r<p>提示语法格式：</p>\r\r<pre class="brush:jscript;">\rmessage:{\r	字段名:{\r		校验器:&quot;提示&quot;,\r		校验器:&quot;提示&quot;\r	}\r}</pre>\r\r<p>支持的校验类型有：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/4071109841.png" style="width: 800px; height: 447px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r$(&quot;#formId&quot;).validate({\r	rules:{\r		username: {\r			required: true\r		},\r		password:{\r			required: true,\r			rangelength: [2,5]\r		},\r		repassword:{\r			equalTo: &quot;[name=&#39;password&#39;]&quot;\r		}\r	},\r	messages: {\r		username: {\r			required: &quot;不能为空&quot;;\r		},\r		password: {\r			rangelength: &quot;长度{0}-{1}&quot;之间\r		}，\r	}\r});</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 89),
(1148, '校验类型.png', '校验类型-png', 1538737090, 1538737090, 'a:5:{s:4:"name";s:16:"校验类型.png";s:4:"path";s:35:"/usr/uploads/2018/10/4071109841.png";s:4:"size";i:487629;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1147, 0),
(1149, 'BootStrap简介', '1149', 1538959620, 1538959620, '<p>本文记录WEB前端学习过程中遇到的BootStrap简介～</p>\r<!--more-->\r\r<p>BootStrap是基于HTML、CSS和JavaScript的前端框架（半成品）。它预定义一套CSS样式和与样式对应的jQuery代码，我们只需要提供固定的HTML结构，添加固定的class样式，就可以完成指定效果的实现。</p>\r\r<p>BootStrap在jQuery的基础之上工作，可以理解BootStrap就是jQuery的一个插件。</p>\r\r<p>BootStrap使得WEB开发更加快捷，代码优雅，美观大方。</p>\r\r<p>BootStrap是由Twitter公司的设计师 Mark Otto 和 Jacob Thornton 合作开发。</p>\r\r<p>BootStrap基础入门使用的都是自带CSS样式，高级开发中需要使用HTML5、CSS和动态CSS语言Less进行自定义开发。</p>\r\r<p>国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于BootStrap源码进行性能优化而来的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 73),
(1150, '响应式布局', '1150', 1538960460, 1538960533, '<p>本文记录WEB前端学习过程中遇到的响应式布局～</p>\r<!--more-->\r\r<p>响应式布局是指，一个网站能够兼容多个终端（手机、iPad等），而不需要为每个终端都开发一个特定的版本，这个概念是为解决移动互联网浏览而诞生的。</p>\r\r<p>响应式布局课可以为不同终端的用户提供更加舒适的页面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用&ldquo;大势所趋&rdquo;来形容也不为过。随着越来越多的设计师采用这个技术，我们不仅看到了很多的创新，还看到了一些成形的模式。</p>\r\r<p>BootStrap就是响应式布局最成功的实现，为了兼容不同的浏览器采用jQuery，为了适配不同的终端采用CSS3 Media Query（媒体查询）。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 81),
(1151, 'BootScrap布局容器', '1151', 1538961158, 1538961158, '<p>本文记录WEB前端学习过程中遇到的BootScrap布局容器～</p>\r<!--more-->\r\r<p>BootStrap需要为页面内容和栅格系统包裹一个container容器。</p>\r\r<p>提供的常用的两个容器如下：</p>\r\r<ul>\r	<li>.container类用于固定宽度并支持响应式布局的容器：</li>\r</ul>\r\r<pre class="brush:xml;">\r&lt;div class=&quot;container&quot;&gt;\r	...\r&lt;/div&gt;</pre>\r\r<ul>\r	<li>.container-fluid类用于100%宽度，占据全部窗口(viewport)的容器：</li>\r</ul>\r\r<pre class="brush:xml;">\r&lt;div class=&quot;container-fluid&quot;&gt;\r	...\r&lt;/div&gt;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--居中显示，两边有留白--&gt;\r&lt;div class=&quot;container&quot; style=&quot;border: 1px solid #F00; height: 100px;&quot;&gt;\r	...\r&lt;/div&gt;\r\r&lt;!--整个宽度--&gt;\r&lt;div class=&quot;container-fluid&quot; style=&quot;border: 1px solid #F00; height: 100px;&quot;&gt;\r	...\r&lt;/div&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 85),
(1152, '栅格参数.png', '栅格参数-png', 1538962018, 1538962018, 'a:5:{s:4:"name";s:16:"栅格参数.png";s:4:"path";s:34:"/usr/uploads/2018/10/144609059.png";s:4:"size";i:242041;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1153, 0),
(1153, 'BootStrap栅格', '1153', 1538962062, 1538962062, '<p>本文记录WEB前端学习过程中遇到的BootStrap栅格～</p>\r<!--more-->\r\r<p>BootStrap提供了一套响应式并且移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p>\r\r<p>栅格的特点：</p>\r\r<ul>\r	<li>&ldquo;行row&rdquo;必须包含在.container或.container-fluid中；</li>\r	<li>&ldquo;列column&rdquo;可以作为&ldquo;行row&rdquo;的直接子元素；</li>\r	<li>行使用的样式&rdquo;.row&quot;和列使用的样式&ldquo;col-*-*&rdquo;内容应当放置于&ldquo;列column&rdquo;内；</li>\r	<li>列大于12时，将另起一行排列；</li>\r	<li>栅格类适用于与屏幕宽度大于或等于分界点大小的设备，并且针对小屏幕设备覆盖栅格类。</li>\r</ul>\r\r<p>栅格列参数（large:lg, medium:md, small: sm, x-small: xs）：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/144609059.png" style="width: 800px; height: 354px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;div class=&quot;container&quot;&gt;\r	&lt;div class=&quot;row&quot;&gt;\r		&lt;div class=&quot;col-md-3 col-xs-6&quot;&gt;11&lt;/div&gt;\r		&lt;div class=&quot;col-md-3 col-xs-6&quot;&gt;12&lt;/div&gt;\r		&lt;div class=&quot;col-md-3 col-xs-6&quot;&gt;13&lt;/div&gt;\r		&lt;div class=&quot;col-md-3 col-xs-6&quot;&gt;14&lt;/div&gt;\r	&lt;/div&gt;\r	&lt;div class=&quot;row&quot;&gt;\r		&lt;div class=&quot;col-md-3 col-xs-6&quot;&gt;21&lt;/div&gt;\r		&lt;div class=&quot;col-md-3 col-xs-6&quot;&gt;22&lt;/div&gt;\r		&lt;div class=&quot;col-md-3 col-xs-6&quot;&gt;23&lt;/div&gt;\r		&lt;div class=&quot;col-md-3 col-xs-6&quot;&gt;24&lt;/div&gt;\r	&lt;/div&gt;\r&lt;/div&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 91),
(1154, 'BootStrap按钮', '1154', 1539007080, 1539008027, '<p>本文记录WEB前端学习过程中遇到的BootStrap按钮～</p>\r<!--more-->\r\r<p>.btn-lg、.btn-sm或.btn-xs可以设置按钮的不同尺寸。</p>\r\r<p>.active类设置按钮的激活状态，其表现为被按压下去（底色更深、边框颜色更深或者向内投射阴影）。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;（默认样式）Default&lt;/button&gt;\r&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;（首选项）Primary&lt;/button&gt;\r&lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;（成功）Success&lt;/button&gt;\r&lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;（一般信息）Info&lt;/button&gt;\r&lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;（警告）Warning&lt;/button&gt;\r&lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;（危险）Danger&lt;/button&gt;\r&lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot;&gt;（链接）Link&lt;/button&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 80),
(1155, 'BootStrap响应式工具', '1155', 1539008760, 1539009148, '<p>本文记录WEB前端学习过程中遇到的BootStrap响应式工具～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/1067083350.png" style="width: 800px; height: 333px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--\r	设置one div，中等屏幕和超小屏幕显示\r	设置two div，小屏幕和超大屏幕隐藏\r--&gt;\r\r&lt;div class=&quot;visible-md visible-xs&quot;&gt;one&lt;/div&gt;\r&lt;div class=&quot;hidden-sm hidden-lg&quot;&gt;two&lt;div&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 91),
(1156, 'BootStrap响应式工具.png', 'BootStrap响应式工具-png', 1539008900, 1539008900, 'a:5:{s:4:"name";s:28:"BootStrap响应式工具.png";s:4:"path";s:35:"/usr/uploads/2018/10/1067083350.png";s:4:"size";i:294616;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1155, 0),
(1157, 'JUnit单元测试', '1157', 1539530280, 1539530364, '<p>本文记录Java学习过程中遇到的JUnit单元测试～</p>\r<!--more-->\r\r<p>JUnit是一个Java语言的单元测试框架，属于第三方工具，一般情况下需要导入jar包。不过，大多数的Java开发环境已经集成了JUnit作为单元测试工具。</p>\r\r<p>测试类：可以简单的理解为可以取代Java的main方法的方法，在测试类方法前面必须加上@Test注解。</p>\r\r<p>常用的注解有：</p>\r\r<ul>\r	<li>@Test：用于修饰需要执行的方法；</li>\r	<li>@Before：测试方法执行前执行的方法；</li>\r	<li>@After：测试方法执行后执行的方法。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class JUnitDemo{\r	@Before\r	public void myBefore(){\r		System.out.println(&quot;before&quot;);\r	}\r\r	@Test\r	public void myTest(){\r		System.out.println(&quot;test&quot;);\r	}\r\r	@After\r	public void myAfter(){\r		System.out.println(&quot;after&quot;);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 82),
(1158, '外键', '1158', 1540027500, 1540027956, '<p>本文记录MySQL学习过程中遇到的外键～</p>\r<!--more-->\r\r<p>我们可以通过主表的主键和从表的外键来描述主从关系，呈现出来就是一对多关系。</p>\r\r<p>外键的特点：</p>\r\r<ul>\r	<li>从表外键的值是对主表主键的引用；</li>\r	<li>从表外键类型必须与主表主键类型一致。</li>\r</ul>\r\r<p>声明外键约束的语法：</p>\r\r<pre class="brush:sql;">\r--增加外键\ralter table 从表 add [constraint] [外键名称] foreign key 从表外键字段名 references 主表 主表的主键;\r--删除外键\ralter table 从表 drop foreign key 外键名称;</pre>\r\r<p>注意：使用外键的目的是保证数据完整性。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(1159, '表与表之间关系', '1159', 1540028040, 1540028673, '<p>本文记录MySQL学习过程中遇到的表与表之间的关系～</p>\r<!--more-->\r\r<p>表与表之间的关系就是表与表数据之间的关系。</p>\r\r<p>1.一对多关系：</p>\r\r<ul>\r	<li>常见实例：客户和订单、分类和商品以及部分和员工等；</li>\r	<li>一对多建表原则：在从表（多方）创建一个字段，该字段作为外键指向主表（一方）的主键。</li>\r</ul>\r\r<p>2.多对多关系：</p>\r\r<ul>\r	<li>常见实例：学生和课程、商品和订单以及人和角色等；</li>\r	<li>多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。（就是将一个多对多拆成两个一对多）</li>\r</ul>\r\r<p>3.一对一关系：</p>\r\r<p>在实际的开发中应用不多，因为一对一可以创建成一张表。</p>\r\r<p>两种建表原则：</p>\r\r<ul>\r	<li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一；</li>\r	<li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 66),
(1160, '多表查询', '1160', 1540029060, 1540029691, '<p>本文记录MySQL学习过程中遇到的多表查询～</p>\r<!--more-->\r\r<p>1.交叉连接查询（两个表的乘积）</p>\r\r<pre class="brush:sql;">\rselect * from A,B;\rselect * from A cross join B;</pre>\r\r<p>2.内连接查询（inner join，inner可以省略）</p>\r\r<pre class="brush:sql;">\rselect * from A,B where 条件;\rselect * from A inner join B where 条件;\rselect * from A join B where 条件;</pre>\r\r<p>3.外连接查询（outer join，outer可以省略）</p>\r\r<p>左外连接</p>\r\r<pre class="brush:sql;">\rselect * from A left outer join B on 条件;</pre>\r\r<p>右外连接</p>\r\r<pre class="brush:sql;">\rselect * from A right outer join B on 条件;</pre>\r\r<p>全外连接</p>\r\r<pre class="brush:sql;">\rselect * from A full outer join B on 条件;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 82),
(1161, '子查询', '1161', 1540032120, 1540032435, '<p>本文记录MySQL学习过程中遇到的子查询～</p>\r<!--more-->\r\r<p>子查询：一条select语句结果作为另一条select语句的一部分（查询条件、查询结果或者表等）。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rselect * from B where bid in (select bid from A where aname like &#39;%b%&#39;);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(1162, '装饰者设计模式', '1162', 1540046220, 1540046725, '<p>本文记录Java学习过程中遇到的装饰者设计模式～</p>\r<!--more-->\r\r<p>设计模式：专门为解决某一类问题而编写的固定格式的代码。</p>\r\r<p>装饰者固定结构：接口A、已知的实现类C和需要装饰者创建的代理类B</p>\r\r<p>装饰者实现步骤：</p>\r\r<ol>\r	<li>创建类B，并实现接口A；</li>\r	<li>提供类B的构造方法，参数类型为A，用于接收A接口的其他实现类C；</li>\r	<li>给类B添加类型为A的成员方法，用于存放A接口的其他实现类；</li>\r	<li>增强需要的方法；</li>\r	<li>实现不需要增强的方法，方法体重新调用成员变量存放的其他实现类对应的方法。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rclass B implements A{\r	private A a;\r	public B(A a){\r		this.a = a;\r	}\r	//需要增强的方法\r	public void close(){\r\r	}\r	//不需要增强的方法\r	public void commit(){\r		this.a.commit();\r	}\r}\r\r\rA a = ...C;\rB b = new B(a);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97),
(1163, 'C3P0连接池', '1163', 1540047360, 1540048519, '<p>本文记录Java学习过程中遇到的C3P0连接池～</p>\r<!--more-->\r\r<p>C3P0是一个开源免费的连接池。目前使用它的开源项目有：Spring和Hibernate等。使用第三方工具需要导入jar包，C3P0使用时还需要添加配置文件c3p0-config.xml。</p>\r\r<h3>导入jar包</h3>\r\r<p>这里使用0.9.2版本，需要导入jar包。</p>\r\r<pre class="brush:java;">\rc3p0-0.9.1.2.jar</pre>\r\r<h3>配置文件</h3>\r\r<pre class="brush:xml;">\r&lt;c3p0-config&gt;\r	&lt;!-- 默认配置 --&gt;\r	&lt;default-config&gt;\r		&lt;!-- 连接数据库的4项基本参数 --&gt;\r		&lt;property name=&quot;dirverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;\r		&lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://127.0.0.1:3306/test&lt;/property&gt;\r		&lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;\r		&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;\r		&lt;!-- 如果池中数据连接不够时一次增长的个数 --&gt;\r		&lt;property name=&quot;acquireincrement&quot;&gt;5&lt;/property&gt;\r		&lt;!-- 初始连接数 --&gt;\r		&lt;property name=&quot;initialPoolSize&quot;&gt;20&lt;/property&gt;\r		&lt;!-- 最小连接数 --&gt;\r		&lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;\r		&lt;!-- 最大连接数 --&gt;\r		&lt;property name=&quot;maxPoolSize&quot;&gt;40&lt;/property&gt;\r		&lt;!-- JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量 --&gt;\r		&lt;property name=&quot;maxStatements&quot;&gt;0&lt;/property&gt;\r		&lt;!-- 连接池内单个连接所拥有的最大缓存statements数 --&gt;\r		&lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt;\r	&lt;/default-config&gt;\r	&lt;!-- 配置的命名 --&gt;\r	&lt;named-config name=&quot;oliver&quot;&gt;\r		&lt;!-- 连接数据库的4项基本参数 --&gt;\r		&lt;property name=&quot;dirverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;\r		&lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://127.0.0.1:3306/test&lt;/property&gt;\r		&lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;\r		&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;\r		&lt;!-- 如果池中数据连接不够时一次增长的个数 --&gt;\r		&lt;property name=&quot;acquireincrement&quot;&gt;5&lt;/property&gt;\r		&lt;!-- 初始连接数 --&gt;\r		&lt;property name=&quot;initialPoolSize&quot;&gt;20&lt;/property&gt;\r		&lt;!-- 最小连接数 --&gt;\r		&lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;\r		&lt;!-- 最大连接数 --&gt;\r		&lt;property name=&quot;maxPoolSize&quot;&gt;40&lt;/property&gt;\r		&lt;!-- JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量 --&gt;\r		&lt;property name=&quot;maxStatements&quot;&gt;0&lt;/property&gt;\r		&lt;!-- 连接池内单个连接所拥有的最大缓存statements数 --&gt;\r		&lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt;\r	&lt;/named-config&gt;\r&lt;/c3p0-config&gt;</pre>\r\r<h3>常见配置项</h3>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/2191194143.png" style="width: 800px; height: 685px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/735834310.png" style="width: 800px; height: 351px;" /></p>\r\r<h3>编写工具类</h3>\r\r<pre class="brush:java;">\rimport java.sql.Connection;\rimport java.sql.SQLException;\r\rimport javax.sql.DataSource;\r\rimport com.mchange.v2.c3p0.ComboPooledDataSource;\r\rpublic class C3P0Utils {\r	private static ComboPooledDataSource dataSource = new ComboPooledDataSource(&quot;itheima&quot;);\r\r	public static DataSource getDataSource() {\r		return dataSource;\r	}\r\r	public static Connection getConnection() {\r		try {\r			return dataSource.getConnection();\r		} catch (SQLException e) {\r			throw new RuntimeException(e);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 119),
(1164, '常见配置项01.png', '常见配置项01-png', 1540048380, 1540048380, 'a:5:{s:4:"name";s:21:"常见配置项01.png";s:4:"path";s:35:"/usr/uploads/2018/10/2191194143.png";s:4:"size";i:365955;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1163, 0),
(1165, '常见配置项02.png', '常见配置项02-png', 1540048381, 1540048381, 'a:5:{s:4:"name";s:21:"常见配置项02.png";s:4:"path";s:34:"/usr/uploads/2018/10/735834310.png";s:4:"size";i:215851;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1163, 0),
(1166, 'JavaBean组件', '1166', 1540050600, 1540054156, '<p>本文记录Java学习过程中遇到的JavaBean组件～</p>\r<!--more-->\r\r<p>JavaBean就是一个类，在开发过程中常用于封装数据。</p>\r\r<p>具有如下特性：</p>\r\r<ul>\r	<li>需要实现接口：java.io.Serializable，通常偷懒省略了；</li>\r	<li>提供私有字段：private 类型 字段名；</li>\r	<li>提供getter/setter方法；</li>\r	<li>提供无参构造。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class Person{\r	private int id;\r	private String name;\r\r	public Person(){\r		super();\r	}\r\r	public int getId(){\r		return this.id;\r	}\r\r	public void setId(int id){\r		this.id = id;\r	}\r\r	public String getName(){\r		return this.name;\r	}\r\r	public void setName(String name){\r		this.name = name;\r	}\r\r	public String toString(){\r		return this.id + &quot;  : &quot; + this.name;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 84),
(1167, 'XML简介', '1167', 1540708607, 1540708607, '<p>本文记录Java学习过程中遇到的XML简介～</p>\r<!--more-->\r\r<p>XML全称为Extensible Markup Language，意思是可扩展的标记语言。XML语法上和HTML比较相似，但HTML中的元素是固定的，而XML的标签是可以由用于自定义的。</p>\r\r<p>W3C在1998年2月发布1.0版本，2004年2月又发布1.1版本，但因为1.1版本不能向下兼容1.0版本，所以1.1基本没人使用。同时，W3C在2004年2月又发布了1.0版本的第三版。我们目前使用的都是XML的1.0版本。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 78),
(1168, 'XML常见应用', '1168', 1540708702, 1540708702, '<p>本文记录Java学习过程中遇到的XML常见应用～</p>\r<!--more-->\r\r<p>XML常见的应用主要有配置文件和存放数据等。</p>\r\r<p>1.配置文件</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r&lt;web-app version=&quot;2.5&quot;&gt;\r	&lt;servlet&gt;\r		&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\r		&lt;servlet-class&gt;ren.oliver.HelloServlet&lt;/servlet-class&gt;\r	&lt;/servlet&gt;\r	&lt;servlet-mapping&gt;\r		&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\r		&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\r	&lt;/servlet-mapping&gt;\r&lt;/web-app&gt;</pre>\r\r<p>2.存放数据</p>\r\r<p>实例代码：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r&lt;persons&gt;\r	&lt;person id=&quot;001&quot;&gt;\r		&lt;name&gt;Oliver King&lt;/name&gt;\r		&lt;sex&gt;男&lt;/sex&gt;\r	&lt;/person&gt;\r	&lt;person id=&quot;002&quot;&gt;\r		&lt;name&gt;Cathy King&lt;/name&gt;\r		&lt;sex&gt;女&lt;/sex&gt;\r	&lt;/person&gt;\r&lt;/persons&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 80),
(1169, '转义字符.png', '转义字符-png', 1540710237, 1540710237, 'a:5:{s:4:"name";s:16:"转义字符.png";s:4:"path";s:34:"/usr/uploads/2018/10/802324383.png";s:4:"size";i:471008;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1170, 0),
(1170, 'XML语法', '1170', 1540710300, 1540710962, '<p>本文记录Java学习过程中遇到的XML语法～</p>\r<!--more-->\r\r<h3>XML文档说明</h3>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</pre>\r\r<ol>\r	<li>文档声明必须以&lt;?xml开头，以?&gt;结尾；</li>\r	<li>文档声明必须从文档的0行0列位置开始；</li>\r	<li>文档声明只有三个属性：</li>\r</ol>\r\r<ul style="margin-left: 40px;">\r	<li>version：必须属性，指定XML文档版本；</li>\r	<li>encoding：可选书习惯，指定当前文档的编码格式，默认值为UTF-8；</li>\r	<li>standalone：是否依赖外部约束。</li>\r</ul>\r\r<h3>元素element</h3>\r\r<pre class="brush:xml;">\r&lt;element&gt;\r	xxx\r&lt;/element&gt;</pre>\r\r<ol>\r	<li>元素是XML文档中最重要的组成部分；</li>\r	<li>格式化良好的XML文档，必须之后一个根元素；</li>\r	<li>普通元素的结构由开始标签、元素体和结束标签组成，例如：&lt;element&gt;内容&lt;/element&gt;；</li>\r	<li>元素体：元素体可以是元素，也可以是文本；</li>\r	<li>空元素：空元素只有开始标签，而没有结束标签，但元素必须自己闭合，例如：&lt;element /&gt;；</li>\r	<li>元素命名格式：</li>\r</ol>\r\r<ul style="margin-left: 40px;">\r	<li>区分大小写；</li>\r	<li>不能使用空格，也不能使用冒号；</li>\r	<li>不建议以XML、xml或者Xml开头。</li>\r</ul>\r\r<h3>属性</h3>\r\r<pre class="brush:xml;">\r&lt;web-app version=&quot;2.5&quot; /&gt;</pre>\r\r<ol>\r	<li>属性是元素的一部分，它必须出现在元素的开始标签中；</li>\r	<li>属性的定义格式：属性名=属性值，其中属性值必须使用单引号或者双引号；</li>\r	<li>一个元素可以有无数个属性，但是一个元素中不能出现同名的属性；</li>\r	<li>属性名不能使用空格、冒号等特殊字符，且必须以字母开头。</li>\r</ol>\r\r<h3>注释</h3>\r\r<pre class="brush:xml;">\r&lt;!-- 注释内容 --&gt;</pre>\r\r<p>XML的注释与HMTL相同，即以&quot;&lt;!--&quot;开始，以&quot;--&gt;&quot;结束，注释内容会被XML解析器忽略。</p>\r\r<h3>转义字符</h3>\r\r<p>XML中的转义字符和HTML一样，因为转义字符已经被XML文档结构所使用，所以在元素体或属性值中向使用这些符号就必须使用转义字符，例如：&lt;, &gt;, &#39;, &quot;, &amp;。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/802324383.png" style="width: 800px; height: 414px;" />​</p>\r\r<h3>CDATA区</h3>\r\r<pre class="brush:xml;">\r&lt;![CDATA[\r	数据内容\r]]&gt;</pre>\r\r<ol>\r	<li>当大量的转义字符出现在XML文档中时，会使XML文档的可读性大幅度降低，这时使用CDATA就会好一些。</li>\r	<li>在CDATA段中出现的符号都不需要使用转义字符，这可以很大的提供XML文档的可读性；</li>\r	<li>在CDATA段中不能包含&quot;]]&gt;&quot;，即CDATA段的结束定界符。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 112),
(1171, 'DTD约束简介', '1171', 1540710757, 1540710757, '<p>本文记录Java学习过程中遇到的DTD约束简介～</p>\r<!--more-->\r\r<p>DTD（Document Type Definition），文档类型定义，用来约束XML文档。规定XML文档中元素的名称，子元素的名称和元素的属性等。</p>\r\r<p>在开发过程中，我们很少自己编写DTD约束文档，通常情况都是根据框架提供的DTD约束文档编写对应XML文档，使用DTD约束的常见框架有：struts2和hibername等。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97),
(1172, 'DTD约束语法', '1172', 1540712940, 1540713089, '<p>本文记录Java学习过程中遇到的DTD约束语法～</p>\r<!--more-->\r\r<h3>文档声明</h3>\r\r<p>1.内部DTD，在XML文档内部嵌入DTD，只对当前XML有效：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;\r&lt;!DOCTYPE web-app [\r	具体的约束语法\r]&gt;\r&lt;web-app&gt;\r&lt;/web-app&gt;</pre>\r\r<p>2.外部DTD-本地DTD，DTD文档在本地系统上，一般为公司内部自己项目使用：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;\r&lt;!DOCTYPE web-app SYSTEM &quot;web-app_2_3.dtd&quot;&gt;\r&lt;web-app&gt;\r&lt;/web-app&gt;</pre>\r\r<p>3.外部DTD-公共DTD，DTD文档在网络上，一般框架提供：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;\r&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystem, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;\r&lt;web-app&gt;\r&lt;/web-app&gt;</pre>\r\r<h3>元素声明</h3>\r\r<p>定义元素语法：</p>\r\r<pre class="brush:xml;">\r&lt;!ELEMENT 元素名 元素描述&gt;</pre>\r\r<p>元素名：自定义；</p>\r\r<p>元素描述：包括符号和数据类型</p>\r\r<ul>\r	<li>常见符号：?, *, + ,(), |, ,；</li>\r	<li>常见类型：#PCDATA表示内容时文本，不能是子标签。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/3722737576.png" style="width: 800px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!ELEMENT web-app (servelt*, servlet-mapping*, welcome-file-list?)&gt;\r\rweb-app包括3个标签，且必须顺序出现：\r\rservlet子标签个数任意；\rservlet-mapping子标签个数任意；\rwelcome-file-list子标签最多只能出现一次。\r\r&lt;!ELEMENT servlet (servlet-name, description?, (servlet-class|jsp-file))&gt;\r\rservlet包括3个子标签，且必须顺序出现：\r\rservlet-name子标签必须有，且只能出现一次；\rdescription子标签最多只能出现一次；\rservlet-class和jsp-file二选一，且只能出现一次。\r\r&lt;!ELEMENT servlet-name (#PCDATA)&gt;\r\rservlet-name的标签体必须是文本。\r\r&lt;!ELEMENT welcome-file-list (welcome-file+)&gt;\r\rwelcome-file-list至少有一个子标签welcome-file。</pre>\r\r<h3>属性说明</h3>\r\r<p>属性的语法：</p>\r\r<pre class="brush:xml;">\r&lt;!ATTLIST 元素名\r	属性名 属性类型 约束\r	属性名 属性类型 约束\r	...\r&gt;</pre>\r\r<p>元素名：必须属性，即要约束的元素名；</p>\r\r<p>属性名：必须属性，自定义名称；</p>\r\r<p>属性类型：常见的有ID、CDATA、枚举等</p>\r\r<ul>\r	<li>ID：ID类型的属性用来标识元素的唯一性；</li>\r	<li>CDATA：文本类型；</li>\r	<li>枚举：(a|b|c|...)，多选一。</li>\r</ul>\r\r<p>约束：</p>\r\r<ul>\r	<li>#REQUIRED：说明属性是必须的；</li>\r	<li>#IMPLIED：说明属性是可选的。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!ATTLIST web-app\r	version CDATA #IMPLIED\r&gt;\r\r给web-app元素添加version属性，属性值必须是文本，且可选。</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 84),
(1173, 'DTD常见符号.png', 'DTD常见符号-png', 1540713054, 1540713054, 'a:5:{s:4:"name";s:19:"DTD常见符号.png";s:4:"path";s:35:"/usr/uploads/2018/10/3722737576.png";s:4:"size";i:519062;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1172, 0),
(1174, 'Schema约束简介', '1174', 1540713300, 1540713396, '<p>本文记录Java学习过程中遇到的Schema约束简介～</p>\r<!--more-->\r\r<p>Schema约束具有如下特性：</p>\r\r<ul>\r	<li>Schema是新的XML文档约束；</li>\r	<li>Schema要比DTD强大很多，是DTD的替代者；</li>\r	<li>Schema本身也是XML文档，但Schema文档的扩展名为xsd，而不是xml；</li>\r	<li>Schema功能更强大，数据类型更完善；</li>\r	<li>Schema支持名称空间。</li>\r</ul>\r\r<p>使用Schema约束的常见框架有：spring等。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 91);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1175, 'Schema约束语法', '1175', 1540738200, 1540742560, '<p>本文记录Java学习过程中遇到的Schema约束语法～</p>\r<!--more-->\r\r<p>XSDL（XML Schema定义语言）由元素、属性、命名空间和XML文档种的其他节点构成的。</p>\r\r<h3>XSD中的元素</h3>\r\r<p>XSD文档至少要包含：schema根元素和XML模式命名空间的定义、元素定义。</p>\r\r<p>1.Schema根元素</p>\r\r<p>语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&ldquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r	子元素等内容\r&lt;/xsd:schema&gt;</pre>\r\r<p>在XSD中必须定义一个且只能定义一个schema根元素。根元素中包括模式的约束、XML模式命名空间的定义，其他命名空间的定义、版本信息、语言信息和其他一些属性。</p>\r\r<p>2.元素</p>\r\r<p>语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:element name=&rdquo;user&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;</pre>\r\r<p>XSD中的元素是利用element标识符来声明的。其中name属性是元素的名字，type属性是元素值的类型，在这里可以是XML Schema中内置的数据类型或其他类型。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&ldquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r    &lt;xsd:element name=&rdquo;user&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>以上文档对应的有效XML文档如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&rdquo;1.0&rdquo;?&gt;\r&lt;user&gt;string&lt;/user&gt;</pre>\r\r<p>在元素的定义中还有2个属性：minOccurs和maxOccurs。其中minOccurs定义了该元素在父元素中出现的最少次数（默认为1，值为大于等于0的整数），maxOccurs定义了该元素在父元素中出现的最多次数（默认为1，值为大于等于0的整数）。在maxOccurs中可以把值设置为unbounded，表示对元素出现的最多次数没有限制。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=http://www.w3.org/2001/XMLSchema&gt;\r    &lt;xsd:element name=&rdquo;user&rdquo; type=&rdquo;xsd:string&rdquo; minOccurs=&rdquo;0&rdquo; maxOccurs=&rdquo;unbounded&rdquo; /&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>表示为元素user的类型为string，出现的次数最少为0（也就是可选），最多不限制。</p>\r\r<p>3.引用元素和替代</p>\r\r<p>语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r    &lt;xsd:element name=&rdquo;user&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r    &lt;xsd:element name=&rdquo;name&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:sequence&gt;\r                &lt;xsd:element ref=&rdquo;user&rdquo; /&gt;\r            &lt;/xsd:sequence&gt;\r        &lt;/xsd:complexType&gt;\r    &lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>引用是利用element标记符的ref属性实现的。主要适用于避免在文档中多次定义同一个元素，应当将经常使用的元素定义为根元素的子元素，以便在文档的任何地方引用它。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r    &lt;xsd:element name=&rdquo;yonghu&rdquo; type=&rdquo;xsd:string&rdquo; substitutionGroup=&rdquo;user&rdquo; /&gt;\r    &lt;xsd:element name=&rdquo;user&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r    &lt;xsd:element name=&rdquo;name&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:sequence&gt;\r                &lt;xsd:element ref=&rdquo;user&rdquo; /&gt;\r            &lt;/xsd:sequence&gt;\r        &lt;/xsd:complexType&gt;\r    &lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>以上文档对应的有效XML文档如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&rdquo;1.0&rdquo;?&gt;\r&lt;name&gt;\r    &lt;user&gt;string&lt;/user&gt;\r&lt;/name&gt;</pre>\r\r<p>或者：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&rdquo;1.0&rdquo;?&gt;\r&lt;name&gt;\r    &lt;yonghu&gt;string&lt;/yonghu&gt;\r&lt;/name&gt;</pre>\r\r<p>主要是利用element标识符中的属性substitutionGroup实现的别名。</p>\r\r<p>4.设置默认值和固定值</p>\r\r<p>语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:element name=&rdquo;city&rdquo; type=&rdquo;xsd:string&rdquo; default=&rdquo;xian&rdquo; /&gt;\r&lt;xsd:element name=&rdquo;country&rdquo; type=&rdquo;xsd:string&rdquo; fixed=&rdquo;china&rdquo; /&gt;</pre>\r\r<p>通过default属性的设置，可以在XML文档中没有对city元素定义时赋予默认值。而使用fixed属性，可以给元素country设定一个固定的值china，并且不允许改变！</p>\r\r<p>5.利用组合器控制结构</p>\r\r<p>sequence组合器，定义了一列元素必须按照模式中指定的顺序显示（如果是可选的，也可以不显示）。语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r    &lt;xsd:element name=&rdquo;name&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:sequence&gt;\r                &lt;xsd:element name=&rdquo;first&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;middle&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;last&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r           &lt;/xsd:sequence&gt;\r        &lt;/xsd:complexType&gt;\r    &lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>all组合器，允许所定义的元素可以按照任意顺序显示，all元素的子元素在默认情况下是必须的，而且每次最多显示一次。语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r    &lt;xsd:element name=&rdquo;name&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:all minOccurs=&rdquo;0&rdquo;&gt;\r                &lt;xsd:element name=&rdquo;first&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;middle&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;last&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r            &lt;/xsd:all&gt;\r        &lt;/xsd:complexType&gt;\r    &lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>choice组合器，允许指定多组声明中的一个，用于互斥情况。语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r    &lt;xsd:element name=&rdquo;name&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:choice&gt;\r                &lt;xsd:element name=&rdquo;first&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;middle&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;last&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r            &lt;/xsd:choice&gt;\r        &lt;/xsd:complexType&gt;\r    &lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<h3>定义属性</h3>\r\r<p>在XML Schema文档中可以按照定义元素的方法定义属性，但受限制的程度较高。它们只能是简单类型，只能包含文本，且没有子属性。可以应用在attribute元素定义中的属性如下：</p>\r\r<ul>\r	<li>default：初始默认值；</li>\r	<li>fixed：不能修改和覆盖的属性固定值；</li>\r	<li>name：属性的名称；</li>\r	<li>ref：对前一个属性定义的引用；</li>\r	<li>type：该属性的XSD类型或者简单类型；</li>\r	<li>use：如何使用属性；</li>\r	<li>form：确定attributeFormDefault的本地值；</li>\r	<li>id；模式文档中属性唯一的ID。</li>\r</ul>\r\r<p>default、fixed、name、ref和type属性与在element标记中定义的对应属性相同，但type只能是简单类型。Use属性的值可以是：optional（属性不是必须的，此为默认属性）、prohibited或者required（属性是强制的）。</p>\r\r<h3>创建属性</h3>\r\r<p>语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:attribute name=&rdquo;age&rdquo; type=&rdquo;xsd:integer&rdquo; /&gt;</pre>\r\r<p>该语句定义了一个名为age的属性，它的值必须是一个整数。把它添加到模式中时，它必须时schema元素、complexType元素或者attributeGroup元素的子元素。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r    &lt;xsd:element name=&rdquo;name&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:sequence&gt;\r                &lt;xsd:element name=&rdquo;first&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r            &lt;/xsd:sequence&gt;\r            &lt;xsd:attribute name=&rdquo;age&rdquo; type=&rdquo;xsd:integer&rdquo; use=&rdquo;optional&rdquo; /&gt;\r        &lt;/xsd:complexType&gt;\r    &lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>以上代码对应有效的XML文档如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&rdquo;1.0&rdquo;?&gt;\r&lt;name age=&rdquo;27&rdquo;&gt;\r    &lt;first&gt;string&lt;/first&gt;\r&lt;/name&gt;</pre>\r\r<p>如上所示，要把属性附加在元素上，属性应该在complexType定义中的组合器之后定义或引用。</p>\r\r<h3>XML Schema数据类型</h3>\r\r<p>XML Schema提供了一组丰富的内置数据类型，用于定义元素中允许的类型，下面将介绍一些完全符合C#标准的通用类型。</p>\r\r<p>1.基本数据类型</p>\r\r<p>基本数据类型是在XML Schema中使用的每种数据类型的最基本构成块，可以根据这些类型构造自定义的类型。这些类型包括：</p>\r\r<ul>\r	<li>boolean：可以是1（true）或者0（false）；</li>\r	<li>dateTime：表示时间的部分可选，格式：CCYY-MM-DDThh:mm:ss，例如：2005-3-18T14:48:12；</li>\r	<li>decimal：表示任意精度的十进制数字；</li>\r	<li>string：字符数据；</li>\r	<li>int：表示从-2,147,483,648到2,147,483,648之间一个整数；</li>\r	<li>nonNegativeInteger：表示大于或者等于0的一个整数；</li>\r	<li>nonPositiveInteger：表示小于或者等于0的一个整数；</li>\r	<li>short：表示从-32768到32767之间的一个整数。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=http://www.w3.org/2001/XMLSchema&gt;\r	&lt;xsd:element name=&rdquo;ContactDetails&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:sequence&gt;\r                &lt;xsd:element ref=&rdquo;name&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;rate&rdquo; type=&rdquo;xsd:decimal&rdquo; /&gt;\r            &lt;/xsd:sequence&gt;\r            &lt;xsd:attribute name=&rdquo;lastUpdated&rdquo; type=&rdquo;xsd:dateTime&rdquo; /&gt;\r        &lt;/xsd:complexType&gt;\r	&lt;/xsd:element&gt;\r	&lt;xsd:element name=&rdquo;name&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:sequence&gt;\r                &lt;xsd:element name=&rdquo;first&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;middle&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;last&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r            &lt;/xsd:sequence&gt;\r            &lt;xsd:attribute name=&rdquo;local&rdquo; type=&rdquo;xsd:boolean&rdquo; /&gt;\r        &lt;/xsd:complexType&gt;\r	&lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>以上文档对应有效的XML文档如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&rdquo;1.0&rdquo;?&gt;\r&lt;ContactDetails lastUpdated=&rdquo; 2005-3-18T14:48:12&rdquo;&gt;\r	&lt;name local=&rdquo;true&rdquo;&gt;\r    	&lt;first&gt;santld&lt;/first&gt;\r       	&lt;middle/&gt;\r        &lt;last&gt;wang&lt;/last&gt;\r	&lt;/name&gt;\r	&lt;rate&gt;10.27&lt;/rate&gt;\r&lt;/ContactDetails&gt;</pre>\r\r<p>2.简单类型&nbsp;</p>\r\r<p>虽然从内置数据类型中得到了许多的功能，但是在许多情况下，只有数据类型来限制数据的值是远远不够的。这里在学习简单类型之前，先看看约束，常见的约束有：</p>\r\r<ul>\r	<li>enumeration：用空格分开的一组指定的数值，它把数据类型约束为指定的值；</li>\r	<li>fractionDigit：指定小数点后的最大位数；</li>\r	<li>length：长度单位；</li>\r	<li>minExclusive：下限值，所有的值都必须大于该值；</li>\r	<li>maxExclusive：上限值，所有的值都应该小于该值；</li>\r	<li>minLength：长度单位的最小个数；</li>\r	<li>maxLength：长度单位的最大数；</li>\r	<li>minInclusive：最小值，所有的值都应该大于或者等于该值；</li>\r	<li>maxInclusive：最大值，所有的值都应该小于或者等于该值；</li>\r	<li>pattern：数据类型的值必须匹配的指定模式，pattern值必须是一个正则表达式；</li>\r	<li>totalDigits：指定小数最大位数的值；</li>\r	<li>whiteSpace：其值为：preserve（值中的空格不能改变），replace（所有的制表符、换行符和回车符都用空格代替），collapse（执行replace，删除相邻的、结尾处和开头处的空格）。</li>\r</ul>\r\r<p>要应用上述的约束，就要利用元素restriction。这个元素中有2个属性：id属性是模式文档中restriction元素的唯一标识符，base属性设置为一个内置的XSD数据类型或者现有的简单类型定义，他是一种被限制的类型。</p>\r\r<p>示例代码：&nbsp;</p>\r\r<pre class="brush:xml;">\r&lt;xsd:restriction base=&rdquo;xsd:string&rdquo;&gt;\r	&lt;xsd:minLength value=&rdquo;4&rdquo; /&gt;\r    &lt;xsd:maxLength value=&rdquo;10&rdquo; /&gt;\r&lt;/xsd:restriction&gt;\r\r如上，将字符串最小长度限定为4个字符，将最大长度限定为10个字符。\r\r&lt;xsd:restriction base=&rdquo;xsd:int&rdquo;&gt;\r	&lt;xsd:minInclusive value=&rdquo;1&rdquo; /&gt;\r	&lt;xsd:maxInclusive value=&rdquo;100&rdquo; /&gt;\r&lt;/xsd:restriction&gt;\r\r如上，将一个整数的取值范围设置为1到100之间。\r\r&lt;xsd:restriction base=&rdquo;xsd:string&rdquo;&gt;\r	&lt;xsd:enumeration value=&rdquo;FistValue&rdquo; /&gt;\r	&lt;xsd:enumeration value=&rdquo;SecondValue&rdquo; /&gt;\r	&lt;xsd:enumeration value=&rdquo;ThirdValue&rdquo; /&gt;\r&lt;/xsd:restriction&gt;\r\r如上，字符串只能为枚举出的三种值。</pre>\r\r<p>简单类型是对一个节点的可能值进一步限制的自定义数据类型。创建简单类型需要利用simpleType元素，其定义语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;simpleType id=&rdquo;ID&rdquo; name=&rdquo;NCName&rdquo; final=&rdquo;(#all|(list|union|restriction))&rdquo; /&gt;</pre>\r\r<ul>\r	<li>id属性应唯一的标明文档内的simpleType元素；</li>\r	<li>name不能使用冒号字符；</li>\r	<li>simpleType不能包含元素，也不能有属性，根据在simpleType中定义的规则，它基本上是一个值，或者是一个值的集合。</li>\r</ul>\r\r<p>示例代码：&nbsp;</p>\r\r<pre class="brush:xml;">\r&lt;xsd:simpleType name=&rdquo;personsName&rdquo;&gt;\r	&lt;xsd:restriction base=&rdquo;xsd:string&rdquo;&gt;\r        &lt;xsd:minLength value=&rdquo;4&rdquo; /&gt;\r        &lt;xsd:maxLength value=&rdquo;8&rdquo; /&gt;\r	&lt;/xsd:restriction&gt;\r&lt;/xsd:simpleType&gt;\r&lt;xsd:element name=&rdquo;first&rdquo; type=&rdquo;personsName&rdquo; /&gt;</pre>\r\r<p>以上文档对应有效的XML文档如下：</p>\r\r<pre class="brush:xml;">\r&lt;first&gt;Santld&lt;/first&gt;</pre>\r\r<p>以上文档对应无效的XML文档如下：</p>\r\r<pre class="brush:xml;">\r&lt;first&gt;SS&lt;/first&gt;\r&lt;first&gt;Santld wang&lt;/first&gt; </pre>\r\r<p>3.复杂类型&nbsp;</p>\r\r<p>复杂类型的定义必须使用complexType元素，在这里可以包含属性和元素。在复杂类型的使用中，主要是complexType和simpleType配合使用。语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:complexType name=&rdquo;name&rdquo; /&gt;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:element name=&quot;name&quot; type=&quot;FullName&quot; /&gt;\r&lt;xsd:complexType name=&quot;FullName&quot;&gt;\r	&lt;xsd:sequence&gt;\r		&lt;xsd:element name=&quot;first&quot; type=&quot;PersonsFirstname&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; default=&quot;John&quot; /&gt;\r		&lt;xsd:element name=&quot;middle&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; nillable=&quot;true&quot; /&gt;\r		&lt;xsd:element name=&quot;last&quot; type=&quot;xsd:string&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; default=&quot;Doe&quot; /&gt;\r	&lt;/xsd:sequence&gt;\r	&lt;xsd:attribute name=&quot;title&quot; type=&quot;PersonsTitle&quot; default=&quot;Mr.&quot; /&gt;\r&lt;/xsd:complexType&gt;\r\r&lt;xsd:simpleType name=&quot;PersonsFirstname&quot;&gt;\r	&lt;xsd:restriction base=&quot;xsd:string&quot;&gt;\r		&lt;xsd:minLength value=&quot;4&quot; /&gt;\r		&lt;xsd:maxLength value=&quot;10&quot; /&gt;\r	&lt;/xsd:restriction&gt;\r&lt;/xsd:simpleType&gt;\r\r&lt;xsd:simpleType name=&quot;PersonsTitle&quot;&gt;\r	&lt;xsd:restriction base=&quot;xsd:string&quot;&gt;\r		&lt;xsd:enumeration value=&quot;Mr.&quot; /&gt;\r		&lt;xsd:enumeration value=&quot;Mrs.&quot; /&gt;\r		&lt;xsd:enumeration value=&quot;Miss.&quot; /&gt;\r	&lt;/xsd:restriction&gt;\r&lt;/xsd:simpleType&gt;</pre>\r\r<p>如上就实现了一个复杂类型，该例子实现了一个复杂类型FullName，其中包含了两个简单类型PersonsFirstname和PersonsTitle。</p>\r\r<h3>分组和属性</h3>\r\r<p>在为定义XML文档而创建的一些更为复杂的定义中，会有一些元素集、属性集的组合，这是我们就使用了分组的概念。分组定义中使用的是group元素。</p>\r\r<p>定义语法如下：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:group name=&rdquo;CityChoice&rdquo;&gt;\r	&lt;xsd:choice&gt;\r        &lt;xsd:element name=&rdquo; Beijing &rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r        &lt;xsd:element name=&rdquo; Shanghai &rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r        &lt;xsd:element name=&rdquo;Xian&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r	&lt;/xsd:choice&gt;\r&lt;/xsd:group&gt;\r\r&lt;xsd:element name=&rdquo;City&rdquo;&gt;\r	&lt;xsd&rdquo;group ref=&rdquo;CityChoice&rdquo; minOccurs=&rdquo;1&rdquo; maxOccurs=&rdquo;1&rdquo; /&gt;\r&lt;/xsd:element&gt;</pre>\r\r<p>对属性的分组，应该使用attributeGroup元素。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:attributeGroup name=&rdquo;contactAttribs&rdquo;&gt;\r	&lt;xsd:attribute name=&rdquo;city&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r	&lt;xsd:attribute name=&rdquo;country&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r	&lt;xsd:attribute name=&rdquo;age&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r&lt;/xsd:attributeGroup&gt;\r\r&lt;xsd:element name=&rdquo;contact&rdquo;&gt;\r	&lt;xsd:complexType&gt;\r        &lt;xsd:attributeGroup ref=&rdquo;contactAttribs&rdquo; /&gt;\r	&lt;/xsd:complexType&gt;\r&lt;/xsd:element&gt;</pre>\r\r<p>以上文档对应有效的XML文档如下：</p>\r\r<pre class="brush:xml;">\r&lt;contact city=&rdquo; Beijing &rdquo; country=&rdquo; China &rdquo; age=&rdquo;25&rdquo; /&gt;</pre>\r\r<h3>内容模型</h3>\r\r<p>内容模型可以对在XML文档内使用的元素、属性和类型进行限制，确定用户可以在XML实例的哪些等级添加自己的元素和属性。</p>\r\r<ul>\r	<li>any：当在XML中声明元素时any是默认的内容模型，该模型可以包含文本、元素和空格。如果允许添加元素的内容，且无需屋里修改模式文件，就可以使用该模型。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:xchema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r	&lt;xsd:element name=&rdquo;name&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:sequence&gt;\r                &lt;xsd:element name=&rdquo;first&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;middle&rdquo; type=&rdquo;OtherNames&rdquo; /&gt;\r                &lt;xsd:element name=&rdquo;last&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r            &lt;/xsd:sequence&gt;\r        &lt;/xsd:complexType&gt;\r	&lt;/xsd:element&gt;\r	&lt;xsd:complexType name=&rdquo;OtherNames&rdquo;&gt;\r        &lt;xsd:sequence&gt;\r            &lt;xsd:any namespace=&rdquo;##any&rdquo; processContents=&rdquo;lax&rdquo; minOccurs=&rdquo;0&rdquo; maxOccurs=&rdquo;unbounded&rdquo; /&gt;\r        &lt;/xsd:sequence&gt;\r	&lt;/xsd:complexType&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>例子中的xsd:any元素说明该类型允许添加内容。namespace属性允许的值为：</p>\r\r<ul>\r	<li>##any（元素可以来自任何命名空间）</li>\r	<li>##other（元素可以来自除了该元素的父元素所在的目标命名空间之外的命名空间）</li>\r	<li>##local（元素不受命名空间的限制）</li>\r	<li>##targetNamespace（元素来自父元素的目标命名空间）</li>\r</ul>\r\r<p>processContents属性说明对这里所创建的元素进行验证时所执行的操作，取值有如下3种：</p>\r\r<ul>\r	<li>strict：标明XML处理器必须获得和那些命名空间相关联的模式，并验证元素和属性；</li>\r	<li>lax：与strict相似，只是如果处理器找不到模式文档，也不会出现错误；</li>\r	<li>skip：不利用模式文档验证XML文档。</li>\r</ul>\r\r<p>上述模式的一个有效实例如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&rdquo;1.0&rdquo;?&gt;\r&lt;name&gt;\r	&lt;first&gt;santld&lt;/first&gt;\r	&lt;middle&gt;\r        &lt;nameInChina&gt;San&lt;/nameInChina&gt;\r	&lt;/middle&gt;\r	&lt;last&gt;wang&lt;/last&gt;\r&lt;/name&gt;</pre>\r\r<ul>\r	<li>empty：禁止把文本或者元素作为一个声明为空的元素的子元素，如果要保证该元素不包括子元素、文本甚至空格，就可以使用它。在XSD中时利用xsd:anyType类型来限定它的，这样就意味元素只能包含属性。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r	&lt;xsd:element name=&rdquo;contact&rdquo;&gt;\r        &lt;xsd:complexType&gt;\r            &lt;xsd:complexContent&gt;\r                &lt;xsd:restriction base=&rdquo;xsd:anyType&rdquo;&gt;\r                    &lt;xsd:attribute name=&rdquo;age&rdquo; type=&rdquo;xsd:integer&rdquo; /&gt;\r                &lt;/xsd:restriction&gt;\r            &lt;/xsd:complexContent&gt;\r        &lt;/xsd:complexType&gt;\r	&lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>以上就是一个复杂类型，只允许有一个age属性。在例子里complexContent元素可以表示complexType的内容要进行扩充或者限制，在这里，我们对其内容进行限制，因此使用了restriction元素，如果扩展则使用exension元素。</p>\r\r<ul>\r	<li>element：这个前面已经了解过了，不再赘述。</li>\r	<li>mixed：包含文本、内容和属性。在complexType元素上把mixed属性的值设为true，就一个声明一个mixed内容模型了。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&rdquo;http://www.w3.org/2001/XMLSchema&rdquo;&gt;\r	&lt;xsd:element name=&rdquo;contact&rdquo;&gt;\r        &lt;xsd:complexType mixed=&rdquo;true&rdquo;&gt;\r            &lt;xsd:sequence&gt;\r                &lt;xsd:element name=&rdquo;first&rdquo; type=&rdquo;xsd:string&rdquo; /&gt;\r            &lt;/xsd:sequence&gt;\r        &lt;xsd:complexType&gt;\r	&lt;/xsd:element&gt;\r&lt;/xsd:schema&gt;</pre>\r\r<p>上述模式的一个有效实例如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&rdquo;1.0&rdquo;?&gt;\r&lt;contact&gt;My first name is&lt;first&gt;Santld&lt;/first&gt;.&lt;/contact&gt;</pre>\r\r<p>在例子中contact元素就包含了文本和元素first。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 152),
(1176, 'Schema命名空间', '1176', 1540827900, 1540828504, '<p>本文记录Java学习过程中遇到的Schema命名空间～</p>\r<!--more-->\r\r<p>如果一个XML文档中使用多个Schema文件，而这些Schema文件中定义了相同名称的元素时就会出现名字冲突。这就想一个Java文件中使用了import java.util.*和import java.sql.*时，在使用Data类时，那么就不明确Date类时，那么就不明确Date是哪个包下的Date了。</p>\r\r<p>总之名称空间就是用来处理元素和属性的名称冲突问题，与Java中的包是同一用途。如果每个元素和属性都有自己的名称空间，那么就不会出现名字冲突问题，就像是每个类都有自己所在的包一样，那么类名就不会出现冲突。</p>\r\r<h3>约束文档和XML关系</h3>\r\r<p>当W3C提出Schema约束规范时，就提供&ldquo;官方约束文档&rdquo;。我们通过官方文档，必须&ldquo;自定义Schema约束文档&rdquo;，开发中&ldquo;自定义文档&rdquo;由框架编写者提供。我们提供&ldquo;自定义文档&rdquo;限定，编写出自己的XML文档。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/1970933932.png" style="width: 800px; height: 157px;" /></p>\r\r<h3>声明命名空间</h3>\r\r<p>默认命名空间：</p>\r\r<pre class="brush:xml;">\r&lt;xxx xmlns=&quot;&quot;&gt;，使用&lt;标签&gt;</pre>\r\r<p>显式命名空间：</p>\r\r<pre class="brush:xml;">\r&lt;xxx xmlns:别名=&quot;&quot;&gt;，使用&lt;别名:标签&gt;</pre>\r\r<p>示例代码（web-app_2_5.xsd）：</p>\r\r<pre class="brush:xml;">\r&lt;xsd:schema xmlns:xsd=&quot;http://www.w3c.org/2001/XMLSchema&quot; ...&gt;\r\r表示自定义Schema约束文档引用官方文档作为显式命名空间。如果要使用官方提供的元素或属性，必须使用xsd前缀（自定义，此处表示官方文档，所以使用xsd）\r&lt;xsd:schema&gt;标签就由官方文档提供，默认命名空间直接使用。</pre>\r\r<p>示例代码（web.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;web-app xmlns=http://www.example.org/web-app_2_5 ...&gt;\r\r表示XML文档引用&ldquo;自定义约束文档&rdquo;作为默认命名空间，因为使用默认命名空间，所以&lt;web-app&gt;可以直接使用。</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 105),
(1177, '约束文档与XML的关系.png', '约束文档与XML的关系-png', 1540827995, 1540827995, 'a:5:{s:4:"name";s:31:"约束文档与XML的关系.png";s:4:"path";s:35:"/usr/uploads/2018/10/1970933932.png";s:4:"size";i:116666;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1176, 0),
(1178, 'XML解析', '1178', 1540829235, 1540829235, '<p>本文记录Java学习过程中遇到的XML解析概述～</p>\r\r<!--more-->\r\r<p>当将数据存储在XML后，我们就希望通过程序获得XML的内容。如果我们使用Java基础的IO知识，也是可以完成的，不过需要非常繁琐的操作，且开发中会遇到各种问题（比如，只读和读写等）。所以人们为不同问题提供不同的解析方式，并提交对应的解析器，方便开发人员操作XML。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97),
(1179, 'XML解析方式和解析器', '1179', 1540913760, 1540913851, '<p>本文记录Java学习过程中遇到的XML解析方式和解析器～</p>\r<!--more-->\r\r<p>开发中比较常见的解析方式有三种，如下：</p>\r\r<p>1.DOM：要求解析器把整个XML文档装载到内存，并解析成一个Document对象。</p>\r\r<ul>\r	<li>优点：元素与元素之间保留结构关系，故可以进行增删改查操作；</li>\r	<li>缺点：XML文档过大，可能出现内存溢出情况。</li>\r</ul>\r\r<p>2.SAX：是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。并以事件驱动的方式进行具体解析，每执行一行，都将触发对应的事件。</p>\r\r<ul>\r	<li>优点：处理速度快，可以处理大文件；</li>\r	<li>缺点：只能读，将逐行释放资源。</li>\r</ul>\r\r<p>3.PULL：Android内置的XML解析方式，类似SAX。</p>\r\r<p>解析器：就是根据不同的解析方式提供的具体实现。有的解析器操作过于频繁，为了方便开发人员，就提供了易于操作的解析开发包。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/1634670670.png" style="width: 800px; height: 124px;" /></p>\r\r<p>常见的解析开发包有：</p>\r\r<ul>\r	<li>JAXP：SUN公司提供的支持DOM和SAX的开发包；</li>\r	<li>JDom：dom4j的兄弟；</li>\r	<li>jsoup：一种处理HTML特定解析开发包；</li>\r	<li>dom4j：比较常用的解析开发包，hibernate底层采用的就是它。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(1180, '解析器.png', '解析器-png', 1540913835, 1540913835, 'a:5:{s:4:"name";s:13:"解析器.png";s:4:"path";s:35:"/usr/uploads/2018/10/1634670670.png";s:4:"size";i:125843;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1179, 0),
(1181, 'XML.png', 'XML-png', 1540914228, 1540914228, 'a:5:{s:4:"name";s:7:"XML.png";s:4:"path";s:35:"/usr/uploads/2018/10/1978138379.png";s:4:"size";i:585167;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1184, 0),
(1182, 'DOM01.png', 'DOM01-png', 1540914238, 1540914238, 'a:5:{s:4:"name";s:9:"DOM01.png";s:4:"path";s:35:"/usr/uploads/2018/10/1003993221.png";s:4:"size";i:637475;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1184, 0),
(1183, 'DOM02.png', 'DOM02-png', 1540914247, 1540914247, 'a:5:{s:4:"name";s:9:"DOM02.png";s:4:"path";s:35:"/usr/uploads/2018/10/1184308316.png";s:4:"size";i:536064;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1184, 0),
(1184, 'DOM解析原理和结构模型', '1184', 1540914597, 1540914597, '<p>本文记录Java学习过程中遇到的DOM解析原理和结构模型～</p>\r<!--more-->\r\r<p>XML DOM和HTML DOM类似，XML DOM将整个XML文档加载到内存，生成一个DOM树，并获得一个Document对象，通过Document对象就可以对DOM进行操作。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/1978138379.png" style="width: 800px; height: 282px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/1003993221.png" style="width: 800px; height: 498px;" /></p>\r\r<p>DOM中的核心概念就是节点，在XML文档中的元素、属性、文本等，在DOM中都是节点。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/10/1184308316.png" style="width: 800px; height: 444px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(1185, 'dom4j的API的使用', '1185', 1540916100, 1540916192, '<p>本文记录Java学习过程中遇到的dom4j的API的使用～</p>\r\r<!--more-->\r\r<p>dom4j必须使用核心类SaxReader加载XML文档获得Document，通过Document对象获得文档的根元素，然后就可以操作了。</p>\r\r<p>常用的API有：</p>\r\r<p>1.SaxReader对象</p>\r\r<ul>\r	<li>read(...)加载执行XML文档</li>\r</ul>\r\r<p>2.Document对象</p>\r\r<ul>\r	<li>getRootElement()获得跟元素</li>\r</ul>\r\r<p>3.Element对象</p>\r\r<ul>\r	<li>elements(...)获得指定名称的所有子元素，可以不指定名称</li>\r	<li>element(...)获得指定名称的第一个子元素，可以不指定名称</li>\r	<li>getName()获得当前元素的元素名</li>\r	<li>attributeValue(...)获得指定属性名的属性值</li>\r	<li>elementText(...)获得指定名称子元素的文本值</li>\r	<li>getText()获得当前元素的文本内容</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void DOM4JDemo() throws Exception{\r	//1.获得document\r	SAXReader saxReader = new SAXReader();\r	Document document = saxReader.read(new File(&quot;src/web.xml&quot;));\r\r	//2.获取跟元素\r	Element rootElement = document.getRootElement();\r\r	//3.打印version属性值\r	String version = rootElement.attributeValue(&quot;version&quot;);\r	System.out.println(version);\r\r	//4.获得所有子元素\r	List&lt;Element&gt; allChildElement = rootElement.elements();\r\r	//5.遍历所有子元素\r	for(Element childElement:allChildElement){\r		//6.打印元素名\r		String childElementName = childElement.getName();\r		System.out.println(childElementName);\r\r		//7.处理servlet，并获得子标签的内容\r		if(&quot;servlet&quot;.equals(childElementName)){\r			//8.获得元素对象，然后获得文本\r			Element servletNameElement = childElement.element(&quot;servlet-name&quot;);\r			String servletName = servletNameElement.getText();\r			System.out.println(servletName);\r\r			//9.获得元素文本值\r			String servletClass = childElement.elementText(&quot;servlet-class&quot;);\r			System.out.println(servletClass);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 132),
(1186, 'HTTP协议简介', '1186', 1541086192, 1541086192, '<p>本文记录TCP/IP学习过程中遇到的HTTP协议简介～</p>\r\r<!--more-->\r\r<p>HTTP协议：超文本传输协议（HTTP，Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布合接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 80),
(1187, 'HTTP协议的作用和特点', '1187', 1541086440, 1541087000, '<p>本文记录TCP/IP学习过程中遇到的HTTP协议的作用和特点～</p>\r<!--more-->\r\r<p><strong>HTTP协议的作用</strong></p>\r\r<p>HTTP协议是学习Java Web开发的基石，不深入了解HTTP协议，就不能说掌握了Web开发，更无法管理和维护一些复杂的Web站点。</p>\r\r<p><strong>HTTP协议的特点</strong></p>\r\r<ul>\r	<li>基于请求/响应模型的协议，请求和响应必须成对（先有请求后有响应）；</li>\r	<li>HTTP协议的默认端口为80，例如，http://www.oliver.ren:80/。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 92),
(1188, 'HTTP协议的版本和组成', '1188', 1541086740, 1541088955, '<p>本文记录TCP/IP学习过程中遇到的HTTP协议的版本和组成～</p>\r<!--more-->\r\r<p><strong>HTTP协议的版本</strong></p>\r\r<p>HTTP/1.0，发送请求，创建一次连接，获得一个Web资源，连接断开；<br />\rHTTP/1.1，发送请求，创建一次连接，获得多个Web资源，连接断开。</p>\r\r<p><strong>HTTP协议的组成</strong></p>\r\r<p>HTTP请求包括：请求行、请求头、请求体；</p>\r\r<ul>\r	<li>请求行</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rPOST /index.html HTTP/1.1</pre>\r\r<p>请求行必须在HTTP请求格式的第一行。</p>\r\r<p>请求行格式：</p>\r\r<pre class="brush:java;">\r请求方式 资源路径 协议/版本</pre>\r\r<p>请求方式（一共有7种，常用的有GET和POST）：</p>\r\r<ol>\r	<li>GET请求：将请求参数追加在URL后面，不安全。例如，form.html?username=oliver&amp;password=123456，并且URL长度限制GET请求方式的数据大小。GET请求没有请求体；</li>\r	<li>POST请求：请求参数显示请求体处，较安全，并且POST请求数据大小没有限制。只有表单设置为method=&quot;post&quot;才是POST请求，其他的都是GET请求。</li>\r</ol>\r\r<ul>\r	<li>请求头</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rHost：www.oliver.ren:80</pre>\r\r<p>请求头从第二行开始，到第一个空行结束。即请求头和请求体之间存在一个空行。请求头通常以键值对（key:value）方式传递数据：key为规范规定的固定值；value为key对应的取值，通常是一个值，可能是一组。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3840848524.png" style="width: 800px; height: 590px;" /></p>\r\r<ul>\r	<li>请求体</li>\r</ul>\r\r<p>通常情况下，只有POST请求方式才会使用到请求体，请求体中都是用户表单提交的数据，每一项数据都使用键值对（key=value），多组值使用&amp;链接。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rusername=oliver&amp;password=123456</pre>\r\r<p>HTTP响应包括：响应行、响应头、响应体。</p>\r\r<ul>\r	<li>相应行</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rHTTP/1.1 200 OK</pre>\r\r<p>格式为：</p>\r\r<pre class="brush:java;">\r协议/版本 状态码 状态码描述</pre>\r\r<p>状态码为服务器与浏览器用于确定状态的固定数字号码，常见的有：200-请求成功，302-请求重定向，304-请求资源没有改变，访问本地缓存，404-请求资源不存在，通常是用户路径编写错误，也可能是服务器资源已删除，500-服务器内部错误，通常是程序抛异常。</p>\r\r<ul>\r	<li>响应头</li>\r</ul>\r\r<p>响应头也是用的键值对，服务器通过响应头来控制浏览器的行为，不同的头浏览器操作不同。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/1367293042.png" style="width: 800px; height: 304px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/734434964.png" style="width: 800px; height: 109px;" /></p>\r\r<ul>\r	<li>响应体</li>\r</ul>\r\r<p>就是服务器发送给浏览器的正文。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 100),
(1189, '请求头.png', '请求头-png', 1541088875, 1541088875, 'a:5:{s:4:"name";s:13:"请求头.png";s:4:"path";s:35:"/usr/uploads/2018/11/3840848524.png";s:4:"size";i:516649;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1188, 0),
(1190, '常见请求头01.png', '常见请求头01-png', 1541088917, 1541088917, 'a:5:{s:4:"name";s:21:"常见请求头01.png";s:4:"path";s:35:"/usr/uploads/2018/11/1367293042.png";s:4:"size";i:203768;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1188, 0),
(1191, '常见响应头02.png', '常见响应头02-png', 1541088920, 1541088920, 'a:5:{s:4:"name";s:21:"常见响应头02.png";s:4:"path";s:34:"/usr/uploads/2018/11/734434964.png";s:4:"size";i:101261;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1188, 0),
(1192, 'Web通信.png', 'Web通信-png', 1541089788, 1541089788, 'a:5:{s:4:"name";s:13:"Web通信.png";s:4:"path";s:35:"/usr/uploads/2018/11/3354245883.png";s:4:"size";i:154207;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1193, 0),
(1193, 'Web通信', '1193', 1541089800, 1541089844, '<p>本文记录Java学习过程中遇到的Web通信～</p>\r\r<!--more-->\r\r<p>Web采用B/S通信模式，通过超文本传输协议（HTTP，HyperText Transport Protocol）进行通信。通过浏览器地址栏编写URL，向服务器发送一个请求，服务器端根据请求进行响应的处理，处理完成之后，会向浏览器作出一个响应，及将服务器资源发送给浏览器。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3354245883.png" style="width: 800px; height: 160px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 89),
(1194, '常见软件架构', '1194', 1541255820, 1541256221, '<p>本文记录Java学习过程中遇到的常见软件架构～</p>\r\r<!--more-->\r\r<p>C/S架构：Client/Server，客户端/服务端，要求客户端电脑安装一个客户端程序。</p>\r\r<p>常见应用：QQ，迅雷，360，钉钉等；</p>\r\r<p>优点：</p>\r\r<ul>\r	<li>用户体验好，效果炫；</li>\r	<li>对信息安全的控制较强；</li>\r	<li>应用服务器运行数据负荷较轻，部分计算功能在客户端完成。</li>\r</ul>\r\r<p>缺点：</p>\r\r<ul>\r	<li>占用用户硬盘空间；</li>\r	<li>维护麻烦；</li>\r	<li>安装使用依赖其他条件。</li>\r</ul>\r\r<p>B/S架构：Browser/Server，浏览器/服务器。通过浏览器与服务器交互，不需要安装其他程序。</p>\r\r<p>常见应用：网银系统，淘宝，京东，12306等；</p>\r\r<p>优点：</p>\r\r<ul>\r	<li>维护和升级简单，无缝升级；</li>\r	<li>不用必须安装程序，操作系统本身就内置了浏览器；</li>\r	<li>可以通过使用Ajax继续改善用户体验。</li>\r</ul>\r\r<p>缺点：</p>\r\r<ul>\r	<li>动画效果受浏览器限制；</li>\r	<li>对信息安全控制较差，例如：网银就需要使用U盾，在浏览器端加密；</li>\r	<li>应用服务器运行数据负荷较重，大部分计算都在服务器端，增加服务器压力。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 80),
(1195, 'Web资源种类', '1195', 1541256200, 1541256200, '<p>本文记录Java学习过程中遇到的Web资源种类～</p>\r<!--more-->\r\r<p>常见的Web资源有两种，即动态资源和静态资源。</p>\r\r<ul>\r	<li>静态资源：指Web页面中供人们浏览的数据始终是不变的，比如：HTML、CSS、JS、图片和多媒体文件等；；</li>\r	<li>动态资源：指Web页面中供人们浏览的数据是由程序产生的，不通时间点访问Web页面看到的内容各不相同。比如：JSP/Servlet、ASP和PHP。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 88),
(1196, 'Web服务器.png', 'Web服务器-png', 1541256829, 1541256829, 'a:5:{s:4:"name";s:16:"Web服务器.png";s:4:"path";s:33:"/usr/uploads/2018/11/72151740.png";s:4:"size";i:283638;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1197, 0),
(1197, 'Web服务器', '1197', 1541256858, 1541256858, '<p>本文记录Java学习过程中遇到的Web服务器～</p>\r<!--more-->\r\r<p>JCP（Java Community Process）是Java技术规范制定与更新的国际组织，主要维护规范包括：J2ME、J2SE、J2EE和XML等。</p>\r\r<p>J2EE企业级开发Java标准规范包括：Servlet、jsp、JDBC、XML、JTA和JavaMail等，在Java中规范就是接口，J2EE又称为JavaEE。</p>\r\r<p>Web服务器对JavaEE规范部分或全部支持，也就是Web服务器实现部分或全部接口。</p>\r\r<p>常见的Web服务器有：</p>\r\r<ol>\r	<li>Tomcat：Apache组织提供的一个免费的小型Web服务器软件，支持Servlet和JSP规范；</li>\r	<li>WebLogic：BEA公司提供的一个收费的大型的Web服务器软件，后被Oracle收购，支持J2EE的所有规范；</li>\r	<li>WebSphere：IBM公司提供的一个收费的大型的Web服务器软件，支持J2EE的所有规范；</li>\r	<li>JBoss：是一个基于J2EE的开放源代码的应用服务器，它是一个管理EJB的容器和服务器。JBoss核心服务不包括支持Servlet/JSP的Web容器，一般与Tomcat或Jetty绑定使用。</li>\r</ol>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/72151740.png" style="width: 800px; height: 343px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 73),
(1198, 'URL简介', '1198', 1541257380, 1541257457, '<p>本文记录Java学习过程中遇到的URL简介～</p>\r\r<!--more-->\r\r<p>URL（Uniform Resource Locator）：同一资源定位符是对互联网上资源位置的一种表示，互联网上的每个文件都有一个唯一的URL。</p>\r\r<p>URL的完整格式为：</p>\r\r<pre class="brush:java;">\r协议://用户名:密码@域名:端口号/资源位置？参数=值#标志</pre>\r\r<ul>\r	<li>协议：http、https或ftp等；</li>\r	<li>用户名和密码：常用于ftp地址，路径中直接写账号密码（一般情况下不用）；</li>\r	<li>域名：可以是域名或者IP地址，两种都可以访问Web资源；</li>\r	<li>端口号：程序必须使用端口号，才可以让另一个计算机访问。例如：http的默认端口号为80；</li>\r	<li>资源位置：用于描述Web资源在服务器上的位置；</li>\r	<li>参数和值：浏览器和服务器交互传递的数据；</li>\r	<li>标志：锚点，用于指定页面的某一个位置。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//常见路径\rhttp://www.oliver.ren:80/index.php\r\r//包含请求\rhttp://www.oliver.ren/admin/manage-posts.php?page=1\r\r//使用锚点\rhttp://www.oliver.ren/about.html#foot</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 89),
(1199, 'Tomcat简介.png', 'Tomcat简介-png', 1541258153, 1541258153, 'a:5:{s:4:"name";s:16:"Tomcat简介.png";s:4:"path";s:35:"/usr/uploads/2018/11/4290623899.png";s:4:"size";i:253068;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1200, 0),
(1200, 'Tomcat简介', '1200', 1541258171, 1541258171, '<p>本文记录Java学习过程中遇到的Tomcat简介～</p>\r<!--more-->\r\r<p>Tomcat服务器是一个免费的开放源代码的Web应用服务器，属于轻量应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。</p>\r\r<p>Tomcat支持Servlet和JSP规范，且最新的Servlet和JSP规范总能在Tomcat中得到体现。</p>\r\r<p>Apache软件基金会有两款常用软件：Apache Web服务器和Tomcat Web服务器，他们具有如下的异同点：</p>\r\r<ul>\r	<li>Apache Web服务器是专门处理HTML页面的；</li>\r	<li>Tomcat Web服务器，不仅可以处理Servlet和JSP，而且也能处理HTML页面，不过性能上不如Apache Web服务器；</li>\r	<li>在开发中，一般使用Tomcat处理Servlet和JSP，使用Apache服务器处理HTML页面，即Apache和Tomcat被整合在一起使用。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/4290623899.png" style="width: 800px; height: 449px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 85),
(1201, 'Tomcat版本.png', 'Tomcat版本-png', 1541258471, 1541258471, 'a:5:{s:4:"name";s:16:"Tomcat版本.png";s:4:"path";s:35:"/usr/uploads/2018/11/4036828818.png";s:4:"size";i:166106;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1202, 0),
(1202, 'Tomcat常见版本', '1202', 1541258486, 1541258486, '<p>本文记录Java学习过程中遇到的Tomcat常见版本～</p>\r<!--more-->\r\r<p>Tomcat目前存在很多版本，我们需要了解Tomcat的版本，从而知道自己的创建的项目使用的第几版本规范，不同版本的规范技术可能不同。我们学习的Web 5.0，Servlet规范的版本是2.5，Tomcat至少使用6.0。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/4036828818.png" style="width: 800px; height: 144px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 88),
(1203, 'Tomcat目录结构', '1203', 1541260082, 1541260082, '<p>本文记录Java学习过程中遇到的Tomcat目录结构～</p>\r<!--more-->\r\r<p>Tomcat的目录结构如下：</p>\r\r<p>bin：脚本目录</p>\r\r<ul>\r	<li>启动脚本：startup.sh</li>\r	<li>停止脚本：shutdown.sh</li>\r</ul>\r\r<p>conf：配置文件目录</p>\r\r<ul>\r	<li>核心配置文件：server.xml</li>\r	<li>用户权限配置文件：tomcat-users.xml</li>\r	<li>所有Web项目默认配置文件：web.xml</li>\r</ul>\r\r<p>lib：依赖库，Tomcat和Web项目中需要使用的jar包</p>\r\r<p>logs：日志文件</p>\r\r<ul>\r	<li>用户访问信息的日志：localhost_access_log.*.txt，*表示时间。例如：localhost_access_log.2018-11-01.txt</li>\r</ul>\r\r<p>temp：临时文件目录</p>\r\r<p>webapps：默认情况下发布Web项目所存放的目录</p>\r\r<p>work：Tomcat处理JSP的工作目录</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 88),
(1204, 'JAVA_HOME.png', 'JAVA_HOME-png', 1541263730, 1541263730, 'a:5:{s:4:"name";s:13:"JAVA_HOME.png";s:4:"path";s:34:"/usr/uploads/2018/11/399397094.png";s:4:"size";i:196326;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1206, 0),
(1205, '端口号冲突.png', '端口号冲突-png', 1541263776, 1541263776, 'a:5:{s:4:"name";s:19:"端口号冲突.png";s:4:"path";s:35:"/usr/uploads/2018/11/3491595919.png";s:4:"size";i:456401;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1206, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1206, 'Tomcat常见问题', '1206', 1541263740, 1541263872, '<p>本文记录Java学习过程中遇到的Tomcat常见问题～</p>\r\r<!--more-->\r\r<p>JAVA_HOME的配置</p>\r\r<p>如果没有配置JAVA_HOME环境变量，在双击&quot;start.bat&quot;文件运行Tomcat时，将一闪而过。这个环境变量必须配置，即JAVA_HOME指向JDK的安装目录。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/399397094.png" style="width: 800px; height: 243px;" /></p>\r\r<p>端口号冲突</p>\r\r<p>当同一台计算机启动两个Tomcat时，第二个Tomcat将会在控制台抛异常，摘要信息如下：</p>\r\r<pre class="brush:java;">\r严重：Failed to initialize end point associated with ProtocolHandler[&quot;http-bio-8080&quot;]\rjava.net.BindException: Address already in use: JVM_Bind &lt;null&gt;：8080\r...\rCaused by: java.net.BindException: Address already in use: JVM_Bind\r...</pre>\r\r<p>控制台将出现大量异常信息，描述的是3个端口被占用（8080、8009、8005）</p>\r\r<p>可以通过$JAVA_HOME/conf/server.xml修改端口号：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3491595919.png" style="width: 800px; height: 230px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 79),
(1207, 'Web项目目录结构', '1207', 1541264346, 1541264346, '<p>本文记录Java学习过程中遇到的Web项目目录结构～</p>\r\r<!--more-->\r\r<p>一般的Web项目的架构如下：</p>\r\r<pre class="brush:java;">\r项目名称（WebContent）\r|--静态资源（HTML、CSS和JS）\r|--WEB-INF（不能通过浏览器访问）\r	|&mdash;&mdash;web.xml（Web项目的核心配置，Servlet 2.5必须有，3.0可省略）\r	|&mdash;&mdash;lib（Web项目所需要的第三方的jar的存放位置）\r	|&mdash;&mdash;classes（Java源码编译后生成class文件存放的位置）</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 111),
(1208, '运行环境.png', '运行环境-png', 1541264914, 1541264914, 'a:5:{s:4:"name";s:16:"运行环境.png";s:4:"path";s:35:"/usr/uploads/2018/11/3212494334.png";s:4:"size";i:370270;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1209, '添加服务器.png', '添加服务器-png', 1541264954, 1541264954, 'a:5:{s:4:"name";s:19:"添加服务器.png";s:4:"path";s:34:"/usr/uploads/2018/11/225412825.png";s:4:"size";i:815891;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1210, '03.png', '03-png', 1541264972, 1541264972, 'a:5:{s:4:"name";s:6:"03.png";s:4:"path";s:35:"/usr/uploads/2018/11/3419807061.png";s:4:"size";i:328494;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1211, '04.png', '04-png', 1541264977, 1541264977, 'a:5:{s:4:"name";s:6:"04.png";s:4:"path";s:34:"/usr/uploads/2018/11/934772195.png";s:4:"size";i:150052;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1212, '05.png', '05-png', 1541264986, 1541264986, 'a:5:{s:4:"name";s:6:"05.png";s:4:"path";s:34:"/usr/uploads/2018/11/525128485.png";s:4:"size";i:469291;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1213, '06.png', '06-png', 1541264995, 1541264995, 'a:5:{s:4:"name";s:6:"06.png";s:4:"path";s:35:"/usr/uploads/2018/11/3036846318.png";s:4:"size";i:410187;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1214, '001.png', '001-png-12', 1541265066, 1541265066, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2018/11/1842079882.png";s:4:"size";i:197224;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1215, '002.png', '002-png-8', 1541265073, 1541265073, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/11/1802622905.png";s:4:"size";i:668013;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 8, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1216, '003.png', '003-png-8', 1541265076, 1541265076, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:35:"/usr/uploads/2018/11/1578542724.png";s:4:"size";i:283232;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 9, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1217, 0),
(1217, 'Eclipse发布Web项目', '1217', 1541265115, 1541265115, '<p>本文记录Java学习过程中遇到的Eclipse发布Web项目～</p>\r<!--more-->\r\r<p><strong>配置Tomcat</strong></p>\r\r<p>1.获得服务器运行环境配置（Window-Preferences-Server-Runtime Environment）：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3212494334.png" style="width: 800px; height: 349px;" /></p>\r\r<p>2.添加服务器：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/225412825.png" style="width: 800px; height: 749px;" /></p>\r\r<p>3.选择服务器在硬盘的地址，然后所有的都是确定/Next/Finish：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3419807061.png" style="height: 424px; width: 800px;" /></p>\r\r<p>4.完成配置：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/934772195.png" style="width: 800px; height: 101px;" /></p>\r\r<p>5.设置发布设置：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/525128485.png" style="width: 800px; height: 337px;" /></p>\r\r<p>6.修改Tomcat发布的位置：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3036846318.png" style="width: 800px; height: 274px;" /></p>\r\r<p><strong>发布Web项目</strong></p>\r\r<p>1.项目右键（Run As-Run on Server）：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/1842079882.png" style="width: 800px; height: 128px;" /></p>\r\r<p>2.选择Web服务器执行程序：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/1802622905.png" style="width: 800px; height: 672px;" /></p>\r\r<p>3.选择或添加文本框：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/1578542724.png" style="width: 800px; height: 482px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 110),
(1218, 'Servlet简介', '1218', 1541599380, 1554078324, '<p>本文记录Java学习过程中遇到的Servlet～</p>\r<!--more-->\r\r<p>Servlet表示运行在服务端的Java小程序，是sun公司提供一套规范（接口），用来处理客户端请求和响应给浏览器的动态资源。</p>\r\r<p>Servlet的实质就Java代码，通过Java的API动态的向客户端输出内容。</p>\r\r<p>Servlet规范包含三个技术点：</p>\r\r<ul>\r	<li>servlet技术；</li>\r	<li>filter技术---过滤器；</li>\r	<li>listener技术---监听器。</li>\r</ul>\r\r<p>其中，Servlet技术最为核心。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 72),
(1219, 'Servlet作用', '1219', 1541599920, 1541599971, '<p>本文记录Java学习过程中遇到的Servlet的作用～</p>\r<!--more-->\r\r<p>Servlet用来处理从客户端发送过来的请求并对该请求作出响应。</p>\r\r<p>它的主要任务有：</p>\r\r<ol>\r	<li>获取请求；</li>\r	<li>处理请求；</li>\r	<li>完成响应。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 73),
(1220, 'Servlet的API', '1220', 1541692419, 1541692419, '<p>本文记录Java学习过程中遇到的Servlet的API～</p>\r<!--more-->\r\r<p>1.Servlet接口中的方法</p>\r\r<p>init(ServletConfig config)：</p>\r\r<ul>\r	<li>执行时间：servlet对象创建的时候执行；</li>\r	<li>config：servlet对象的配置信息。</li>\r</ul>\r\r<p>service(ServletRequest request, ServletResponse response)：</p>\r\r<ul>\r	<li>执行时间：每次请求都会执行；</li>\r	<li>request：代表请求，认为封装的是请求的信息；</li>\r	<li>response：代表响应，认为封装的是响应的信息。</li>\r</ul>\r\r<p>destroy()：</p>\r\r<ul>\r	<li>执行时间：servlet销毁的时候。</li>\r</ul>\r\r<p>2.HttpServlet类的方法</p>\r\r<ul>\r	<li>init()：初始化方法；</li>\r	<li>doGet(HttpServletRequest request, HttpServletResponse response)：处理get请求；</li>\r	<li>doPost(HttpServletRequest request, HttpServletResponse response)：处理post请求；</li>\r	<li>destroy()：销毁方法。</li>\r</ul>\r\r<p>注意：init()只会在第一次访问的时候执行，service则每次都会被调用。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 69),
(1221, 'Servlet的配置', '1221', 1541694660, 1541694806, '<p>本文记录Java学习过程中遇到的Servlet的配置～</p>\r<!--more-->\r\r<div>1.基本配置</div>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:xml;">\r&lt;!-- servlet的类的配置 --&gt;\r&lt;servlet&gt;\r	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;\r	&lt;servlet-class&gt;helloServlet&lt;/servlet-class&gt;\r	&lt;init-param&gt;\r		&lt;param-name&gt;key&lt;/param-name&gt;\r		&lt;param-value&gt;value&lt;/param-value&gt;\r	&lt;/init-param&gt;\r&lt;/servlet&gt;\r\r&lt;!-- servlet的虚拟路径的配置 --&gt;\r&lt;servlet-mapping&gt;\r	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;\r	&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\r&lt;/servlet-mapping&gt;</pre>\r</div>\r\r<div>其中url-pattern的配置方式：</div>\r\r<ul>\r	<li>完全匹配：访问的资源与配置的资源完全相同才能访问到；</li>\r</ul>\r\r<div>\r<pre class="brush:xml;">\r&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</pre>\r</div>\r\r<ul>\r	<li>目录匹配：格式为/directory/*，*代表任意；</li>\r</ul>\r\r<div>\r<pre class="brush:xml;">\r&lt;url-pattern&gt;/a/b/c/*&lt;/url-pattern&gt;</pre>\r</div>\r\r<ul>\r	<li>扩展名匹配：格式为*.xxx，*表示任意；</li>\r</ul>\r\r<div>\r<pre class="brush:xml;">\r&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</pre>\r</div>\r\r<div>注意：第二种与第三种不要混用，这样做是错误的。</div>\r\r<div>&nbsp;</div>\r\r<div>2.服务器启动实例化Servlet配置</div>\r\r<div>&nbsp;</div>\r\r<div>Servlet默认会第一次访问时创建，当在Servlet的配置中加上一个配置&lt;load-on-startup&gt;就可以让Servlet对象在服务器启动时就创建。</div>\r\r<div>&nbsp;</div>\r\r<div>3.缺省Servlet</div>\r\r<div>&nbsp;</div>\r\r<div>可以将一个url-pattern配置成/，代表该Servlet是缺省的Servlet。当访问资源地址和所有的Servlet都不匹配的时候，缺省的Servlet就会负责处理。</div>\r\r<div>&nbsp;</div>\r\r<div>其实，web应用中所有的资源和响应都是Servlet负责的，包括静态资源。</div>\r\r<div>&nbsp;</div>\r\r<div>4.欢迎页面</div>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:xml;">\r&lt;welcome-file-list&gt;\r	&lt;welcome-file&gt;index.html&lt;/welcome-file&gt;\r	&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\r&lt;/welcome-file-list&gt;</pre>\r</div>\r\r<div>在访问的时候，会按照配置的顺序逐一尝试，知道有可以用的为止。</div>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 85),
(1222, 'ServletContext简介', '1222', 1541913294, 1541913294, '<p>本文记录Java学习过程中遇到的ServletContext简介～</p>\r<!--more-->\r\r<p>ServletContext代表是一个Web应用的环境（上下文）对象，ServletContext对象内部封装是该web应用的信息，ServletContext对象一个Web应用只有一个。</p>\r\r<p>ServletContext对象的生命周期如下：</p>\r\r<ul>\r	<li>创建：该web应用被加载（服务器启动或发布Web应用（前提，服务器启动状态））；</li>\r	<li>销毁：web应用被卸载（服务器关闭，移除该Web应用）。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 68),
(1223, 'ServletContext常用方法', '1223', 1541914499, 1541914499, '<p>本文记录Java学习过程中遇到的ServletContext常用方法～</p>\r<!--more-->\r\r<p>如何获取到Servlet对象：</p>\r\r<ul>\r	<li>ServletContext servletContext = config.getServletContext();</li>\r	<li>ServletContext servletContext = this.getServletContext();</li>\r</ul>\r\r<p>ServletContext常用的方法有：</p>\r\r<ul>\r	<li>void setAttribute(String name, Object object)：向ServletContext中存数据；</li>\r	<li>Object getAttribute(String name)：从ServletContext中取数据；</li>\r	<li>void removeAttribute(String name)：从ServletContext中移除数据；</li>\r	<li>Enumeration&lt;String&gt; getInitParameterNames()：获取初始化参数列表；</li>\r	<li>String getInitParameter(String name)：获取初始化参数；</li>\r	<li>Set getResourcePaths(String path)：返回一个Set集合，集合中包含资源目录中子目录和文件的路径名称，参数path必须以/开始，指定匹配资源的部分路径；</li>\r	<li>String getRealPath(String path)：返回资源文件在服务器文件系统上的真实路径（文件的绝对路径），参数path代表资源文件的虚拟路径，它应该以/开始，/表示当前Web应用的根目录（如果Servlet容器不能将虚拟路径转换为文件系统的真实路径，则返回null）；</li>\r	<li>URL getResource(String paht)：返回映射到某个资源文件的URL对象，参数path必须以/开始，/表示当前Web应用的根目录；</li>\r	<li>InputStream getResourceAsStream(String path)：返回映射到某个资源文件的InputStream输入流对象。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(1224, 'HttpServletResponse简介', '1224', 1542531480, 1542531557, '<p>本文记录Java学习过程中遇到的HttpServletResponse～</p>\r<!--more-->\r\r<p>在Servlet的API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP的响应消息。</p>\r\r<p>由于HTTP的响应消息分为状态行、响应消息头和消息体三部分。因此，在HttpServletResponse接口中定义了向客户端发送响应状态码、响应消息头和响应消息体的方法。</p>\r\r<p><strong>发送状态码相关的方法</strong></p>\r\r<p>当Servlet向客户端发送响应消息时，需要在响应消息中设置状态码。为此，HttpServletResponse接口中，定义了两个发送状态码的方法，具体如下：</p>\r\r<p>1.setStatus(int status)方法</p>\r\r<p>该方法用于设置HTTP响应消息的状态码，并生成相应状态行。由于响应状态行中的状态描述信息直接与状态码相关，而HTTP版本由服务器确定。因此，只用通过setStatus(int status)方法设置了状态码，即可实现状态行的发送。需要注意的是，正常情况下，Web服务器会默认产生一个状态码为200的状态行。</p>\r\r<p>2.sendError(int status)方法</p>\r\r<p>该方法用于发送表示错误信息的状态码。例如，404状态码表示找不到客户端请求的资源。在response对象中，提供了两个重载的sendError方法，具体如下：</p>\r\r<p>public void sendError(int code) throws java.io.IOException<br />\rpublic void sendError(int code, String message) throws java.io.IOException</p>\r\r<p>在上面重载的两个方法中，第一个方法只是发送错误信息的状态码，而第二个方法除了发送状态码外，还可以增加一个用于提示说明的文本信息，该文本信息将出现在发送给客户端的正文内容中。</p>\r\r<p><strong>发送响应消息头相关的方法</strong></p>\r\r<p>1.addHeader(String name, String value)和setHeader(String name, String value)方法</p>\r\r<p>这两个方法都是用来设置HTTP协议的响应头字段。其中，参数name用来指定响应头字段的名称，参数value用来指定响应头字段的值。不同的是，addHeader()方法可以增加同名的响应头字段，而setHeader()方法则会覆盖同名的头字段。</p>\r\r<p>2.addIntHeader(String name, int value)和setIntHeader(String name, int value)方法</p>\r\r<p>这两个方法专门用于设置包含整数值的响应头。避免了使用addHeader()和setHeader()方法时，需要将int类型的设置值转换为String类型的麻烦。</p>\r\r<p>3.setContentLength(int len)方法</p>\r\r<p>该方法用于设置响应消息的实体内容的大小，单位为字节。对于HTTP协议来说，这个方法就是设置Content-Length响应头字段的值。</p>\r\r<p>4.setContentType(String type)方法</p>\r\r<p>该字段用于设置Servlet输出内容的MIME类型，对于HTTP协议来说，就是设置Content-Type响应头字段的值。例如，如果发送到客户端的内容是jpeg格式的图像数据，就需要将响应头字段的类型设置为&ldquo;image/jpeg&rdquo;。需要注意的是，如果响应的内容为文本，setContentType()方法还可以设置字符编码，例如，text/html;charset=UTF-8。</p>\r\r<p>5.setLocale(Locale loc)方法</p>\r\r<p>该方法用于设置响应消息的本地化信息。对HTTP来说，就是设置Content-Language响应头字段和Content-Type头字段中的字符集编码部分。需要注意的是，如果HTTP响应消息没有设置Content-Type头字段，setLocale()方法设置的字符集编码不会出现在HTTP消息的响应头中；如果调用了setCharacterEncoding()或setContentType()方法指定了响应内容的字符集编码，setLocale()方法将不再具有指定字符集编码的功能。</p>\r\r<p>6.setCharaceterEncoding(String charset)方法</p>\r\r<p>该方法用于设置输出输出内容实用的字符编码。对HTTP协议来说，就是设置Content-Type头字段中的字符集编码部分。如果没有设置Content-Type头字段，setCharacterEncoding方法设置的字符集编码不会出现在HTTP消息的响应头中。setCharacterEncoding()方法比setContentType()和setLocale()方法的优先权高，它的设置结果将覆盖setContentType()和setLocale()方法所设置的字符码表。</p>\r\r<p>注意：在上面列举的一系列方法中，addHeader()、setHeader()、addIntHeader()和setIntHeader()方法都是用于设置各种头字段的，而setContentType()、setLocale()和setCharacterEncoding()方法用于设置字符编码，这些设置字符编码的方法可以有效解决乱码问题。</p>\r\r<p><strong>发送响应消息体相关的方法</strong></p>\r\r<p>由于在HTTP响应消息中，大量的数据都是通过响应消息体传递的。因此，ServletResponse遵循以IO流传递大量数据的设计理念。在发送响应消息体时，定义了两个与输出流相关的方法，具体如下：</p>\r\r<p>1.getOutputStream()方法</p>\r\r<p>该方法所获取的字节输出流对象为ServletOutputStream类型。由于ServletOutputStream是OutputStream的子类，它可以直接输出字节数组中的二进制数据。因此，要想输出二进制格式的响应正文，就需要使用getOutputStream()方法。</p>\r\r<p>2.getWriter()方法</p>\r\r<p>该方法所获取的字符输出流对象为PrintWriter类型。由于PrintWriter类型的对象可以直接输出字符文本内容。因此，要想输出内容全为字符文本的网页文档，需要使用getWriter()方法。</p>\r\r<p>注意：虽然response对象的getOutputStream()和getWriter()方法都可以发送响应消息体，但是他们之间互相排斥，不可同时使用，否则会发生IllegalStateException异常。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 66),
(1225, '文件下载原理', '1225', 1542532620, 1542536595, '<p>本文记录Java学习过程中遇到的文件下载原理～</p>\r<!--more-->\r\r<p>对于文件下载，我们并不陌生，因为通常在上网时所下载的图片、文档和影片等都是文件下载的范畴。现在很多网站都提供了下载各类资源的功能，因此在学习Web开发过程中，有必要学习文件下载的实现方式。</p>\r\r<p>实现文件下载功能比较简单，通常情况下，不需要使用第三方组件实现，而是直接使用Servlet类和输出/输出流实现。与访问服务器文件不同的是，要实现文件的下载，不仅需要指定文件的路径，还需要在HTTP协议中设置两个响应消息头，具体如下：</p>\r\r<pre class="brush:xml;">\r//设定接收程序处理数据的方式\rContent-Disposition: attachment; filename =\r\r//设定实体内容的MIME类型\rContent-Type: application/x-msdownload</pre>\r\r<p>浏览器通常会直接处理响应的实体内容，需要在HTTP响应消息中设置两个响应消息头字段，用来指定接收程序处理数据内容的方式为下载方式。当单击&ldquo;下载&rdquo;超链接时，系统将请求提交到对应的Servlet。在该Servlet中，首先获取下载文件的地址，并根据该地址创建文件字节输入流，然后通过该流读取下载文件内容，最后将读取的内容通过输出流写到目标文件中。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 99),
(1226, '乱码.png', '乱码-png', 1542539302, 1542539302, 'a:5:{s:4:"name";s:10:"乱码.png";s:4:"path";s:35:"/usr/uploads/2018/11/3779744396.png";s:4:"size";i:142078;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1231, 0),
(1227, '编码错误分析.png', '编码错误分析-png', 1542539332, 1542539332, 'a:5:{s:4:"name";s:22:"编码错误分析.png";s:4:"path";s:34:"/usr/uploads/2018/11/600209790.png";s:4:"size";i:97606;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1231, 0),
(1228, '客户端乱码.png', '客户端乱码-png', 1542539372, 1542539372, 'a:5:{s:4:"name";s:19:"客户端乱码.png";s:4:"path";s:35:"/usr/uploads/2018/11/3445148473.png";s:4:"size";i:106562;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1231, 0),
(1230, '解码错误分析.png', '解码错误分析-png', 1542539423, 1542539423, 'a:5:{s:4:"name";s:22:"解码错误分析.png";s:4:"path";s:35:"/usr/uploads/2018/11/3224860393.png";s:4:"size";i:134697;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1231, 0),
(1231, 'Tomcat中文输出乱码问题', '1231', 1542539640, 1542539820, '<p>本文记录Java学习过程中遇到的Tomcat中文输出乱码问题～</p>\r<!--more-->\r\r<div>由于计算机中的数据都是以二进制形式存储的，所以当传输文本时，就会发生字符和字节之间的转换。字符和字节之间的转换是通过查码表完成的，将字符转换成字节的过程称为编码，将字节转换成字符的过程称为解码，如果编码和解码使用的码表不一致，就会导致乱码问题。</div>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>&nbsp;</div>\r\r<div>\r<pre class="brush:java;">\rimport java.io.*;\rimport javax.servlet.*;\rimport javax.servlet.http.*;\r\rpublic class ChineseServlet extends HttpServlet {\r    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{\r        String data = &quot;中国&quot;;\r        PrintWriter out = response.getWriter();\r        out.println(data);\r    }\r    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{\r        doGet(request, response);\r    }\r}</pre>\r</div>\r\r<div>在web.xml中配置完ChineseServlet的映射后，启动Tomcat服务器，在浏览器访问ChineseServlet，浏览器显示如下所示：</div>\r\r<div>&nbsp;</div>\r\r<div><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3779744396.png" style="width: 800px; height: 179px;" /></div>\r\r<div>&nbsp;</div>\r\r<div>从上图可以看出，浏览器显示的内容都是&ldquo;？？&rdquo;，说明发生了乱码问题。实际上此处产生乱码的原因是response对象的字符输出流在编码时，采用的ISO-8859-1的编码表，该码表并不兼容中文，会将&ldquo;中国&ldquo;编码为&ldquo;63 63&rdquo;（在ISO-8859-1的码表中查不到的字符就会显示63）。当浏览器对接收到的数据进行解码时，会采用默认的码表GB2312，将&ldquo;63&rdquo;解码为&ldquo;？&rdquo;，因此，浏览器将&ldquo;中国&rdquo;两个字符显示成了&ldquo;？？&rdquo;，具体分析如下图所示：</div>\r\r<div>&nbsp;</div>\r\r<div><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/600209790.png" style="width: 800px; height: 161px;" /></div>\r\r<div>&nbsp;</div>\r\r<div>为了解决上述编码错误，在HttpServletResponse接口中，提供了一个setCharacterEncoding()方法，该方法用于设置字符的编码方式，具体代码如下：</div>\r\r<div>\r<pre class="brush:java;">\rresponse.setCharacterEncoding(&quot;utf-8&quot;);</pre>\r</div>\r\r<div>在浏览器中再次访问ChineseServlet，结果如下：</div>\r\r<div>&nbsp;</div>\r\r<div><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3445148473.png" style="width: 800px; height: 180px;" /></div>\r\r<div>&nbsp;</div>\r\r<div>从上图可以看出，浏览器中显示的乱码不是&ldquo;？？&rdquo;，但也不是需要输出的&ldquo;中国&rdquo;。通过分析发现，这是由于浏览器编码错误导致的，因为response对象的字符输出流设置的编码方式为UTF-8，而浏览器使用的编码方式是GB2312，具体分析过程如下：</div>\r\r<div>&nbsp;</div>\r\r<div><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3224860393.png" style="width: 800px; height: 124px;" /></div>\r\r<div>&nbsp;</div>\r\r<div>对于上面出现的解码错误，可以通过修改浏览器的解码方式解决。在浏览器中点击菜单栏中的 查看--编码--UTF-8 选项（或者鼠标点击浏览器内部，在弹出的窗口中选择 编码--其它--UTF-8 ），将浏览器的解码方式设置为UTF-8，浏览器的现实结果如下图：</div>\r\r<div>&nbsp;</div>\r\r<div><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/1403677074.png" style="width: 800px; height: 180px;" /></div>\r\r<div>&nbsp;</div>\r\r<div>从上图可以看出，浏览器的现实内容没有出现乱码。由此说明，通过修改浏览器的解码方式可以解决乱码，但是，这样的做法仍然是不可取的，因为你不能让用户每次都去改浏览器的解码方式。为此，在HttpServletResponse对象中，提供了两种解决解码乱码的方案：</div>\r\r<div>&nbsp;</div>\r\r<div>方案一：</div>\r\r<div>\r<pre class="brush:java;">\r// 设置HttpServletResponse使用utf-8编码\rresponse.setCharacterEncoding(&quot;utf-8&quot;);\r// 通知浏览器使用utf-8解码\rresponse.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);</pre>\r</div>\r\r<div>方案二：</div>\r\r<div>\r<pre class="brush:java;">\r// 包含第一种方式的两个功能\rresponse.setContentType(&quot;text/html;charset=utf-8&quot;);</pre>\r</div>\r\r<div>通常情况下，为了使代码更加简洁，会采用第二种方案。</div>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97),
(1233, '正常的结果.png', '正常的结果-png', 1542539775, 1542539775, 'a:5:{s:4:"name";s:19:"正常的结果.png";s:4:"path";s:35:"/usr/uploads/2018/11/1403677074.png";s:4:"size";i:153994;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1231, 0),
(1234, 'HttpServletRequest简介', '1234', 1542555666, 1542555666, '<p>本文记录Java学习过程中遇到的HttpServletRequest简介～</p>\r<!--more-->\r\r<p>在Servlet的API中，定义了一个HttpServletRequest接口，它继承自ServletRequest接口，专门用来封装HTTP请求消息。由于HTTP请求分为请求行、请求消息头和请求体三部分。因此，在HttpServletRequest接口中定义了获取请求行、请求头和请求体的相关方法。</p>\r\r<p><strong>获取请求行信息的相关方法</strong></p>\r\r<p>当访问Servlet时，会在请求消息的请求行中，包含请求方法、请求资源名和请求路径等信息。为了获取这些信息，在HttpServletRequest接口中，定义了一系列用于获取请求行的方法，如下：</p>\r\r<p>1.getMethod()方法</p>\r\r<p>该方法用于获取HTTP请求消息中的请求方式（如GET和POST等）。</p>\r\r<p>2.getRequestURI()方法</p>\r\r<p>该方法用于获取请求行中资源名称部分，即位于URL的主机和端口之后、参数部分之前的部分。</p>\r\r<p>3.getQueryString()方法</p>\r\r<p>该方法用于获取请求行中的参数部分，也就是资源路径后面问号(?)以后的所有内容。</p>\r\r<p>4.getProtocol()方法</p>\r\r<p>该方法用于获取请求行中的协议名和版本，例如HTTP/1.0或者HTTP/1.1。</p>\r\r<p>5.getContextPath()方法</p>\r\r<p>该方法用于获取请求URL中属于Web应用程序的路径，这个路径以&quot;/&quot;开头，表示相对于整个Web站点的根目录，路径结尾不含&quot;/&quot;。如果请求URL属于Web站点的根目录，那么返回结果为空字符串(&quot;&quot;)。</p>\r\r<p>6.getServletPath()方法</p>\r\r<p>该方法用于获取Servlet的名称或Servlet所映射的路径。</p>\r\r<p>7.getRemoteAddr()方法</p>\r\r<p>该方法用于获取请求客户端的IP地址，其格式类似于&quot;127.0.0.1&quot;。</p>\r\r<p>8.getRemoteHost()方法</p>\r\r<p>该方法用于获取请求客户端的完整主机名，其格式类似于&quot;www.oliver.ren&quot;。需要注意的是，如果无法解析出客户端的完整主机名，该方法将会返回客户端的IP地址。</p>\r\r<p>9.getRemotePort()方法</p>\r\r<p>该方法用于获取请求客户端的网络连接的端口号。</p>\r\r<p>10.getLocalAddr()方法</p>\r\r<p>该方法用于获取Web服务器上接收当前请求网络连接的IP地址。</p>\r\r<p>11.getLocalName()方法</p>\r\r<p>该方法用于获取Web服务器上接收当前请求网络连接IP对应的主机名。</p>\r\r<p>12.getLocalPort()方法</p>\r\r<p>该方法用于获取Web服务器上接收当前请求网络连接的端口号。</p>\r\r<p>13.getServerName()方法</p>\r\r<p>该方法用于获取当前请求所指向的主机名，即HTTP请求消息中Host头字段所对应的主机名部分。</p>\r\r<p>14.getServerPort()方法</p>\r\r<p>该方法用于获取当前请求所连接的服务器端口号，即HTTP请求消息中Host头字段所对应的端口号部分。</p>\r\r<p>15.getScheme()方法</p>\r\r<p>该方法用于获取请求的协议名，例如http、https和ftp等。</p>\r\r<p>16.getRequestURL()方法</p>\r\r<p>该方法用于获取客户端发出请求时的完整URL，包括协议、服务器名、端口号、资源路径等信息，但不包括后面的查询参数部分。注意，getRequestURL()方法返回的结果是StringBuffer类型，而不是String类型，这样更便于对结果进行修改。</p>\r\r<p><strong>获取请求消息头的相关方法​</strong></p>\r\r<p>当请求Servlet时，需要通过请求头向服务器传递附加信息。例如，客户端可以接收的数据类型、压缩方式和语言等。为此，在HttpServletRequest接口中，定义了一系列用于获取HTTP请求头字段的方法，如下所示：</p>\r\r<p>1.getHeader(String name)方法</p>\r\r<p>该方法用于获取一个指定头字段的值，如果请求消息中没有包含指定的头字段，getHeader()方法返回null；如果请求消息中包含有多个指定名称的头字段，getHeader()方法返回其中第一个头字段的值。</p>\r\r<p>2.getHeaders(String name)方法</p>\r\r<p>该方法返回一个Enumeration集合对象，该集合对象由请求消息中出现的某个指定名称的所有头字段值组成。在多数情况下，一个头字段名在请求消息中只出现一次，但有时候可能会出现多次。</p>\r\r<p>3.getHeaderNames()方法</p>\r\r<p>该方法用于获取一个包含所有请求头字段的Enumeration对象。</p>\r\r<p>4.getIntHeader(String name)方法</p>\r\r<p>该方法用于获取指定名称的头字段，并且将其值转为int类型。需要注意的是，如果指定名称的头字段不存在，返回值为-1；如果获取到的头字段的值不能转为int类型，将发生NumberFormatException异常。</p>\r\r<p>5.getDateHeader(String name)方法</p>\r\r<p>该方法用于获取指定头字段的值，并将其按GMT时间格式转换成一个代表日期/时间的长整数，这个长整数是自1970年01月01日00点00分00秒算起的以毫秒为单位的时间值。</p>\r\r<p>6.getContentType()方法</p>\r\r<p>该方法用于获取Content-Type头字段的值，结果为String类型。</p>\r\r<p>7.getCharacterEncoding()方法</p>\r\r<p>该方法用于返回请求消息的实体部分的字符集编码，通常是从Content-Type头字段中进行提取，结果为String类型。</p>\r\r<p><strong>获取请求参数相关的方法</strong></p>\r\r<p>在实际开发中，经常需要获取用户提交的表单数据。例如，用户名、密码和电子邮件等，为了方便获取表单中的请求参数，在HttpServletRequest接口中定义类一系列获取请求参数的方法，如下所示：</p>\r\r<p>1.getParameter(String name)方法</p>\r\r<p>该方法用于获取某个指定名称的参数值，如果请求消息中没有包含指定名称的参数，则返回null；如果指定名称的参数存在但没有设置值，则返回一个空串；如果请求消息中包含有多个该指定名称的参数，放回第一个出现的参数值。</p>\r\r<p>2.getParameterValues(String name)方法</p>\r\r<p>HTTP请求消息中可以有多个相同名称的参数（通常由一个包含有多个同名的字符元素的form表单生成），如果要获得HTTP请求消息中的同一个参数名所对应的所有参数值，那么就应该使用getParameterValues()方法，该方法用于返回一个String类型的数组。</p>\r\r<p>3.getParameterNames()方法</p>\r\r<p>该方法用于返回一个包含请求消息中所有参数名的Enumeration对象，在此基础上，可以对请求消息中的所有参数进行遍历处理。</p>\r\r<p>4.getParameterMap()方法</p>\r\r<p>该方法用于将请求消息中的所有参数名和值装入一个Map对象中返回。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 116),
(1235, 'Tomcat请求参数的中文乱码问题', '1235', 1542813340, 1542813340, '<p>本文记录Java学习过程中遇到的Tomcat请求参数的中文乱码问题～</p>\r<!--more-->\r\r<p>在填写表单数据时，难免会输入中文，如姓名或者公司名称等等。由于HTML设置了浏览器在传递请求参数时，采用的编码方式是UTF-8，但在解码时采用的是默认的ISO8859-1，因此会导致乱码的出现。</p>\r\r<p>解决步骤：</p>\r\r<p>1.设置解码方式</p>\r\r<p>在HttpServletRequest接口中，提供了一个setCharacterEncoding()方法，该方法用于设置request对象的解码方式。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rrequest.setCharacterEncoding(&quot;utf-8&quot;);\rString name = request.getParameter(&quot;username&quot;);</pre>\r\r<p>但是这种方法仅仅对POST请求有效，对GET无效。</p>\r\r<p>2.对字符串先解码再重新编码</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rString name = request.getParameter(&quot;username&quot;);\rname = new String(name.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);</pre>\r\r<p>这种方法可以解决所有的乱码问题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(1236, 'Request域对象', '1236', 1542814030, 1542814030, '<p>本文记录Java学习过程中遇到的Request域对象～</p>\r\r<!--more-->\r\r<p>Request是一个域对象，不仅可以获取一系列的参数，还可以通过属性传递数据。在ServletRequest接口中，定义了一系列操作属性的方法，具体如下：</p>\r\r<p>1.setAttribute(String name, Object o)方法</p>\r\r<p>该方法用于将一个对象与一个名称关联后存储进ServletRequest对象中。需要注意的是，如果ServletRequest对象中已经存在指定名称的属性，setAttribute()方法将会先删除原来的属性，然后再添加新的属性。如果传递给setAttribute()方法的属性值对象为null，则删除指定名称的属性，这是的效果等同于removeAttribute()方法。</p>\r\r<p>2.getAttribute(String name)方法</p>\r\r<p>该方法用于从ServletRequest对象中返回指定名称的属性对象。</p>\r\r<p>3.removeAttribute(String name)方法</p>\r\r<p>该方法用于从ServletRequest对象中删除指定名称的属性。</p>\r\r<p>4.getAttributeNames()方法</p>\r\r<p>该方法用于返回一个包含ServletRequest对象中的所有属性名的Enumeration对象。在此基础上，可以对ServletRequest对象中的所有属性进行遍历处理。</p>\r\r<p>需要注意的是，只有属于同一个请求中的数据才可以通过ServletRequest对象传递数据。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 104),
(1237, '请求转发工作原理.png', '请求转发工作原理-png', 1542815564, 1542815564, 'a:5:{s:4:"name";s:28:"请求转发工作原理.png";s:4:"path";s:35:"/usr/uploads/2018/11/2928952655.png";s:4:"size";i:112508;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1238, 0),
(1238, 'RequestDispatcher对象', '1238', 1542815580, 1542815615, '<p>本文记录Java学习过程中遇到的RequestDispatcher对象～</p>\r\r<!--more-->\r\r<p>当一个Web资源收到客户端的请求后，如果希望服务器通知另外一个资源去处理请求。这时，除了使用sendRedirect()方法实现请求重定向外，还可以通过RequestDispatcher接口的实例对象来实现。与他相关的方法如下：</p>\r\r<p>1.getRequestDispatcher(String path)方法</p>\r\r<p>返回封装了某个路径所指定资源的RequestDispatcher对象。其中，参数path必须以&ldquo;/&rdquo;开头，用于表示当前Web应用的根目录。需要注意的是，WEB-INF目录中的内容对RequestDispatcher对象也是可见的。因此，传递给getRequestDispatcher(String path)方法的资源可以是WEB-INF目录中的文件。</p>\r\r<p>2.forword(ServletRequest request, ServletResponse response)方法</p>\r\r<p>该方法用于将请求从一个Servlet传递给另外一个Web资源。在Servlet中，可以对请求做一个初步处理，然后通过调用这个方法，将请求传递给其他资源进行响应。需要注意的是，该方法必须在响应提交给客户端之前被调用，否则将抛出IllegalStateException异常。</p>\r\r<p>3.include(ServletRequest request, ServletResponse response)方法</p>\r\r<p>下面介绍下请求转发：</p>\r\r<p>在Servlet中，如果当前Web资源不想处理请求时，可以通过forward()方法将当前请求传递给其它的Web资源进行处理，这种方式称为请求转发。请求转发的工作原理图如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/2928952655.png" style="width: 800px; height: 302px;" /></p>\r\r<p>从上图可以看出，当客户端访问Servlet1时，可以通过forward()方法将请求转发给其它的Web资源，其它Web资源处理完请求后，直接将响应结果返回到客户端。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 72),
(1240, '重定向和转发.png', '重定向和转发-png', 1542815868, 1542815868, 'a:5:{s:4:"name";s:22:"重定向和转发.png";s:4:"path";s:35:"/usr/uploads/2018/11/1785204927.png";s:4:"size";i:135048;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1241, 0),
(1241, '重定向和请求转发的区别', '1241', 1542815900, 1542815900, '<p>本文记录Java学习过程中遇到的重定向和请求转发的区别～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/1785204927.png" style="width: 800px; height: 391px;" /></p>\r\r<p>如上图，重定向和请求转发的区别如下：</p>\r\r<ol>\r	<li>重定向的地址栏会发生变化，请求转发的地址栏不变；</li>\r	<li>重定向两次请求两次响应，请求转发一次请求一次响应；</li>\r	<li>重定向路径需要加工程名，请求转发路径不需要加工程名；</li>\r	<li>重定向可以跳转到任何网站，请求转发只能在服务器内部进行转发。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 66),
(1242, '会话.png', '会话-png', 1543158235, 1543158235, 'a:5:{s:4:"name";s:10:"会话.png";s:4:"path";s:35:"/usr/uploads/2018/11/3229857868.png";s:4:"size";i:279347;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1243, 0),
(1243, '会话简介', '1243', 1543158252, 1543158252, '<p>本文记录Java学习过程中遇到的会话～</p>\r<!--more-->\r\r<p>在日常生活中，从拨通电话到挂断电话之间的一连串的你问我答的过程就是一次会话。Web应用中的会话过程类似于生活中的打电话过程，它指的是一个客户端（浏览器）与Web服务器之间连续发生的一系列请求和响应过程。例如，一个用户在某网站上的整个购物过程就是一次会话。</p>\r\r<p>在打电话过程中，通话双方会有通话内容，同样，在客户端与服务器端交互的过程中，也会产生一些数据。例如，用户甲和乙分别登陆了一个购物网站，甲购买了一个手机，乙购买了一个平板，当这个两个用户结账时，Web服务器需要对用户甲和乙的信息分别进行保存。</p>\r\r<p>在前面章节讲解的对象中，HttpServletRequest对象和ServletContext对象都可以对数据进行保存，但是这两个对象都不可行，具体原因如下：</p>\r\r<p>客户端请求Web服务器时，针对每次HTTP请求，Web服务器都会创建一个HttpServletRequest对象，该对象只能保存本次请求所传递的数据。由于购买和结账是两个不同的请求，所以在发送结账请求的时候，之前购买请求中的数据将会丢失；<br />\r使用ServletContext对象保存数据时，由于同一个Web应用共享的是同一个ServletContext对象，所以当用户在发送结账请求时，服务器无法区分哪些商品是哪个用户所购买的，而会将该购物网站中所有用户购买的商品进行结算，这显然是不对的；<br />\r为了保存会话过程中产生的数据，在Servlet技术中，提供了两个用于保存会话数据的对象，分别是Cookie和Session。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/3229857868.png" style="width: 800px; height: 211px;" />​</p>\r\r<p>注意：cookie和浏览器缓存是有区别的，浏览器缓存可以缓存任意内容（上网浏览的所有内容），cookie只是服务器需要浏览器缓存的数据（浏览器缓存中的一部分）。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 59),
(1244, 'Cookie传输过程.png', 'Cookie传输过程-png', 1543159293, 1543159293, 'a:5:{s:4:"name";s:22:"Cookie传输过程.png";s:4:"path";s:35:"/usr/uploads/2018/11/2703207967.png";s:4:"size";i:246557;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1246, 0),
(1245, 'cookie.png', 'cookie-png', 1543159338, 1543159338, 'a:5:{s:4:"name";s:10:"cookie.png";s:4:"path";s:35:"/usr/uploads/2018/11/1136607084.png";s:4:"size";i:414786;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1246, 0),
(1246, 'Cookie简介', '1246', 1543159358, 1543159358, '<p>本文记录Java学习过程中遇到的Cookie～</p>\r<!--more-->\r\r<p>在日常生活中，当顾客在购物时，商城经常会赠送顾客一张会员卡，卡上记录用户的个人信息（姓名和手机号等）、消费额度和积分额度等。顾客一旦接受了会员卡，以后每次光临该商场时，都可以使用这张会员卡，商场也将根据会员卡上的消费记录计算会员的优惠额度和累积积分。</p>\r\r<p>在Web应用中，Cookie的功能类似于这张会员卡，当用户通过浏览器访问Web服务器时，服务端会给客户端发送一些信息，这些信息都保存在Cookie中。这样，当该浏览器再次访问服务器时，都会在请求头中将Cookie发送给服务器，方便服务器对浏览器作出正确的响应。</p>\r\r<p>服务器向客户端发送Cookie时，会在HTTP响应头字段中增加Set-Cookie响应头字段。Set-Cookie头字段中设置的Cookie遵循一定的语法格式，具体如下：</p>\r\r<p>Set-Cookie: key=value; path=/;</p>\r\r<p>在上述示例中，key表示cookie的名称，value表示cookie的值，path表示cookie的属性。需要注意的是，cookie必须以键值对的形式存在，其属性可以有多个，这些属性之间必须用分号和空格分隔。</p>\r\r<p>了解了cookie信息的发送方式后，接下来，通过一张图来描述cookie在浏览器和服务器之后的传输过程，如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/2703207967.png" style="width: 800px; height: 277px;" /></p>\r\r<p>在上图中，描述了cookie在浏览器和服务器之间的传输过程。当用户第一次访问服务器时，服务器会在响应消息中增加Set-Cookie头字段，将用户信息以Cookie的形式发送给浏览器。一旦用户浏览器接受了服务器发送的Cookie消息，就会将它保存在浏览器的缓冲区中。这样，当浏览器后续访问服务器时，都会在请求消息中将用户信息以cookie的形式发送给Web服务器，从而使服务器分辨出当前请求是由哪个用户发出的。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/11/1136607084.png" style="width: 800px; height: 250px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 79),
(1247, 'Cookie常用的API', '1247', 1543160038, 1543160038, '<p>本文记录Java学习过程中遇到的Cookie常用的API～</p>\r\r<!--more-->\r\r<p>1.new Cookie(String key, Stirng value)方法</p>\r\r<p>创建cookie。</p>\r\r<p>2.response.addCookie(cookie)方法</p>\r\r<p>将cookie发送给浏览器。</p>\r\r<p>3.request.getCookies()方法</p>\r\r<p>获取客户端发送过来的所有cookie。</p>\r\r<p>4.getName()方法</p>\r\r<p>获取cookie的名称。</p>\r\r<p>5.getValue()方法</p>\r\r<p>获取cookie的值。</p>\r\r<p>6.setMaxAge(int expiry)方法</p>\r\r<p>设置cookie的有效时间：如果没有设置，cookie只缓存到浏览器缓存中，浏览器关闭cookie就会被删除；如果设置有效时间，在时间范围内，cookie被写入浏览器端的硬盘上，下次打开浏览器仍然客户访问到，知道cookie过期</p>\r\r<p>7.setPath(String uri)方法</p>\r\r<p>设置cookie允许被访问的路径，设置的路径以及自路径都被允许访问。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 61),
(1248, 'Cookie的分类', '1248', 1543160400, 1554079078, '<p>本文记录Java学习过程中遇到的Cookie的分类～</p>\r<!--more-->\r\r<p>会话级别的Cookie：默认的，关闭了浏览器Cookie就销毁了；</p>\r\r<p>持久级别的Cookie：需要设置有效时间。</p>\r\r<p>setMaxAge(0)：手动删除持久性的Cookie（前提是path和name必须一致）。</p>\r\r<p>cookie的唯一标示是domain+path+name：</p>\r\r<ul>\r	<li>domain：域名；</li>\r	<li>path：路径；</li>\r	<li>name：cookie的名称。</li>\r</ul>\r\r<p>注意：如果路径和名称一样，两次addCookie()，后者将覆盖前者。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 94),
(1249, 'Session简介', '1249', 1543243433, 1543243433, '<p>本文记录Java学习过程中遇到的Session～</p>\r\r<!--more-->\r\r<p>当人们去医院就诊时，就诊病人需要办理医院的就诊卡，该卡上只有卡号，没有其它信息。但病人每次去该医院就诊时，只要出示就诊卡，医务人员便可根据卡号查询病人的就诊信息。Session技术就好比医院发放给病人的就诊卡和医院为每个病人保留病例档案的过程。当浏览器访问Web服务器时，Servlet容器就会创建一个Session对象和ID属性，其中，Session对象就相当于病历档案，ID就相当于就诊卡号。当客户端后续访问服务器时，只要将标识号传递给服务器，服务器就能判断出该请求是哪个客户端发送的，从而选择与之相应的Session对象为其服务。</p>\r\r<p>需要注意的是，由于客户端需要接收、记录和回送Session对象的ID。因此，通常情况下，Session是借助Cookie技术来传递ID属性的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 97);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1250, 'Session常用的API', '1250', 1543244400, 1543244468, '<p>本文记录Java学习过程中遇到的Session常用的API～</p>\r\r<!--more-->\r\r<p>1.getSession(boolean create)和getSession()方法</p>\r\r<p>这两个方法都用于返回与当前请求相关的HttpSession对象。不同的是，第一个getSession()方法根据传递的参数来判断是否创建新的HttpSession对象，如果参数为true，则在相关的HttpSession对象不存在时创建并返回新的HttpSession对象，否则不创建新的HttpSession对象，而是返回null；第二个getSession()方法则相当于第一个方法参数为true时的情况，在相关的HttpSession对象不存在时总是创建新的HttpSession对象。</p>\r\r<p>2.getId()方法</p>\r\r<p>用于返回与当前HttpSession对象关联的会话标识号。</p>\r\r<p>3.getCreationTime()方法</p>\r\r<p>返回Session创建的时间，这个时间是创建Session的时间与1970年1月1日0点之间时间差的毫秒值。</p>\r\r<p>4.getLastAccessedTime()方法</p>\r\r<p>返回客户端最后一次发送与Session相关请求的时间，这个时间是发送请求的时间与1970年1月1日0点之间时间差的毫秒值。</p>\r\r<p>5.setMaxInactiveInterval(int interval)方法</p>\r\r<p>用于设置当前HttpSession对象可空闲的以秒为单位的最长时间，也就是修改当前会话的默认超时间隔。</p>\r\r<p>6.isNew()方法</p>\r\r<p>判断当前HttpSession对象是否是新创建的。</p>\r\r<p>7.invalidate()方法</p>\r\r<p>用于强制使Session对象无效。</p>\r\r<p>8.getServletContext()方法</p>\r\r<p>用于返回当前HttpSession对象所属于的Web应用程序对象，即当前Web应用的ServletContext对象。</p>\r\r<p>9.setAttribute(String name, Object o)方法</p>\r\r<p>用于将一个对象与一个名称关联后存储到当前的HttpSession对象中。</p>\r\r<p>10.getAttribute(String name)方法</p>\r\r<p>用于从当前的HttpSession对象中返回指定名称的属性对象。</p>\r\r<p>11.removeAttribute(String name)方法</p>\r\r<p>用于从当前的HttpSession对象中删除指定名称的属性对象。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 132),
(1251, 'JSP简介', '1251', 1543850989, 1543850989, '<p>本文记录Java学习过程中遇到的JSP简介～</p>\r<!--more-->\r\r<p>JSP全名是Java Server Pages，它是建立在Servlet规范之上的动态网页开发技术。在JSP文件中，HTML代码与Java代码共同存在。其中，HTML代码用来实现网页中静态内容的显示，Java代码用来实现网页中动态内容的显示。为了与传统的HTML有所区别，JSP文件的扩展名为.jsp。</p>\r\r<p>JSP技术所开发的Web应用程序是基于Java的，它可以用一种简洁而快速的方法从Java程序生成Web页面，其使用上具有如下几点特征：</p>\r\r<ul>\r	<li>跨平台：由于JSP是基于Java语言的，它可以使用Java API，所以它也是跨平台的，可以应用于不同的系统中，如Windows和Linux等。当从一个平台移植到另一个平台时，JSP和JavaBean的代码并不需要重新编译，这是因为Java的字节码是与平台无关的，这也应验了Java语言&ldquo;一次编译，到处执行&rdquo;的特点；</li>\r	<li>业务代码相分离：在使用JSP技术开发Web应用时，可以将页面的开发与应用程序的开发分离开。开发人员使用HTML来设计页面，使用JSP标签和脚本来动态生成页面上的内容。在服务器端，JSP引擎（或容器）负责解析JSP标签和脚本程序，生成所请求的内容，并将执行结果以HTML页面的形式返回到浏览器；</li>\r	<li>组件重用：JSP中可以使用JavaBean编写业务组件，也就是使用一个JavaBean类封装业务处理代码或者作为一个数据存储模型，在JSP页面中，甚至在整个项目中，都可以重复使用这个JavaBean，同时，JavaBean也可以应用到其它Java应用程序中；</li>\r	<li>预编译：预编译就是在用户第一次通过浏览器访问JSP页面时，服务器将对JSP页面代码进行编译，并且仅执行一次编译。编译好的代码将被保存，在用户下一次访问时，会直接执行编译好的代码。这样不仅节约了服务器的CPU资源，还大大提升了客户端的访问速度。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 107),
(1252, 'JSP运行原理', '1252', 1543851639, 1543851639, '<p>本文记录Java学习过程中遇到的JSP运行原理～</p>\r<!--more-->\r\r<p>JSP的工作模式是请求/响应模式，客户端首先发出HTTP请求，JSP程序收到请求后进行处理并返回处理结果。在一个JSP文件第一次被请求时，JSP引擎（或容器）把该JSP文件转换成为一个Servlet，而这个引擎本身也是一个Servlet。JSP的运行过程如下图所示：</p>\r\r<p>JSP的运行过程具体如下：</p>\r\r<ol>\r	<li>客户端发出请求，访问JSP文件；</li>\r	<li>JSP容器先将JSP文件转换成一个Java源文件（Java Servlet源程序），在转换过程中，如果发现JSP文件中存在任何语法错误，则中断转换过程，并向服务端和客户端返回出错信息；</li>\r	<li>如果转换成功，则JSP容器将生成的Java源文件编译成相应的字节码文件，该文件及时一个Servlet，Servlet容器会像处理其它Servlet一样来处理它。</li>\r</ol>\r\r<p>注意：JSP本质上就是Servlet。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 146),
(1253, 'JSP脚本元素', '1253', 1543942365, 1543942365, '<p>本文记录Java学习过程中遇到的JSP脚本元素～</p>\r<!--more-->\r\r<div>JSP脚本元素是指套在&lt;%和%&gt;之中的一条或多条Java程序代码。通过JSP脚本元素可以将Java代码嵌入HTML页面中，所有可执行的Java代码，都可以通过JSP脚本来执行。</div>\r\r<div>&nbsp;</div>\r\r<div>JSP脚本元素主要包括三种类型：</div>\r\r<div>&nbsp;</div>\r\r<ul>\r	<li>JSP Scriptlet；</li>\r	<li>JSP声明语句；</li>\r	<li>JSP表达式。</li>\r</ul>\r\r<div>&nbsp;</div>\r\r<div>1.JSP Scriptlet</div>\r\r<div>&nbsp;</div>\r\r<div>JSP Scriptlet是一段代码段。当需要使用Java实现一些复杂操作或控制时，可以使用它。JSP Scriptlet的语法格式为：</div>\r\r<div>\r<pre class="brush:xml;">\r&lt;% Java代码（变量、方法或语句等） %&gt;</pre>\r</div>\r\r<div>在JSP Scriptlet中声明的变量是JSP页面的局部变量，调用JSP Scriptlet时，会为局部变量分配内存空间，调用结束后，释放局部变量占用的内存空间。</div>\r\r<div>&nbsp;</div>\r\r<div>2.JSP声明语句</div>\r\r<div>&nbsp;</div>\r\r<div>JSP的声明语句用于声明变量和方法，以&lt;%!开始，以%&gt;结束，其语法格式如下：</div>\r\r<div>\r<pre class="brush:xml;">\r&lt;%!\r定义的变量或方法等\r%&gt;</pre>\r</div>\r\r<div>在上述语法格式中，被声明的Java代码将被编译到Servlet的_jspService()方法之外，即在JSP声明语句中定义的都是成员方法、成员变量、静态方法、静态变量和静态代码块等。在JSP声明语句中声明的方法在整个JSP页面内都有效。</div>\r\r<div>&nbsp;</div>\r\r<div>在一个JSP页面中可以有很多个JSP声明语句，单个声明中的Java语句可以是不完整的，但是多个声明组合后的结果必须是完整的Java语句。</div>\r\r<div>&nbsp;</div>\r\r<div>注意：&lt;%!和%&gt;是用来定义成员变量属性和方法的，&lt;%和%&gt;主要是用来输出内容的。因此，如果涉及到了成员变量的操作，那么就应该使用&lt;%!和%&gt;，而如果是涉及到了输出内容的时候，就使用&lt;%和%&gt;。</div>\r\r<div>&nbsp;</div>\r\r<div>3.JSP表达式</div>\r\r<div>&nbsp;</div>\r\r<div>JSP表达式用于将程序数据输出到客户端，它将要输出的变量或者表达式直接封装在以&lt;%=开头和以%&gt;结尾的标记中，其基本语法为：</div>\r\r<div>\r<pre class="brush:xml;">\r&lt;%= expression %&gt;</pre>\r</div>\r\r<div>在上述语法格式中，JSP表达式会将&ldquo;expression&rdquo;表达式的结果输出到浏览器中。</div>\r\r<div>&nbsp;</div>\r\r<div>注意：</div>\r\r<ul>\r	<li>&lt;%=和%&gt;标记之间插入的是表达式，不能插入语句；</li>\r	<li>&lt;%=是一个完整的符号，&lt;%和=之间不能有空格；</li>\r	<li>JSP表达式中的变量或表达式后面不能有分号。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 123),
(1254, 'JSP注释对比.png', 'JSP注释对比-png', 1544264828, 1544264828, 'a:5:{s:4:"name";s:19:"JSP注释对比.png";s:4:"path";s:34:"/usr/uploads/2018/12/347173792.png";s:4:"size";i:67190;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1255, 0),
(1255, 'JSP注释', '1255', 1544264865, 1544264865, '<p>本文记录Java学习过程中遇到的JSP注释～</p>\r<!--more-->\r\r<p>通其它各种编程语言一样，JSP也有自己的注释方式，其基本语法格式为：</p>\r\r<pre class="brush:xml;">\r&lt;%-- 注释信息 --%&gt;</pre>\r\r<p>需要注意的是，Tomcat在将JSP页面编译成Servlet程序时，会忽略JSP页面中被注释的内容，不会将注释信息发送到客户端。</p>\r\r<p>JSP中可能用到的注释有三种：</p>\r\r<p>1.JSP注释</p>\r\r<pre class="brush:xml;">\r&lt;%-- JSP注释 --%&gt;</pre>\r\r<p>2.Java注释</p>\r\r<pre class="brush:xml;">\r&lt;% //Java注释 %&gt;</pre>\r\r<p>3.HTML注释</p>\r\r<pre class="brush:xml;">\r&lt;!-- HTML注释 --&gt;</pre>\r\r<p>它们的区别如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/347173792.png" style="width: 800px; height: 121px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 95),
(1256, 'page指令.png', 'page指令-png', 1544266979, 1544266979, 'a:5:{s:4:"name";s:14:"page指令.png";s:4:"path";s:35:"/usr/uploads/2018/12/2723475645.png";s:4:"size";i:415473;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1257, 0),
(1257, 'JSP指令', '1257', 1544266980, 1544267900, '<p>本文记录Java学习过程中遇到的JSP指令～</p>\r<!--more-->\r\r<p>为了设置JSP页面的一些信息，Sun公司提供了JSP指令。</p>\r\r<p>JSP2.0中共定义了page、include和taglib三种指令，每种指令都定义了各自的属性。</p>\r\r<p>1.page指令</p>\r\r<p>在JSP页面中，经常需要对页面的某些特性进行描述。例如，页面的编码方式，JSP页面采用的语言等，这时可以通过page指令来实现。page指令的基本语法格式为：</p>\r\r<pre class="brush:xml;">\r&lt;%@page key1=&quot;value1&quot; key2=&quot;value2&quot; %&gt;</pre>\r\r<p>在上面的语法格式中，page用于声明指令名称，属性用来指定JSP页面的某些特性。page指令提供了一系列与JSP页面相关的属性，如下所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/2723475645.png" style="width: 800px; height: 1026px;" /></p>\r\r<p>上表列举了page指令的常见属性。其中，除了import属性外，其他的属性都只能出现一次，否则会编译失败。注意，page指令的属性名称都是区分大小写的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;%@ page language=&quot;java&quot; contextType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;\r&lt;%@ page import=&quot;java.awt.*% &gt;\r&lt;%@ page import=&quot;java.util.*&quot;,&quot;java.awt.*&quot; %&gt;</pre>\r\r<p>上面的代码中使用了page指令的language、contextType、pageEncoding和import属性。</p>\r\r<p>注意，page执行对整个页面都有效，而与其书写的位置无关，但是习惯上把page指令写在JSP页面的最前面。</p>\r\r<p>2.include指令</p>\r\r<p>在实际开发中，有时需要在JSP页面静态包含一个文件，例如HTML文件和文本文件等，这时可以通过include执行来实现，include指令的语法格式为：</p>\r\r<pre class="brush:xml;">\r&lt;%@ include file=&quot;被包含的文件地址&quot; %&gt;</pre>\r\r<p>include指令只有一个file属性，该属性用来指定插入到JSP页面目标位置的文件资源。</p>\r\r<p>关于include指令的具体应用，有很多问题需要注意，具体如下：</p>\r\r<ol>\r	<li>被引入的文件必须遵循JSP语法，其中的内容可以包含静态HTML、JSP脚本元素和JSP指令等普通JSP页面所具有的一切内容；</li>\r	<li>除了指令元素之外，被引入的文件中的其它元素都被转换成相应的Java源代码，然后插入进当前JSP页面所翻译成的Servlet源文件中，插入位置与include指令在当前JSP页面中的位置保持一致。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 88),
(1258, 'JSP内置对象', '1258', 1544271900, 1544272912, '<p>本文记录Java学习过程中遇到的JSP内置对象～</p>\r<!--more-->\r\r<p>在JSP页面中，有一些对象需要频繁使用，如果每次都重新创建这些对象就会非常麻烦。为了简化Web应用程序的开发，JSP2.0规范中提供了9个隐式（内置）对象，它们是JSP默认创建的，可以直接在JSP页面中使用。</p>\r\r<p>这9个隐式对象的名称、类型和描述如下表：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/65779486.png" style="width: 800px; height: 370px;" /></p>\r\r<p>在上表中，列举了JSP的9个隐式对象及它们各自对应的类型。</p>\r\r<p>1.out对象</p>\r\r<p>在JSP页面中，经常需要向客户端发送文本内容。这时，可以使用out对象来实现。out对象是javax.servlet.jsp.JspWriter类的实例对象，它的作用与ServletResponse.getWriter()方法返回的PrintWriter对象非常相似，都是用于向客户端发送文本形式的实体内容。不同的是，out对象的类型为JspWriter，它相当于一种带缓冲功能的PrintWriter。</p>\r\r<p>JSP页面的out对象与Servlet引擎提供的缓冲区之间的工作关系如下图所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/1927707483.png" style="width: 800px; height: 353px;" /></p>\r\r<p>从上图可以看出，在JSP页面中，通过out隐式对象写入数据相当于将数据插入到JspWriter对象的缓冲区中，只有调用了ServletResponse.getWriter()方法，缓冲区中的数据才能真正写入到Servlet引擎所提供的缓冲区中。</p>\r\r<p>2.pageContent对象</p>\r\r<p>在JSP页面中，使用pageContext对象可以获取JSP的其他8个隐式对象。pageContext对象是javax.servlet.jsp.PageContext类的实例对象，它代表当前JSP页面的运行环境，并提供了一系列用于获取其他隐式对象的方法。PageContext对象获取隐式对象的方法如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/4193055990.png" style="width: 800px; height: 269px;" /></p>\r\r<p>上表中列举了pageContext获取其他隐式对象的方法。这样，当传递一个pageContext对象后，就可以通过这些方法轻松地获取到其他8个隐式对象。</p>\r\r<p>pageContext对象不仅提供了获取隐式对象的方法，还提供了存储数据的功能。pageContext对象存储数据是通过操作属性实现的，下表列举了pageContext操作属性的一系列方法：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/2965221094.png" style="width: 800px; height: 208px;" /></p>\r\r<p>上表列举了pageContext对象操作属性的相关方法。其中，参数name指定的属性名称，参数scope指定的是属性的作用范围。</p>\r\r<p>pageContext对象的作用范围有4个值，具体如下：</p>\r\r<ul>\r	<li>PageContext.PAGE_SCOPE：表示页面范围；</li>\r	<li>PageContext.REQUEST_SCOPE：表示请求范围；</li>\r	<li>PageContext.SESSION_SCOPE：表示会话范围；</li>\r	<li>PageContext.APPLICATION_SCOPE：表示Web应用程序范围。</li>\r</ul>\r\r<p>需要注意的是，当使用findAttribute()方法查找名称为name的属性时，会按照page、request、session和application的顺序依次进行查找。如果找到，则返回属性的名称，否则返回null。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 141),
(1259, 'JSP隐式对象.png', 'JSP隐式对象-png', 1544272821, 1544272821, 'a:5:{s:4:"name";s:19:"JSP隐式对象.png";s:4:"path";s:33:"/usr/uploads/2018/12/65779486.png";s:4:"size";i:180143;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1258, 0),
(1260, '缓冲区.png', '缓冲区-png', 1544272849, 1544272849, 'a:5:{s:4:"name";s:13:"缓冲区.png";s:4:"path";s:35:"/usr/uploads/2018/12/1927707483.png";s:4:"size";i:93131;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1258, 0),
(1261, 'pageContext对象获取隐式对象.png', 'pageContext对象获取隐式对象-png', 1544272873, 1544272873, 'a:5:{s:4:"name";s:39:"pageContext对象获取隐式对象.png";s:4:"path";s:35:"/usr/uploads/2018/12/4193055990.png";s:4:"size";i:166009;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1258, 0),
(1262, 'pageContext对象操作属性.png', 'pageContext对象操作属性-png', 1544272897, 1544272897, 'a:5:{s:4:"name";s:33:"pageContext对象操作属性.png";s:4:"path";s:35:"/usr/uploads/2018/12/2965221094.png";s:4:"size";i:93902;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1258, 0),
(1263, 'JSP隐式对象.png', 'JSP隐式对象-png-1', 1544272930, 1544272930, 'a:5:{s:4:"name";s:19:"JSP隐式对象.png";s:4:"path";s:35:"/usr/uploads/2018/12/1012157239.png";s:4:"size";i:180143;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 0, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1258, 0),
(1264, '作用域范围的区别.png', '作用域范围的区别-png', 1544273397, 1544273397, 'a:5:{s:4:"name";s:28:"作用域范围的区别.png";s:4:"path";s:34:"/usr/uploads/2018/12/883939486.png";s:4:"size";i:64271;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1265, 0),
(1265, 'JSP四个域对象范围', '1265', 1544273400, 1544273448, '<p>本文记录Java学习过程中遇到的JSP四个域对象范围～</p>\r\r<!--more-->\r\r<p>JSP中有四个对象：</p>\r\r<ul>\r	<li>page：表示当前页，通常没用，JSP标签底层使用；</li>\r	<li>request：表示一次请求，通常一次请求就一个页面，但如果使用请求转发，可以涉及多个页面；</li>\r	<li>session：表示一次会话，可以在多次请求之间共享数据；</li>\r	<li>application：表示一个Web应用，整个Web应用共享，多次会话共享数据。</li>\r</ul>\r\r<p>作用范围的区别可以总结为下表：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/883939486.png" style="width: 800px; height: 152px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 78),
(1266, '包含区别.png', '包含区别-png', 1544275700, 1544275700, 'a:5:{s:4:"name";s:16:"包含区别.png";s:4:"path";s:35:"/usr/uploads/2018/12/2711830358.png";s:4:"size";i:553374;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1267, 0),
(1267, 'JSP动作对象', '1267', 1544275680, 1544275870, '<p>本文记录Java学习过程中遇到的JSP动作对象～</p>\r<!--more-->\r\r<p>JSP动作元素用来控制JSP的行为，执行一些常见的JSP页面动作。通过动作元素可以实现使用多行Java代码能够实现的效果，如包含页面文件、实现请求转发等。</p>\r\r<p><strong>&lt;jsp:include&gt;动作对象</strong></p>\r\r<p>在JSP页面中，为了把其他资源的输出内容插入到当前JSP页面的输出内容中，JSP技术提供了&lt;jsp:include&gt;动作元素，&lt;jsp:include&gt;动作元素的具体语法格式如下所示：</p>\r\r<pre class="brush:xml;">\r&lt;jsp:include page=&quot;relativeURL&quot; flush=&quot;true|false&quot; /&gt;</pre>\r\r<p>在上述语法格式中，page属性用于指定被引入资源的相对路径，flush属性用于指定是否将当前页面的输出内容刷新到客户端，默认情况下，flush属性的值为false。</p>\r\r<p>&lt;jsp:include&gt;包含的原理是将被包含的页面编译处理后将结果包含在页面中。当浏览器第一次请求一个使用&lt;jsp:include&gt;包含其他页面中，之后编译包含页面，最后将两个页面组合的结果回应给浏览器。</p>\r\r<p>需要注意的是，虽然include指令和&lt;jsp:include&gt;标签都能够包含一个文件，但它们之间有很大的区别，具体如下：</p>\r\r<p>&lt;jsp:include&gt;标签中要引入的资源和当前JSP页面是两个彼此独立的执行实体，即被动态引入的资源必须能够被Web容器独立执行。而include指令只能引入遵循JSP格式的文件，被引入文件与当前JSP文件需要共同合并才能翻译成一个Servlet源文件；<br />\r&lt;jsp:include&gt;标签中引入的资源是在运行才包含的，而且只包含运行结果；而include指令引入的资源是在编译时期包含的，包含的是源代码；<br />\r&lt;jsp:include&gt;标签运行原理与RequestDispatcher.include()方法类似，即被包含的页面不能改变响应状态码或者设置响应头，而include指令没有这方面的限制。</p>\r\r<p>动态包含与静态包含的区别可以用下图来总结：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/2711830358.png" style="width: 800px; height: 330px;" />​</p>\r\r<p><strong>&lt;jsp:forward&gt;动作对象</strong></p>\r\r<p>&lt;jsp:forward&gt;可以进行请求转发，其基本语法格式为：</p>\r\r<pre class="brush:xml;">\r&lt;jsp:forward page=&quot;targetURL&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 130),
(1268, 'EL表达式简介', '1268', 1544837827, 1544837827, '<p>本文记录Java学习过程中遇到的EL表达式简介～</p>\r\r<!--more-->\r\r<p>在JSP开发中，为了获取Servlet域对象中存储的数据，经常需要书写很多Java代码，这样的做法会使JSP页面混乱，难以维护。为此，在JSP2.0规范中提供了EL表达式。EL是Expression Language的缩写，它是一种简单的数据访问语言。EL设计的目的是为了使JSP写起来更加简单。表达式语言的灵感来自于ECMAScript和XPath表达式语言，它提供了在JSP中简化表达式的方法，让JSP的代码更加简化。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 76),
(1269, 'EL表达式语法', '1269', 1544838050, 1544838050, '<p>本文记录Java学习过程中遇到的EL表达式语法～</p>\r<!--more-->\r\r<p>由于EL可以简化JSP页面的书写。因此，在JSP的学习中，掌握EL是相当重要的。要使用EL表达式，首先要学习它的语法。EL表达式的语法非常简单，都是以&quot;${&quot;符号开始，以&quot;}&quot;符号结束的，具体格式如下：</p>\r\r<pre class="brush:java;">\r${表达式}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 129),
(1270, 'EL表达式的内置对象', '1270', 1544840823, 1544840823, '<p>本文记录Java学习过程中遇到的EL表达式的内置对象～</p>\r<!--more-->\r\r<div>&nbsp;</div>\r\r<div>EL表达式的内置对象有6类，分别如下：</div>\r\r<div>&nbsp;</div>\r\r<div>1.作用域：</div>\r\r<div>&nbsp;</div>\r\r<ul>\r	<li>pageScope：page作用域；</li>\r	<li>requestScope：request作用域；</li>\r	<li>sessionScope：session作用域；</li>\r	<li>applicationScope：application作用域。</li>\r</ul>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>&nbsp;</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%-- 初始化数据 --%&gt;\r&lt;% \rpageContext.setAttribute(&quot;name&quot;, &quot;value&quot;);\rrequest.setAttribute(&quot;name&quot;, &quot;value&quot;);\rsession.setAttribute(&quot;name&quot;, &quot;value&quot;);\rapplication.setAttribute(&quot;name&quot;, &quot;value&quot;);\r%&gt;\r\r&lt;%-- 使用JSP脚本获取值，没找到返回null --%&gt;\r&lt;%=pageContext.getAttribute(&quot;name&quot;) %&gt;\r&lt;%=request.getAttribute(&quot;name&quot;) %&gt;\r&lt;%=session.getAttribute(&quot;name&quot;) %&gt;\r&lt;%=application.getAttribute(&quot;name&quot;) %&gt;\r\r&lt;%-- 使用EL获取值，没找到返回&ldquo;&rdquo; --%&gt;\r${ pageScope.name }\r${ requestScope.name }\r${ sessionScope.name }\r${ applicationScope.name }\r\r&lt;%-- 依次获得数据域，顺序为：page&gt;request&gt;session&gt;application --%&gt;\r${ name }</pre>\r</div>\r\r<div>2.请求参数：</div>\r\r<ul>\r	<li>param：获得一个参数；</li>\r	<li>paramValues：获得一组参数。</li>\r</ul>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r//请求路径：/page.jsp?username=oliver&amp;hobby=a&amp;hobby=b&amp;hobby=c\r&lt;%--\rparam.xxx      //对应request.getParameter(&quot;xxx&quot;);\rparamValues.xxx //对应request.getParameterValues(&quot;xxx&quot;);\r--%&gt;\r${ param.username }\r${ param.hobby } &lt;%-- 获得第一个参数 --%&gt;\r${ paramValues.hobby } &lt;%-- 获得一组数据，使用数组 --%&gt;\r${ paramValues.hobby[1] } &lt;%-- 如果是数组，可以通过下标获取其中的值 --%&gt;</pre>\r</div>\r\r<div>3.请求头</div>\r\r<ul>\r	<li>header：获得一个请求头；</li>\r	<li>headerValues：获得一组请求头。</li>\r</ul>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%--\rheader.xxx  //对应request.getHeader(&quot;xxx&quot;)\rheaderValues.xxx //对应request.getHeaders(&quot;xxx&quot;)\r--%&gt;\r${ header.accept }\r\\${ header.accept-Encoding }\r&lt;%-- 非法的，有异常，&ldquo;-&rdquo;会被解析成减号，需要使用&ldquo;/&rdquo;进行大哥EL表达式转义 --%&gt;\r${ header[&#39;accept-Encoding&#39;] }\r${ headerValues[&#39;accept-Encoding&#39;][0] }</pre>\r</div>\r\r<div>4.JSP上下文对象</div>\r\r<ul>\r	<li>pageContext</li>\r</ul>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%--\rpageContext对应pageContext对象\r--%&gt;\r\r&lt;%=((HttpServletRequest)pageContext.getRequest()).getContextPath()%&gt;\r\r${ pageContext.request.contextPath }</pre>\r</div>\r\r<div>5.全局初始化参数</div>\r\r<ul>\r	<li>initParam</li>\r</ul>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%--\rweb.xml配置\r&lt;context-param&gt;\r&lt;param-name&gt;name&lt;/param-name&gt;\r&lt;param-value&gt;value&lt;/param-value&gt;\r&lt;/context-param&gt;\rinitPara对应的是servletContext.getInitParameter(&quot;name&quot;)\r--%&gt;\r\r${ initParam.person }</pre>\r</div>\r\r<div>6.cookie</div>\r\r<ul>\r	<li>cookie</li>\r</ul>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%--\rcookie没有对应api，底层使用request.getCookies()获得所有cookie，然后遍历并存到Map中(Map&lt;key, value&gt;)\r--%&gt;\r${ cookie } &lt;%--获取所有的cookie--%&gt;\r${ cookie.company } &lt;%--通过key获取对应的value--%&gt;\r${ cookie.company.name } &lt;%--通过JavaBean属性获得属性，获取cookie的名称--%&gt;\r${ cookie.company.value } &lt;%--通过JavaBean属性获得属性，获取cookie的取值--%&gt;</pre>\r</div>\r\r<div>注意，.和[]的区别有：1.[]用于有下标的数据(数组，list集合)，.用于有属性的数据(map,对象)；2.如果属性名中包含有特殊的字符，必须使用[]。</div>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 103),
(1271, 'EL表达式获取数据', '1271', 1544849220, 1544849344, '<p>本文记录Java学习过程中遇到的EL表达式获取数据～</p>\r<!--more-->\r\r<div>1.获得字符串（必须存放在作用域）</div>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%\rString str = &quot;Oliver&#39;s Blog&quot;;\rpageContext.setAttribute(&quot;string&quot;, str);\r%&gt;\r${ str }</pre>\r</div>\r\r<div>2.获得数组</div>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%\rString[] stringArray = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};\rpageContext.setAttribute(&quot;stringArray&quot;, stringArray, PageContext.REQUEST_SCOPE);\r%&gt;\r${ stringArray }\r${ stringArray[1] }</pre>\r</div>\r\r<div>3.获得List数据</div>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%\rList&lt;String&gt; list = new ArrayList&lt;String&gt;();\rlist.add(&quot;zhangsan&quot;);\rlist.add(&quot;lisi&quot;);\rlist.add(&quot;wangwu&quot;);\rpageContext.setAttribute(&quot;list&quot;, list);\r%&gt;\r${ list }\r${ list[2] }</pre>\r</div>\r\r<div>4.获得Map&lt;String, String&gt;数据</div>\r\r<div>&nbsp;</div>\r\r<div>示例代码：</div>\r\r<div>\r<pre class="brush:java;">\r&lt;%\rMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\rmap.put(&quot;a&quot;, &quot;a&quot;);\rmap.put(&quot;b&quot;, &quot;b&quot;);\rmap.put(&quot;c&quot;, &quot;c&quot;);\rpageContext.setAttribute(&quot;map&quot;, map);\r%&gt;\r${ map }\r${ map.a }\r\r5.获得Map&lt;String JavaBean&gt;数据\r\r&lt;%\rMap&lt;String, User&gt; map = new HashMap&lt;String, User&gt;();\rmap.put(&quot;a&quot;, new User(&quot;a&quot;, &quot;a&quot;, 1));\rmap.put(&quot;b&quot;, new User(&quot;b&quot;, &quot;b&quot;, 1));\rmap.put(&quot;c&quot;, new User(&quot;c&quot;, &quot;c&quot;, 1));\rpageContext.setAttribute(&quot;map&quot;, map);\r%&gt;\r\r${ map }\r${ map.b }\r${ map.b.userName }\r${ map[&#39;c&#39;].userName }</pre>\r</div>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 127),
(1272, 'EL表达式的运算符', '1272', 1544862840, 1544863169, '<p>本文记录Java学习过程中遇到的EL表达式的运算符～</p>\r<!--more-->\r\r<p>1.算数运算符</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/1191589525.png" style="width: 800px; height: 310px;" /></p>\r\r<p>2.逻辑运算符</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/2516268484.png" style="width: 800px; height: 335px;" /></p>\r\r<p>3.关系运算符</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/1934801369.png" style="width: 800px; height: 188px;" /></p>\r\r<p>4.三元运算符</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\r${ n1 &lt; n2 ? true : false }</pre>\r\r<p>5.empty运算符</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\r${ empty var }</pre>\r\r<p>具体作用：</p>\r\r<ol>\r	<li>对象是否为null；</li>\r	<li>运算符是否为null；</li>\r	<li>集合是否为0。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 81),
(1273, '算数运算符.png', '算数运算符-png', 1544862930, 1544862930, 'a:5:{s:4:"name";s:19:"算数运算符.png";s:4:"path";s:35:"/usr/uploads/2018/12/1191589525.png";s:4:"size";i:493452;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1272, 0),
(1274, '逻辑运算符.png', '逻辑运算符-png', 1544862956, 1544862956, 'a:5:{s:4:"name";s:19:"逻辑运算符.png";s:4:"path";s:35:"/usr/uploads/2018/12/2516268484.png";s:4:"size";i:562405;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1272, 0),
(1275, '关系运算符.png', '关系运算符-png', 1544862991, 1544862991, 'a:5:{s:4:"name";s:19:"关系运算符.png";s:4:"path";s:35:"/usr/uploads/2018/12/1934801369.png";s:4:"size";i:372233;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1272, 0),
(1276, 'JSTL.png', 'JSTL-png', 1544864247, 1544864247, 'a:5:{s:4:"name";s:8:"JSTL.png";s:4:"path";s:34:"/usr/uploads/2018/12/654945328.png";s:4:"size";i:246937;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1277, 0),
(1277, 'JSTL简介', '1277', 1544864265, 1544864265, '<p>本文记录Java学习过程中遇到的JSTL标签库～</p>\r<!--more-->\r\r<p>从JSP1.1规范开始，JSP就支持使用自定义标签，使用自定义标签大大降低了JSP页面的复杂度，同时增强了代码的重复性。为此，许多Web应用厂商都定制了自身应用的标签库，然而同一功能的标签由不同的Web应用厂商制定可能是不同的，这就导致世面上出现了很多功能相同的标签，令网页制作者无从选择。为了解决这个问题，Sun公司制定了一套标准标签库（Java Server Pages Standard Tag Library），简称JSTL。</p>\r\r<p>JSTL虽然被称为标准标签库，而实际上这个标签库是由5个不同功能的标签库共同组成的。在JSTL1.1规范中，为这5个标签库分别指定了不同的URI以及建议使用的前缀，如下表所示：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/654945328.png" style="width: 800px; height: 196px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 76),
(1278, 'JSTL常用标签', '1278', 1544866020, 1544867196, '<p>本文记录Java学习过程中遇到的JSTL常用标签～</p>\r<!--more-->\r\r<p>JSTL常用的标签库有两个，即if和foreach标签。</p>\r\r<p>1.if标签</p>\r\r<p>在程序开发中，经常需要使用if语句进行条件判断，如果要在JSP页面中进行条件判断，就需要使用Core标签库提供的&lt;c:if&gt;标签，该标签专门用于完成JSP页面中的条件判断，它有两种语法格式，具体如下：</p>\r\r<p>语法1：没有标签体的情况，将结果存放到指定的作用域</p>\r\r<pre class="brush:java;">\r&lt;c:if test=&quot;testCondition&quot; var=&quot;result&quot; [scope=&quot;{page|request|session|application}&quot;] /&gt;</pre>\r\r<p>语法2：有标签体的情况，在标签体中指定要输出的内容</p>\r\r<pre class="brush:java;">\r&lt;c:if test=&quot;testCondition&quot; &gt;\r    body content\r&lt;/c:if&gt;</pre>\r\r<p>在上述语法格式中，可以看到&lt;c:if&gt;标签有三个属性，具体如下：</p>\r\r<ul>\r	<li>test属性用于设置逻辑表达式，如果属性test的计算结果为true，那么标签体将被执行，否则标签体不会被执行；</li>\r	<li>var属性用于指定逻辑表达式中变量的名字；</li>\r	<li>scope属性用于指定var变量的作用范围，默认值为page。</li>\r</ul>\r\r<p>2.forEach标签</p>\r\r<p>在JSP页面中，经常需要对属性对象进行循环迭代操作。为此，Core标签库提供了一个&lt;c:forEach&gt;标签，该标签专门用于迭代集合对象中的元素，如Set、List、Map和数组等，并且能重复执行标签体中的内容，它有两种语法格式，具体如下：</p>\r\r<p>语法1：迭代包含多个对象的集合</p>\r\r<pre class="brush:xml;">\r&lt;c:forEach [var=&quot;varName&quot;] items=&quot;collection&quot; [varStatus=&quot;varStatusName&quot;] [begin=&quot;begin&quot;] [end=&quot;end&quot;] [step=&quot;step&quot;]&gt;\r	body content\r&lt;/c:forEach&gt;</pre>\r\r<p>语法2：迭代指定范围内的集合</p>\r\r<pre class="brush:xml;">\r&lt;c:forEach [var=&quot;varName&quot;] [varStatus=&quot;varStatusName&quot;] [begin=&quot;begin&quot;] [end=&quot;end&quot;] [step=&quot;step&quot;]&gt;\r	body content\r&lt;/c:forEach&gt;</pre>\r\r<p>在上述语法格式中，可以看到&lt;c:forEach&gt;标签有多个属性，具体解释如下：</p>\r\r<ul>\r	<li>var属性用于将当前迭代到的元素保存到page域中的名称；</li>\r	<li>items属性用于指定将要迭代的集合对象；</li>\r	<li>varStatus用于指定当前迭代状态信息的对象保存到page域中的名称，用于设置一个javax.servlet.jsp.jstl.core.LoopTagStatus类型的变量；</li>\r	<li>begin属性用于指定从集合中第几个元素开始进行迭代，begin的索引值从0开始，如果没有指定iterms属性，就从begin指定的值开始迭代，直到迭代结束为止；</li>\r	<li>step属性用于指定迭代的布长，即迭代因子的增量。</li>\r</ul>\r\r<p>&lt;c:forEach&gt;标签在程序开发中经常会被用到，因此熟练掌握&lt;c:forEach&gt;标签是很有必要的。</p>\r\r<p>使用&lt;c:forEach&gt;标签的varStatus属性可以获取以下信息：</p>\r\r<ul>\r	<li>count：表示元素在集合中的序号，从1开始计数；</li>\r	<li>index：表示当前元素在集合中的索引，从0开始计数；</li>\r	<li>first：表示当前是否为集合中的第一个元素；</li>\r	<li>last：表示当前是否为集合的最后一个元素。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 114),
(1279, 'MVC.png', 'MVC-png', 1544866830, 1544866830, 'a:5:{s:4:"name";s:7:"MVC.png";s:4:"path";s:35:"/usr/uploads/2018/12/2224206423.png";s:4:"size";i:413313;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1280, 0),
(1280, 'MVC设计模式', '1280', 1544866845, 1544866845, '<p>本文记录Java学习过程中遇到的MVC设计模式</p>\r<!--more-->\r\r<p>MVC设计模式，是Model-View-Controller的简写，是软件工程中的一种软件架构模式，是一种分离业务逻辑与页面显示的设计方法。它把软件系统分为三个基本部分：</p>\r\r<ul>\r	<li>控制器Controller：对请求进行处理，负责请求转发；</li>\r	<li>视图View：界面设计人员进行图形界面设计；</li>\r	<li>模型Model：编写程序应用的功能（实现算法等）和数据库管理。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/2224206423.png" style="width: 800px; height: 466px;" />​</p>\r\r<p>MVC可对程序的后期维护和扩展提供了方便，并且为程序某些部分的重用提供了方便。并且MVC也使程序简化，更加直观。</p>\r\r<p>注意：MVC不是Java所特有的，几乎现在所有B/S结构的软件都采用了MVC设计模式。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 113),
(1281, 'JSP开发模式', '1281', 1544871600, 1544871734, '<p>本文记录Java学习过程中遇到的JSP开发模式～</p>\r<!--more-->\r\r<p>当Sun公司推出JSP后，同时也提供了相应的开发模式，JavaWeb经历了JSP Model1第一代、JSP Model1第二代和JSP Model2三个时期。</p>\r\r<p>1.JSP Model1 第一代</p>\r\r<p>JSP Model试JavaWeb早起的模型，它适合小型Web项目，开发成本低。Model1第一代时期，服务端只有JSP页面，所有的操作都在JSP页面中，连访问数据库的API也在JSP页面中完成。也就是说，所有的东西都耦合在一起，对后期的维护和扩展极为不利。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/2052498915.png" style="width: 800px; height: 170px;" /></p>\r\r<p>2.JSP Model1 第二代</p>\r\r<p>JSP Model1第二代有所改进，把业务逻辑的内容放到了JavaBean中，而JSP页面负责显示以及请求调度的工作。虽然第二代比第一代好了些，但还让JSP做了很多的工作，JSP中把视图工作和请求调度（控制器）的工作耦合在一起了。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/1738223247.png" style="width: 800px; height: 241px;" /></p>\r\r<p>3.JSP Model2</p>\r\r<p>Model2使用到的技术有：Servelt、JSP和JavaBean。Model2是MVC设计模式在Java语言的具体体现。</p>\r\r<p>JSP：视图层，用来与用户打交道，负责接收用户的数据，以及显示数据给用户；<br />\rServlet：控制层，负责找到合适的模型对象来处理业务逻辑，转发到合适的视图；<br />\rJavaBean：模型层，完成具体的业务工作，例如：转账等。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/180442504.png" style="width: 800px; height: 509px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 71),
(1282, '003.png', '003-png-9', 1544871677, 1544871677, 'a:5:{s:4:"name";s:7:"003.png";s:4:"path";s:34:"/usr/uploads/2018/12/180442504.png";s:4:"size";i:698771;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1281, 0),
(1283, '001.png', '001-png-13', 1544871678, 1544871678, 'a:5:{s:4:"name";s:7:"001.png";s:4:"path";s:35:"/usr/uploads/2018/12/2052498915.png";s:4:"size";i:176246;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1281, 0),
(1284, '002.png', '002-png-9', 1544871679, 1544871679, 'a:5:{s:4:"name";s:7:"002.png";s:4:"path";s:35:"/usr/uploads/2018/12/1738223247.png";s:4:"size";i:214728;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1281, 0),
(1285, '三层架构.png', '三层架构-png', 1544872365, 1544872365, 'a:5:{s:4:"name";s:16:"三层架构.png";s:4:"path";s:35:"/usr/uploads/2018/12/4026833044.png";s:4:"size";i:278241;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1286, 0),
(1286, 'Java三层架构', '1286', 1544872379, 1544872379, '<p>本文记录Java学习过程中遇到的Java三层架构～</p>\r<!--more-->\r\r<p>JSP模式是理论基础，但实际开发中，我们常将服务器端程序根据逻辑进行分层。一般比较常见的是分三层，一般称为经典三层体系架构。三层分别是：表示层、业务逻辑层和数据访问层，具体解释如下：</p>\r\r<ul>\r	<li>表示层：又称为web层，与浏览器进行数据交互的；</li>\r	<li>业务逻辑层：又称为service层，专门用于处理业务数据的；</li>\r	<li>数据访问层：又称为dao层，与数据库进行数据交换的，将数据库的一条记录与JavaBean进行对应。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/4026833044.png" style="width: 800px; height: 246px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(1287, '事务简介', '1287', 1545456995, 1545456995, '<p>本文记录Java学习过程中遇到的事物～</p>\r\r<!--more-->\r\r<p>事务指的是逻辑上的一组操作，组成这组操作的各个单元要么全部成功，要么全部失败。</p>\r\r<p>事务的作用：保证在一个事务中多次操作要么全部成功，要么全部失败。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 52),
(1288, 'MySQL事务操作', '1288', 1545457440, 1545457511, '<p>本文记录MySQL学习过程中遇到的事务操作～</p>\r<!--more-->\r\r<p>MySQL中针对事务的操作常用的SQL语句有三个：</p>\r\r<ul>\r	<li>start transaction：开启事务；</li>\r	<li>commit：提交事务；</li>\r	<li>rollback：回滚事务。</li>\r</ul>\r\r<p>示例代码（手动提交）：</p>\r\r<pre class="brush:sql;">\rstart transaction;\rupdate account set money=money-100 where userid=1;\rupdate account set money=money+100 where userid=2;\rcommit;或者rollback;</pre>\r\r<p>示例代码（自动提交）：</p>\r\r<pre class="brush:sql;">\rshow variables like &#39;autocommit&#39;;\rset autocommit = 0;</pre>\r\r<p>注意：MySQL事务的自动提交默认是打开的，而Oracle默认是关闭的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 70),
(1289, 'JDBC事务操作', '1289', 1545457890, 1545457890, '<p>本文记录Java学习过程中遇到的JDBC事务操作～</p>\r<!--more-->\r\r<p>JDBC中针对事务的操作常用方法有三个：</p>\r\r<ul>\r	<li>conn.setAutoCommit(false)：开启事务；</li>\r	<li>conn.commit()：提交事务；</li>\r	<li>conn.rollback()：回滚事务。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rtry {\r        conn.setAutoCommit(false);\r	update account set money=money-100 where userid=1;\r	update account set money=money+100 where userid=2;\r	conn.commit();\r} catch (Exception e) {\r	conn.rollback()\r} finally {\r	conn.close();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 58),
(1290, 'DBUtils事务操作', '1290', 1545458232, 1545458232, '<p>本文记录Java学习过程中遇到的DBUtils事务操作～</p>\r<!--more-->\r\r<p>DBUtils中针对事务的操作常用方法有五个：</p>\r\r<ul>\r	<li>conn.setAutoCommit(false)：开启事务；</li>\r	<li>new QueryRunner()：创建核心类，不设置数据源（手动管理连接）；</li>\r	<li>query(conn, sql, handler, params)或者update(conn, sql, params)：手动传递连接；</li>\r	<li>DbUtils.commitAndClose(conn)：提交并关闭连接；</li>\r	<li>DbUtils.rollbackAndClose(conn)：回顾并关闭连接。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 60),
(1291, 'ThreadLocal.png', 'ThreadLocal-png', 1545460578, 1545460578, 'a:5:{s:4:"name";s:15:"ThreadLocal.png";s:4:"path";s:35:"/usr/uploads/2018/12/3633740872.png";s:4:"size";i:463934;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1292, 0),
(1292, 'ThreadLocal对象', '1292', 1545460596, 1545460596, '<p>本文记录Java学习过程中遇到的ThreadLocal对象～</p>\r<!--more-->\r\r<p>在&ldquo;事务传递参数&rdquo;过程中，我们必须修改方法的参数个数来传递连接，才可以完成整个事务操作。其实，在JDK中给我们提供了一个工具类：ThreadLocal，此类可以在一个线程中共享数据。</p>\r\r<p>java.lang.TreadLocal类提供了线程局部（thread-local）对象，用于在当前线程中共享数据。ThreadLocal工具类底层就是一个Map，key存放的是当前线程，value存放需要共享的数据。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2018/12/3633740872.png" style="width: 800px; height: 281px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 54),
(1293, '事务特性', '1293', 1545461040, 1545461659, '<p>本文记录Java学习过程中遇到的事务特性～</p>\r<!--more-->\r\r<p>事务的特性一般包括四个，简称为ACID，具体如下：</p>\r\r<ul>\r	<li>原子性（Atomicity）：指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生；</li>\r	<li>一致性（Consistency）：指事务前后数据的完整性必须保持一致；</li>\r	<li>隔离性（Isolation）：指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离；</li>\r	<li>持久性（Durability）：指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，后面即使数据库发生故障也不应该对其有任何影响。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 60),
(1294, '事务并发访问的问题', '1294', 1545462488, 1545462488, '<p>本文记录MySQL学习过程中遇到的事务并发访问的问题～</p>\r\r<!--more-->\r\r<p>如果不考虑隔离性，事务存在3种并发访问问题：</p>\r\r<ul>\r	<li>脏读：一个事务读到了另一个事务未提交的数据；</li>\r	<li>不可重复读：一个事务读到了另一个事务已经提交（update）的数据。导致，另一个事务在事务中的多次查询结果不一致；</li>\r	<li>虚读/幻读：一个事务读到了另一个事务已经提交（insert）的数据。导致，另一个事务在事务中的多次查询结果不一致。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 61),
(1295, '事务的隔离级别', '1295', 1545465555, 1545465555, '<p>本文记录MySQL学习过程中遇到的事务的隔离级别～</p>\r<!--more-->\r\r<p>数据库规范规定了4种隔离级别，分别用于描述两个事务并发的所有情况：</p>\r\r<p>1.read uncommitted读未提交：一个事务读到另一个事务没有提交的数据；</p>\r\r<ul>\r	<li>存在：3个问题；</li>\r	<li>解决：0个问题。</li>\r</ul>\r\r<p>2.read committed读已提交：一个事务读到另一个事务已经提交的数据；</p>\r\r<ul>\r	<li>存在：2个问题（不可重复读，虚读）；</li>\r	<li>解决：1个问题（脏读）。</li>\r</ul>\r\r<p>3.repeatable read可重复读：在一个事务中读到的数据始终保持一致，无论另一个事务是否提交；</p>\r\r<ul>\r	<li>存在：1个问题（虚读）；</li>\r	<li>解决：2个问题（脏读、不可重复读）。</li>\r</ul>\r\r<p>4.serializable串行化：同时只能执行一个事务，相当于事务中的单线程。</p>\r\r<ul>\r	<li>存在：0个问题；</li>\r	<li>解决：3个问题（脏读、不可重复读、虚读）。</li>\r</ul>\r\r<p>安全性和性能对比：</p>\r\r<ul>\r	<li>安全性：serializable&gt;repeatable read&gt;read committed&gt;read uncommitted</li>\r	<li>性能：serializable&lt;repeatable read&lt;read committed&lt;read uncommitted</li>\r</ul>\r\r<p>常见数据库的默认隔离级别：</p>\r\r<ul>\r	<li>MySQL：repeatable read；</li>\r	<li>Oracle：read committed。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 66);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1296, '不可重复读和幻读的区别', '1296', 1545467160, 1554081397, '<p>本文记录MySQL学习过程中遇到的不可重复读和幻读的区别～</p>\r<!--more-->\r\r<p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p>\r\r<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该SQL第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p>\r\r<p>所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。</p>\r\r<p>上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。</p>\r\r<ul>\r	<li>悲观锁</li>\r</ul>\r\r<p>正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机 制，也无法保证外部系统不会修改数据）。</p>\r\r<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>\r\r<ul>\r	<li>乐观锁</li>\r</ul>\r\r<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>\r\r<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 &ldquo;version&rdquo; 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>\r\r<p>要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 132),
(1299, 'AJAX原理', '1299', 1546347300, 1546354355, '<p>本文记录WEB前端学习过程中遇到的AJAX原理～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/01/2298927205.png" style="width: 800px; height: 282px;" /></p>\r\r<p>AJAX引擎会在不刷新浏览器地址栏的情况下发送请求：</p>\r\r<ul>\r	<li>使用JavaScript获得浏览器内置的AJAX引擎（XMLHttpRequest对象）；</li>\r	<li>通过AJAX引擎确定请求路径和请求参数；</li>\r	<li>通知AJAX引擎发送请求。</li>\r</ul>\r\r<p>服务器收到AJAX发送的请求后会进行处理：</p>\r\r<ul>\r	<li>服务器获得请求参数；</li>\r	<li>服务器处理请求参数（增删改查等操作）；</li>\r	<li>服务器响应数据给浏览器。</li>\r</ul>\r\r<p>AJAX引擎获得服务器响应的数据，通过执行JavaScript的回掉函数将数据传递给浏览器页面：</p>\r\r<ul>\r	<li>通过设置给AJAX引擎的回调函数获得服务器响应的数据；</li>\r	<li>使用JavaScript在指定的位置，显示响应数据，从而局部修改页面的数据，达到局部刷新的目的。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 66),
(1300, 'AJAX原理.png', 'AJAX原理-png', 1546347388, 1546347388, 'a:5:{s:4:"name";s:14:"AJAX原理.png";s:4:"path";s:35:"/usr/uploads/2019/01/2298927205.png";s:4:"size";i:331529;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1299, 0),
(1301, 'AJAX使用-原生JS', '1301', 1546348960, 1546348960, '<p>本文记录WEB前端学习过程中遇到的AJAX的使用-原生JS篇～</p>\r<!--more-->\r\r<p>原生JS操作AJAX的步骤为：</p>\r\r<ul>\r	<li>获得AJAX引擎；</li>\r	<li>设置回调函数；</li>\r	<li>确定请求路径；</li>\r	<li>发送请求。</li>\r</ul>\r\r<p>GET请求</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//1.获得AJAX引擎\rvar xmlhttp = new XMLHttpRequest();\r\r//2.设置回调函数\rxmlhttp.onreadystatechange = function(){\r	if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200){\r		alert(&quot;响应数据为：&quot; + xmlhttp.responseText);\r	}\r};\r\r//3.确认请求方式、路径和参数\rxmlhttp.open(&quot;GET&quot;,&quot;/test?username=oliver&amp;password=password&quot;);\r\r//4.发送请求\rxmlhttp.send(null);</pre>\r\r<p>POST请求</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//1.获得AJAX引擎\rvar xmlhttp = new XMLHttpRequest();\r\r//2.设置回调函数\rxmlhttp.onreadystatechange = function(){\r	if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200){\r		alert(&quot;响应数据为：&quot; + xmlhttp.responseText);\r	}\r};\r\r//3.确认请求方式、路径和参数\rxmlhttp.open(&quot;POST&quot;,&quot;/test&quot;);\r\r//4.设置请求编码\rxmlhttp.setRequestHeader(&quot;content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);\r\r//5.发送请求\rxmlhttp.send(&quot;username=oliver&amp;password=password&quot;);</pre>\r\r<p>XMLHttpRequest对象浏览器兼容</p>\r\r<p>示例代码（固定函数）：</p>\r\r<pre class="brush:jscript;">\rfunction getXMLHttp(){\r	var xmlhttp = null;\r	if (window.XMLHttpRequest){\r		// 谷歌、火狐、IE9+\r		xmlhttp = new XMLHttpRequest();\r	} else {\r		// IE6、7和8\r		xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 61),
(1302, '同步与异步', '1302', 1546349978, 1546349978, '<p>本文记录WEB前端学习过程中遇到的同步与异步～</p>\r<!--more-->\r\r<p>同步：客户端发送请求到服务器端，当服务器返回响应之前，客户端都处于等待卡死状态</p>\r\r<p>异步：客户端发送请求到服务器端，无论服务器是否返回响应，客户端都可以随意做其他事情，不会被卡死</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 61),
(1303, 'AJAX使用-jQuery', '1303', 1546350840, 1546350910, '<p>本文记录WEB前端学习过程中遇到的AJAX的使用-jQuery篇～</p>\r\r<!--more-->\r\r<p>jQuery是一个优秀的js框架，自然对js原生的ajax进行了封装，封装后的ajax的操 作方法更简洁，功能更强大，与ajax操作相关的jquery方法有如下几种，但开发中 经常使用的有三种，具体如下：</p>\r\r<p>1）$.get(url, [data], [callback], [type])</p>\r\r<p>常用的option有如下：</p>\r\r<ul>\r	<li>url：代表请求的服务器端地址</li>\r	<li>data：代表请求服务器端的数据（可以是key=value形式也可以是json格式）</li>\r	<li>callback：表示服务器端成功响应所触发的函数（只有正常成功返回才执行）</li>\r	<li>type：表示服务器端返回的数据类型（jquery会根据指定的类型自动类型转换）</li>\r	<li>常用的返回类型：text、json、html等</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//get请求\r$(&quot;#getID&quot;).click(function(){\r	var url = &quot;/test&quot;;\r	var params = {\r		&quot;username&quot;:&quot;oliver&quot;,\r		&quot;password&quot;:&quot;password&quot;\r	};\r	$.get(url, params, function(data){\r		alert(data);\r	});\r});</pre>\r\r<p>2）$.post(url, [data], [callback], [type])</p>\r\r<p>常用的option有如下：</p>\r\r<ul>\r	<li>url：代表请求的服务器端地址</li>\r	<li>data：代表请求服务器端的数据（可以是key=value形式也可以是json格式）</li>\r	<li>callback：表示服务器端成功响应所触发的函数（只有正常成功返回才执行）</li>\r	<li>type：表示服务器端返回的数据类型（jquery会根据指定的类型自动类型转换）</li>\r	<li>常用的返回类型：text、json、html等</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//post请求\r$(&quot;#postID&quot;).click(function(){\r	var url = &quot;/test&quot;;\r	var params = {\r		&quot;username&quot;:&quot;oliver&quot;,\r		&quot;password&quot;:&quot;password&quot;\r	};\r	$.post(url, params, function(data){\r		alert(data);\r	});\r});</pre>\r\r<p>3）$.ajax( { option1:value1,option2:value2... } );</p>\r\r<p>常用的option有如下：</p>\r\r<ul>\r	<li>async：是否异步，默认是true代表异步</li>\r	<li>data：发送到服务器的参数，建议使用json格式</li>\r	<li>dataType：服务器端返回的数据类型，常用text和json</li>\r	<li>success：成功响应执行的函数，对应的类型是function类型</li>\r	<li>type：请求方式，POST/GET</li>\r	<li>url：请求服务器端地址</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 62),
(1304, 'JSON.png', 'JSON-png', 1546352843, 1546352843, 'a:5:{s:4:"name";s:8:"JSON.png";s:4:"path";s:35:"/usr/uploads/2019/01/1902833113.png";s:4:"size";i:139096;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1305, 0),
(1305, 'JSON简介', '1305', 1546352820, 1546354281, '<p>本文记录WEB前端学习过程中遇到的JSON～</p>\r<!--more-->\r\r<p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。JSON采用完全独立于语言的文本格式，就是说不同的编程语言的JSON数据格式是一样的。</p>\r\r<p>同时，JSON易于阅读和编写，同时也易于机器解析和生成（一般用于提升网络传输效率）。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/01/1902833113.png" style="width: 800px; height: 439px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 59),
(1306, 'JSON格式', '1306', 1546353480, 1554081649, '<p>本文记录WEB前端学习过程中遇到的JSON格式～</p>\r<!--more-->\r\r<p>JSON常见的格式有两种，即对象格式和数组格式，两个可以相互嵌套，分别如下：</p>\r\r<p><strong>JSON对象格式</strong></p>\r\r<pre class="brush:java;">\r{&quot;key&quot;:&quot;value&quot;,&quot;key&quot;:&quot;value&quot;}</pre>\r\r<ul>\r	<li>键和值使用冒号分隔；</li>\r	<li>标准规范要求key必须使用双引号，value如果没有双引号则表示变量。</li>\r</ul>\r\r<p>JSON数组格式：</p>\r\r<pre class="brush:java;">\r[obj, obj, ...]</pre>\r\r<ul>\r	<li>表示一组值，多个值使用逗号分隔。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:jscript;">\r//1.JSON对象\rvar user = {\r	&quot;username&quot;:&quot;oliver&quot;,\r	&quot;password&quot;:&quot;password&quot;\r};\ralert(user.username);\r\r//2.JSON数组\rvar arr = [&quot;oliver&quot;, &quot;cathy&quot;];\ralert(arr[1]);\r\r//3.嵌套使用\rvar data = [\r	{&quot;uid&quot;:1, &quot;uname&quot;: &quot;oliver&quot;},\r	{&quot;uid&quot;:2, &quot;uname&quot;: &quot;cathy&quot;}\r];\ralert(data[1].uname);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 83),
(1307, 'JSON使用-JSONLIB', '1307', 1546354140, 1546354217, '<p>本文记录Java学习过程中遇到的JSON的使用-JSONLIB篇～</p>\r\r<!--more-->\r\r<p>常用对象：</p>\r\r<ul>\r	<li>JSONObject：Java对象（JavaBean和Map）与JSON数据的转换工具类；</li>\r	<li>JSONArray：Java集合（List和Array）与JSON数据的转换工具类。</li>\r</ul>\r\r<p>常用方法：</p>\r\r<ul>\r	<li>static fromObject(...)：静态方法，用于将Java对象或集合转化成JSONLIB对象；</li>\r	<li>toString()：将JSONLIB对象转换成JSON字符串。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// Map或JavaBean\rMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\rmap.put(&quot;username&quot;, &quot;oliver&quot;);\rmap.put(&quot;password&quot;, &quot;password&quot;);\rString str =  JSONObject.fromObject(map).toString();\rSystem.out.println(str);\r\r// List或Array\rList&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();\rlist.add(map);\rlist.add(map);\rstr = JSONArray.fromObject(list).toString();\rSystem.out.println(str);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 48),
(1308, '监听器Listener简介', '1308', 1546695873, 1546695873, '<p>本文记录Java学习过程中遇到的监听器Listener～</p>\r<!--more-->\r\r<p>监听器是指对整个WEB环境的监听，当被监听的对象发生改变时，立即调用相应的方法进行处理。</p>\r\r<p>常见的应用场景：</p>\r\r<ul>\r	<li>Java SE GUI编程；</li>\r	<li>Android手机开发编程。</li>\r</ul>\r\r<p>常用的相关术语：</p>\r\r<ul>\r	<li>事件源：被监听的对象（目标对象）；</li>\r	<li>监听器对象：用于监听事件源的对象；</li>\r	<li>注册（绑定）：将监听器对象绑定给事件源，当事件源发生某些行为时，监听对象将被执行；</li>\r	<li>事件：事件源的行为；</li>\r	<li>事件对象：在监听器对象中获得事件源。</li>\r</ul>\r\r<p>使用流程：</p>\r\r<ul>\r	<li>编写监听器实现类，实现指定的接口；</li>\r	<li>在web.xml文件中配置监听器（部分监听器不需要配置）。</li>\r</ul>\r\r<p>JavaEE规范规定了8个监听器接口，用于监听不用的WEB对象，具体如下：</p>\r\r<ul>\r	<li>监听域对象的创建与销毁；</li>\r	<li>监听域对象属性的变化（添加、修改和删除）；</li>\r	<li>监听session作用域中的特殊JavaBean。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 54),
(1309, '域对象创建和销毁监听器', '1309', 1546696740, 1546697805, '<p>本文记录Java学习过程中遇到的域对象创建和销毁监听器，这些对象都需要在web.xml中配置才能生效～</p>\r<!--more-->\r\r<p><strong>ServletRequest对象-ServletRequestListener</strong></p>\r\r<p>它有两个方法，分别监听request对象的创建和销毁，具体为：</p>\r\r<ul>\r	<li>requestInitialized(ServletRequestEvent sre)：监听request的创建；</li>\r	<li>requestDestroyed(ServletRequestEvent sre)：监听request的销毁。</li>\r</ul>\r\r<p>注意：ServletRequestEvent可以通过getServletContext()和getServletRequest()方法分别获取ServletContext对象和ServletRequest对象。</p>\r\r<p><strong>HttpSession对象-HttpSessionListener</strong></p>\r\r<p>它有两个方法，分别监听session对象的创建和销毁，具体为：</p>\r\r<ul>\r	<li>sessionCreated(HttpSessionEvent se)：监听session的创建；</li>\r	<li>sessionDestroyed(HttpSessionEvent se)：监听session的销毁，session的默认销毁时间是30分钟，可以在web.xml中自定义配置，当然也可以手工调用invalidate()销毁。</li>\r</ul>\r\r<p>注意：HttpSessionEvent对象可以用过getSession()方法获得session对象。</p>\r\r<p><strong>ServletContext对象-ServletContextListener</strong></p>\r\r<p>它有两个方法，分别监听ServletContext对象的创建和销毁，具体为：</p>\r\r<ul>\r	<li>contextInitialized(ServletContextEvent sce)：监听ServletContext的创建；</li>\r	<li>contextDestroyed(ServletContextEvent sce)：监听ServletContext的销毁。</li>\r</ul>\r\r<p>注意：ServletContextEvent可以通过getServletContext()方法获得ServletContext对象。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 51),
(1310, '域对象属性监听器', '1310', 1546697820, 1554082062, '<p>本文记录Java学习过程中遇到的域对象属性监听器，这些对象都需要在web.xml中配置才能生效～</p>\r<!--more-->\r\r<p><strong>ServletRequest对象-ServletRequestAttributeListener</strong></p>\r\r<p>它有三个方法，分别监听ServletRequest对象中属性的添加、修改和删除，具体为：</p>\r\r<ul>\r	<li>attributeAdded(ServletRequestAttributeEvent srae)：监听ServletRequest属性的添加；</li>\r	<li>attributeReplaced(ServletRequestAttributeEvent srae)：监听ServletRequest属性的修改；</li>\r	<li>attributeRemoved(ServletRequestAttributeEvent srae)：监听ServletRequest属性的删除。</li>\r</ul>\r\r<p>注意：可以通过ServletRequestAttributeEvent的getName()和getValue()方法获取属性改变前的值，还可以通过getServletContext()和getServletRequest()方法获取相应的ServletContext和ServletRquest。</p>\r\r<p><strong>HttpSession对象-HttpSessionAttributeListener</strong></p>\r\r<p>它有三个方法，分别监听HttpSession对象中属性的添加、修改和删除，具体为：</p>\r\r<ul>\r	<li>attributeAdded(HttpSessionBindingEvent event)：监听HttpSession属性的添加；</li>\r	<li>attributeReplaced(HttpSessionBindingEven event)：监听HttpSession属性的修改；</li>\r	<li>attributeRemoved(HttpSessionBindingEven event)：监听HttpSession属性的删除。</li>\r</ul>\r\r<p>注意：可以通过HttpSessionBindingEvent的getName()和getValue()方法获取属性改变前的值，还可以通过getSession()获得HttpSession对象。</p>\r\r<p><strong>ServletContext对象-ServletContextAttributeListener</strong></p>\r\r<p>它有三个方法，分别监听ServletContext对象中属性的添加、修改和删除，具体为：</p>\r\r<ul>\r	<li>attributeAdded(ServletContextAttributeEvent event)：监听ServletContext属性的添加；</li>\r	<li>attributeReplaced(ServletContextAttributeEvent event)：监听ServletContext属性的修改；</li>\r	<li>attributeRemoved(ServletContextAttributeEvent event)：监听ServletContext属性的删除。</li>\r</ul>\r\r<p>注意：可以通过ServletContextAttributeEvent的getName()和getValue()方法获取属性改变前的值，还可以通过getServletContext()获得HttpSession对象。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 74),
(1311, 'Session作用域中的特殊JavaBean监听器', '1311', 1546698944, 1546698944, '<p>本文记录Java学习过程中遇到的Session作用域中的特殊JavaBean监听器，这些对象都不需要在web.xml中配置～</p>\r<!--more-->\r\r<p><strong>绑定和解绑-HttpSessionBindingListener</strong></p>\r\r<p>它有两个方法，分别监听HttpSession对象中相关JavaBean的绑定和解绑，具体为：</p>\r\r<ul>\r	<li>valueBound(HttpSessionBindingEvent event)：监听HttpSession中相关JavaBean的绑定；</li>\r	<li>valueUnbound(HttpSessionBindingEvent event)：监听HttpSession中相关JavaBean的解绑。</li>\r</ul>\r\r<p>注意：可以通过HttpSessionBindingEvent的getName()和getValue()方法获取属性改变前的值，还可以通过getSession()方法获取相应的HttpSession对象。</p>\r\r<p><strong>钝化和活化-HttpSessionActivationListener</strong></p>\r\r<p>它有两个方法，分别监听HttpSession对象中相关JavaBean的钝化和活化，具体为：</p>\r\r<ul>\r	<li>sessionDidActivate(HttpSessionEvent event)：监听HttpSession中相关JavaBean的活化；</li>\r	<li>sessionWillPassivate(HttpSessionEvent event)：监听HttpSession中相关JavaBean的钝化。</li>\r</ul>\r\r<p>注意：可以通过HttpSessionEvent的getSession()方法获取相应的HttpSession对象。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 52),
(1312, '邮件简介', '1312', 1546700389, 1546700389, '<p>本文记录学习过程中遇到的电子邮件～</p>\r<!--more-->\r\r<p><strong>邮件服务器</strong></p>\r\r<ul>\r	<li>要在网上提供电子邮件功能，必须有专门的电子邮件服务器；</li>\r	<li>邮件服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中；</li>\r	<li>邮件服务器按照提供的服务类型，可以分为发送邮件的服务器和接收邮件的服务器。</li>\r</ul>\r\r<p><strong>电子邮箱</strong></p>\r\r<p>电子邮箱其实就是用户在邮件服务器上申请的一个账户，服务器会为每个账户分配一定的空间，账户的用户可以使用这个账户和空间发送电子邮件和保存别人发送过来的电子邮件。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 54),
(1313, '邮件协议', '1313', 1546700700, 1546700743, '<p>本文记录学习过程中遇到的邮件协议～</p>\r<!--more-->\r\r<p>SMTP协议-发邮件协议</p>\r\r<ul>\r	<li>全称为Simple Mail Transfer Protocol（简单邮件传输协议），定义了邮件客户端软件与SMTP服务器之间，以及两台SMTP服务器之间的通讯规则；</li>\r	<li>端口号：25。</li>\r</ul>\r\r<p>POP3协议-收邮件协议</p>\r\r<ul>\r	<li>全称为Post Office Protocol（邮局协议），定义了邮件客户端软件与POP3服务器的通讯规则；</li>\r	<li>端口号：110。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 75),
(1314, '定时器Timer', '1314', 1546701404, 1546701404, '<p>本文记录Java学习过程中遇到的定时器Timer～</p>\r<!--more-->\r\r<p>JDK提供工具类Timer，用于触发定时器，执行TimerTask任务。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rSystem.out.println(new Date().toLocaleString());\r\r//1.定时器核心类\rTimer timer = new Timer();\r\r//2.定时执行指定任务\r//参数1：需要执行的任务；\r//参数2：执行任务的延迟时间，单位：毫秒；\r//参数3：执行任务的轮回（周期）时间，单位：毫秒。\rtimer.schedule(new TimerTask(){\r	@Override\r	public void run(){\r		System.out.println(new Date().toLocaleString());\r	}\r}, 2000, 4000);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 63),
(1315, '过滤器简介', '1315', 1546872681, 1546872681, '<p>本文记录Java学习过程中遇到的过滤器～</p>\r\r<!--more-->\r\r<p>过滤器是一个运行在服务器端的程序，先于与之相关的Servlet或JSP页面运行，实现对请求资源的过滤的功能。</p>\r\r<p>过滤器可附加到一个或多个Servlet或JSP页面上，可以检查请求信息，也可以处理响应信息。</p>\r\r<p>Filter的基本功能是对Servlet容器调用Servlet的过程进行拦截，从而在Servlet执行前后实现一些特殊的功能。</p>\r\r<p>过滤器常用实例：</p>\r\r<ul>\r	<li>自动登录；</li>\r	<li>解决全站乱码；</li>\r	<li>屏蔽非法文字；</li>\r	<li>进行响应数据压缩。</li>\r</ul>\r\r<p>过滤器编写流程</p>\r\r<ul>\r	<li>编写javax.servlet.Filter接口的实现类；</li>\r	<li>在web.xml中使用&lt;filter&gt;和&lt;filter-mapping&gt;进行配置。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 49),
(1316, 'Filter生命周期', '1316', 1546873456, 1546873456, '<p>本文记录Java学习过程中遇到的Filter生命周期～</p>\r\r<!--more-->\r\r<p>Filter生命周期（从创建到销毁的过程）：</p>\r\r<ul>\r	<li>服务器启动的时候，服务器就会创建过滤器的对象，并调用初始化方法init()；</li>\r	<li>每次访问被拦截目标资源，过滤器中的doFilter的方法就会执行，执行完后通过chain.doFilter(request, response)放行；</li>\r	<li>当服务器关闭的时候，服务器就会销毁Filter对象，同时执行destroy()方法。</li>\r</ul>\r\r<p>FilterConfig类</p>\r\r<ul>\r	<li>getFilterName()：获取Filter的名字；</li>\r	<li>getServletContext()：获取ServletContext上下文对象；</li>\r	<li>getInitParameter(String)：获取指定的初始化参数；</li>\r	<li>getInitParameterNames()：获取所有的初始化参数。</li>\r</ul>\r\r<p>FilterChain类</p>\r\r<ul>\r	<li>doFilter(request, response)：过滤器链中的过滤器的执行顺序与&lt;filter-mapping&gt;的配置顺序有关。</li>\r</ul>\r\r<p>过滤器的配置</p>\r\r<ul>\r	<li>url-pattern：与Servlet中的配置一样；</li>\r	<li>servlet-name：对指定的Servlet进行拦截；</li>\r	<li>dispatcher：REQUEST：默认值；FORWARD：拦截转发；ERROR：拦截跳转到错误页面；INCLUDE：拦截在一个页面中包含另一个页面。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 61),
(1317, '类加载器.png', '类加载器-png', 1547303824, 1547303824, 'a:5:{s:4:"name";s:16:"类加载器.png";s:4:"path";s:34:"/usr/uploads/2019/01/196851835.png";s:4:"size";i:139428;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1319, 0),
(1318, '类加载器的分类.png', '类加载器的分类-png', 1547303847, 1547303847, 'a:5:{s:4:"name";s:25:"类加载器的分类.png";s:4:"path";s:34:"/usr/uploads/2019/01/627476268.png";s:4:"size";i:228483;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1319, 0),
(1319, '类加载器简介', '1319', 1547303863, 1547303863, '<p>本文记录Java学习过程中遇到的类加载器～</p>\r<!--more-->\r\r<p>类加载器就是将字节码文件(.class)加载到内存的工具。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/01/196851835.png" style="width: 800px; height: 326px;" /></p>\r\r<p>类加载器有三种，不同类加载器加载不同的字节码文件：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/01/627476268.png" style="width: 800px; height: 440px;" />​</p>\r\r<p>BootStrap：引导类加载器：加载都是最基础的文件；<br />\rExtClassLoader：扩展类加载器：加载都是基础的文件；<br />\rAppClassLoader：应用类加载器：三方jar包和自己编写Java文件。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 57),
(1320, '注解简介', '1320', 1547304769, 1547304769, '<p>本文记录Java学习过程中遇到的注解～</p>\r<!--more-->\r\r<p>注解：英文Annotation，是一种代码级别的说明，它是JDK1.5及以后版本引入的一个特性，与类、接口和枚举是在同一个层次。</p>\r\r<p>注解的作用：</p>\r\r<ul>\r	<li>编译检查：通过代码里标识注解，让编译器能够实现基本的编译检查；</li>\r	<li>代码分析：通过代码里标识注解，对代码进行分析，从而达到取代XML的目的；</li>\r	<li>编写文档：通过代码里标识注解，辅助生成帮助文档对应的内容。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 59),
(1321, 'JDK提供的注解', '1321', 1547305140, 1547305287, '<p>本文记录Java学习过程中遇到的JDK提供的注解～</p>\r<!--more-->\r\r<p>@Deprecated：表示被修饰的方法已经过时，过时的方法不建议使用，但仍可以使用；</p>\r\r<p>@Override：JDK5表示复写父类的方法，JDK6还可以表示实现接口的方法；</p>\r\r<p>@SupperssWarnings：表示抑制警告，被修饰过的类或方法如果存在编译警告，将被编译器忽略。</p>\r\r<ul>\r	<li>deprecation：忽略过时；</li>\r	<li>rawtypes：忽略类型安全；</li>\r	<li>unused：忽略不适用；</li>\r	<li>unchecked：忽略安全检查；</li>\r	<li>null：忽略空指针；</li>\r	<li>all：忽略所有警告。</li>\r</ul>\r\r<p>注意：一般被标记为过时的方法都存在不同的缺陷，例如，安全问题或者被新的API取代。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 67),
(1322, '自定义注解', '1322', 1547307262, 1547307262, '<p>本文记录Java学习过程中遇到的自定义注解～</p>\r<!--more-->\r\r<p><strong>基本语法</strong></p>\r\r<p>定义注解需要使用关键字@interface。</p>\r\r<p>示例代码（定义注解）：</p>\r\r<pre class="brush:java;">\r@interface MyAnno{\r	\r}</pre>\r\r<p>示例代码（定义含有属性的注解）：</p>\r\r<pre class="brush:java;">\r@interface MyAnno{\r	String value();\r}</pre>\r\r<p>属性格式：</p>\r\r<pre class="brush:java;">\r修饰符 返回值类型 属姓名() [default 默认值]</pre>\r\r<ul>\r	<li>修饰符：默认值为public abstract，且只能是public abstract；</li>\r	<li>返回值类型：基本类型、String、Class、注解和枚举，以及以上类型的一维数组；</li>\r	<li>属姓名：自定义，符合变量名的命名规范即可；</li>\r	<li>default：默认值，可以省略。</li>\r</ul>\r\r<p><strong>使用</strong></p>\r\r<p>注解的使用格式：</p>\r\r<pre class="brush:java;">\r@注解类名(key=value, key=value, ...)</pre>\r\r<p>注意事项：</p>\r\r<ul>\r	<li>注解可以没有属性，如果有属性需要使用小括号括住；</li>\r	<li>属性格式：key=value，多个属性使用逗号分隔；</li>\r	<li>如果属性名为value且只有一个属性，value可以省略；</li>\r	<li>如果同时使用多个属性，属性名为value的不能省略属性名；</li>\r	<li>如果属性类型为数组，设置内容格式为：{1, 2, 3}；</li>\r	<li>如果属性类型为数组，值只有一个，{}可以省略；</li>\r	<li>一个对象上，注解只能使用一个，不能重复使用。</li>\r</ul>\r\r<p><strong>解析</strong></p>\r\r<p>如果给类或方法等添加注解，需要获得注解上设置的数据的时候就必须对注解进行解析，JDK提供java.lang.reflect.AnnotatedElement接口允许在运行时通过反射获得注解。</p>\r\r<p>AnnotatedElement接口常用方法：</p>\r\r<ul>\r	<li>boolean isAnnotationPresent(Class clazz)：获取当前对象是否有注解；</li>\r	<li>T getAnnotation(Class&lt;T&gt; annotationClass)：获取当前对象上执行的注解；</li>\r	<li>Annotation[] getAnnotations()：获取当前对象及从父类上继承的所有注解；</li>\r	<li>Annotation[] getDeclaredAnnotations()：获取当前对象上所有的注解。</li>\r</ul>\r\r<p><strong>元注解</strong></p>\r\r<p>元注解时用来修饰注解的注解。</p>\r\r<p>JDK提供4种元注解：</p>\r\r<p>@Retention：用于确定被修饰的自定义注解的生命周期：</p>\r\r<ul>\r	<li>RetentionPolicy.SOURCE：被修饰的注解只能存在源码中，字节码.class中没有，提供给编译器使用；</li>\r	<li>RetentionPolicy.CLASS：被修饰的注解只能存在源码和字节码中，运行时内存中没有，提供给JVM虚拟机使用；</li>\r	<li>RetentionPolicy.RUNTIME：被修饰的注解存在于源码、字节码和内存中，用于取代XML配置。</li>\r</ul>\r\r<p>@Target：用于确定被修饰的自定义注解：</p>\r\r<ul>\r	<li>ElementType.TYPE：修饰类和接口；</li>\r	<li>ElementType.CONSTRUCTOR：修饰构造函数；</li>\r	<li>ElementType.METHOD：修饰方法；</li>\r	<li>ElementType.FIELD：修饰方法。</li>\r</ul>\r\r<p>@Documented：使用JavaDoc生成API文档时是否包含此注解；</p>\r\r<p>@Inherited：父类使用被修饰的注解子类是否继承。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 55),
(1323, '《SpringBoot实战》PDF完整版下载', '1323', 1547895150, 1547895150, '<p>本文分享一本书《SpringBoot实战》。</p>\r<!--more-->\r\r<p>本书以Spring应用程序开发为中心，全面讲解如何运用Spring Boot提高效率，使应用程序的开发和管理更加轻松有趣。作者行文亲切流畅，以大量示例讲解了Spring Boot在各类情境中的应用，内容涵盖起步依赖、Spring Boot CLI、Groovy、Grails、Actuator。对于Spring Boot开发应用中较为繁琐的内容，附录奉上整理完毕的表格，一目了然，方便读者查阅。</p>\r\r<p>目录如下：</p>\r\r<p>第1章　入门　　1</p>\r\r<p>1.1　Spring风云再起　　1</p>\r\r<p>1.1.1　重新认识Spring　　2</p>\r\r<p>1.1.2　Spring Boot精要　　3</p>\r\r<p>1.1.3　Spring Boot不是什么　　6</p>\r\r<p>1.2　Spring Boot入门　　6</p>\r\r<p>1.2.1　安装Spring Boot CLI　　7</p>\r\r<p>1.2.2　使用Spring Initializr初始化Spring Boot项目　　10</p>\r\r<p>1.3　小结　　18</p>\r\r<p>第2章　开发第一个应用程序　　19</p>\r\r<p>2.1　运用Spring Boot　　19</p>\r\r<p>2.1.1　查看初始化的Spring Boot新项目　　21</p>\r\r<p>2.1.2　Spring Boot项目构建过程解析　　24</p>\r\r<p>2.2　使用起步依赖　　27</p>\r\r<p>2.2.1　指定基于功能的依赖　　28</p>\r\r<p>2.2.2　覆盖起步依赖引入的传递依赖　　29</p>\r\r<p>2.3　使用自动配置　　30</p>\r\r<p>2.3.1　专注于应用程序功能　　31</p>\r\r<p>2.3.2　运行应用程序　　36</p>\r\r<p>2.3.3　刚刚发生了什么　　38</p>\r\r<p>2.4　小结　　41</p>\r\r<p>第3章　自定义配置　　42</p>\r\r<p>3.1　覆盖Spring Boot自动配置　　42</p>\r\r<p>3.1.1　保护应用程序　　43</p>\r\r<p>3.1.2　创建自定义的安全配置　　44</p>\r\r<p>3.1.3　掀开自动配置的神秘面纱　　48</p>\r\r<p>3.2　通过属性文件外置配置　　49</p>\r\r<p>3.2.1　自动配置微调　　50</p>\r\r<p>3.2.2　应用程序Bean的配置外置　　55</p>\r\r<p>3.2.3　使用Profile进行配置　　59</p>\r\r<p>3.3　定制应用程序错误页面　　62</p>\r\r<p>3.4　小结　　64</p>\r\r<p>第4章　测试　　66</p>\r\r<p>4.1　集成测试自动配置　　66</p>\r\r<p>4.2　测试Web应用程序　　68</p>\r\r<p>4.2.1　模拟Spring MVC　　69</p>\r\r<p>4.2.2　测试Web安全　　72</p>\r\r<p>4.3　测试运行中的应用程序　　74</p>\r\r<p>4.3.1　用随机端口启动服务器　　75</p>\r\r<p>4.3.2　使用Selenium测试HTML页面　　76</p>\r\r<p>4.4　小结　　78</p>\r\r<p>第5章　Groovy与Spring Boot CLI　　80</p>\r\r<p>5.1　开发Spring Boot CLI应用程序　　80</p>\r\r<p>5.1.1　设置CLI项目　　81</p>\r\r<p>5.1.2　通过Groovy消除代码噪声　　81</p>\r\r<p>5.1.3　发生了什么　　85</p>\r\r<p>5.2　获取依赖　　86</p>\r\r<p>5.2.1　覆盖默认依赖版本　　87</p>\r\r<p>5.2.2　添加依赖仓库　　88</p>\r\r<p>5.3　用CLI运行测试　　89</p>\r\r<p>5.4　创建可部署的产物　　91</p>\r\r<p>5.5　小结　　91</p>\r\r<p>第6章　在Spring Boot中使用Grails　　93</p>\r\r<p>6.1　使用GORM进行数据持久化　　93</p>\r\r<p>6.2　使用Groovy Server Pages定义视图　　98</p>\r\r<p>6.3　结合Spring Boot与Grails 3　　100</p>\r\r<p>6.3.1　创建新的Grails项目　　100</p>\r\r<p>6.3.2　定义领域模型　　103</p>\r\r<p>6.3.3　开发Grails控制器　　104</p>\r\r<p>6.3.4　创建视图　　105</p>\r\r<p>6.4　小结　　107</p>\r\r<p>第7章　深入Actuator　　108</p>\r\r<p>7.1　揭秘Actuator的端点　　108</p>\r\r<p>7.1.1　查看配置明细　　109</p>\r\r<p>7.1.2　运行时度量　　115</p>\r\r<p>7.1.3　关闭应用程序　　121</p>\r\r<p>7.1.4　获取应用信息　　121</p>\r\r<p>7.2　连接Actuator的远程shell　　122</p>\r\r<p>7.2.1　查看autoconfig报告　　123</p>\r\r<p>7.2.2　列出应用程序的Bean　　124</p>\r\r<p>7.2.3　查看应用程序的度量信息　　124</p>\r\r<p>7.2.4　调用Actuator端点　　125</p>\r\r<p>7.3　通过JMX监控应用程序　　126</p>\r\r<p>7.4　定制Actuator　　128</p>\r\r<p>7.4.1　修改端点ID　　128</p>\r\r<p>7.4.2　启用和禁用端点　　129</p>\r\r<p>7.4.3　添加自定义度量信息　　129</p>\r\r<p>7.4.4　创建自定义跟踪仓库　　132</p>\r\r<p>7.4.5　插入自定义健康指示器　　134</p>\r\r<p>7.5　保护Actuator端点　　136</p>\r\r<p>7.6　小结　　138</p>\r\r<p>第8章　部署Spring Boot应用程序　　139</p>\r\r<p>8.1　衡量多种部署方式　　139</p>\r\r<p>8.2　部署到应用服务器　　140</p>\r\r<p>8.2.1　构建WAR文件　　141</p>\r\r<p>8.2.2　创建生产Profile　　142</p>\r\r<p>8.2.3　开启数据库迁移　　145</p>\r\r<p>8.3　推上云端　　150</p>\r\r<p>8.3.1　部署到Cloud Foundry　　150</p>\r\r<p>8.3.2　部署到Heroku　　153</p>\r\r<p>8.4　小结　　155</p>\r\r<p>附录A　Spring Boot开发者工具　　157</p>\r\r<p>附录B　Spring Boot起步依赖　　163</p>\r\r<p>附录C　配置属性　　169</p>\r\r<p>附录D　Spring Boot依赖　　202</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1FRasxSJP-d0WOJK1plFKRA" target="_blank">百度网盘</a></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 96),
(1324, 'JDK动态代理', '1324', 1547922480, 1554082609, '<p>本文记录Java学习过程中遇到的JDK动态代理～</p>\r<!--more-->\r\r<p>动态代理，就是不用手动编写一个代理对象，不需要一一编写与目标对象相同的方法，在运行时的内存中动态生成代理对象，即字节码对象级别的代理对象。</p>\r\r<p>动态代理的API：在JDK的API中有个Proxy类中存在一个生成动态代理的的方法newProxyInstance：</p>\r\r<pre class="brush:java;">\rstatic Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</pre>\r\r<p>返回值：Object就是代理对象<br />\r参数：</p>\r\r<ul>\r	<li>loader：代表与目标对象相同的类加载器-------目标对象.getClass().getClassLoader()</li>\r	<li>interfaces：代表与目标对象实现的所有的接口字节码对象数组</li>\r	<li>h：具体的代理的操作，InvocationHandler接口</li>\r</ul>\r\r<p>注意：JDK的Proxy方式实现的动态代理的目标对象必须有接口，没有接口就不能实现JDK版动态代理。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 72),
(1325, 'NoSQL数据库简介', '1325', 1549454520, 1549454581, '<p>本文记录Redis学习过程中遇到的NoSQL～</p>\r<!--more-->\r\r<p>NoSQL（Not Only SQL），意思是&ldquo;不仅仅是SQL&rdquo;，是一项全新的数据库理念，泛指非关系型的数据库。</p>\r\r<p>随着互联网Web2.0网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系型数据库产品的发展非常迅速。而传统的关系型数据库在应付Web2.0网站，特别是超大规模和高并发的SNS类型的Web2.0纯动态网站的时候，已经显得力不从心，暴露出了很多难以克服的问题，例如：</p>\r\r<p>1. High Performance - 对数据库高并发读写的需求</p>\r\r<p>Web2.0网站需根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法动态页面静态化技术，因此数据库并发负载非常高，往往要达到每次上万次读写请求。关系型数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实，对于普通的BBS网站，往往也存在对高并发写请求的需求，例如，网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。</p>\r\r<p>2. Huge Storage - 对海量数据的高效率存储和访问的需求</p>\r\r<p>类似Facebook，Twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就打到了2.5亿条用户动态，对于关系型数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下甚至不可忍受的。再例如大型Web网站的用户登录系统，例如腾讯，盛大，动辄数亿的账号，关系型数据库也很难应付。</p>\r\r<p>3. High Scalability &amp;&amp; High Availability - 对数据库的高扩展性和高可用性的需求</p>\r\r<p>在基于Web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像Web Server和App Server那样简单的通过添加更多的硬件和服务器节点来扩展性能和负载能力。对于很多需要提供24个小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库就不能通过不断的添加服务器节点来实现扩展呢？</p>\r\r<p>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 82),
(1328, 'NoSQL特点', '1328', 1549455465, 1549455465, '<p>本文记录Redis学习过程中遇到的NoSQL的特点～</p>\r\r<!--more-->\r\r<p>在大数据存储上，非关系型数据库具有关系型数据库无法比拟的性能优势，例如：</p>\r\r<p>1.易扩展</p>\r\r<p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间在架构的层面上带来了可扩展的能力。</p>\r\r<p>2.大数据量且高性能</p>\r\r<p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。</p>\r\r<p>3.灵活的数据模型</p>\r\r<p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦，这一点在大数据量的Web2.0时代尤其明显。</p>\r\r<p>4.高可用</p>\r\r<p>NoSQL在不太影响性能的情况下，就可以方便的实现高可用的架构。比如Cassandra、Hbase模型，通过复制模型也能实现高可用。</p>\r\r<p>综上所述，NoSQL的非关系特性使其成为了后Web2.0时代的宠儿，助力大型Web2.0网站的再次起飞，是一项全新的数据库革命性运动。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 40),
(1329, 'Redis简介', '1329', 1549465324, 1549465324, '<p>本文记录Redis学习过程中遇到的Redis～</p>\r<!--more-->\r\r<p>2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人Salvatore Samfilippo便对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。不过，Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。</p>\r\r<p>Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博等公司，国外如Github等公司都是Redis的用户。</p>\r\r<p>VMware公司从2010年开始赞助Redis的开发，Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。</p>\r\r<p>Redis是用C语言开发的一个开源的高性能键值对数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p>\r\r<ul>\r	<li>字符串类型；</li>\r	<li>散列类型；</li>\r	<li>列表类型；</li>\r	<li>集合类型；</li>\r	<li>有序集合类型。</li>\r</ul>\r\r<p>官方提供的性能测试数据：50个并发执行10w个请求，读的速度是11w次/s，写的速度是8.1w次/s。该数据仅供参考，不同服务器配置也会有所不同。</p>\r\r<p>Redis常见的应用场景：</p>\r\r<ul>\r	<li>缓存（数据查询、短链接、新闻内容、商品内容等等）；</li>\r	<li>聊天室的在线好友列表；</li>\r	<li>任务队列（秒杀、抢购、12306等）；</li>\r	<li>应用排行榜；</li>\r	<li>网站访问统计数据；</li>\r	<li>数据过期处理；</li>\r	<li>分布式集群架构中的Session分离。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 52),
(1330, 'Redis的启动停止', '1330', 1549499773, 1549499773, '<p>本文记录Redis学习过程中遇到的Redis的启动与停止～</p>\r<!--more-->\r\r<p>Redis有两种启动模式，即前端启动模式与后端启动模式：</p>\r\r<p>前端模式：</p>\r\r<p>直接运行bin/redis-server将以前端模式启动，前端模式启动的缺点是启动完成后，不能再进行其他操作，如果要操作必须使用Ctrl+C，同时redis-server程序结束，此方法不推荐。</p>\r\r<pre class="brush:bash;">\r/usr/local/redis/bin/redis-server</pre>\r\r<p>后端模式：</p>\r\r<p>修改redis.conf配置文件，deamonize设置为yes，redis-server以后端模式启动。</p>\r\r<p>启动的时候需要指定配置文件：</p>\r\r<pre class="brush:bash;">\rcd /usr/local/redis\r./bin/redis-server ./redis.conf\rps -ef | grep redis</pre>\r\r<p>Redis停止</p>\r\r<p>Redis的停止有两种模式，即强制停止和用showdown命令停止。</p>\r\r<p>强制程序结束（强行终止Redis进程可能会导致Redis持久化数据丢失）：</p>\r\r<pre class="brush:bash;">\rps -ef | grep -i redis\rkill -9 pid</pre>\r\r<p>正确停止Redis的方式应该是向Redis发送shutdown命令：</p>\r\r<pre class="brush:bash;">\rcd /usr/local/redis\r./bin/redis-cli shutdown</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 84),
(1331, 'Jedis简介', '1331', 1549503120, 1549503156, '<p>本文记录Redis学习过程中遇到的Jedis～</p>\r\r<!--more-->\r\r<p>Redis不仅可以使用命令来操作，现在基本上主流的语言都有客户端支持，比如Java、C、C#、C++、PHP、Node.js和Go等。</p>\r\r<p>在Redis官网中列很多Java客户端，有Jedis、Redisson、Jredis、JDBC-Redis等，其中官方推荐使用Jedis和Redisson，企业中用的最多的应该是Jedis。</p>\r\r<p>示例代码（单实例连接）：</p>\r\r<pre class="brush:java;">\rJedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);\rjedis.set(&quot;name&quot;, &quot;oliver&quot;);\rString name = jedis.get(&quot;name&quot;);\rSystem.out.println(name);\rjedis.close();</pre>\r\r<p>示例代码（连接池连接）：</p>\r\r<pre class="brush:java;">\rJedisPoolConfig config = new JedisPoolConfig();\rconfig.setMaxTotal(30);\rconfig.setMaxIdle(10);\rJedisPool jedisPool = new JedisPool(config, &quot;127.0.0.1&quot;, 6379);\r\rJedis jedis = null;\rtry {\r	jedis = jedisPool.getResource();\r	jedis.set(&quot;name&quot;, &quot;oliver&quot;);\r	String name = jedis.get(&quot;name&quot;);\r	System.out.println(name);\r} catch (Exception e) {\r	e.printStackTrace();\r} finally {\r	if (jedis != null) {\r		jedis.close();\r	}\r	if (jedisPool != null) {\r		jedisPool.close();\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 63),
(1332, 'Redis数据结构', '1332', 1549508411, 1549508411, '<p>本文记录Redis学习过程中遇到的Redis数据结构～</p>\r<!--more-->\r\r<p>Redis是一种高级的key-value的存储系统，其中value支持五种数据类型：</p>\r\r<ul>\r	<li>字符串-String；</li>\r	<li>哈希-Hash；</li>\r	<li>字符串列表-list；</li>\r	<li>字符串集合-set；</li>\r	<li>有序字符串集合-sorted set。</li>\r</ul>\r\r<p>关于key的定义需要注意一下几点：</p>\r\r<ul>\r	<li>key不要太长，最好不要操作1024个字节，这不仅会消耗内存还会降低查找效率；</li>\r	<li>key不要太短，如果太短会降低key的可读性；</li>\r	<li>在项目中，key最好有一个统一的命名规范。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 50);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1333, 'Redis数据类型-String', '1333', 1549519704, 1549519704, '<p>本文记录Redis学习过程中遇到的Redis数据类型-String～</p>\r<!--more-->\r\r<p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型存入和获取的数据相同，在Redis中字符串类型的value最多可以容纳的数据长度是512M。</p>\r\r<p>常用的命令有：</p>\r\r<ul>\r	<li>set key value：设定key存储指定的字符串value，如果该key存在则进行覆盖操作，返回值一定是&ldquo;OK&rdquo;；</li>\r	<li>get key：获取key的value，如果与该key关联的value不是String类型，Redis将返回错误信息。因为get命令只能获取String value，如果该key不存在，则返回nil；</li>\r	<li>getset key value：先获取该key的值，然后再设置该key的值；</li>\r	<li>del key：删除指定的key；</li>\r	<li>incr key：将指定的key的value原子性的递增1。如果该key不存在，则其初始值为0，在incr之后变成1。如果value的值不能转成整型，该操作将执行失败并返回相应的错误信息；</li>\r	<li>decr key：与incr相反，减1；</li>\r	<li>incrby key imcrement：将指定的key的value原子性的增加increment。如果该key不存在，则其初始值为0，在incr之后变成increment。如果value的值不能转成整型，该操作将执行失败并返回相应的错误信息；</li>\r	<li>decrby key decrement：与incrby相反；</li>\r	<li>append key value：拼凑字符串，如果该key存在，则在原有的value后追加该值；如果该key不存在，则重新创建一个key/value。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rset name oliver\rget name\rgetset name cathy\rdel name\rset num1 0\rincr num1\rget num1\rincr num2\rget num2\rset name cathy\rincr cathy</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 51),
(1334, 'Redis数据类型-Hash', '1334', 1549521570, 1549521570, '<p>本文记录Redis学习过程中遇到的Redis数据类型-Hash～</p>\r\r<!--more-->\r\r<p>Redis中的Hash类型可以看成具有String key和String value的Map容器，所以该类型非常适合与存储值对象的信息。如username、password和age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间，每一个Hash可以存储4294967295个键值对。</p>\r\r<p>常用命令：</p>\r\r<ul>\r	<li>hset key field value：为指定的key设定field/value对（键值对）；</li>\r	<li>hset key field1 value [field2 value...]：设置key中的多个field/value；</li>\r	<li>hget key field：返回指定的key中的field的值；</li>\r	<li>hmget key fields：获取key中的多个field的值；</li>\r	<li>hgetall key：获取key中的所有field-value；</li>\r	<li>hdel key field [field...]：可以删除一个或多个字段，返回值是被删除的字段个数；</li>\r	<li>del key：删除整个Map；</li>\r	<li>hincrby key field increment：设置key中field的值增加increment；</li>\r	<li>hexists key field：判断指定的key中的field是否存在；</li>\r	<li>hlen key：获取key所包含的field的数量；</li>\r	<li>hkeys key：获取所有的field；</li>\r	<li>hvals key：获取所有的value。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rhset myhash1 username oliver\rhset myhash1 age 18\rhset myhash2 username cathy age 18\rhget myhash1 username\rhmget myhash1 username age\rhgetall myhash1\rhdel myhash1 username\rdel myhash1\rhincrby myhash1 age 1\rhexists myhash1 username\rhkeys myhash1\rhvals myhash1</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 67),
(1335, 'Redis数据类型-List', '1335', 1549531260, 1549531369, '<p>本文记录Redis学习过程中遇到的Redis数据类型-List～</p>\r<!--more-->\r\r<p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部（left）和尾部（right）添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。</p>\r\r<p>从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而，需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。</p>\r\r<p>ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位操作，所以比较慢；<br />\rLinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入和删除数据时只是更改前后元素的指针指向，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢。</p>\r\r<p>常用命令：</p>\r\r<ul>\r	<li>lpush key values[value1 value2...]：在指定的key所关联的list的头部插入所有的values。如果该key不存在，该命令在插入之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功后，返回元素的总个数；</li>\r	<li>rpush key values[value1 value2...]：在List的尾部插入元素，其他与rpush相同；</li>\r	<li>lrange key start end：获取链表中从start到end的元素的值，start和end从0开始计数；也可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推；</li>\r	<li>lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素。如果该key不存在，返回nil；若key存在，则返回链表的头部元素；</li>\r	<li>rpop key：从尾部弹出元素，其余与lpop相同；</li>\r	<li>llen key：返回指定的key关联的链表中的元素的数量；</li>\r	<li>lpushx key：仅当参数中指定的key存在时，向关联的list的头部插入value。如果不存在，将不进行插入；</li>\r	<li>rpushx key：在该list的尾部添加元素，其余与lpushx相同；</li>\r	<li>lrem key count value：删除count个值为value的元素。如果count大于0，从头到尾遍历并删除count个值为value的元素；如果count小于0，则从尾到头遍历删除；如果count等于0，则删除链表中所有等于value的元素；</li>\r	<li>lset key index value：设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素，操作链表的脚标不存在则抛异常；</li>\r	<li>linsert key before|after pivot value：在pivot元素前或后插入value这个元素；</li>\r	<li>rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部（循环操作）；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rlpush mylist a b c\rlpush mylist 1 2 3\rrpush mylist 4 5 6\rlrange mylist 0 -1\rlpop mylist\rrpop mylist\rllen mylist\rlpushx mylist 1\rrpushx mylist c\rlrem mylist 0 a\rlset mylist 0 a\rlinsert mylist after 0 abc\rrpoplpush mylist1 mylist2</pre>\r\r<p>rpoplpush的使用场景：</p>\r\r<p>Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行lpush操作向链表中添加新的元素，我们通常将这样的程序称之为&ldquo;生成者&rdquo;，而另外一个应用程序正在执行rpop操作从链表中取出元素，我们称这样的程序为&ldquo;消费者&rdquo;。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象等发生。然而通过rpoplpush命令，消费者程序在从主消息队列中取出消息之后再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其他的消费者程序继续处理。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 51),
(1336, 'Redis数据类型-Set', '1336', 1549536992, 1549536992, '<p>本文记录Redis学习过程中遇到的Redis数据类型-Set～</p>\r<!--more-->\r\r<p>在Redis中，我们可以将Set类型看作为没有排序的字符集合。和List类型一样，我们也可以在该类型的数值上执行增加、删除或者判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为0(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。</p>\r\r<p>和List类型不同的是，Set集合中不允许出现重复的元素，这一点和C++标准库中的Set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Set之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。</p>\r\r<p>常用命令：</p>\r\r<ul>\r	<li>sadd key values[value1 value2...]：向set中添加数据，如果该key的值已有则不会重复添加；</li>\r	<li>srem key members[member1 member2...]：删除set中指定的成员；</li>\r	<li>smembers key：获取set中所有的成员；</li>\r	<li>sismember key member：判断参数中指定的成员是否在该set中，1表示存在，0表示不存在或者该key不存在（无论集合中有多少元素都可以极速的返回结果）；</li>\r	<li>sdiff key1 key2：返回key1与key2中相差的成员，而且与key的顺序有关，即返回差集。</li>\r	<li>sinter key1 key2...：返回交集；</li>\r	<li>sunion key1 key2...：返回并集；</li>\r	<li>scard key：获取set中成员的数量；</li>\r	<li>srandmember key：随机返回set中的一个成员；</li>\r	<li>sdiffstore destination key1 key2：将key1和key2相差的成员存储在destination上；</li>\r	<li>sinterstore destination key1 key2...：将返回的交集存储在destination上；</li>\r	<li>sunionstore destination key1 key2...：将返回的并集存储在destination上。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rsadd myset a b c\rsadd myset a\rsrem myset a\rsrem myset a b c\rsmembers myset\rsismember myset a\rsadd myset1 a b c\rsadd myset2 a b d\rsdiff myset1 myset2\rsinter myset1 myset2\rsunion myset1 myset2\rscard myset</pre>\r\r<p>常见的使用场景：</p>\r\r<ol>\r	<li>可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性；</li>\r	<li>充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如，所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们向获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1337, 'Redis数据类型-SortedSet', '1337', 1549545960, 1549630344, '<p>本文记录Redis学习过程中遇到的Redis数据类型-SortedSet～</p>\r<!--more-->\r\r<p>Sorted-Set和Set类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Set中的每一个成员都会有一个分数与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Set中的成员必须是唯一的，但是分数却是可以重复的。</p>\r\r<p>在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted-Set中的成员在集合中的位置是有序的。因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其他类型的数据库中是很难实现的。换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。</p>\r\r<p>常用命令：</p>\r\r<ul>\r	<li>zadd key score1 member1 score2 member2...：将所有成员以及该成员的分数存放到Sorted-Set中。如果该元素已经存在，则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。</li>\r	<li>zscore key member：返回指定成员的分数；</li>\r	<li>zcard key：获取集合中的成员数量；</li>\r	<li>zrem key member1 member2...：移除集合中指定的成员，可以指定多个成员；</li>\r	<li>zrange key start end [withscores]：获取集合中脚标为start到end的成员，[withscores]参数表明返回的成员包含其分数；</li>\r	<li>zrevrange key start stop [withscores]：按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）；</li>\r	<li>zremrangebyrank key start stop：按照排名范围删除元素；</li>\r	<li>zremrangebyscore key min max：按照分数范围删除元素；</li>\r	<li>zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的分数并按照分数从低到高排序。[withscores]显示分数；[limit offset count]：offset表明从脚标为offset的元素开始返回count个成员；</li>\r	<li>zincrby key increment member：设置指定成员的增加的分数，返回值是更改后的分数；</li>\r	<li>zcount key min max：获取分数在[min, max]之间的成员；</li>\r	<li>zrank key member：返回成员在集合中的排名（从小到大）；</li>\r	<li>zrevrank key member：返回成员在集合中的排名（从大到小）。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rzadd mysort 88 oliver 89 cathy\rzscore mysort oliver\rzcard mysort\rzrange mysort 0 -1 withscores\rzrevrange mysort 0 -1 withscores\rzremrangebyrank mysort 0 2\rzremrangebyscore mysort 0 88\rzrangebyscore mysort 0 100 withscores limit 0 1\rzincrby mysort 3 oliver\rzcount mysort 80 90\rzrank mysort oliver\rzrevrank mysort oliver</pre>\r\r<p>常见的使用场景：</p>\r\r<ol>\r	<li>可以用于一个大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行zadd命令更新玩家的分数，此后再通过zrange命令获取积分top10的用户信息。当然，我们也可以利用zrank命令通过username来获取玩家的排行信息。最后我们将组合使用zrange呵zrank命令快速的获取和某个玩家积分相近的其它用户的信息；</li>\r	<li>Sorted-Set类型还可用于构建索引数据。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 65),
(1338, 'Redis中keys的通用操作', '1338', 1549588819, 1549588819, '<p>本文记录Redis学习过程中遇到的Redis中keys的通用操作～</p>\r<!--more-->\r\r<p>常用命令：</p>\r\r<ul>\r	<li>keys pattern：获取所有与pattern匹配的key，返回所有与该pattern匹配的keys。*表示任意一个或多个字符，？表示任意一个字符；</li>\r	<li>del key1 key2...：删除指定的key；</li>\r	<li>exists key：判断该key是否存在，1表示存在，0表示不存在；</li>\r	<li>rename key1 key2：给key重命名；</li>\r	<li>expire key：设置过期时间，单位是秒；</li>\r	<li>ttl key：获取该key所剩的超时时间。如果没有设置超时，则返回-1；如果超时不存在，则返回-2；</li>\r	<li>type key：获取指定的key的类型，以字符串的格式返回，取值有string、list、set、hash和zset，不存在则返回none；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rkeys *\rdel name\rexist name\rrename key1 key2\rexpire name 60\rttl name\rtype name</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 53),
(1339, 'Redis的多数据库特性', '1339', 1549589880, 1549590426, '<p>本文记录Redis学习过程中遇到的Redis的多数据库特性～</p>\r<!--more-->\r\r<p>一个Redis实例可以包括多个数据库，客户端可以指定连接某个Redis实例的哪个数据库，就好比一个MySQL中创建多个数据库，客户端连接时指定连接哪个数据库。</p>\r\r<p>一个Redis实例最多可提供16个数据库，下标从0到15，客户端默认连接第0号数据库。</p>\r\r<p>常用命令：</p>\r\r<ul>\r	<li>select #：切换数据库；</li>\r	<li>move key #：将key移动的#库；</li>\r	<li>ping：测试连接是否存活；</li>\r	<li>echo：在命令行打印一些内容；</li>\r	<li>quit：推出连接；</li>\r	<li>dbsize：返回当前数据库中key的数目；</li>\r	<li>info：获取服务器的信息和统计；</li>\r	<li>flushdb：删除当前选择数据库中的所有key；</li>\r	<li>flushall：删除所有库中的所有key。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rselect 1\rmove name 1\rping\rshutdown\rping\recho oliver\rdbsize\rinfo\rflushdb\rflushall</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 67),
(1342, 'Redis的事务', '1342', 1549600562, 1549600562, '<p>本文记录Redis学习过程中遇到的事务～</p>\r<!--more-->\r\r<p>和众多其它数据库一样，Redis也同样提供了事务机制。在Redis中，multi/exec/discard这三个命令是我们实现事务的基石。</p>\r\r<p>Redis事务的特征：</p>\r\r<ol>\r	<li>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事务中的所有命令被原子的执行；</li>\r	<li>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行；</li>\r	<li>可以通过&ldquo;multi&rdquo;命令开启一个事务，对应于关系型数据库中的&ldquo;begin transaction&quot;语句。在该命令之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行exec/discard命令提交/回滚该事务之内的所有操作，对应于关系型数据库中的commit/rollback语句；</li>\r	<li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而，如果网络中断事件是发生在客户端执行exec命令之后，那么该事务中的所有命令都会被执行；</li>\r	<li>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内所有写操作在本次调用中全部写入磁盘。然而，如果在写入的过程中出现系统崩溃，那么此时就可能只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</li>\r</ol>\r\r<p>常用命令：</p>\r\r<ul>\r	<li>multi：开启事务，其后执行的命令都会被存入命令队列；</li>\r	<li>exec：提交事务；</li>\r	<li>discard：回滚事务。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rset num 1\rget num\rmulti\rincr num\rexec\rget num\rmulti\rincr num\rdiscard\rget num</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 51),
(1341, 'Redis的消息的订阅与发布', '1341', 1549597085, 1549597085, '<p>本文记录Redis学习过程中遇到的Redis的消息的订阅与发布～</p>\r\r<!--more-->\r\r<p>常用命令：</p>\r\r<ul>\r	<li>subscribe channel：订阅频道；</li>\r	<li>psubscribe channel*：批量订阅频道，channel*代表以channel开头的频道；</li>\r	<li>publish channel content：在指定的channel发布content消息。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rsubscribe mychat\rpsubscribe mychat*\rpublish mychat &quot;hello world&quot;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 52),
(1343, 'Redis的持久化', '1343', 1549613640, 1549613814, '<p>本文记录Redis学习过程中遇到的Redis的持久化～</p>\r<!--more-->\r\r<p>Redis的高性能是由于其将所有的数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘上，这个过程就是持久化。</p>\r\r<p>Redis支持两种方式的持久化，一种是RDB方式，另一种是AOF方式，可以单独使用其中一种或者将二者结合使用。</p>\r\r<p>1. RDB持久化（默认）</p>\r\r<p>该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘。</p>\r\r<p>2. AOF持久化</p>\r\r<p>该机制将以日志的形式记录服务器所处理的每一个写操作，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</p>\r\r<p>3. 无持久化</p>\r\r<p>可以通过配置的方式禁用Redis服务器的持久化功能，这样就可以将Redis变为一个功能加强版的memcached了。</p>\r\r<p>4. 同时开启RDB和AOF</p>\r\r<p>Redis支持同时开启RDB和AOF。</p>\r\r<p>RDB模式</p>\r\r<p>优势：</p>\r\r<ol>\r	<li>一旦采用该方式，整个Redis数据库将只包含一个文件，这对于文件备份而言是很好的。通过备份，一旦系统出现故障，可以非常容易的进行恢复；</li>\r	<li>对于灾难恢复，RDB是个不错的选择，因为可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上；</li>\r	<li>性能最大化，对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程进行IO操作了；</li>\r	<li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li>\r</ol>\r\r<p>劣势：</p>\r\r<ol>\r	<li>如果想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB不是一个很好的选择。因为系统一旦在定时持久性之前出现宕机，在此之前没有写入磁盘的数据都会丢失；</li>\r	<li>由于RDB是通过fork子进程来协助完成数据持久化工作的。因此，如果当数据集较大时，可能会导致整个服务器停止几百毫秒，甚至一秒钟。</li>\r</ol>\r\r<p>配置：</p>\r\r<p>快照参数</p>\r\r<ul>\r	<li>save 900 1：每900秒（15分钟）至少有1个key发生变化，则dump内存快照；</li>\r	<li>save 300 10：每300秒（5分钟）至少有10个key发生变化，则dump内存快照；</li>\r	<li>save 60 10000：每60秒（1分钟）至少有10000个key发生变化，则dump内存快照。</li>\r</ul>\r\r<p>保存位置</p>\r\r<ul>\r	<li>dbfilename dump.rdb：保存的文件名；</li>\r	<li>dir ./：保存在当前目录。</li>\r</ul>\r\r<p>AOF</p>\r\r<p>优势：</p>\r\r<ol>\r	<li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中；</li>\r	<li>AOF机制对日志文件的写入操作采用的是Append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而，如果我们本次操作只是写入了一半数据就出现了系统崩溃文件，不用担心，在Redis下一次启动之前，可以通过redis-check-aof工具来帮我们解决数据一致性的问题；</li>\r	<li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以Append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此，AOF机制在进行rewrite切换时可以更好的保证数据安全性；</li>\r	<li>AOF包含一个格式清晰并且易于理解的日志文件用于记录所有的修改操作。事实上，也可以通过该文件完成数据的重建。</li>\r</ol>\r\r<p>劣势：</p>\r\r<ol>\r	<li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件；</li>\r	<li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li>\r</ol>\r\r<p>配置：</p>\r\r<ul>\r	<li>appendonly yes/no：是否开启AOF；</li>\r	<li>appendfsync always/everysec/no：每修改写入/每秒写入/不同步。</li>\r</ul>\r\r<p>命令：</p>\r\r<ul>\r	<li>bgrewriteaof：不满足重写条件的时候，手动重写。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 78),
(1344, 'Redis常用配置', '1344', 1549619871, 1549619871, '<p>本文记录Redis学习过程中遇到的Redis的常用配置～</p>\r<!--more-->\r\r<p>Redis常见的配置如下：</p>\r\r<ul>\r	<li>daemonize：默认情况下，Redis不是在后台运行的。如果需要在后台运行，把该项的值更改为yes；</li>\r	<li>pidfile：当Redis在后台运行的时候，Redis默认会被pid文件放在/var/run/redis.pid，可以配置到其它地址。当运行多个redis服务时，需要指定不同的pid文件很多口；</li>\r	<li>bind：指定Redis只接收来自该IP地址的请求。如果不进行设置，那么将处理所有请求，建议在生产环境中配置此项；</li>\r	<li>port：监听端口，默认为6379；</li>\r	<li>timeout：设置客户端连接时的超时时间，单位是秒；</li>\r	<li>loglevel：log等级有四个：debug，verbose，notice和warning，生产环境一般开启notice；</li>\r	<li>logfile：配置log文件地址，默认使用标准输出，也就是打印在命令行终端的窗口上；</li>\r	<li>databases：设置数据库的个数，可以使用select命令来切换数据库，默认使用的是0库；</li>\r	<li>save：设置Redis进行数据库镜像的频率；</li>\r	<li>rdbcompression：在进行镜像备份时，是否进行压缩；</li>\r	<li>dbfilename：镜像备份文件的文件名；</li>\r	<li>dir：数据库镜像备份的文件放置的路径（这里的路径跟文件名要分开配置是因为Redis在进行备份时，先会将当前数据库的状态写入到一个临时文件中。等备份完成时，再把该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中）；</li>\r	<li>slaveof：设置该数据库为其它数据库的从库；</li>\r	<li>masterauth：当主数据库连接需要密码验证时需要指定此项；</li>\r	<li>requirepass：设置客户端连接后进行任何其它指定前需要使用的密码（因为Redis速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒进行15w次密码尝试，所以需要指定非常强大的密码来防止暴力破解）；</li>\r	<li>maxclients：限制同时连接的客户端数量。当连接数超过这个值时，Redis将不再接收其它连接请求，客户端尝试连接时将收到Error信息；</li>\r	<li>maxmemory：设置redis能够使用的最大内存（当内存满了的时候，如果还接收到set命令，Redis将先尝试剔除设置过expire信息的key，而不管该key的过期时间有没有到。在删除时，将按照过期时间进行剔除，最早将要被过期的key将最先被删除。如果带有expire信息的key都删光了，那么将返回错误。这样，Redis将不再接收写请求，而只接收读请求。maxmemory的设置比较适合于把Redis当作类似memcached的缓存使用）；</li>\r	<li>appendonly：AOF模式是否开启的设置；</li>\r	<li>appendfsync：设置AOF模式的频率，取值有always、everysec和no；</li>\r	<li>vm-enabled：是否开启虚拟内存支持；</li>\r	<li>vm-swap-file：设置虚拟内存的交换文件的路径；</li>\r	<li>vm-max-memory：设置开启虚拟内存之后，Redis将使用的最大物理内存的大小（默认为0，Redis将把他所有的能放到交换文件的都放到交换文件中，以尽量少的使用物理内存。生产环境下建议根据实际情况设置该值，最好不要使用默认值0）；</li>\r	<li>vm-page-size：设置虚拟内存的页大小（如果value的比较大，也就是说要在value中放置博客、新闻之类的所有文章内容，就设置的大一点，如果要放置的都是很小的内容，就设置的小一点）；</li>\r	<li>vm-pages：设置交换文件的总page数量（page table信息会放在物理内存中，每8个page就会占据内存中的1个byte，总的虚拟内存大小=vm-page-size*vm-pages）；</li>\r	<li>vm-max-threads：设置vm的IO同时使用的线程数量（因为在进行内存交换时，对数据有编码和解码的过程，所以尽管IO设备在硬件上本不能支持很多的并发读写，但是如果保存的value值比较大，将该值设置大一些，还是能够提升性能的）；</li>\r	<li>glueoutputbuf：把小的输出缓存放在一起，以便能够在通过tcp packet中为客户端发送多个响应；</li>\r	<li>hash-max-zipmap-entries：在Redis 2.0中引入了hash数据结构，当hash中包含超过指定元素个数并且最大的元素没有超过临界值时，hash将以一种特殊的编码格式来存储，这里可以设置这两个临界值；</li>\r	<li>activerrehashing：开启之后，Redis将在每100ms时候使用1ms的CPU时间来对Redis的hash表进行重新hash，可以降低内存的使用。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 98),
(1347, 'ORM原理.png', 'ORM原理-png', 1550397559, 1550397559, 'a:5:{s:4:"name";s:13:"ORM原理.png";s:4:"path";s:35:"/usr/uploads/2019/02/2946009804.png";s:4:"size";i:139986;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1348, 0),
(1348, 'Hibernate简介', '1348', 1550397540, 1554161623, '<p>本文记录Java学习过程中遇到的Hibernate简介～</p>\r<!--more-->\r\r<p>Hibernate框架是当今主流的Java持久层框架之一，由于它具有简单易学、灵活性强、扩展性强等特点，能够大大地简化程序的代码量，提高工作效率，因此受到广大开发人员的喜爱。</p>\r\r<p>Hibernate是一个开放源码的ORM（Object Relational Mapping，对象关系映射）框架，它对JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。</p>\r\r<p>使用传统的JDBC开发应用系统时，如果是小型应用系统，并不觉得有多么麻烦，但是对于大型应用系统的开发，使用JDBC就会显得力不从心。例如，对几十或者几百张包含几十个字段的表进行插入操作时，编写的SQL语句不但很长，而且繁琐，容易出错。在读取数据时，需要写多条get语句从结果集中取出各个字段的信息，不但枯燥重复，而且工作量非常大。为了提高数据访问层的编程效率，Gavin King开发出了一个当今最流行的ORM框架，也就是Hibernate框架。</p>\r\r<p>所谓的ORM就是利用描述对象和数据库之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把ORM理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。</p>\r\r<p>ORM的原理如下图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/02/2946009804.png" style="width: 800px; height: 238px;" /></p>\r\r<p>与其它操作数据库的技术相比，Hibernate具有以下几点优势：</p>\r\r<ul>\r	<li>Hibernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率；</li>\r	<li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO（Data Access Object，数据访问对象）层的编码工作；</li>\r	<li>Hibernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系；</li>\r	<li>可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用的时候，可以自行编码进行扩展。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 57),
(1349, 'Hibernate常用配置', '1349', 1550402340, 1554162115, '<p>本文记录Java学习过程中遇到的Hibernate的常用配置～</p>\r<!--more-->\r\r<p>映射文件的配置</p>\r\r<p>该配置文件用于向Hibernate提供持久化类到关系型数据库的映射，每个映射文件的结构基本都是相同的，常见的格式如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r&lt;!DOCTYPE hibernate-mapping PUBLIC \r    &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;\r    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;\r   &lt;!-- 配置表与实体对象的关系 --&gt;\r   &lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;\r&lt;hibernate-mapping package=&quot;ren.oliver.domain&quot; &gt;\r	&lt;!-- \r		class元素: 配置实体与表的对应关系的\r			name: 完整类名\r			table:数据库表名\r	 --&gt;\r	&lt;class name=&quot;Customer&quot; table=&quot;cst_customer&quot; &gt;\r		&lt;!-- id元素:配置主键映射的属性\r				name: 填写主键对应属性名\r				column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名\r				type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.\r						每个类型有三种填法: java类型|hibernate类型|数据库类型\r				not-null(可选):配置该属性(列)是否不能为空. 默认值:false\r				length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度\r		 --&gt;\r		&lt;id name=&quot;cust_id&quot;  &gt;\r			&lt;!-- generator:主键生成策略--&gt;\r			&lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;\r		&lt;/id&gt;\r		&lt;!-- property元素:除id之外的普通属性映射\r				name: 填写属性名\r				column(可选): 填写列名\r				type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.\r						每个类型有三种填法: java类型|hibernate类型|数据库类型\r				not-null(可选):配置该属性(列)是否不能为空. 默认值:false\r				length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度\r		 --&gt;\r		&lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot; &gt;\r			&lt;!--  &lt;column name=&quot;cust_name&quot; sql-type=&quot;varchar&quot; &gt;&lt;/column&gt; --&gt;\r		&lt;/property&gt;\r	&lt;/class&gt;\r&lt;/hibernate-mapping&gt;</pre>\r\r<p>注意：映射文件通常是一个XML文件即可，但一般命名为：类型.hbm.xml</p>\r\r<p>核心配置文件：</p>\r\r<p>Hibernate的配置文件，包含了连接持久层与映射文件所需的基本信息，其配置文件有两种格式，具体如下：</p>\r\r<ul>\r	<li>一种是properties属性文件格式的配置文件，它使用键值对的形式存放信息，默认文件名称为hibernate.properties；</li>\r	<li>另一种是xml格式的配置文件，xml配置文件的默认名称为hibernate.cfg.xml。</li>\r</ul>\r\r<p>上述两种格式的配置文件是等价的，具体使用哪个可以自由选择。xml格式的配置文件更易于修改，配置能力更强，当改变底层应用配置时候不需要改变和重新编译代码，只修改配置文件的相应属性即可，而properties格式的文件则不具有此优势。因此，在实际项目开发中，大多数情况会使用xml格式的配置文件。</p>\r\r<p>xml格式的配置文件常见的格式如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r&lt;!DOCTYPE hibernate-configuration PUBLIC\r	&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;\r	&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;\r&lt;hibernate-configuration&gt;\r	&lt;session-factory&gt;\r	\r		&lt;!-- \r		#hibernate.dialect org.hibernate.dialect.MySQLDialect\r		#hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect\r		#hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect\r		#hibernate.connection.driver_class com.mysql.jdbc.Driver\r		#hibernate.connection.url jdbc:mysql:///test\r		#hibernate.connection.username gavin\r		#hibernate.connection.password\r		 --&gt;\r		 &lt;!-- 数据库驱动 --&gt;\r		&lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;\r		 &lt;!-- 数据库url --&gt;\r		&lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate&lt;/property&gt;\r		 &lt;!-- 数据库连接用户名 --&gt;\r		&lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt;\r		 &lt;!-- 数据库连接密码 --&gt;\r		&lt;property name=&quot;hibernate.connection.password&quot;&gt;1234&lt;/property&gt;\r		&lt;!-- 数据库方言\r			不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.\r			sql99标准: DDL 定义语言  库表的增删改查\r					  DCL 控制语言  事务 权限\r					  DML 操纵语言  增删改查\r			注意: MYSQL在选择方言时,请选择最短的方言.\r		 --&gt;\r		&lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\r		\r		\r		&lt;!-- #hibernate.show_sql true \r			 #hibernate.format_sql true\r		--&gt;\r		&lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt;\r		&lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;\r		&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt;\r		&lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;\r		&lt;!-- \r		## auto schema export  自动导出表结构. 自动建表\r		#hibernate.hbm2ddl.auto create		自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)\r		#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)\r		#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).\r		#hibernate.hbm2ddl.auto validate	校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败.\r		 --&gt;\r		&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;\r		&lt;!-- 引入orm元数据\r			路径书写: 填写src下的路径\r		 --&gt;\r		&lt;mapping resource=&quot;ren/oliver/domain/Customer.hbm.xml&quot; /&gt;\r		\r	&lt;/session-factory&gt;\r&lt;/hibernate-configuration&gt;</pre>\r\r<p>该配置文件的根元素是hibernate-configuration，该元素包含子元素session-factory，在session-factory元素中又包含了多个property元素，这些property元素用来对Hibernate连接数据库的一些重要信息进行配置。</p>\r\r<p>Hibernate核心配置文件的一些常用属性名称及用途如下：</p>\r\r<ul>\r	<li>hibernate.dialect：操作数据库的方言；</li>\r	<li>hibernate.connection.driver_class：连接数据库驱动程序；</li>\r	<li>hibernate.connection.url：连接数据库的URL地址；</li>\r	<li>hibernate.connection.username：数据库的用户名；</li>\r	<li>hibernate.connection.password：数据库的密码；</li>\r	<li>hibernate.show_sql：在控制台上输出SQL语句；</li>\r	<li>hibernate.format_sql：格式化控制台输出的SQL语句；</li>\r	<li>hibernate.hbm2ddl.auto：当SessionFactory创建时是否根据映射文件自动验证表结构或自动创建更新数据库表结构；</li>\r	<li>hibernate.connection.autocommit：事务是否自动提交。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 67),
(1346, '文件上传', '1346', 1550392860, 1550395660, '<p>本文记录Java学习过程中遇到的文件上传～</p>\r<!--more-->\r\r<p>其实，文件上传和下载的实质都是文件的拷贝：</p>\r\r<ul>\r	<li>文件上传：从本地拷贝到服务器磁盘上；</li>\r	<li>文件下载：从服务器磁盘上拷贝到本地磁盘。</li>\r</ul>\r\r<p>文件上传的步骤：</p>\r\r<ul>\r	<li>客户端写一个文件上传表单；</li>\r	<li>编写服务器端的代码用于接收上传的文件。</li>\r</ul>\r\r<p>示例代码（客户端）：</p>\r\r<pre class="brush:xml;">\r&lt;form action=&quot;/WEB32/fileuploadServlet2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\r	&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;\r	&lt;input type=&quot;file&quot; name=&quot;filename&quot;&gt;&lt;br&gt;\r	&lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;&gt;\r&lt;/form&gt;</pre>\r\r<p>注意：</p>\r\r<ul>\r	<li>method必须是post；</li>\r	<li>enctype必须是multipart/form-data。</li>\r</ul>\r\r<p>示例代码（服务端）：</p>\r\r<pre class="brush:java;">\r//1、创建磁盘文件项工厂\r//作用：设置缓存文件的大小  设置临时文件存储的位置\rString path_temp = this.getServletContext().getRealPath(&quot;temp&quot;);\r//DiskFileItemFactory factory = new DiskFileItemFactory(1024*1024, new File(path_temp));\rDiskFileItemFactory factory = new DiskFileItemFactory();\rfactory.setSizeThreshold(1024*1024);\rfactory.setRepository(new File(path_temp));\r//2、创建文件上传的核心类\rServletFileUpload upload = new ServletFileUpload(factory);\r//设置上传文件的名称的编码\rupload.setHeaderEncoding(&quot;UTF-8&quot;);\r\r//ServletFileUpload的API\rboolean multipartContent = upload.isMultipartContent(request);//判断表单是否是文件上传的表单\rif(multipartContent){\r	//是文件上传的表单\r	//***解析request获得文件项集合\r	List&lt;FileItem&gt; parseRequest = upload.parseRequest(request);\r	if(parseRequest!=null){\r		for(FileItem item : parseRequest){\r			//判断是不是一个普通表单项\r			boolean formField = item.isFormField();\r			if(formField){\r				//username=zhangsan\r				String fieldName = item.getFieldName();\r				String fieldValue = item.getString(&quot;UTF-8&quot;);//对普通表单项的内容进行编码\r				\r				System.out.println(fieldName+&quot;----&quot;+fieldValue);\r				\r				//当表单是enctype=&quot;multipart/form-data&quot;时 request.getParameter相关的方法\r				//String parameter = request.getParameter(&quot;username&quot;);\r			}else{\r				//文件上传项\r				//文件的名\r				String fileName = item.getName();\r				//获得上传文件的内容\r				InputStream in = item.getInputStream();\r				String path_store = this.getServletContext().getRealPath(&quot;upload&quot;);\r				OutputStream out = new FileOutputStream(path_store+&quot;/&quot;+fileName);\r				IOUtils.copy(in, out);\r				in.close();\r				out.close();\r				\r				//删除临时文件\r				item.delete();\r			}\r		}\r\r}else{\r	//不是文件上传表单\r	//使用原始的表单数据的获得方式 request.getParameter();\r}</pre>\r\r<p><strong>常用的API</strong></p>\r\r<p>DiskFileItemFactory：磁盘文件项工厂（一些相关的配置的设置：缓存的大小和临时目录的位置）：</p>\r\r<ul>\r	<li>factory.setSizeThreshold()：设置缓存大小，单位是字节；</li>\r	<li>factory.setRepository(File)：设置临时文件的目录。</li>\r</ul>\r\r<p>ServletFileUplaod：文件上传的一个核心类 ：</p>\r\r<ul>\r	<li>ServletFileUpload.isMultipartContent(request)：判断是否是一个文件上传的表单；</li>\r	<li>upload.parseRequest(request)：解析request获得表单项的集合；</li>\r	<li>upload.setHeaderEncoding(&quot;UTF-8&quot;)：设置上传的文件名的编码方式。</li>\r</ul>\r\r<p>FileItem：代表每一个表单项：</p>\r\r<ul>\r	<li>item.isFormField()：判断是否是普通表单项；</li>\r	<li>item.getFieldName()：获得表单的name属性值；</li>\r	<li>item.getString(&quot;UTF-8&quot;)：获得表单的value值；</li>\r	<li>item.getName()：获得上传文件的名称；</li>\r	<li>item.getInputStream()：获得上传文件；</li>\r	<li>item.delete()：删除临时文件。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 58);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1350, 'Hibernate常用API', '1350', 1550406840, 1550406960, '<p>本文记录Java学习过程中遇到的Hibernate的常用API～</p>\r<!--more-->\r\r<p>hibernate常用的API有四种，分别是：Configuration、SessionFactory、Session和Transaction。</p>\r\r<p><strong>Configuration</strong></p>\r\r<p>Configuration主要用于加载配置文件。在使用hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载和管理hibernate的配置文件信息。在启动hibernate的过程中，Configuration实例首先确定hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 加载src下面的hibernate.cfg.xml配置文件\rConfiguration config = new Configuration().config();\r\r// 加载自定义位置的配置文件\rConfiguration config = new Configuration().config(&quot;自定义位置&quot;);\r\r// 加载额外的映射文件，适用于properties格式的核心配置文件\rconfig.addResource(&quot;xxx/Class.hbm.xml&quot;);</pre>\r\r<p><strong>SessionFactory</strong></p>\r\r<p>SessionFactory接口负责hibernate的初始化和建立session对象。它在hibernate中起到一个缓冲区作用，hibernate可以将自动生成的SQL语句、映射数据和某些可重复利用的数据放在这个缓冲区中。同时，它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rSessionFactory sessionFactory = config.buildSessionFactory();</pre>\r\r<p>SessionFactory具有如下特点：</p>\r\r<ul>\r	<li>它是线程安全的，同一个实例能够提供多个线程共享；</li>\r	<li>它是重量级的，不能随意的创建和销毁它的实例。</li>\r</ul>\r\r<p>由于SessionFactory的这些特点，一般情况下，一个项目中只需要一个SessionFactory，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，在实际项目开发中，通常会抽取一个工具类来提供Session对象。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class HibernateUtils {\r	private static final SessionFactory sf;\r	\r	static{\r		//1 创建,调用空参构造\r		Configuration conf = new Configuration().configure();\r		//2 根据配置信息,创建 SessionFactory对象\r		 sf = conf.buildSessionFactory();\r	}\r	\r	//获得session =&gt; 获得全新session\r	public static Session openSession(){\r				//3 获得session\r				Session session = sf.openSession();\r				\r				return session;\r		\r	}\r	//获得session =&gt; 获得与线程绑定的session\r	public static Session getCurrentSession(){\r		//3 获得session\r		Session session = sf.getCurrentSession();\r		\r		return session;\r	}\r	public static void main(String[] args) {\r		System.out.println(HibernateUtils.openSession());\r	}\r	\r}</pre>\r\r<p>SessionFactory内部还维护了一个连接池，如果需要使用第三方的连接池，如C3P0，那么需要手工进行配置。</p>\r\r<pre class="brush:xml;">\r&lt;!--配置C3P0连接池--&gt;\r&lt;property name=&quot;connection.provider_class&quot;&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt;\r&lt;!--在连接池中可用的数据库连接的最少数目--&gt;\r&lt;property name=&quot;c3p0.min_size&quot;&gt;5&lt;/property&gt;\r&lt;!--在连接池中所有数据库连接的最大数目--&gt;\r&lt;property name=&quot;c3p0.max_size&quot;&gt;20&lt;/property&gt;\r&lt;!--连接的超时时间，单位为秒--&gt;\r&lt;property name=&quot;c3p0.timeout&quot;&gt;120&lt;/property&gt;\r&lt;!--超时连接的检查时间--&gt;\r&lt;property name=&quot;c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt;</pre>\r\r<p><strong>Session</strong></p>\r\r<p>session是应用程序与数据库之间交互操作的一个单线程对象，是hibernate运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。</p>\r\r<p>创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rSession session1 = sessionFactory.openSession();\rSession session2 = sessionFactory.getCurrentSession();</pre>\r\r<p>以上两种获取Session实例方式的主要区别是，采用openSession方法获取session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而，getCurrentSession方法创建的Session实例会被当定到当前线程中，它在提交或回滚操作时会自动关闭。</p>\r\r<p>Session是线程不安全的，多个并发线程同时操作一个Session实例时，就可能导致Session数据存取的混乱。因此，设计软件架构时应避免多个线程共享一个Session实例。同时它也是轻量级的，实例的创建和销毁不需要消耗太多的资源。它还有一个缓存，即hibernate的一级缓存，这个缓存主要用于存放当前工作单元加载的对象。</p>\r\r<p>在Session中提供了大量的常用方法，具体如下：</p>\r\r<ul>\r	<li>save()、update()和saveOrUpdate()方法：用于增加和修改对象；</li>\r	<li>delete()方法：用于删除对象；</li>\r	<li>get()和load()方法：根据主键查询；</li>\r	<li>createQuery()和createSQLQuery()方法：用于数据库查询对象；</li>\r	<li>createCriteria()方法：条件查询。</li>\r</ul>\r\r<p><strong>Transaction</strong></p>\r\r<p>Transaction接口用于管理事务，它是hibernate的数据库事务接口，并且对底层的事务接口进行了封装。</p>\r\r<p>实例代码：</p>\r\r<pre class="brush:java;">\rTransaction transaction = session.beginTransaction()；</pre>\r\r<p>在Transaction接口中，提供了事务管理的常用方法，具体如下：</p>\r\r<ul>\r	<li>commit()方法：提交事务；</li>\r	<li>rollcack()方法：回滚事务。</li>\r</ul>\r\r<p>Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发生错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法或者rollback()方法。如果没有开启事务，那么每个session操作都相当于一个独立的事务。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 60),
(1351, 'Hibernate持久化类简介', '1351', 1550936891, 1550936891, '<p>本文记录Java学习过程中遇到的Hibernate持久化类简介～</p>\r\r<!--more-->\r\r<p>Hibernate是持久层的ORM映射框架，专注于数据的持久化工作。所谓的持久化，就是将闪存中的数据永久存储到关系型数据库中。</p>\r\r<p>所谓的持久化类就是一个与数据库表建立了映射关系的Java实体类，可以简答的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 44),
(1352, 'Hibernate持久化类编写规则', '1352', 1550973164, 1550973164, '<p>本文记录Java学习过程中遇到的Hibernate持久化类编写规则～</p>\r<!--more-->\r\r<p>在编写持久化类的时候有以下几点需要注意：</p>\r\r<ul>\r	<li>持久化类需要提供无参数的构造方法：因为在Hibernate底层需要诗意哦那个反射来生成类的实例；</li>\r	<li>持久化类的属性私有，对私有属性提供共有的set/get方法：因为在Hibernate底层会将查询到的数据进行封装；</li>\r	<li>持久化类的属性要尽量使用包装类的类型：因为包装类和基本数据类型的默认值不同，包装类的类型语义描述更清晰，而基本数据类型不容易描述；</li>\r	<li>持久化类要有一个唯一标示OID与表的主键对应：因为Hibernate中需要通过这个唯一标示OID区分在内存中是否是同一个持久化类（在Java中是通过地址区分是否是同一个对象的，在关系型数据库中是通过主键区分是否是同一条记录的，注意：Hibernate是不允许在内存中出现两个OID相同的持久化对象的）；</li>\r	<li>持久化类尽量不要使用final进行修饰：因为Hibernate中有延迟加载的机制，这个机制中会产生代理对象，Hibernate产生代理对象使用的是字节码的增强技术完成的（其实就是产生了当前类的一个子类对象实现的）。如果使用了final修饰持久化类，那么就不能产生子类，从而就不会产生代理对象，那么Hibernate的延迟加载策略就会失效。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1353, 'Hibernate主键类型', '1353', 1550973516, 1550973516, '<p>本文记录Java学习过程中遇到的Hibernate主键类型～</p>\r\r<!--more-->\r\r<p>Hibernate有两种主键类型，即自然主键和代理主键，具体说明如下：</p>\r\r<ul>\r	<li>自然主键：把具有业务含义的字段作为主键。例如，在User表中，将&ldquo;身份证号&rdquo;做为主键，身份证号不为null，且每个user的身份证号都不相同；</li>\r	<li>代理主键：把不具有业务含义的字段作为主键。该字段一般取名为&ldquo;ID&rdquo;，通常为整数类型，因为整数类型比字符串类型要节省更多的数据库空间。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 48),
(1354, 'Hibernate主键生成策略', '1354', 1550974525, 1550974525, '<p>本文记录Java学习过程中遇到的Hibernate主键生成策略～</p>\r<!--more-->\r\r<p>Hibernate中，提供了几个内置的主键生成策略，常用的主键生成策略的名称和描述如下：</p>\r\r<ul>\r	<li>increment：用于long、short或者int类型，由Hibernate自动以递增的方式生存唯一标示符，每次增加1。只有当没有其它进程向同一张表中插入数据时才可以使用，不能在集群环境下使用，适用于代理主键；</li>\r	<li>identity：采用底层数据库本身提供的主键生成标识符，条件是数据库支持自动增长数据类型。在DB2、MySQL、SQL Server、Sybase和HypersonicSQL数据库中可以使用该生成器，该生成器要求在数据库中把主键定义成为自增长类型，适用于代理主键；</li>\r	<li>sequence：Hibernate根据底层数据库序列生成标识符，条件是数据库支持序列，例如Oracle，适用于代理主键；</li>\r	<li>hilo：使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_unique_key，默认字段为integer类型，名称是next_hi；</li>\r	<li>native：根据底层数据库对自动生成标识符的能力来选择identity、sequence或hilo三种生成器中的一种，适合跨数据库平台开发，适用于代理主键；</li>\r	<li>uuid：Hibernate采用128位的UUID算法来生成标识符，该算法能够在网络环境中生成唯一的字符串标识符，其UUID被编码为一个长度为32位的十六进制字符串。这种策略并不流行，因为字符串类型的主键比整数类型的主键占用更多的数据库空间，适用于代理主键；</li>\r	<li>assigned：由Java程序负责生产标识符，如果不指定ID元素的generrator属性，则默认使用该主键生成策略，适用于自然主键。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1355, 'trans.png', 'trans-png', 1550976655, 1550976655, 'a:5:{s:4:"name";s:9:"trans.png";s:4:"path";s:35:"/usr/uploads/2019/02/3221317851.png";s:4:"size";i:230110;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1356, 0),
(1356, 'Hibernate持久化对象状态', '1356', 1550976660, 1554162734, '<p>本文记录Java学习过程中遇到的Hibernate持久化对象状态～</p>\r<!--more-->\r\r<p>Hibernate为了更好的来管理持久化类，特意将持久化类分成了三种状态。在Hibernate中持久化的对象可以划分为三种状态，分别是瞬时态、持久态和游离态。一个持久化态的实例可能处于三种不同状态中的某一种，三种状态的详细介绍如下：</p>\r\r<ul>\r	<li>瞬时态-transient：瞬时态也成为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标示OID，尚未与Hibernate的Session关联，在数据库中也没有对应的记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库中的数据无任何关联，仅是一个信息携带的载体；</li>\r	<li>持久态-persistent：持久态的对象存在持久化标示OID，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有相应的记录，每条记录只对应唯一的持久化对象。需要注意的是，持久态对象是在事务还未提交前变成持久态的；</li>\r	<li>游离态-detached：托管态也称为离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了游离态。游离态对象存在持久化标示OID，并且仍然与数据库中的记录存在关联，只是失去了与当前Session的关联，游离态对象发生改变时Hibernate不能检测到。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rSession session = HibernateUtils.openSession();\rTransaction tx = session.beginTransaction();\r\r//瞬时态\rUser user = new User();\ruser.setUsername(&quot;oliver&quot;);\r\r//持久态\rsession.save(user);\r\rtx.commit();\rsession.close();\r\r//游离态\rSystem.out.println(user.getUsername);</pre>\r\r<p>三种状态的状态演化图如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/02/3221317851.png" style="width: 800px; height: 508px;" /></p>\r\r<p>从上图可以看出，当一个对象被执行new创建后，该对象处于瞬时态；当对瞬时态对象执行Session的save()或saveOrUpdate()方法后，该对象将被放入Session的一级缓存，对象变成持久态；当对持久态对象执行evict()、close()或clear()操作后，对象进入游离态；当直接执行Session的get()、load()、find()或iterate()等方法从数据库查询对象时，查询到的对象也处于持久态；当对数据库中的记录进行update()、saveOrUpdate()或lock()等操作后，此时游离态的对象就过度到持久态；由于瞬时态和托管态的对象不在Session的管理范围，所以会在一段时间后被JVM回收。</p>\r\r<p>持久化对象的三种状态可以通过调用Session中的一系列方法实现状态间的转化，具体如下：</p>\r\r<p>1.瞬时态转化到其它状态</p>\r\r<ul>\r	<li>瞬时态转化为持久态：执行Session的save()或saveOrUpdate()方法；</li>\r	<li>瞬时态转换为托管态：为瞬时态对象设置持久化标示OID。</li>\r</ul>\r\r<p>2.持久态对象到其它状态</p>\r\r<ul>\r	<li>持久态转化为瞬时态：执行Session的delete()方法，需要注意的是被删除的持久化对象，不建议再次使用；</li>\r	<li>持久态转化为游离态：执行Session的evict()、close()或clear()方法。evict()方法用于清除一级缓存中某一个对象；close()方法用于关闭Session，清除一级缓存；clear()方法用于清除一级缓存的所有对象。</li>\r</ul>\r\r<p>3.游离态对象到其它状态</p>\r\r<ul>\r	<li>游离态转化为持久态：执行Session的update()、saveOrUpdate()或lock()方法；</li>\r	<li>游离态转化为瞬时态：将游离态对象的持久化标示OID设置为null。</li>\r</ul>\r\r<p>注意：持久化对象能够自动更新数据库中对应的记录。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 60),
(1357, 'Hibernate一级缓存', '1357', 1550978122, 1550978122, '<p>本文记录Java学习过程中遇到的Hibernate的一级缓存～</p>\r<!--more-->\r\r<p>缓存是计算机领域非常通用的概念。它介于应用程序和永久性数据存储源（如硬盘上的文件或者数据库）之间，其作用是降低应用程序直接读写永久性数据存储源的频率，从而提高应用的运行性能。</p>\r\r<p>缓存中的数据是数据存储源中数据的拷贝，缓存的物理介质通常是内存。</p>\r\r<p>Hibernate的缓存分为一级缓存和二级缓存，这两级缓存都位于持久化层，存储的都是数据库数据的备份。其中，一级缓存为Hibernate的内置缓存，不能被卸载。</p>\r\r<p>Hibernate的一级缓存就是指Session缓存，它是一块内存空间，用来存放管理的Java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。</p>\r\r<p>在Session接口的实现中包含一系列的Java集合，这些Java集合构成了Session缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。因此，一级缓存也被称为是Session基本的缓存。</p>\r\r<p>Hibernate的一级缓存有如下特点：</p>\r\r<ul>\r	<li>当应用程序调用Session接口的save()、update()、saveOrUpdate()时候，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相关对象信息加入到一级缓存中去；</li>\r	<li>当调用Session接口的load()、get()方法，以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，如果有则直接返回，不会查询数据库；如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中；</li>\r	<li>当调用Session的close()方法时，Session缓存会被清空。</li>\r</ul>\r\r<p>一级缓存中的快照：</p>\r\r<p>Hibernate向一级缓存放入数据时候，同时复制一份数据放入到Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 36),
(1358, 'Hibernate事务管理', '1358', 1550979720, 1550979812, '<p>本文记录Java学习过程中遇到的Hibernate的事务管理～</p>\r\r<!--more-->\r\r<p>在Hibernate中，可以通过代码来操作管理事务，如通过&quot;Transaction tx = session.beginTransaction();&quot;开启一个事务；持久化操作后，通过&quot;tx.commit();&quot;提交事务；如果事务出现异常，又通过&quot;tx.rollback();&quot;操作来回滚事务。</p>\r\r<p>除了在代码中对事务开启，提交和回滚操作外，还可以在Hibernate的配置文件中对事务进行配置。配置文件中，可以设置事务的隔离级别。其具体的配置方法是在hibernate.cfg.xml文件中的&lt;session-factory&gt;标签元素中进行的。配置方法如下所示：</p>\r\r<pre class="brush:xml;">\r&lt;!--\r	事务隔离级别：\r	1-Read uncommited isolation\r	2-Read commit isolation\r	4-Repeatable read isolation\r	8-Serializable isolation\r--&gt;\r&lt;property name=&quot;hibernate.connection.isolation&quot;&gt;4&lt;/property&gt;</pre>\r\r<p>真正进行事务管理的时候，需要考虑事务的应用场景，也就是说事务控制不应该是DAL层实现的，应该在Service层实现，并且在Service中调用多个DAL实现一个业务逻辑的操作。</p>\r\r<p>其实最主要的是如何在Service中开启事务时使用的Session对象和DAO中多个操作使用的是同一个Session对象。</p>\r\r<p>有两种实现方案：</p>\r\r<ul>\r	<li>在业务层获取到Session，并将Session作为参数传递给DAO；</li>\r	<li>可以使用TreadLocal将业务层获取的Session绑定到当前线程中，然后在DAO中获取Session的时候，都从当前线程中获取。</li>\r</ul>\r\r<p>第二种方式肯定是最优方案，Hibernate的内部已经将这个事情做了，我们只需要配置下。</p>\r\r<p>Hibernate中提供了三种管理Session对象的方法：</p>\r\r<ul>\r	<li>thread：Session对象的生命周期与本地线程绑定；</li>\r	<li>jta：Session对象的生命周期与JTA事务绑定；</li>\r	<li>managed：Hibernate委托程序管理Session对象的生命周期。</li>\r</ul>\r\r<p>配置方式如下：</p>\r\r<pre class="brush:xml;">\r&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;</pre>\r\r<p>hibernate提供sessionFactory.getCurrentSession()创建一个session与ThreadLocal绑定。</p>\r\r<p>而且，Hibernate中提供的这个与线程绑定的Session可以不用关闭，当线程执行结束后，就会自动关闭了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 45),
(1359, 'Hibernate其它常用API', '1359', 1550984001, 1550984001, '<p>本文记录Java学习过程中遇到的Hibernate的Hibernate其它常用API～</p>\r<!--more-->\r\r<p><strong>Query</strong></p>\r\r<p>Query代表面向对象的一个Hibernate查询操作。在Hibernate中，通常使用session.createQuery()方法接受一个HQL语句，然后调用Query的list或uniqueResult()方法执行查询。所谓的HQL是Hibernate Query Language的缩写，其语法很像SQL语法，但它是完全面向对象的。</p>\r\r<p>具体使用步骤如下：</p>\r\r<ol>\r	<li>获得Hibernate的Session对象；</li>\r	<li>编写HQL语句；</li>\r	<li>调用session.createQuery创建查询对象；</li>\r	<li>如果HQL语句包含参数，则调用Query的set方法设置参数；</li>\r	<li>调用Query对象的list()或uniqueResult()方法执行查询。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//查询所有记录\rQuery query = session.createQuery(&quot;from User&quot;);\rList&lt;User&gt; userList = query.list();\rSystem.out.println(userList);\r\r//条件查询-?\rQuery query = session.createQuery(&quot;from User where username = ?&quot;);\rquery.setString(0, &quot;oliver&quot;);\rList&lt;User&gt; userList = query.list();\rSystem.out.println(userList);\r\r//条件查询-变量\rQuery query = session.createQuery(&quot;from User where username = :username and age= :age&quot;);\rquery.setString(&quot;username&quot;, &quot;oliver&quot;);\rquery.setInteger(&quot;age&quot;, 18);\rList&lt;User&gt; userList = query.list();\rSystem.out.println(userList);\r\r//分页查询\rQuery query = session.createQuery(&quot;from User&quot;);\rquery.setFirstResult(3);\rquery.setMaxResults(3);\rList&lt;User&gt; userList = query.list();\rSystem.out.println(userList);</pre>\r\r<p>Query中除了使用list()方法查询全部数据外，还有其它的一些常用方法，具体如下：</p>\r\r<ul>\r	<li>setter()方法：Query接口中提供了一系列的setter方法用于设置查询语句中的参数，针对不同的数据类型，需要使用不同的setter方法；</li>\r	<li>iterator()方法：该方法用于查询语句，返回的结果是一个Iterator对象，在读取时只能按照顺序方式读取，它仅把使用到的数据转化成Java实体对象；</li>\r	<li>uniqueResult()方法：该方法用于返回唯一的结果，在确保只有一条记录的查询时可以使用该方法；</li>\r	<li>executeUpdate()方法：该方法支持HQL语句的更新和删除操作；</li>\r	<li>setFirstResult()方法：该方法可以设置获取第一个记录的位置，也就是它表示从第几条记录开始查询，默认从0开始计算；</li>\r	<li>setMaxResults()方法：该方法用于设置结果集的最大记录数，通常与setFirstResult()方法结合使用，用于限制结果集的范围，以实现分页功能。</li>\r</ul>\r\r<p><strong>Criteria</strong></p>\r\r<p>Criteria是一个完全面向对象，可扩展的条件查询API，通过它完全不需要考虑数据库底层如何实现，以及SQL语句如何编写，它是Hibernate框架的核心查询对象。Criteria查询，又称为QBC查询（Query By Criteria），它是Hibernate的另一种对象检索方式。</p>\r\r<p>Criteria是Hibernate提供的一个面向对象查询条件接口，一个单独的查询就是Criteria接口的一个实例，用于限制Criteria对象的查询，在Hibernate中Criteria对象的创建通常是通过Restrictions工厂类完成的。</p>\r\r<p>使用Criteria对象查询数据的主要步骤如下：</p>\r\r<ol>\r	<li>获得Hibernate的Session对象；</li>\r	<li>通过Session获得Criteria对象；</li>\r	<li>使用Restrictions的静态方法创建Criteria条件对象。Restrictions类中提供了一系列用于设定查询条件的静态方法，这些静态方法都返回Criteria实例，每个Criteria实例代表一个查询条件；</li>\r	<li>向Criteria对象中添加Criteria查询条件。Criteria的add()方法用于加入查询条件；</li>\r	<li>执行Criteria的list()或uniqueResult()获得结果。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//查询所有记录\rCriteria criteria = session.createCriteria(User.class);\rList&lt;User&gt; userList =  criteria.list();\rSystem.out.println(userList);\r\r//条件查询\rCriteria criteria = session.createCriteria(User.class);\rcriteria.add(Restrictions.eq(&quot;username&quot;),&quot;oliver&quot;);\rList&lt;User&gt; userList =  criteria.list();\rSystem.out.println(userList);\r\r//条件查询\rCriteria criteria = session.createCriteria(User.class);\rcriteria.add(Restrictions.eq(&quot;username&quot;),&quot;oliver&quot;);\rcriteria.add(Restrictions.eq(&quot;age&quot;),38);\rList&lt;User&gt; userList =  criteria.list();\rSystem.out.println(userList);\r\r//分页查询\rCriteria criteria = session.createCriteria(User.class);\rcriteria.setFirstResult(3);\rcriteria.setMaxResults(3);\rList&lt;User&gt; userList =  criteria.list();\rSystem.out.println(userList);</pre>\r\r<p>注意：如果只返回一个值，可以使用uniqueResult()方法。</p>\r\r<p><strong>SQLQuery</strong></p>\r\r<p>SQLQuery比较简单，它用于接收一个SQL语句进行查询，然后调用list()或者uniqueResult()方法进行查询。但是SQL语句不会直接封装到实体对象中，需要我们手工封装。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//基本查询\rSQLQuery sqlQuery = session.createSQLQuery(&quot;select * from User&quot;);\rList&lt;Object[]&gt; list = sqlQuery.list();\r\rfor (Object[] objects : list) {\r	System.out.println(Arrays.toString(objects));\r}\r\r//自动封装到对象中\rSQLQuery sqlQuery = session.createSQLQuery(&quot;select * from User&quot;);\rsqlQuery.addEntity(User.class);\rList&lt;User&gt; list = sqlQuery.list();\r\rfor (User user : list) {\r	System.out.println(user);\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 43),
(1360, 'Hibernate常见表关系', '1360', 1550985432, 1550985432, '<p>本文记录Java学习过程中遇到的Hibernate常见表关系～</p>\r<!--more-->\r\r<p>Hibernate框架实现了ORM思想，将关系数据库中表的数据映射成对象，是开发人员把对数据库的操作转化为对对象的操作。</p>\r\r<p>数据库中表之间存在着三种关系，也就是系统设计中的三种实体关系，即一对一、一对多和多对多。</p>\r\r<p>三种关系的建表原则分别如下：</p>\r\r<ul>\r	<li>一对一：1）唯一外键对应：假设任意一方为多，在多的一方创建外键指向一的一方的主键，然后将外键设置为唯一；2）主键对应：一方的主键作为另一方的主键；</li>\r	<li>一对多：在多的一方创建外键指向一的一方的主键；</li>\r	<li>多对多：创建一个中间表，中间表中至少两个字段作为外键分别指向两个多方的主键。</li>\r</ul>\r\r<p>数据库表能够描述实体数据之间的关系，通过对象也可以进行描述，示例代码如下：</p>\r\r<pre class="brush:java;">\r//一对一\rclass A {\r	B b;\r}\rclass B {\r	A a;\r}\r\r//一对多\rclass A {\r	Set&lt;B&gt; bs;\r}\rclass B {\r	A a;\r}\r\r//多对多\rclass A {\r	Set&lt;B&gt; bs;\r}\rclass B {\r	Set&lt;A&gt; as;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1361, 'Hibernate一对多关系', '1361', 1550987012, 1550987012, '<p>本文记录Java学习过程中遇到的Hibernate一对多关系～</p>\r\r<!--more-->\r\r<p>一对多关系的表达</p>\r\r<p>在一的一方的映射文件中，使用&lt;set&gt;标签来描述被映射类中的Set集合，&lt;key&gt;标签的column属性值对应多的一方的外键名称，使用&lt;one-to-many&gt;标签来描述持久化类的一对多关联，其中class属性用来描述映射的关联类；在多的一方的映射文件中，用&lt;many-to-one&gt;标签来表达，name属性用来描述多的一方在一的一方类中的属性名称，class属性用来制定映射的类，column属性对应表中的外键列名。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r//一的一方\r&lt;set name=&quot;linkMans&quot;&gt;\r	&lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt;\r	&lt;one-to-many class=&quot;domain.LinkMan&quot;/&gt;\r&lt;/set&gt;\r\r//多的一方\r&lt;many-to-one name=&quot;customer&quot; class=&quot;domain.Customer&quot; column=&quot;lkm_cust_id&quot;/&gt;</pre>\r\r<p>一对多关系的相关操作</p>\r\r<p>级联操作是指当主控方执行保存、更新或者删除操作时，其关联对象（被控方）也执行相同的操作。在映射文件中通过对cascade属性的设置来控制是否对关联对象采用级联操作，级联操作对各种关联关系都是有效的。</p>\r\r<p>cascade的常见取值如下：</p>\r\r<ul>\r	<li>none：默认值，不进行级联操作；</li>\r	<li>save-update：级联保存更新；</li>\r	<li>delete：级联删除；</li>\r	<li>all：save-update+delete。</li>\r</ul>\r\r<p>放弃维护关系操作是指放弃外键的维护关系，也就是不再是双方同时维护外键关系，使用inverse属性配置。在一对多关系中，一般是一的一方放弃维护。</p>\r\r<p>inverse的常见取值如下：</p>\r\r<ul>\r	<li>false：默认值，不放弃维护关系；</li>\r	<li>true：放弃维护关系。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 43),
(1362, 'Hibernate多对多关系', '1362', 1550988603, 1550988603, '<p>本文记录Java学习过程中遇到的Hibernate多对多关系～</p>\r\r<!--more-->\r\r<p>多对多关系的表达</p>\r\r<p>两个多方都维护一个&lt;set&gt;，使用table属性指定第三张表的名称，使用key标签指定在第三张表中的字段名，然后使用many-to-many中的class属性指定要关联的类，column指定关联的外键列名。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;set name=&quot;roles&quot; table=&quot;sys_user_role&quot;&gt;\r	&lt;key column=&quot;user_id&quot;/&gt;\r	&lt;many-to-many class=&quot;domain.Role&quot; column=&quot;role_id&quot; /&gt;\r&lt;/set&gt;\r\r&lt;set name=&quot;users&quot; table=&quot;sys_user_role&quot;&gt;\r	&lt;key column=&quot;role_id&quot;/&gt;\r	&lt;many-to-many class=&quot;domain.User&quot; column=&quot;user_id&quot; /&gt;\r&lt;/set&gt;</pre>\r\r<p>注意：多对多关系中，必须有一方放弃维护外键关系，否则会发生主键冲突，一般是被动方放弃关系维护。</p>\r\r<p>多对多关系的相关操作</p>\r\r<p>级联操作是指当主控方执行保存、更新或者删除操作时，其关联对象（被控方）也执行相同的操作。在映射文件中通过对cascade属性的设置来控制是否对关联对象采用级联操作，级联操作对各种关联关系都是有效的。</p>\r\r<p>cascade的常见取值如下：</p>\r\r<ul>\r	<li>none：默认值，不进行级联操作；</li>\r	<li>save-update：级联保存更新；</li>\r	<li>delete：级联删除，多对多的时候不建议开启，一般都是不合理的；</li>\r	<li>all：save-update+delete。</li>\r</ul>\r\r<p>放弃维护关系操作是指放弃外键的维护关系，也就是不再是双方同时维护外键关系，使用inverse属性配置。在多对多关系中，一般是被动的一方放弃维护，比如角色方，而不是用户方。</p>\r\r<p>inverse的常见取值如下：</p>\r\r<ul>\r	<li>false：默认值，不放弃维护关系；</li>\r	<li>true：放弃维护关系。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1363, 'Hibernate检索方式', '1363', 1551000000, 1551013913, '<p>本文记录Java学习过程中遇到的Hibernate检索方式～</p>\r<!--more-->\r\r<p>Hibernate的检索方式主要有5种，分别是导航对象图检索方式、OID检索方式、HQL检索方式、QBC检索方式和SQL检索方式。下面对这5种检索方式的使用进行讲解：</p>\r\r<p>对象图导航检索</p>\r\r<p>对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。比如，要查找一个联系人对应的客户，就可以由联系人对象自动导航找到联系人所属的客户对象。当然，前提是必须在对象关系映射文件上配置了多对一的关系。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rLinkMan linkMan = (LinkMan)session.get(LinkMan.class, 1L);\rCustomer customer = linkMan.getCustomer();</pre>\r\r<p>OID检索方式</p>\r\r<p>OID检索方式主要是用Session的get()和load()方法加载某条记录对应的对象。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rCustomer customer = (Customer)session.get(Customer.class,1l);\rCustomer customer = (Customer)session.load(Customer.class,1l);</pre>\r\r<p>HQL检索</p>\r\r<p>HQL（Hibernate Query Language）是面向对象的查询语言，它和SQL查询语言有些相似，但它使用的是类、对象和属性的概念，而没有表和字段的概念。在Hibernate提供的各种检索方式中，HQL是官方推荐的查询语言，也是使用最广泛的一种检索方式。</p>\r\r<p>它具有如下功能：</p>\r\r<ul>\r	<li>在查询语句中设定各种查询条件；</li>\r	<li>支持投影查询，即仅检索出对象的部分属性；</li>\r	<li>支持分页查询；</li>\r	<li>支持分组查询，允许使用group by和having关键字；</li>\r	<li>提供内置聚合函数，如sum()、min()和max()等；</li>\r	<li>能够调用用户定义的SQL函数；</li>\r	<li>支持自查询，即嵌套查询；</li>\r	<li>支持动态绑定参数。</li>\r</ul>\r\r<p>Hibernate提供的Query接口是专门的HQL查询接口，它能够执行各种复杂的HQL查询语句。</p>\r\r<p>完整的HQL语句的结构如下：</p>\r\r<pre class="brush:java;">\rselect ... from ... where ... group by ... having ... ordery by ... asc/desc</pre>\r\r<p>可见HQL查询非常类似于标准SQL查询。通常情况下，当检索数据表中的所有记录时，查询语句中可以省略select关键字，示例如下：</p>\r\r<pre class="brush:java;">\rfrom User</pre>\r\r<p>如果执行该查询语句，则会返回应用程序中的所有Customer对象，需要注意的是Customer是类名，而不是表名，类名需要区分大小写，而关键字from不区分大小写。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 基本查询\rQuery query =  session createQuery(&quot;from Customer&quot;);\rList&lt;Customer&gt; list = query.list();\r\r// 别名\rQuery query =  session createQuery(&quot;select c from Customer c&quot;);\rList&lt;Customer&gt; list = query.list();\r\rfor (Customer c : list) {\r	System.out.println(c);\r}\r\r// 排序查询\rQuery query =  session createQuery(&quot;from Customer order by cust_id desc&quot;);\rList&lt;Customer&gt; list = query.list();\r\rfor (Customer c : list) {\r	System.out.println(c);\r}\r\r// 条件查询-？\rQuery query =  session createQuery(&quot;from Customer where cust_name = ?&quot;);\rquery.setString(0, &quot;oliver&quot;);\rquery.setParameter(0, &quot;oliver&quot;);\rList&lt;Customer&gt; list = query.list();\r\r// 条件查询-变量\rQuery query =  session createQuery(&quot;from Customer where cust_name = :name&quot;);\rquery.setString(&quot;name&quot;, &quot;oliver&quot;);\rquery.setParameter(&quot;name&quot;, &quot;oliver&quot;);\rList&lt;Customer&gt; list = query.list();\r\r// 分页查询\rQuery query =  session createQuery(&quot;from Customer order by cust_id desc&quot;);\rquery.setFirstResult(5);\rquery.setMaxResult(5);\rList&lt;Customer&gt; list = query.list();\r\r// 统计查询\rQuery query =  session createQuery(&quot;select count(*) from Customer&quot;);\rLong num = (Long)query.uniqueResult();\r\r// 投影查询-单列\rQuery query =  session createQuery(&quot;select cust_name from Customer&quot;);\rList&lt;String&gt; list = query.list();\r\r// 投影查询-多列\rQuery query =  session createQuery(&quot;select cust_id,cust_name from Customer&quot;);\rList&lt;Object[]&gt; list = query.list();\r\r// 构造方式的投影查询\rQuery query =  session createQuery(&quot;select new Customer(cust_id,cust_name} from Customer&quot;);\rList&lt;Customer&gt; list = query.list();</pre>\r\r<p>QBC检索</p>\r\r<p>QBC(Query By Criteria)是Hibernate提供的另一种检索对象的方式，它主要由Criteria接口、Criterion接口和Expression类组成。Criteria接口是Hibernate API中的一个查询接口，它需要由session进行创建。Criterion是Criteria的查询条件，在Criteria中提供了add(Criterion criterion)方法来添加查询条件。</p>\r\r<p>QBC的检索是使用Restrictions对象编写查询条件的，在Restrictions类中提供了大量的静态方法来创建查询条件。常用的方法如下：</p>\r\r<ul>\r	<li>eq：等于；</li>\r	<li>allEq：使用Map，使用key/value进行多个等于的比较；</li>\r	<li>gt：大于；</li>\r	<li>ge：大于等于；</li>\r	<li>lt：小于；</li>\r	<li>le：小于等于；</li>\r	<li>between：对应SQL的between子句；</li>\r	<li>like：对应SQL的like子句；</li>\r	<li>in：对应SQL的in子句；</li>\r	<li>and：and关系；</li>\r	<li>or：or关系；</li>\r	<li>sqlRestriction：SQL限定查询。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 简单查询\rCriteria criteria = session.createCriteria(Customer.class);\rList&lt;Customer&gt; list = criteria.list();\r\r// 条件查询\rCriteria criteria = session.createCriteria(Customer.class);\rcriteria.add(Restrictions.eq(&quot;csut_name&quot;, &quot;oliver&quot;));\rList&lt;Customer&gt; list = criteria.list();\r\r// 分页查询\rCriteria criteria = session.createCriteria(Customer.class);\rcriteria.setFirstResult(5);\rcriteria.setMaxResults(5);\rList&lt;Customer&gt; list = criteria.list();\r\r// 排序查询\rCriteria criteria = session.createCriteria(Customer.class);\rcriteria.addOrder(Order.desc(&quot;cust_id&quot;));\rList&lt;Customer&gt; list = criteria.list();\r\r// 统计查询\rCriteria criteria = session.createCriteria(Customer.class);\rcriteria.setProjection(Projections.rowCount());\rLong count = (Long) criteria.uniqueResult();</pre>\r\r<p>离线条件检索：</p>\r\r<p>DetachedCriteria翻译为离线条件查询，因为它是可以脱离Session来使用的一种条件查询对象。Criteria对象必须由Session对象来创建，也就是说必须先有Session才可以生成Criteria对象，而DetachedCriteria对象可以在其他层对条件进行封装。</p>\r\r<p>这个对象也是比较有用的，尤其是在SSH整合以后，这个对象经常会使用。它的主要优点是做一些特别复杂的条件查询的时候，往往会在WEB层向业务层传递很多的参数，业务层又会将这些参数传递给DAO层。最后，在DAO层中拼接SQL完成查询。有了离线条件查询对象后，这些工作都可以不用关心了，我们可以在WEB层将数据封装好，传递到业务层，再由业务层传递给DAO完成查询。</p>\r\r<p>SQL检索</p>\r\r<p>采用HQL或QBC检索方式时，Hibernate生成标准的SQL查询语句，适用于所有的数据库平台，因此这两种检索方式都是跨平台的。但有的应用程序可能需要根据底层数据的SQL方言来生成一些特殊的查询语句。在这种情况下，可以利用Hibernate提供的SQL检索方式。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rSQLQuery sqlQuery = session.createSQLQuery(&quot;select * from Customer&quot;);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 51),
(1364, 'MySQL连接查询', '1364', 1551015628, 1551015628, '<p>本文记录MySQL学习过程中遇到的MySQL连接查询～</p>\r<!--more-->\r\r<p><strong>交叉连接</strong></p>\r\r<p>交叉连接放回的结果是被连接的两个表中所有数据行的笛卡尔积，也就是返回第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</p>\r\r<p>交叉连接的语法格式如下：</p>\r\r<pre class="brush:sql;">\rselect * from table1 cross join table2;\rselect * from table1, table2;</pre>\r\r<p>从上述描述情况可以看出，交叉连接的结果就是两个表中所有数据的组合。需要注意的是，在实际开发中这种业务需求是很少见的，一般不会使用交叉连接，而是使用具体的条件对数据进行有目的的查询。</p>\r\r<p><strong>内连接</strong></p>\r\r<p>内连接又称简单连接或自然连接，是一种常见的连接查询。内连接使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据行，组合成新的记录，也就是说在内连接查询中，只有满足条件的记录才能出现在查询结果中。内连接查询的语法格式如下：</p>\r\r<pre class="brush:sql;">\rselect ... from table1 [inner] join table2 on table1.column1 = table2.column2;</pre>\r\r<p>在上述语法格式中，inner join用于连接两个表，on用于指定连接条件，其中inner可以省略。内连接其实还可以分为两类：</p>\r\r<p>1.隐式内连接：顾名思义隐式的就是看不到inner join关键字，而使用where关键字替代；</p>\r\r<pre class="brush:sql;">\rselect * from table1, table2 where table1.colume1 = table2.column2;</pre>\r\r<p>2.显示内连接：就是在语句中明显的调用了inner join关键字。</p>\r\r<pre class="brush:sql;">\rselect * from table1 inner join table2 on table1.column1 = table2.column2;\rselect * from table1 join table2 on table1.column1 = table2.column2;</pre>\r\r<p><strong>外连接</strong></p>\r\r<p>前门讲解的内连接查询中，返回的结果只包含符合查询条件和连接条件的数据，然而有时还需要包含没有关联的数据，即返回查询结果中不仅包含符合条件的数据，而且还包括左表（左连接或左外连接）、右表（右连接或右外连接）或两个表（全外连接）中的所有数据，此时就需要使用外连接查询，外连接分为左连接和右连接。</p>\r\r<p>外连接的语法格式如下：</p>\r\r<pre class="brush:sql;">\rselect ... from table1 left|right [outer] join table2 on table1.column1 = table2.column2 where ...;</pre>\r\r<p>外连接的语法格式和内连接类似，只不过使用的是left join和right join关键字，其中关键字左边的表被称为左表，关键字右边的表被称为右表。</p>\r\r<p>左右连接查询的结果是不一致的，具体如下：</p>\r\r<ul>\r	<li>left join：返回包括左表中的所有记录和右表中符合连接条件的记录。</li>\r</ul>\r\r<pre class="brush:sql;">\rselect * from table1 left outer join table2 on table1.column1 = table2.column2;\rselect * from table1 left join table2 on table1.column1 = table2.column2;</pre>\r\r<ul>\r	<li>right join：返回包括右表中的所有记录和左表中符合连接条件的记录。</li>\r</ul>\r\r<pre class="brush:sql;">\rselect * from table1 right outer join table2 on table1.column1 = table2.column2;\rselect * from table1 right join table2 on table1.column1 = table2.column2;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 60),
(1365, 'HQL连接查询', '1365', 1551016980, 1554163856, '<p>本文记录Java学习过程中遇到的HQL连接查询～</p>\r<!--more-->\r\r<p>Hibernate进行多表查询与SQL其实很相似，但是HQL会在原来SQL分类的基础上多出一些操作。</p>\r\r<p>HQL的多表连接查询的分类如下：</p>\r\r<p>交叉连接</p>\r\r<p>内连接</p>\r\r<ul>\r	<li>显式内连接</li>\r	<li>隐式内连接</li>\r	<li>迫切内连接</li>\r</ul>\r\r<p>外连接</p>\r\r<ul>\r	<li>左外连接</li>\r	<li>迫切左外连接</li>\r	<li>右外连接</li>\r</ul>\r\r<p>其实，这些连接查询语法大致都是一致的，就是HQL查询的是对象而SQL查询的是表。但是，HQL的连接不用写具体的on条件，直接写关联的属性即可。</p>\r\r<p>内连接与迫切内连接的主要区别在于封装数据：</p>\r\r<ul>\r	<li>内连接：发送的就是内连接的语句，封装的时候将属于各自对象的数据封装到各自的对象中，最后得到一个List&lt;Object[]&gt;；</li>\r	<li>迫切内连接：发送的是内连接的语句，需要在编写HQL的时候在join后添加一个fetch关键字，Hibernate会发送HQL中的fetch关键字，从而将每条数据封装到对象中，最后得到一个List&lt;Customer&gt;。</li>\r</ul>\r\r<p>注意：迫切内连接封装以后会出现重复的数据，所以往往在手动编写迫切内连接查询的时候会使用distinct去掉重复值。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 58);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1366, 'Hibernate抓取策略', '1366', 1551018960, 1554164175, '<p>本文记录Java学习过程中遇到的Hibernate抓取策略～</p>\r<!--more-->\r\r<p>抓取策略是当应用程序需要在关联关系间进行导航的时候，Hibernate如何获取关联对象的策略。</p>\r\r<p>Hibernate的抓取策略是Hibernate提升性能的一种手段，可以在获取关联对象的时候，对发送的语句进行优化，但是往往抓取策略需要和延迟加载一起使用来提升性能。</p>\r\r<p>延迟加载的分类：</p>\r\r<p>延迟加载（lazy load，懒加载）是Hibernate关联关系对象默认的加载方式，延迟加载机制是为了避免一些无谓的性能开销而提出的。所谓延迟加载就是当在真正需要数据的时候，才真正执行数据加载操作。</p>\r\r<p>通常将延迟加载分为两类：一类叫做类级别延迟，另一类叫做关联级别的延迟。类级别的延迟指的是查询某个对象的时候，是否采用有延迟，这个通常在&lt;class&gt;标签上配置lazy属性。关联级别的延迟指的是，查询一个对象的关联对象的时候是否采用延迟加载。这个通常在&lt;set&gt;或&lt;many-to-one&gt;上配置lazy属性。</p>\r\r<p>类级别的延迟加载：</p>\r\r<p>使用load方法查询某个对象的时候，这个类是否采用延迟加载的策略，就是类级别的延迟。类级别的延迟一般在&lt;class&gt;是配置lazy属性，默认值是true。所以，使用load()方法去查询的时候，不会马上发送SQL语句，当真正使用该对象的时候，才会发送SQL语句。</p>\r\r<p>其实，如果不想使用延迟加载也有很多种方法，当然最简单的就是将这个类的映射文件上的lazy设置为false，当然也可以将这个持久类改为final修饰。</p>\r\r<p>关联级别的延迟加载：</p>\r\r<p>关联级别的延迟通常在&lt;set&gt;和&lt;many-to-one&gt;上来进行配置。</p>\r\r<p>&lt;set&gt;标签上的lazy的取值：</p>\r\r<ul>\r	<li>true：默认值，采用延迟加载；</li>\r	<li>false：不采用延迟加载；</li>\r	<li>extra：极其懒惰的。</li>\r</ul>\r\r<p>&lt;many-to-one&gt;标签上的lazy的取值：</p>\r\r<ul>\r	<li>proxy: 默认值，是否采用延迟取决于一的一方类上的lazy属性的值；</li>\r	<li>false：不采用延迟加载；</li>\r	<li>no-proxy: 暂不介绍。</li>\r</ul>\r\r<p>抓取策略指的是查询到某个对象的时候，如何抓取其关联对象。可以通过在关联对象的标签（set或many-to-one）上配置fetch属性来配置。</p>\r\r<p>&lt;set&gt;标签上fetch的取值：</p>\r\r<ul>\r	<li>select：默认值，发送的是普通的select语句；</li>\r	<li>join：发送一条迫切左外连接去查询；</li>\r	<li>subselect：发送一条子查询语句查询其关联对象。</li>\r</ul>\r\r<p>&lt;many-to-one&gt;标签上fetch的取值：</p>\r\r<ul>\r	<li>select：默认值，发送的是普通的select语句；</li>\r	<li>join：发送一条迫切左外连接语句查询其关联对象。</li>\r</ul>\r\r<p>注意：当fetch设置为join的时候，lazy就失效了。</p>\r\r<p>批量抓取：</p>\r\r<p>在抓取的策略中有一种叫做批量抓取，就是同时查询多个对象的关联对象的时候，可以采用批量抓取进行优化。如果要实现批量的抓取效果，可以通过配置batch-size来完成。</p>\r\r<ul>\r	<li>一对多的时候，在&lt;set&gt;标签上配置batch-size；</li>\r	<li>多对一的时候，在class标签上配置batch-size。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 84),
(1367, 'Struts2简介', '1367', 1551663660, 1551711453, '<p>本文记录Java学习过程中遇到的Struts2简介～</p>\r<!--more-->\r\r<p>Struts2是一种基于MVC模式的轻量级Web框架，它自问世以来，就受到了广大Web开发者的关注，并广泛应用于各种企业系统的开发中。目前掌握Struts框架几乎成为Web开发者的必备技能之一。</p>\r\r<p>在介绍Struts之前，先认识一下Struts1。Struts1是最早的基于MVC模式的轻量级Web框架，它能够合理的划分代码结构，并包含验证框架、国际化框架等多种实用工具框架。但是，随着技术的进步，Struts1的局限性也越来越多的暴露出来。为了符合更加灵活、高效的开发需求，Struts2框架应运而生。</p>\r\r<p>Struts2是Struts1的下一代产品，是在Struts1和WebWork技术的基础上进行合并后的全新框架（WebWork是由OpenSymphony组织开发的，致力于组件化的代码重用的J2EE的Web框架，它也是一个MVC框架）。虽然Struts2的名字与Struts1相似，但其设计思想却有很大不同。实质上，Struts2是以WebWork为核心的，它采用拦截器的机制来处理用户的请求。这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts2可以理解为WebWork的更新产品。</p>\r\r<p>Struts2拥有优良的设计和功能，其优势具体如下：</p>\r\r<ul>\r	<li>项目开源，使用及扩展方便，天生优势；</li>\r	<li>提供Exception处理机制；</li>\r	<li>Result方式的页面导航，通过Result标签很方便的实现重定向和页面跳转；</li>\r	<li>通过简单、集中的配置来调度业务类，使得配置和修改都非常容易；</li>\r	<li>提供简单、统一的表达式语言来访问所有可供访问的数据；</li>\r	<li>提供标准、强大的验证框架和国际化框架；</li>\r	<li>提供强大的、可以有效减少页面代码的标签；</li>\r	<li>提供良好的Ajax支持；</li>\r	<li>拥有简单的插件，只需放入相应的Jar包，任何人都可以扩展Struts2框架，比如自定义拦截器、自定义结果类型、自定义标签等，为Struts2定制需要的功能，不需要什么特殊配置，并且可以发布给其他人使用；</li>\r	<li>拥有智能的默认设置，不需要另外进行繁琐的设置，使用默认设置就可以完成大多数项目程序开发所需要的功能。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 48),
(1368, '前端控制器模式', '1368', 1551711887, 1551711887, '<p>本文记录Java学习过程中遇到的前端控制器模式～</p>\r<!--more-->\r\r<p>在传统的Web开发模式中，有一次请求就会对应一个Servlet，这样会导致出现很多Servlet。</p>\r\r<p>而Struts2将所有的请求都先经过一个前端控制器，在前端控制器中实现框架的部分功能，剩下具体操作要提交到具体的Action中，那么所有的请求都会经过前端控制器。过滤器filter就是前端控制器最好的一个实现方式，因为需要所有的请求都可以被过滤器拦截，然后在过滤器中实现部分的功能。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 37),
(1369, 'Struts2常用的Jar包', '1369', 1551712546, 1551712546, '<p>本文记录Java学习过程中遇到的Struts2常用的Jar包～</p>\r<!--more-->\r\r<p>Struts常用的Jar包有：</p>\r\r<ul>\r	<li>asm-3.3.jar：操作Java字节码的类库；</li>\r	<li>asm-commons-3.3.jar：提供了基于事件的表现形式；</li>\r	<li>asm-tree-3.3.jar：提供了基于对象的表现形式；</li>\r	<li>struts2-core-2.3.24.jar：Struts2框架的核心类库；</li>\r	<li>xwork-core-2.3.24.jar：WebWork核心库，Struts2的构建基础；</li>\r	<li>ognl-3.0.6.jar：对象图导航语言（Object Graph Navigation Language），struts2框架通过其读写对象的属性；</li>\r	<li>freemarker-2.3.22.jar：Struts2标签模版使用的类库；</li>\r	<li>javassist-3.11.0.GA.jar：JavaScript字节码解析器；</li>\r	<li>commons-fileupload-1.3.1.jar：Struts2文件上传组件依赖包；</li>\r	<li>commons-io-2.2.jar：Struts2的输入输出，传文件依赖的Jar；</li>\r	<li>commons-lang-2.4.jar：包含一些数据类型工具，是对java.lang包的增强；</li>\r	<li>log4j-api-2.2.jar：Struts2的日志管理组件依赖包的API；</li>\r	<li>log4j-core-2.2.jar：Struts2的日志管理组件依赖包。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 37),
(1370, 'Struts2流程图.png', 'Struts2流程图-png', 1551712918, 1551712918, 'a:5:{s:4:"name";s:20:"Struts2流程图.png";s:4:"path";s:34:"/usr/uploads/2019/03/428875740.png";s:4:"size";i:668466;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1371, 0),
(1371, 'Struts2执行流程', '1371', 1551712956, 1551712956, '<p>本文记录Java学习过程中遇到的Struts2执行流程～</p>\r<!--more-->\r\r<p>从客户端发送请求过来，先经过前端控制器（核心过滤器StrutsPrepareAndExecuteFilter）过滤器中执行一组拦截器，然后执行对应的Action，最后在之前前面的拦截器的后处理方法，具体流程如下图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/428875740.png" style="width: 800px; height: 470px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1372, '加载顺序01.png', '加载顺序01-png', 1551715092, 1551715092, 'a:5:{s:4:"name";s:18:"加载顺序01.png";s:4:"path";s:35:"/usr/uploads/2019/03/1642700105.png";s:4:"size";i:866929;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1375, 0),
(1373, '加载顺序02.png', '加载顺序02-png', 1551715097, 1551715097, 'a:5:{s:4:"name";s:18:"加载顺序02.png";s:4:"path";s:35:"/usr/uploads/2019/03/1215309293.png";s:4:"size";i:382673;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1375, 0),
(1374, '加载顺序03.png', '加载顺序03-png', 1551715102, 1551715102, 'a:5:{s:4:"name";s:18:"加载顺序03.png";s:4:"path";s:35:"/usr/uploads/2019/03/3768436538.png";s:4:"size";i:433713;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1375, 0),
(1375, 'Struts2配置文件加载顺序', '1375', 1551715350, 1551715350, '<p>本文记录Java学习过程中遇到的Struts2配置文件的加载顺序～</p>\r<!--more-->\r\r<p>每次从客户端发送请求到服务器都要先经过Struts2的核心过滤器StrutsPrepareAndExecuteFilter，这个过滤器有两个功能：预处理和执行。在预处理中主要就是来加载配置文件的。对应的是过滤器中的init方法，而执行是用来执行一组拦截器完成部分功能的，对应的是过滤器的doFilter方法。所以，如果要去了解Struts2的配置文件的加载顺序，那么需要查询过滤器的init方法。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/1642700105.png" style="width: 800px; height: 480px;" /></p>\r\r<p>在init方法中，调用了init的initDispatcher的方法来加载配置文件，进入到该代码中：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/1215309293.png" style="width: 800px; height: 240px;" /></p>\r\r<p>发现这个方法又调用了distatcher的init方法，进入init方法内部：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/3768436538.png" style="width: 800px; height: 318px;" />​</p>\r\r<p>这一系列的代码就是用来加载Struts2的配置文件的：</p>\r\r<pre class="brush:java;">\rinit_DefaultProperties();</pre>\r\r<p>加载org.apache.struts.default.properties配置的是struts2的所有常量：</p>\r\r<pre class="brush:java;">\rinit_TraditionalXmlConfigurations();</pre>\r\r<p>加载struts-default.xml、struts-plugin.xml、struts.xml：</p>\r\r<pre class="brush:java;">\rinit_legacyStrutsProperties();</pre>\r\r<p>加载自定义的struts.properties：</p>\r\r<pre class="brush:java;">\rinit_CustomConfigurationProviders();</pre>\r\r<p>加载用户配置的提供对象：</p>\r\r<pre class="brush:java;">\rinit_FilterInitParameters();</pre>\r\r<p>加载web.xml：</p>\r\r<pre class="brush:java;">\rinit_AliasStandardObjects();</pre>\r\r<p>加载标准对象。</p>\r\r<p>前三个配置文件（default.properties、struts-default.xml、struts-plugin.xml）不用关心，是Struts2内部的配置文件，无法修改。能修改的是struts.xml、struts.properties和web.xml。这三个配置文件的加载时有顺序的，三个配置文件都可以修改常量的值，但后加载的配置文件中的常量的值会覆盖先加载的配置文件中的值。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 56),
(1376, 'Struts2中Action的配置', '1376', 1551716940, 1551717621, '<p>本文记录Java学习过程中遇到的Struts2中Action的配置～</p>\r<!--more-->\r\r<p>Struts2框架的核心配置文件时struts.xml文件，该文件主要用来配置Action和请求的对应关系。</p>\r\r<p><strong>&lt;package&gt;的配置</strong></p>\r\r<p>Struts2框架的核心组件时Action和拦截器，它使用包来管理Action和拦截器。每个包就是多个Action、多个拦截器、多个拦截器引用的集合。在struts.xml文件中，package元素用来定义包配置，每个package元素定义了一个包配置。</p>\r\r<p>package元素的常用属性如下：</p>\r\r<ul>\r	<li>name：必填属性，它指定该包的名字，此名字是该包被其他包引用的key；</li>\r	<li>namespace：可选属性，该属性定义该包的命名空间；</li>\r	<li>extends：可选属性，它指定该包继承自其他包。继承其他包，可以继承其他包中的Action定义和拦截器定义等；</li>\r	<li>abstract：可选属性，它指定该包是否是一个抽象包，抽象包中不能包含Action定义。</li>\r</ul>\r\r<p>以上就是package元素的常用属性。其中，在配置包时，必须指定name属性，就是包的标识。除此之外，还可以指定一个可选的extends属性，extends属性值必须是另一个包的name属性值，但该属性值通常都设置为struts-default，这样该包中的Action就具有了Struts2框架默认的拦截器等功能。另外，Struts2还提供了一种所谓的抽象包，抽象包不能包含Action定义。为了显示指定的包是抽象包，可以为该package元素增加abstract=&rdquo;true&ldquo;属性。</p>\r\r<p>在package中还有namespace的配置，namespace属性与action标签的name属性共同决定了访问路径。</p>\r\r<p>namespace有如下三种配置：</p>\r\r<ul>\r	<li>默认名称空间：namespace=&ldquo;&rdquo;；</li>\r	<li>根名称空间：namespace=&ldquo;/&rdquo;；</li>\r	<li>带名称的名称空间：namespace=&ldquo;/demo&rdquo;。</li>\r</ul>\r\r<p><strong>Action的配置</strong></p>\r\r<p>Action映射是框架中的基本&ldquo;工作单元&rdquo;。Action映射就是将一个请求的URL映射到一个Action类，当一个请求匹配某个Action名称时，框架就使用这个映射来确定如何处理请求。</p>\r\r<p>在struts.xml中，action元素共有4个属性，具体介绍如下：</p>\r\r<ul>\r	<li>name：必填属性，标示Action，指定了Action所处理的请求的URL；</li>\r	<li>class：可选属性，指定Action对应的Action类；</li>\r	<li>method：可选属性，指定请求Action时调用的方法；</li>\r	<li>converter：可选属性，指定类型转换器的类。</li>\r</ul>\r\r<p>其中，name属性和namespace属性共同决定了访问路径，class对应的是Action类的全路径。method指定了执行Action的哪个方法，默认是ececute方法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 39),
(1377, 'Struts2常量配置', '1377', 1551746640, 1551746709, '<p>本文记录Java学习过程中遇到的Struts2常量配置～</p>\r\r<!--more-->\r\r<p>Struts2的常量大多在默认的配置文件中已经配置好，但根据用户需求的不同，开发的要求也不同，可能需要修改这些常量，修改的方法就是在配置文件中对这些常量进行重新配置。</p>\r\r<p>Struts2常量配置共有3种方式，分别如下：</p>\r\r<ul>\r	<li>在struts.xml文件中使用&lt;constant&gt;元素配置常量；</li>\r	<li>在struts.properties文件中配置常量；</li>\r	<li>在web.xml文件中通过&lt;init-param&gt;元素配置常量。</li>\r</ul>\r\r<p>1. 在struts.xml文件中通过&lt;constant&gt;元素配置常量</p>\r\r<p>在struts.xml文件中通过&lt;constant&gt;元素配置常量是最常用的方式。在struts.xml文件中通过&lt;constant&gt;元素配置常量时，需要指定两个必填的属性name和value。</p>\r\r<ul>\r	<li>name：该属性指定了常量的常量名；</li>\r	<li>value：该属性指定了常量的常量值。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;struts&gt;\r  &lt;!-- 设置默认编码集 --&gt;\r  &lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;UTF-8&quot; /&gt;\r  &lt;!-- 使用开发者模式 --&gt;\r  &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt;\r&lt;struts&gt;</pre>\r\r<p>2. 在struts.properties文件中配置常量</p>\r\r<p>struts.properties文件是一个标准的properties文件，其格式是key-value对，即每个key对应一个value，key表示的是struts2框架中的常量，而value则是其常量值。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r# 设置默认编码集\rstruts.i18n.encoding=UTF-8\r# 使用开发者模式\rstruts.devMode=true\r# 设置action请求的扩展名为action或者没有扩展名\rstruts.action.extension=action,,\r# 设置不开启动态方法调用\rstruts.enable.DynamicMethodInvocation=false</pre>\r\r<p>3. 在web.xml文件中通过初始化参数配置常量</p>\r\r<p>在web.xml文件中配置核心过滤器StrutsPrepareAndExecuteFilter时，通过初始化参数来配置常量。通过&lt;filter&gt;元素的&lt;init-param&gt;子元素指定，每个&lt;init-param&gt;元素配置了一个struts2常量。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;filter&gt;\r	&lt;filter-name&gt;struts2&lt;/filter-name&gt;\r	&lt;filter-class&gt;\r		org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\r	&lt;filter-class&gt;\r	&lt;init-param&gt;\r		&lt;param-name&gt;struts.i18n.encoding&lt;/param-name&gt;\r		&lt;param-value&gt;UTF-8&lt;/param-value&gt;\r	&lt;init-param&gt;\r&lt;/filter&gt;</pre>\r\r<p>Struts2支持的常量数量众多，在struts2-core-2.3.24.jar包中的org.apache.struts2路径下有一个default.properties文件，该文件里为struts2的所有常量都制定了默认值，可以通过查看该文件了解struts2所支持的常量。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 35),
(1378, 'Struts2分模块配置', '1378', 1551747540, 1551747580, '<p>本文记录Java学习过程中遇到的Struts2分模块配置～</p>\r\r<!--more-->\r\r<p>在实际开发中，通常很多人都需要修改同一个配置文件struts.xml，因为这个文件是struts2的核心配置文件。但是，这个文件一旦改错一点，就会导致整个项目都会出问题，所以struts2提供了&lt;include&gt;标签解决这个问题。</p>\r\r<p>&lt;include&gt;元素用来在一个struts.xml配置文件中包含其他的配置文件，包含配置体现的是软件工程中的&ldquo;分而治之&rdquo;原则。struts2允许将一个配置文件分解成多个配置文件，从而提高配置文件的可读性。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;struts&gt;\r	&lt;!-- 不指定路径默认在src下 --&gt;\r	&lt;include file=&quot;struts-user.xml&quot; /&gt;\r	&lt;!-- 配置文件在具体包中 --&gt;\r	&lt;include file=&quot;ren/oliver/xxx/struts-login.xml&quot; /&gt;\r&lt;/struts&gt;</pre>\r\r<p>注意：配置&lt;include&gt;元素时，必须指定file属性，该属性指定了被包含配置文件的路径。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 47),
(1379, 'Struts2中Action的编写方式', '1379', 1551749100, 1551749164, '<p>本文记录Java学习过程中遇到的Struts2中Action的编写方式～</p>\r\r<!--more-->\r\r<p><strong>Action是一个POJO类</strong></p>\r\r<p>在Struts2中，Action可以不继承特殊的类或不实现任何接口，仅仅是个POJO。POJO全称为Plain Ordinary Java Object（简单的Java对象），只要具有一部分getter/setter方法的那种类，就可以称为POJO。一般在这个POJO类中，要有一个公共的无参构造方法和一个execute()方法。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ActionDemo {\r\r	public String execute() {\r		System.out.println(&quot;ActionDemo&quot;);\r		reture null;\r	}\r}</pre>\r\r<p>execute方法的要求如下：</p>\r\r<ul>\r	<li>方法的权限修饰符为public；</li>\r	<li>返回一个字符串，就是下一个页面的result；</li>\r	<li>方法没有参数。</li>\r</ul>\r\r<p>也就是说，满足上述要求的POJO都可以算作Struts2的Action实现。</p>\r\r<p><strong>Action类实现Action的接口</strong></p>\r\r<p>为了让开发的Action类更规范，Struts2提供了一个Action接口，用户在实现Action控制类时，可以实现struts2提供的这个Action接口。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ActionDemo implements Action {\r\r	@Override\r	public String execute() throws Exception {\r		System.out.println(&quot;ActionDemo&quot;);\r		reture null;\r	}\r}</pre>\r\r<p>提供了5个字符串常量，它们的作用是统一execute()方法的返回值，具体如下：</p>\r\r<ul>\r	<li>SUCCESS：success，代表成功；</li>\r	<li>NONE：none，代表页面不跳转；</li>\r	<li>ERROR：error，代表跳转到错误页面；</li>\r	<li>INPUT：input，数据校验的时候跳转的路径；</li>\r	<li>LOGIN：login，用来跳转到登录页面。</li>\r</ul>\r\r<p><strong>Action类继承ActionSupport类</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class ActionDemo extends ActionSupport {\r\r	@Override\r	public String execute() throws Exception {\r		System.out.println(&quot;ActionDemo&quot;);\r		reture null;\r	}\r}</pre>\r\r<p>ActionSupport类本身实现了Action接口，是struts2中默认的Action接口的实现类，所以继承ActionSupport就相当于实现了Action接口。ActionSupport类还实现了Validateable、ValidationAware、TextProvider、LocaleProvider和Serializable等接口，来为用户提供更多的功能。</p>\r\r<p>ActionSupport类中提供了很多默认方法，这些默认方法包括获取国际化信息的方法、数据校验的方法、默认的处理用户请求的方法等。实际上，ActionSupport类是Struts2默认的Action处理类，如果让编写的Action类继承该ActionSupport类，则会大大简化Action的开发。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 34),
(1380, 'Struts2中Action的方法访问', '1380', 1551798120, 1551798193, '<p>本文记录Java学习过程中遇到的Struts2中Action的方法访问～</p>\r<!--more-->\r\r<p>在&lt;action&gt;的标签中有一个属性method，通过method的配置来指定Action中的某个方法执行。</p>\r\r<p><strong>方式一：通过配置method属性</strong></p>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;h3&gt;客户管理&lt;/h3&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/saveCustomerAction.action&quot;&gt;添加客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/updateCustomerAction.action&quot;&gt;修改客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/deleteCustomerAction.action&quot;&gt;删除客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/findCustomerAction.action&quot;&gt;查询客户&lt;/a&gt;</pre>\r\r<p>示例代码（后端Action）：</p>\r\r<pre class="brush:java;">\rpublic class CustomerAction extends ActionSupport {\r	\r	public String save() {\r		System.out.println(&quot;save&quot;);\r		reture NONE;\r	}\r\r	public String update() {\r		System.out.println(&quot;update&quot;);\r		reture NONE;\r	}\r\r	public String delete() {\r		System.out.println(&quot;delete&quot;);\r		return NONE;\r	}\r\r	public String find() {\r		System.out.println(&quot;find&quot;);\r		return NONE;\r	}\r}</pre>\r\r<p>示例代码（Action的配置）：</p>\r\r<pre class="brush:xml;">\r&lt;package name=&quot;demo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;\r	&lt;action name=&quot;saveCustomerAction&quot; class=&quot;ren.oliver.action.CustomerAction&quot; method=&quot;save&quot; /&gt;\r	&lt;action name=&quot;saveCustomerAction&quot; class=&quot;ren.oliver.action.CustomerAction&quot; method=&quot;update&quot; /&gt;\r	&lt;action name=&quot;saveCustomerAction&quot; class=&quot;ren.oliver.action.CustomerAction&quot; method=&quot;delete&quot; /&gt;\r	&lt;action name=&quot;saveCustomerAction&quot; class=&quot;ren.oliver.action.CustomerAction&quot; method=&quot;find&quot; /&gt;\r&lt;/package&gt;</pre>\r\r<p>用这种方式实现，同一个Action类就被配置了很多次，只是修改了后面的method的值，比较繁琐。</p>\r\r<p><strong>方式二：通过通配符配置</strong></p>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;h3&gt;客户管理&lt;/h3&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/customerAction_save.action&quot;&gt;添加客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/customerAction_update.action&quot;&gt;修改客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/customerAction_delete.action&quot;&gt;删除客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/customerAction_find.action&quot;&gt;查询客户&lt;/a&gt;</pre>\r\r<p>示例代码（后端Action）：</p>\r\r<pre class="brush:java;">\rpublic class CustomerAction extends ActionSupport {\r	\r	public String save() {\r		System.out.println(&quot;save&quot;);\r		reture NONE;\r	}\r\r	public String update() {\r		System.out.println(&quot;update&quot;);\r		reture NONE;\r	}\r\r	public String delete() {\r		System.out.println(&quot;delete&quot;);\r		return NONE;\r	}\r\r	public String find() {\r		System.out.println(&quot;find&quot;);\r		return NONE;\r	}\r}</pre>\r\r<p>示例代码（Action的配置）：</p>\r\r<pre class="brush:xml;">\r&lt;action name=&quot;customerAction_*&quot; class=&quot;ren.oliver.action.CustomerAction&quot; method=&quot;{1}&quot; /&gt;</pre>\r\r<p>在&lt;action&gt;的name属性中使用的*代表任何字符，method中的{1}代表name属性中的出现的第一个*所替代的字符。</p>\r\r<p><strong>方式三：动态方法访问</strong></p>\r\r<p>动态方法访问在Struts2中默认是不开启的，使用的话必须修改先开启一个常量。</p>\r\r<pre class="brush:xml;">\r&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot; /&gt;</pre>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;h3&gt;客户管理&lt;/h3&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/customerAction!save.action&quot;&gt;添加客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/customerAction!update.action&quot;&gt;修改客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/customerAction!delete.action&quot;&gt;删除客户&lt;/a&gt;&lt;br/&gt;\r&lt;a href=&quot;${ pageContext.request.contextPath }/customerAction!find.action&quot;&gt;查询客户&lt;/a&gt;</pre>\r\r<p>示例代码（后端Action）：</p>\r\r<pre class="brush:java;">\rpublic class CustomerAction extends ActionSupport {\r	\r	public String save() {\r		System.out.println(&quot;save&quot;);\r		reture NONE;\r	}\r\r	public String update() {\r		System.out.println(&quot;update&quot;);\r		reture NONE;\r	}\r\r	public String delete() {\r		System.out.println(&quot;delete&quot;);\r		return NONE;\r	}\r\r	public String find() {\r		System.out.println(&quot;find&quot;);\r		return NONE;\r	}\r}</pre>\r\r<p>示例代码（Action的配置）：</p>\r\r<pre class="brush:xml;">\r&lt;action name=&quot;userAction&quot; class=&quot;ren.oliver.action.CustomerAction&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1381, 'Struts2访问Servlet的API', '1381', 1551800040, 1551800108, '<p>本文记录Java学习过程中遇到的Struts2访问Servlet的API～</p>\r<!--more-->\r\r<p>在Struts2中，Action并没有直接和Servlet API进行耦合，也就是说在Struts2的Action中不能直接访问Servlet的API。虽然Struts2中的Action访问Servlet的API麻烦一些，但是这却是Struts2中Action的重要改良之一，方便Action进行单元测试。</p>\r\r<p>尽管Action和Servlet的API解耦会带来很多好处，然而在Action中完全不访问Servlet的API几乎是不可能的，在实现业务逻辑时，经常要访问Servlet中的对象，如：session、request和application等。</p>\r\r<p>在Struts2中，访问Servlet的API有3种方法，具体如下：</p>\r\r<p><strong>通过ActionContext类访问</strong></p>\r\r<p>Struts2框架提供了ActionContext类来访问Servlet的API，ActionContext是Action执行的上下文对象，在ActionContext中保存了Action执行所需要的所有对象，包括parameters、request、session和application等。</p>\r\r<p>ActionContext类访问Servlet的API的常用方法：</p>\r\r<ul>\r	<li>void put(String key, Object value)：将key-value键值对放入ActionContext中，模拟Servlet的API中的HttpServletRequest的setAttribute()方法；</li>\r	<li>Object get(String key)：通过参数key来查找当前ActionContext中的值；</li>\r	<li>Map&lt;String, Object&gt; getApplication()：返回一个Application级别的Map对象；</li>\r	<li>static ActionContext getContext()：获取当前线程的ActionContext对象；</li>\r	<li>Map&lt;String, Object&gt; getParameters()：返回一个包含所有HttpServletRequest参数信息的Map对象；</li>\r	<li>Map&lt;String, Object&gt; getSession()：返回一个Map类型的HttpSession对象；</li>\r	<li>void setApplication(Map&lt;String, Object&gt; application)：设置Application上下文；</li>\r	<li>void setSession(Map&lt;String, Object&gt; session)：设置一个Map类型的Session值。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rActionContext context = ActionContext.getContext();\rcontext.put(&quot;name&quot;, &quot;oliver&quot;);\rcontext.getApplication().put(&quot;name&quot;,&quot;oliver&quot;);\rcontext.getSession().put(&quot;name&quot;,&quot;oliver&quot;);</pre>\r\r<p>通过ActionContext类中的方法调用，分别在request、application和session中放入了键值对。</p>\r\r<p><strong>通过实现特定接口访问</strong></p>\r\r<p>为了在Action中直接访问Servlet的API，Struts2还提供了一系列接口，具体如下：</p>\r\r<ul>\r	<li>ServletRequestAware：实现该接口的Action可以直接访问Web应用的HttpServletRequest实例；</li>\r	<li>ServletResponseAware：实现该接口的Action可以直接访问Web应用的HttpServletResponse实例；</li>\r	<li>SessionAware：实现该接口的Action可以直接访问Web应用的HttpSession实例；</li>\r	<li>ServletContextAware：实现该接口的Action可以直接访问Web应用的ServletContext实例。</li>\r</ul>\r\r<p><strong>通过ServletActionContext访问</strong></p>\r\r<p>为了直接访问Servlet的API，Struts2框架还提供了ServletActionContext类，该类包含了几个常用的静态方法：</p>\r\r<ul>\r	<li>static HttpServletRequest getRequest()：获取Web应用的HttpServletRequest对象；</li>\r	<li>static HttpServletResponse getResponse()：获取Web应用的HttpServletResponse对象；</li>\r	<li>static ServletContext getServletContext()：获取Web应用的ServletContext对象；</li>\r	<li>static PageContext getPageContext()：获取Web应用的PageContext对象。</li>\r</ul>\r\r<p>总结：综上三种访问Servlet的API的方式，建议在开发中优先使用ActionContext，以避免和Servlet的API接口。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 55),
(1382, 'Struts2结果页面的配置', '1382', 1551801884, 1551801884, '<p>本文记录Java学习过程中遇到的Struts2结果页面的配置～</p>\r<!--more-->\r\r<p>在struts.xml文件中，Result的配置非常简单，使用&lt;result&gt;元素来配置result逻辑视图与物理视图之间的映射，&lt;result&gt;元素可以有name和type属性，但这两种属性都不是必选的。</p>\r\r<ul>\r	<li>name属性：指定逻辑视图的名称，默认值是success；</li>\r	<li>type属性：指定返回的视图资源的类型，不同的类型代表不同的结果输出，默认值是dispatcher。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;action name=&quot;demo&quot; class=&quot;ren.oliver.DemoAction&quot;&gt;\r	&lt;result name=&quot;success&quot; type=&quot;dispatcher&quot;&gt;/result.jsp&lt;/result&gt;\r&lt;/action&gt;</pre>\r\r<p>在上述配置中，使用了&lt;result&gt;元素的name和type属性。其中，为Action配置了name为success的result映射，该映射的值可以是JSP页面，也可以是一个Action的name值，用type属性指定了该result的结果类型为dispatcher，它也是默认的结果类型。</p>\r\r<p>在结果页面的配置中，Struts2有两种配置的方式，一种称为全局结果页面，另一种称为局部结果页面，具体解释如下：</p>\r\r<p><strong>全局结果页面</strong></p>\r\r<p>全局结果页面是指同一个包下面配置的Action中返回相同的字符串的值，都可以跳转到该页面，需要通过&lt;global-results&gt;进行配置。</p>\r\r<pre class="brush:xml;">\r&lt;global-results&gt;\r	&lt;result name=&quot;success&quot;&gt;/result.jsp&lt;/result&gt;\r&lt;/global-results&gt;</pre>\r\r<p><strong>局部结果页面</strong></p>\r\r<p>局部结果页面是指在某个Action中根据该字符串的值进行页面的跳转，只对这个Action有效。</p>\r\r<pre class="brush:xml;">\r&lt;action name=&quot;demo&quot; class=&quot;ren.oliver.DemoAction&quot;&gt;\r	&lt;result name=&quot;success&quot; type=&quot;dispatcher&quot;&gt;/result.jsp&lt;/result&gt;\r&lt;/action&gt;</pre>\r\r<p>在Struts2中，当框架调用Action对请求进行处理后，就要向用户呈现一个结果视图，Struts2预定义了多种ResultType，其实就是定义了多种展示结果的技术。</p>\r\r<p>一个结果类型就是实现了com.opensymphony.xwork2.Result接口的类，Struts2把内置的&lt;result-type&gt;都放在struts-default包中，struts-default包就是配置包的父包，这个包定义在struts2-core-2.3.24.jar包中的根目录下的struts-default.xml文件中，可以找到相关的&lt;result-type&gt;的定义。</p>\r\r<p>每个&lt;result-type&gt;元素都是一种视图技术或者跳转方式的封装，其中的name属性指出在&lt;result&gt;元素中如何引用这种视图技术或者跳转方式，对应着&lt;result&gt;元素的type属性。</p>\r\r<p>Struts2中预定义的ResultType如下：</p>\r\r<ul>\r	<li>chain：用来处理Action链，被跳转的Action中仍能获取上个页面的值，如request信息；</li>\r	<li>dispatcher：用来转向页面，通常处理JSP，是默认的结果类型；</li>\r	<li>redirect：重定向到一个URL，被跳转的页面中丢失传递的信息；</li>\r	<li>redirectAction：重定向到一个Action，跳转的页面中丢失传递的信息；</li>\r	<li>freemarker：用来整合FreeMarker模板结果类型；</li>\r	<li>httpheader：用来处理特殊的HTTP行为结果类型；</li>\r	<li>stream：向浏览器发送InputStream对象，通常用来处理文件下载，还可用于Ajax的数据；</li>\r	<li>velocity：用来整合Velocity模板结果类型；</li>\r	<li>xslt：用来整合XML/XSLT结果类型；</li>\r	<li>plainText：显示原始文件内容，例如文件源代码；</li>\r	<li>postback：使得当前请求参数以表单形式提交。</li>\r</ul>\r\r<p>注意：前三个值比较常用，需要重点记忆。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 39),
(1383, 'Struts2数据封装', '1383', 1551835452, 1551835452, '<p>本文记录Java学习过程中遇到的Struts2的数据封装～</p>\r<!--more-->\r\r<p>在实际开发场景中，页面提交请求参数到Action，在Action中接收参数并且需要对请求参数进行数据的封装，将数据封装到一个JavaBean中，然后将JavaBean传递给业务层。Struts2将数据的封装分成两大类：一类是属性驱动，另一类是模型驱动。</p>\r\r<p><strong>属性驱动</strong></p>\r\r<p>属性驱动可以细分为两种，一种只需要提供属性的set方法，另一种可以通过表达式直接封装到对象中。</p>\r\r<p>方式一：提供属性的set方法</p>\r\r<p>在Struts2中，可以直接在Action中定义各种Java基础数据类型的字段，使这些字段与表单数据相对应，并利用这些字段进行数据封装。</p>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;form action=&quot;${pageContext.request.contextPath}/actionDemo.action&quot; method=&quot;post&quot;&gt;\r	姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt;\r	年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br/&gt;\r	生日：&lt;input type=&quot;text&quot; name=&quot;birthday&quot;/&gt;&lt;br/&gt;\r	工资：&lt;input type=&quot;text&quot; name=&quot;salary&quot;/&gt;&lt;br/&gt;\r	&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;br/&gt;\r&lt;/form&gt;</pre>\r\r<p>示例代码（后端Action）：</p>\r\r<pre class="brush:java;">\rpubic class ActionDemo extends ActionSupport {\r	// 接收参数\r	private String name;\r	private Integer age;\r	private Date birthday;\r	private Double salary;\r\r	// set/get方法省略\r\r	@Override\r	public String execute() throws Exception {\r		System.out.println(name);\r		System.out.println(age);\r		System.out.println(birthday);\r		System.out.println(salary);\r\r		return NONE;\r	}\r}</pre>\r\r<p>使用这种方式，如果需要传入的数据很多的话，那么Action的属性也会变得很多，再加上属性有对应的set/get方法，Action类的代码会很庞大，在Action里编写业务代码时，会使Action非常臃肿，不够简介。</p>\r\r<p>方式二：页面提供表达式</p>\r\r<p>把属性和相应的set/get方法从Action里提取出来，单独作为一个值对象，这个对象就是用来封装这些数据的，在相应的Action里可以直接使用这个对象，而且可以在多个Action里使用。采用这种方式，一般以JavaBean来实现，所封装的属性和表单的属性一一对应，JavaBean将成为数据传递的载体。</p>\r\r<p>示例代码（前端代码）：</p>\r\r<pre class="brush:xml;">\r&lt;form action=&quot;${pageContext.request.contextPath}/actionDemo.action&quot; method=&quot;post&quot;&gt;\r	姓名：&lt;input type=&quot;text&quot; name=&quot;user.name&quot;/&gt;&lt;br/&gt;\r	年龄：&lt;input type=&quot;text&quot; name=&quot;user.age&quot;/&gt;&lt;br/&gt;\r	生日：&lt;input type=&quot;text&quot; name=&quot;user.birthday&quot;/&gt;&lt;br/&gt;\r	工资：&lt;input type=&quot;text&quot; name=&quot;user.salary&quot;/&gt;&lt;br/&gt;\r	&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;br/&gt;\r&lt;/form&gt;</pre>\r\r<p>示例代码（后端Action）：</p>\r\r<pre class="brush:java;">\rpublic class ActionDemo extends ActionSupport {\r\r	// 数据封装对象\r	private User user;\r\r	// set/get方法省略\r\r	@Override\r	public String execute() throws Exception {\r		System.out.println(user);\r\r		return NONE;\r	}\r}</pre>\r\r<p>注意：以上这种方式需要提供对user的get方法，如果没有提供get方法，在Struts2的底层就没有办法获得到该对象，那么在user中只会有一个属性被封装进去，而其他的属性都是null。</p>\r\r<p><strong>模型驱动</strong></p>\r\r<p>在Struts2中，Action处理请求参数还有另外一种方式，叫做模型驱动。通过实现ModelDriven接口来接收请求参数，Action类必须实现ModelDriven接口，并且要重写getModel()方法，这个方法返回的就是Action所使用的数据模型对象。</p>\r\r<p>模型驱动方式通过JavaBean模型进行数据传递。只要是普通的JavaBean，就可以充当模型部分。采用这种方式，JavaBean所封装的属性与表单一一对应，JavaBean将成为数据传递的载体。</p>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;form action=&quot;${pageContext.request.contextPath}/actionDemo.action&quot; method=&quot;post&quot;&gt;\r	姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt;\r	年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br/&gt;\r	生日：&lt;input type=&quot;text&quot; name=&quot;birthday&quot;/&gt;&lt;br/&gt;\r	工资：&lt;input type=&quot;text&quot; name=&quot;salary&quot;/&gt;&lt;br/&gt;\r	&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;\r&lt;/form&gt;</pre>\r\r<p>示例代码（后端Action）：</p>\r\r<pre class="brush:java;">\rpublic class ActionDemo extends ActionSupport implements ModelDriven&lt;User&gt; {\r	// 手动构建对象\r	private User user = new User();\r\r	@Override\r	public User getModel() {\r		return user;\r	}\r\r	@Override\r	public String execute() throws Exception {\r		System.out.println(user);\r		return NONE;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 39),
(1384, 'Struts2集合类数据封装', '1384', 1551836520, 1551836598, '<p>本文记录Java学习过程中遇到的Struts2的集合类的数据封装～</p>\r\r<!--more-->\r\r<p>在实际开发中，有些时候需要批量插入用户或者批量插入其他对象，在Action中需要接受到多个Action中封装的对象，然后传递给业务层。那么这个时候就需要将表单的数据封装到集合中，常见的集合有两种，即List和Map。</p>\r\r<p><strong>List集合</strong></p>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;form action=&quot;${pageContext.request.contextPath}/actionDemo.action&quot; method=&quot;post&quot;&gt;\r	姓名：&lt;input type=&quot;text&quot; name=&quot;list[0].name&quot;/&gt;&lt;br/&gt;\r	年龄：&lt;input type=&quot;text&quot; name=&quot;list[0].age&quot;/&gt;&lt;br/&gt;\r	生日：&lt;input type=&quot;text&quot; name=&quot;list[0].birthday&quot;/&gt;&lt;br/&gt;\r	工资：&lt;input type=&quot;text&quot; name=&quot;list[0].salary&quot;/&gt;&lt;br/&gt;\r	姓名：&lt;input type=&quot;text&quot; name=&quot;list[1].name&quot;/&gt;&lt;br/&gt;\r	年龄：&lt;input type=&quot;text&quot; name=&quot;list[1].age&quot;/&gt;&lt;br/&gt;\r	生日：&lt;input type=&quot;text&quot; name=&quot;list[1].birthday&quot;/&gt;&lt;br/&gt;\r	工资：&lt;input type=&quot;text&quot; name=&quot;list[1].salary&quot;/&gt;&lt;br/&gt;\r	&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;br/&gt;\r&lt;/form&gt;</pre>\r\r<p>示例代码（后端Action）：</p>\r\r<pre class="brush:java;">\rpublic class ActionDemo extends ActionSupport {\r	private List&lt;User&gt; list;\r\r	// set/get方法省略\r\r	@Override\r	public String execute() throws Exception {\r		for (User user : list) {\r			System.out.println(user);\r		}\r		return NONE;\r	}\r}</pre>\r\r<p><strong>Map集合</strong></p>\r\r<p>示例代码（前端代码）：</p>\r\r<pre class="brush:xml;">\r&lt;form action=&quot;${pageContext.request.contextPath}/actionDemo.action&quot; method=&quot;post&quot;&gt;\r	姓名：&lt;input type=&quot;text&quot; name=&quot;list[&#39;one&#39;].name&quot;/&gt;&lt;br/&gt;\r	年龄：&lt;input type=&quot;text&quot; name=&quot;list[&#39;one&#39;].age&quot;/&gt;&lt;br/&gt;\r	生日：&lt;input type=&quot;text&quot; name=&quot;list[&#39;one&#39;].birthday&quot;/&gt;&lt;br/&gt;\r	工资：&lt;input type=&quot;text&quot; name=&quot;list[&#39;one&#39;].salary&quot;/&gt;&lt;br/&gt;\r	姓名：&lt;input type=&quot;text&quot; name=&quot;list[&#39;two&#39;].name&quot;/&gt;&lt;br/&gt;\r	年龄：&lt;input type=&quot;text&quot; name=&quot;list[&#39;two&#39;].age&quot;/&gt;&lt;br/&gt;\r	生日：&lt;input type=&quot;text&quot; name=&quot;list[&#39;two&#39;].birthday&quot;/&gt;&lt;br/&gt;\r	工资：&lt;input type=&quot;text&quot; name=&quot;list[&#39;two&#39;].salary&quot;/&gt;&lt;br/&gt;\r	&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;br/&gt;\r&lt;/form&gt;</pre>\r\r<p>示例代码（后端Action）：</p>\r\r<pre class="brush:java;">\rpublic class ActionDemo extends ActionSupport {\r	private Map&lt;String, User&gt; map;\r\r	// set/get方法省略\r\r	@Override\r	public String execute() throws Exception {\r		for (String key : map.keySet()) {\r			User user = map.get(key);\r			System.our.println(key + &quot;:&quot; + user);\r		}\r		return NONE;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1385, 'OGNL简介', '1385', 1551889169, 1551889169, '<p>本文记录Java学习过程中遇到的OGNL简介～</p>\r\r<!--more-->\r\r<p>OGNL的全称是对象图导航语言（Object Graph Navigation Language），它是一种功能强大的开源表达式语言，使用这种表达式语言，可以通过某种表达式语法来存取Java对象的任意属性，调用Java对象的方法，同时能够自动实现必要的类型转换。</p>\r\r<p>如果把表达式看作是一个带有语义的字符串，那么OGNL无疑成为了这个语义字符串与Java对象之间沟通的桥梁。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 39),
(1386, 'OGNL作用', '1386', 1551890562, 1551890562, '<p>本文记录Java学习过程中遇到的OGNL的作用～</p>\r<!--more-->\r\r<p>Struts2默认的表达式语言就是OGNL，它具有以下特点：</p>\r\r<ul>\r	<li>支持对象方法调用，例如：objName.methodName()；</li>\r	<li>支持类静态方法调用和值访问，表达式的格式为@[类全名(包括包路径)]@[方法名|值名]，例如：@java.lang.String@format(&#39;foo%s&#39;,&#39;bar&#39;)；</li>\r	<li>支持赋值操作和表达式串联，例如：price=100，discount=0.8，calculatePrice()，在方法中进行乘法计算会返回80；</li>\r	<li>访问OGNL上下文（OGNL Context）和ActionContext；</li>\r	<li>操作集合对象。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 41),
(1387, 'OGNL要素', '1387', 1551891300, 1551972908, '<p>本文记录Java学习过程中遇到的OGNL的要素～</p>\r<!--more-->\r\r<p>OGNL的操作实际上就是围绕着OGNL结构的三个要素进行的，分别是表达式（Expression）、根对象（Root Object）、上下文环境（Context），具体如下：</p>\r\r<p><strong>表达式</strong></p>\r\r<p>表达式是整个OGNL的核心，OGNL会根据表达式去对象中取值。所有OGNL操作都是针对表达式解析后进行的。它表明了此次OGNL操作要做什么。表达式就是一个带有语法含义的字符串，这个字符串规定了操作的类型和操作的内容。OGNL支持大量的表达式语法，不仅支持这种&ldquo;链式&rdquo;对象访问路径，还支持在表达式中进行简单的计算。</p>\r\r<p>示例代码（调用对象的方法）：</p>\r\r<pre class="brush:java;">\rOgnlContext context = new OgnlContext();\rObject obj = Ognl.getValue(&quot;&#39;oliver&#39;.length()&quot;, context, context.getRoot());\rSystem.out.println(obj);</pre>\r\r<p>示例代码（静态方法的调用）：</p>\r\r<pre class="brush:java;">\rOgnlContext context = new OgnlContext();\rObject obj = Ognl.getValue(&quot;@java.lang.Math@random()&quot;, context, context.getRoot());\rSystem.out.println(obj);</pre>\r\r<p><strong>根对象-root</strong></p>\r\r<p>root对象可以理解为OGNL的操作对象，表达式规定了&ldquo;做什么&rdquo;，而Root对象则规定了&ldquo;对谁操作&rdquo;。OGNL称为对象图导航语言，所谓对象图，即以任意一个对象为根，通过OGNL可以访问与这个对象关联的其他对象。</p>\r\r<p><strong>Context对象</strong></p>\r\r<p>OGNL的取值需要一个上下文环境。设置了root对象，OGNL可以对root对象进行取值或写值等操作，root对象所在环境就是OGNL的上下文环境（Context）。上下文环境规定了OGNL的操作&ldquo;在哪里进行&rdquo;。上下文环境Context是一个Map类型的对象，在表达式中访问Context中的对象，需要使用&ldquo;#&rdquo;号加上对象名称，即&ldquo;#对象名称&rdquo;的形式。</p>\r\r<p>示例代码（获得数据）：</p>\r\r<pre class="brush:java;">\rOgnlContext context = new OgnlContext();\rString name = (String) Ognl.getValue(&quot;#name&quot;, context, context.getRoot());\rSystem.out.println(name);\r\rUser user = new User();\ruser.setName(&quot;oliver&quot;);\rcontext.setRoot(user);\r\rString name = (String) Ognl.getValue(&quot;name&quot;, context, context.getRoot());\rSystem.out.println(name);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 37);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1388, 'Struts2值栈', '1388', 1551975060, 1551976510, '<p>本文记录Java学习过程中遇到的Struts2的值栈～</p>\r<!--more-->\r\r<p>在Struts2的值栈中包括两部分，即值栈和上下文对象。</p>\r\r<p>Context：即OgnlContext上下文，它是一个map结构，上下文中存储了一些引用（parameters、request、session和application等），上下文的Root为CompoundRoot。常见的引用如下：</p>\r\r<ul>\r	<li>parameters：该Map中包含当前请求的请求参数；</li>\r	<li>request：该Map中包含当前request对象中的所有属性；</li>\r	<li>session：该Map中包含当前session对象中的所有属性；</li>\r	<li>application：该Map中包含当前application对象中的所有属性；</li>\r	<li>attr：该Map按如下顺序来检索某个属性：request&gt;session&gt;application。</li>\r</ul>\r\r<p>CompoundRoot：存储了action实例，它作为OgnlContext的Root对象。它继承ArrayList实现压栈和出栈功能，拥有栈的特点（先进后出，后进先出），最后压进栈的数据在栈顶，被称为对象栈。</p>\r\r<p>Struts2对原OGNL作出的改进就是Root使用CompoundRoot（自定义栈），使用OgnlValueStack的findValue方法可以在CompoundRoot中从栈顶向栈底找查找的对象的属性值。</p>\r\r<p>CompoundRoot作为OgnlContext的Root对象，并且在CompoundRoot中action实例位于栈顶，当读取action的属性值时会先从栈顶对象中找对应的属性，如果找不到则继续找栈中的其他对象，如果找到则停止查找。</p>\r\r<p><strong>ActionContext与ValueStack的关系</strong></p>\r\r<p>示例代码（源码）：</p>\r\r<pre class="brush:java;">\rpublic ActionContext createActionContext(HttpServletRequest request, HttpServletResponse response) {\r	ActionContext ctx;\r	Integer counter = 1;\r	Integer oldCounter = (Integer)request.getAttribute(CLEANUP_RECURSION_COUNTER);\r	if (oldCounter != null) {\r		counter = oldCounter + 1;\r	}\r\r	ActionContext oldContext= ActionContext.getContext();\r	if (oldContext != null) {\r		ctx = new ActionContext(new HashMap&lt;String, Object&gt;(oldContext.getContextMap()));\r	} else {\r		ValueStack stack = dispatcher.getContainer().putAll(dispatcher.createContextMap(request, response, null));\r		ctx = new ActionContext(stack.getContext());\r	}\r	request.setAttribute(CLEANUP_RECURSION_COUNTER, counter);\r	ActionContext.setContext(ctx);\r	return ctx;\r}</pre>\r\r<p>在创建ActionContext的时候，创建ValueStack的对象，将ValueStack对象给ActionContext；ActionContext中有一个ValueStack的引用；ValueStack中也有一个ActionContext的引用；ActionContext获取ServletAPI的时候依赖值栈。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 通过ActionContext对象获取值栈\rValueStack stack = ActionContext.getContext().getValueStack();\r\r// 通过request域获取值栈\rValueStack stack = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);\r\r// 通过Action中属性提供的set/get方法操作值栈：因为Action本身在值栈中，Action中的属性也就默认在值栈中了，所以我们可以通过对Action的属性提供set/get方法的方式来操作值栈。\r\r// 手动操作值栈：调用值栈的push和set方法对值栈进行操作。</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 36),
(1390, 'Struts2拦截器简介', '1390', 1552005928, 1552005928, '<p>本文记录Java学习过程中遇到的Struts2拦截器～</p>\r<!--more-->\r\r<p>拦截器，在AOP（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作，拦截是AOP的一种实现策略。</p>\r\r<p>在WebWork的中文文档中的解释为&mdash;&mdash;拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取Action中可重用的部分的方式。</p>\r\r<p>拦截器链，或者说拦截器栈，就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1389, 'OGNL特殊字符', '1389', 1551976440, 1551976796, '<p>本文记录Java学习过程中遇到的OGNL的特殊字符～</p>\r<!--more-->\r\r<p><strong>#号的使用</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 获取context的数据 --&gt;\r&lt;s:property value=&quot;#request.name&quot;/&gt;\r\r&lt;!-- 使用Struts的UI标签构建一个Map集合 --&gt;\r&lt;s:iterator value=&quot;#{&#39;aaa&#39;:&#39;111&#39;,&#39;bbb&#39;:&#39;222&#39;,&#39;ccc&#39;:&#39;333&#39;}&quot; var=&quot;entry&quot;&gt;\r	&lt;s:property value=&quot;key&quot;/&gt;---&lt;s:property value=&quot;value&quot;/&gt;&lt;br/&gt;\r	&lt;s:property value=&quot;#entry.key&quot;/&gt;---&lt;s:property value=&quot;#entry.value&quot;/&gt;&lt;br&gt;\r&lt;/s:iterator&gt;\r\r&lt;s:radio list=&quot;#{&#39;1&#39;:&#39;男&#39;,&#39;2&#39;:&#39;女&#39;}&quot; name=&quot;sex&quot;&gt;&lt;/s:radio&gt;</pre>\r\r<p><strong>%号的使用</strong></p>\r\r<pre class="brush:xml;">\r&lt;!-- %强制解析OGNL表达式 --&gt;\r&lt;s:textfield name=&quot;name&quot; value=&quot;%{#request.name}&quot;/&gt;\r\r&lt;!-- %强制不解析OGNL表达式 --&gt;\r&lt;s:property value=&quot;%{&#39;#request.name&#39;}&quot;/&gt;</pre>\r\r<p><strong>$号的使用</strong></p>\r\r<pre class="brush:xml;">\r&lt;action name=&quot;demo&quot; class=&quot;ren.oliver.DemoAction&quot;&gt;\r	&lt;result name=&quot;success&quot; type=&quot;redirectAction&quot;&gt;\r		&lt;param name=&quot;name&quot;&gt;${name}&lt;/param&gt;\r	&lt;/result&gt;\r&lt;/action&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1391, 'Struts2执行流程.png', 'Struts2执行流程-png', 1552006399, 1552006399, 'a:5:{s:4:"name";s:23:"Struts2执行流程.png";s:4:"path";s:33:"/usr/uploads/2019/03/40056052.png";s:4:"size";i:227019;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1392, 0),
(1392, 'Struts2拦截器实现原理', '1392', 1552006416, 1552006416, '<p>本文记录Java学习过程中遇到的Struts2拦截器的实现原理～</p>\r<!--more-->\r\r<p>大部分时候，拦截器方法都是通过代理的方式来调用的。Struts2的拦截器实现相对简单，当请求到达Struts2的ServletDispatcher时，Struts2会查找配置文件，并根据其配置实例化相对的拦截器对象，然后串成一个列表，最后一个一个地调用列表中的拦截器。</p>\r\r<p>Struts2的拦截器是可插拔的，就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，Struts2拦截器链中的拦截器就会按其之前定义的顺序被调用。</p>\r\r<p>Struts2的执行流程如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/40056052.png" style="width: 800px; height: 955px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 32),
(1393, 'Struts2自定义拦截器', '1393', 1552007678, 1552007678, '<p>本文记录Java学习过程中遇到的Struts2自定义拦截器～</p>\r<!--more-->\r\r<p>在程序开发过程中，如果需要开发自己的拦截器类，就需要直接或间接的实现com.openssymphony.xwork2.interceptor.Interceptor接口。</p>\r\r<p>示例代码（Interceptor接口）：</p>\r\r<pre class="brush:java;">\rpublic interface Interceptor extends Serializable {\r	void init();\r	void destroy();\r	String intercept(ActionInvocation invocation) throws Exception;\r}</pre>\r\r<p>该接口提供了三个方法，具体介绍如下：</p>\r\r<ul>\r	<li>void init()：该方法在拦截器被创建后会立即被调用，它在拦截器的生命周期内只被调用一次，可以在该方法中对相关资源进行必要的初始化；</li>\r	<li>void destroy()：该方法与init方法相反，在拦截器实例被销毁之前，将调用该方法来释放和拦截器相关的资源。它在拦截器的生命周期内也只被调用一次。</li>\r	<li>String intercept(ActionInvocation invocation) throws Exception：该方法是拦截器的核心方法，用来添加真正执行拦截工作代码，实现具体的拦截操作。它返回一个字符串作为逻辑视图，系统根据返回的字符串跳转到对应的视图资源。每拦截一个动作请求，该方法就会被调用一次。该方法的ActionInvocation参数包含了被拦截的Action的引用，可以通过该参数的invoke()方法，将控制权转给下一个拦截器或者转给Action的execute()方法。</li>\r</ul>\r\r<p>在实际的开发中，除了实现Interceptor接口可以自定义拦截器外，更常用的一种方式是继承抽象拦截器类AbstractIntercepter。该类实现了Interceptor接口，并且提供了init()方法和destroy()方法的空实现。使用时，可以直接继承该抽象类，而不用实现那些不必要的方法。</p>\r\r<p>示例代码（AbstractIntercepter抽象类）：</p>\r\r<pre class="brush:java;">\rpublic abstract class AbstractIntercepter implements Interceptor {\r	public void init() {}\r	public void destroy() {}\r	String intercept(ActionInvocation invocation) throws Exception;\r}</pre>\r\r<p>只有当自定义的拦截器需要打开系统资源时，才需要覆盖AbstractIntercepter类的init()方法和destroy()方法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 33),
(1394, 'Struts2拦截器配置', '1394', 1552009560, 1552009588, '<p>本文记录Java学习过程中遇到的Struts2拦截器配置～</p>\r<!--more-->\r\r<p><strong>拦截器</strong></p>\r\r<p>要想让拦截器起作用，首先要对它进行配置。拦截器的配置是在struts.xml文件中完成的，它通常以&lt;interceptor&gt;标签开头，以&lt;/interceptor&gt;标签结束。</p>\r\r<p>定义拦截器的语法格式为：</p>\r\r<pre class="brush:xml;">\r&lt;interceptor name=&quot;interceptorName&quot; class=&quot;interceptorClass&quot;&gt;\r	&lt;param name=&quot;paramName&quot;&gt;paramValue&lt;/param&gt;\r&lt;/interceptor&gt;</pre>\r\r<p>上述语法格式中，name属性用来指定拦截器的名称，class属性用于指定拦截器的实现类。有时候，在定义拦截器时需要传入参数，这时需要使用&lt;param&gt;标签，其中name属性用来指定参数的名称，paramValue表示参数的值。</p>\r\r<p><strong>拦截器栈</strong></p>\r\r<p>在实际开发过程中，经常需要在Action执行前同时执行多个拦截动作，例如：用户登录检查、登录日志记录以及权限检查等。这时，可以把多个拦截器组成一个拦截器栈。在使用时，可以将栈内的多个拦截器当成一个整体来引用。当拦截器栈被附加到一个Action上时，在执行Action之前必须先执行拦截器栈中的每一个拦截器。</p>\r\r<p>定义拦截器栈使用&lt;interceptors&gt;元素和&lt;interceptor-stack&gt;子元素，当配置多个拦截器时，需要使用&lt;interceptor-ref&gt;元素来指定多个拦截器，配置语法格式如下：</p>\r\r<pre class="brush:java;">\r&lt;interceptors&gt;\r	&lt;interceptor-stack name=&quot;interceptorStackName&quot;&gt;\r		&lt;interceptor-ref name=&quot;interceptorName&quot;/&gt;\r	&lt;/interceptor-stack&gt;\r&lt;/interceptors&gt;</pre>\r\r<p>在上述语法中，interceptorStackName值表示配置的拦截器栈的名称；interceptorName值表示拦截器的名称。</p>\r\r<p>除此之外，在一个拦截器栈中还可以包含另一个拦截器栈，示例代码如下：</p>\r\r<pre class="brush:xml;">\r&lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;\r	&lt;interceptors&gt;\r		&lt;interceptor name=&quot;interceptor1&quot; class=&quot;interceptor1Class&quot;&gt;\r		&lt;interceptor name=&quot;interceptor2&quot; class=&quot;interceptor2Class&quot;&gt;\r		&lt;interceptor-stack name=&quot;myStack&quot;&gt;\r			&lt;interceptor-ref name=&quot;defaultStack&quot; /&gt;\r			&lt;interceptor-ref name=&quot;interceptor1&quot; /&gt;\r			&lt;interceptor-ref name=&quot;interceptor2&quot; /&gt;\r		&lt;/interceptor-stack&gt;\r	&lt;/interceptors&gt;\r&lt;/package&gt;</pre>\r\r<p>在上述代码中，定义的拦截器栈时myStack，在myStack栈中，除了引用了两个自定义的拦截器interceptor1和interceptor2外，还引用了一个内置拦截器栈defaultStack，这个拦截器是必须要引入的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 37),
(1395, 'Struts2标签库简介', '1395', 1552054440, 1552056046, '<p>本文记录Java学习过程中遇到的Struts2标签库简介～</p>\r<!--more-->\r\r<p>在JavaWeb中，Struts2标签库是一个比较完善，而且功能强大的标签库，它将所有标签都统一到一个标签库中，从而简化了标签的使用，它还提供主题和模板的支持，极大地简化了视图页面代码的编写，同时它还提供对Ajax的支持，大大的丰富了视图的表现效果。与JSTL（JSP Standard Library，JSP标准标签库）相比，Struts2标签库更加易用和强大。</p>\r\r<p><strong>Struts2标签库分类</strong></p>\r\r<p>早期的JSP页面需要嵌入大量的Java脚本来进行输出，这样使得一个简单的JSP页面加入了大量的代码，不利于代码的可维护性和可读性。随着技术的发展，逐渐的采用标签库来进行JSP页面的开发，这使得JSP页面能够在很短的时间内完成开发，而且代码通俗易懂，大大的方便了开发者，Struts2的标签库就是这样发展起来的。</p>\r\r<p>Struts2框架对整个标签库进行了分类，按其功能大致可分为两类，如下图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/2003115588.png" style="width: 800px; height: 211px;" /></p>\r\r<p>由图中可以看出，Struts2标签库主要分为两类：普通标签和UI标签。普通标签主要是在页面生成时，控制执行的流程。UI标签则是以丰富而可复用的HTML文件来显示数据。</p>\r\r<p>普通标签又分为控制标签（Control Tags）和数据标签（Data Tags）。控制标签用来完成条件逻辑、循环逻辑的控制，也可用来做集合的操作。数据标签用来输出后台的数据和完成其他数据访问功能。</p>\r\r<p>UI标签又分为表单标签（Form Tags）、非表单标签（Non-Form Tags）和Ajax标签。表单标签主要用来生成HTML页面中的表单元素，非表单标签主要用来生成HTML的&lt;div&gt;标签及输出Action中封装的信息等。Ajax标签主要用来提供Ajax技术支持。</p>\r\r<p><strong>Struts2标签的使用</strong></p>\r\r<p>Struts2标签库被定义在struts-tags.tld文件中，可以在struts-core-2.3.24.jar中的META-INF目录下找到它。要使用struts2的标签库，一般只需在JSP文件使用taglib指令导入Struts2标签库。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;</pre>\r\r<p>在上述代码中，taglib指令的uri属性用于指定引入标签库描述符文件的URI，prefix属性用于指定引入标签库描述文件的前缀。需要注意的是，在JSP文件中，所有的Struts2标签库都是用&quot;s&quot;前缀。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 36),
(1396, 'Struts2标签库分类.png', 'Struts2标签库分类-png', 1552055970, 1552055970, 'a:5:{s:4:"name";s:26:"Struts2标签库分类.png";s:4:"path";s:35:"/usr/uploads/2019/03/2003115588.png";s:4:"size";i:87285;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1395, 0),
(1397, 'interator的属性.png', 'interator的属性-png', 1552058007, 1552058007, 'a:5:{s:4:"name";s:22:"interator的属性.png";s:4:"path";s:35:"/usr/uploads/2019/03/3360802882.png";s:4:"size";i:275715;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1398, 0),
(1398, 'Struts2控制标签', '1398', 1552058056, 1552058056, '<p>本文记录Java学习过程中遇到的Struts2控制标签～</p>\r<!--more-->\r\r<p>在程序开发中，经常要用流程控制实现分支和循环等操作。为此，Struts2标签库中提供了控制标签，常用的逻辑控制标签主要包括：&lt;s:if&gt;、&lt;s:elseif&gt;、&lt;s:else&gt;和&lt;s:iterator&gt;等。</p>\r\r<p><strong>&lt;s:if&gt;、&lt;s:elseif&gt;、&lt;s:else&gt;标签</strong></p>\r\r<p>与多数编程语言中的if、elseif和else语句的功能类似，&lt;s:if&gt;、&lt;s:elseif&gt;、&lt;s:else&gt;这三个标签用于程序的分支逻辑控制。其中，只有&lt;s:if&gt;标签可以单独使用，而&lt;s:elseif&gt;、&lt;s:else&gt;都必须与&lt;s:if&gt;标签结合使用，其语法格式如下：</p>\r\r<pre class="brush:xml;">\r&lt;s:if test = &quot;表达式1&quot;&gt;\r标签体1\r&lt;/s:elseif&gt;\r&lt;s:if test = &quot;表达式2&quot;&gt;\r标签体2\r&lt;/s:elseif&gt;\r&lt;s:else&gt;\r标签体3\r&lt;/s:else&gt;</pre>\r\r<p>上述语法格式中，&lt;s:if&gt;和&lt;s:elseif&gt;标签必须指定test属性，该属性用于设置标签的判断条件，其值为boolean型的条件表达式。</p>\r\r<p><strong>&lt;s:iterator&gt;标签</strong></p>\r\r<p>&lt;s:iterator&gt;标签主要用于对集合中的数据进行迭代，它可以根据条件遍历集合中的数据。&lt;s:iterator&gt;标签的属性及相关说明如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/3360802882.png" style="width: 800px; height: 365px;" />​</p>\r\r<p>在表中，如果在&lt;s:iterator&gt;标签中指定status属性，那么通过该属性可以获取迭代过程中的状态信息，如：元素数、当前索引值等。通过status属性获取信息的方法如下：</p>\r\r<ul>\r	<li>st.count：返回当前已经遍历的集合元素的个数；</li>\r	<li>st.first：返回当前遍历元素是否为集合的第一个元素；</li>\r	<li>st.last：返回当前遍历元素是否为集合的最后一个元素；</li>\r	<li>st.index：返回遍历元素的当前索引值；</li>\r	<li>st.even：返回当前遍历的元素的索引是否为偶数；</li>\r	<li>st.odd：返回当前遍历的元素的索引是否为奇数。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1399, 'Struts2数据标签', '1399', 1552059994, 1552059994, '<p>本文记录Java学习过程中遇到的Struts2数据标签～</p>\r<!--more-->\r\r<p>在Struts2标签库中，数据标签主要用于各种数据访问相关的功能以及Action的调用等。常用的数据标签有&lt;s:property&gt;、&lt;s:a&gt;、&lt;s:debug&gt;、&lt;s:include&gt;和&lt;s:param&gt;等。</p>\r\r<p><strong>&lt;s:property&gt;标签</strong></p>\r\r<p>&lt;s:property&gt;标签用于输出指定的值，通常输出的是value属性指定的值，&lt;s:property&gt;标签的属性及属性说明如下所示：</p>\r\r<ul>\r	<li>id：可选属性，指定该元素的标识；</li>\r	<li>default：可选属性，如果要输出的属性值为null，则显示default属性的指定值；</li>\r	<li>escape：可选属性，指定是否忽略HTML代码；</li>\r	<li>value：可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出ValueStack栈顶的值。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 输出字符串 --&gt;\r&lt;s:property value=&quot;&#39;www.oliver.ren&#39;&quot;/&gt;&lt;br/&gt;\r\r&lt;!-- 忽略HTML代码 --&gt;\r&lt;s:property value=&quot;&#39;&lt;h3&gt;www.oliver.ren&lt;/h3&gt;&#39;&quot; escape=&quot;true&quot;/&gt;&lt;br/&gt;\r\r&lt;!-- 不忽略HTML代码 --&gt;\r&lt;s:property value=&quot;&#39;&lt;h3&gt;www.oliver.ren&lt;/h3&gt;&#39;&quot; escape=&quot;false&quot;/&gt;&lt;br/&gt;\r\r&lt;!-- 输出默认值 --&gt;\r&lt;s:property value=&quot;&quot; default=&quot;true&quot;/&gt;&lt;br/&gt;</pre>\r\r<p><strong>&lt;s:a&gt;标签</strong></p>\r\r<p>&lt;s:a&gt;标签用于构造HTML页面中的超链接，其使用方式与HTML中的&lt;a&gt;标签类似。&lt;s:a&gt;标签的属性及相关说明如下：</p>\r\r<ul>\r	<li>action：非必需属性，Stirng类型，指定超链接的Action地址；</li>\r	<li>href：非必需属性，Stirng类型，指定超链接地址；</li>\r	<li>namespace：非必需属性，Stirng类型，指定Action的namespace地址；</li>\r	<li>id：非必需属性，Stirng类型，指定其id；</li>\r	<li>method：非必需属性，Stirng类型，指定Action调用的方法。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;s:a href=&quot;http://www.oliver.ren&quot;&gt;Oliver&#39;s Blog&lt;/s:a&gt;\r&lt;s:a namespace=&quot;&quot; action=&quot;&quot;&gt;Oliver&#39;s Blog&lt;/s:a&gt;</pre>\r\r<p><strong>&lt;s:debug&gt;标签</strong></p>\r\r<p>该标签用于在调试程序时输出更多的调试信息，主要输出ValueStack和StackContext中的信息，该标签只有一个id属性，且一般不使用。</p>\r\r<p>在使用debug标签后，网页中会生成一个[Debug]的链接，单击该链接，网页中将输出各种服务器对象的信息。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1400, 'Struts2的模板和主题', '1400', 1552061031, 1552061031, '<p>本文记录Java学习过程中遇到的Struts2的模板和主题～</p>\r<!--more-->\r\r<p>Struts2的UI标签都是基于模板和主题的。所谓模板，就是一些代码，Struts2标签使用这些代码渲染生成相应的HTML代码。模板是一个UI标签的外在表现形式，并且每个标签都会有自己对应的模板。如果为所有的UI标签提供样式和视觉效果相似的模板，那么这一系列的模板就形成了一个主题。</p>\r\r<p>Struts2默认提供了4种主题，分别是simple、xhtml、css_xhtml和Ajax。</p>\r\r<ul>\r	<li>simple主题：这是最简单的主题，使用该主题时，每个UI标签只生成最基本的HTML元素，没有任何附加效果；</li>\r	<li>xhtml主题：这是Struts的默认主题，它对simple主题进行了扩展，提供了布局功能、Label显示名称、以及与验证框架和国际化框架的集成；</li>\r	<li>css_xhtml：该主题是对xhtml的扩展，在xhtml的基础之上添加对CSS的支持和控制；</li>\r	<li>Ajax：继承自xhtml，提供Ajax支持。</li>\r</ul>\r\r<p>这4种内建主题中，xhtml为默认主题，但xhtml有一定的局限性。因为它使用表格进行布局，并且只支持每一行放一个表单项。这样一来，一旦遇到复杂的页面布局，xhtml就难以胜任了。</p>\r\r<p>通常，通过设置常量struts.ui.theme来改变默认主题，具体做法是在struts.xml或者struts.properties文件中增加相应的配置。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r&lt;constant name=&quot;struts.ui.theme&quot; value=&quot;simple&quot;/&gt;\rstruts.ui.theme=simple</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 32),
(1401, 'Struts2表单通用标签.png', 'Struts2表单通用标签-png', 1552095685, 1552095685, 'a:5:{s:4:"name";s:29:"Struts2表单通用标签.png";s:4:"path";s:34:"/usr/uploads/2019/03/354471288.png";s:4:"size";i:398036;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1402, 0),
(1402, 'Struts2的表单标签', '1402', 1552095989, 1552095989, '<p>本文记录Java学习过程中遇到的Struts2的表单标签～</p>\r<!--more-->\r\r<p>Struts2的表单标签用来向服务器提交用户输入的信息，绝大多数的表单标签都有其对应的HTML标签，通过表单标签可以简化表单开发，还可以实现HTML中难以实现的功能。</p>\r\r<p><strong>表单标签的公共属性</strong></p>\r\r<p>Struts2的表单标签用来向服务器提交用户输入信息，在org.apache.struts2.components包中都有一个对应类，所有表单标签对应的类都继承自UIBean类。UIBean类提供了一组公共属性，这些属性是完全通用的。具体如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/354471288.png" style="width: 800px; height: 461px;" /></p>\r\r<p>需要注意的是，表单标签的name和value属性基本等同于HTML组件的name和value，但是也有些不同的地方：表单标签在生成HTML的时候，如果标签没有设置value属性的话，就会从值栈中按照name获取相应的值，把这个值设置成的HTML组件的value。简单的说，就是表单标签的value在生成HTML的时候会自动设置值，其值从值栈中获取。</p>\r\r<p><strong>&lt;s:form&gt;标签</strong></p>\r\r<p>&lt;s:form&gt;标签用来呈现HTML语言中的表单元素，其常用属性如下：</p>\r\r<ul>\r	<li>action：非必需属性，String类型，指定提交时对应的Action，不需要.action后缀；</li>\r	<li>enctype：非必需属性，String类型，对应HTML表单enctype属性；</li>\r	<li>method：非必需属性，String类型，对应HTML表单method属性；</li>\r	<li>namespace：非必需属性，String类型，所提交Action的命名空间。</li>\r</ul>\r\r<p>在使用&lt;s:form&gt;标签时，一般会包含其他的表单元素，如textfild和radio等标签，通过这些表单元素对应的name属性，在提交表单时，将其作为参数传入Struts2框架进行处理。</p>\r\r<p><strong>&lt;s:submit&gt;标签</strong></p>\r\r<p>&lt;s:submit&gt;标签主要用于产生HTML中的提交按钮。该表单元素中，可以指定提交时的Action对应的方法。通常与&lt;s:form&gt;标签一起使用，该标签的常用属性如下：</p>\r\r<ul>\r	<li>action：非必需属性，String类型，指定提交时对应的Action；</li>\r	<li>method：非必需属性，String类型，指定Action中调用的方法。</li>\r</ul>\r\r<p><strong>&lt;s:textfield&gt;和&lt;s:textarea&gt;标签</strong></p>\r\r<p>&lt;s:textfield&gt;和&lt;s:textarea&gt;标签的作用比较相似，都用于创建文本框，区别在于&lt;s:textfield&gt;创建的是单行文本框，而&lt;s:textarea&gt;创建的是多行文本框。二者使用也比较简单，一般指定其label和name属性即可。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;s:textfield label=&quot;用户名&quot; name=&quot;username&quot;/&gt;\r&lt;s:textarea label=&quot;描述&quot; name=&quot;description&quot;/&gt;</pre>\r\r<p>name属性用来指定单行/多行文本框的名称，在Action中，通过该属性获取单行/多行文本框的值。其value属性用来指定单行/多行文本框的当前值。</p>\r\r<p>此外，&lt;textarea&gt;标签可以通过使用cols和rows属性分别指定多行文本框的列数和行数。</p>\r\r<p><strong>&lt;s:password&gt;标签</strong></p>\r\r<p>&lt;s:password&gt;标签用于创建一个密码输入框，它可以生产HTML中的&lt;input type=&quot;password&quot;/&gt;标签，常用在登录表单中输入用户的登录密码。&lt;s:password&gt;标签的常用属性如下：</p>\r\r<p>name：用于指定密码输入框的名称；<br />\rsize：用于限定密码输入框的显示宽度，以字符数为单位；<br />\rmaxlength：用于限定密码输入框的最大输入字符串个数；<br />\rshowPassword：是否显示初始值，即使显示也仍为密文显示，用*遮挡。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;s:password label=&quot;password&quot; name=&quot;password&quot; maxlength=&quot;15&quot;/&gt;</pre>\r\r<p>需要注意的是&lt;s:password&gt;标签与HTML中的&lt;input type=&quot;password&quot;/&gt;标签有些不同：&lt;input type=&quot;password&quot;/&gt;标签只要设置value属性就可以将value属性的值作为默认显示值；而Struts2的&lt;s:password&gt;标签除了要设置value属性，还要设置showPassword属性为true。</p>\r\r<p><strong>&lt;s:radio&gt;标签</strong></p>\r\r<p>&lt;s:radio&gt;标签用于创建单选按钮，生产HTML中的&lt;input type=&quot;radio&quot;/&gt;标签。&lt;s:radio&gt;标签常用属性如下：</p>\r\r<ul>\r	<li>list：必需属性，类型可以是：Collection、Map、Enmumeration、Iterator、Array等，用于生成单选框中的集合；</li>\r	<li>listKey：非必需属性，String类型，指定集合对象中的哪个属性作为选项的value；</li>\r	<li>listValue：非必需属性，String类型，指定集合对象中的哪个属性作为选项的内容。</li>\r</ul>\r\r<p>这三个属性必须要配合使用，由list属性指定从集合中获得元素，由listKey属性指定获得元素之后使用元素的哪个属性作为生成&lt;input type=&quot;radio&quot;/&gt;的value属性，由listValue属性指定生产的&lt;input type=&quot;radio&quot;/&gt;后给用户看的文字。</p>\r\r<p><strong>&lt;s:checkboxlist&gt;标签</strong></p>\r\r<p>&lt;s:checkboxlist&gt;标签用于一次性创建多个复选框，用户可以选择创建零个到多个，它用来产生一组&lt;input type=&quot;checkbox&quot;/&gt;标签，这个标签的常用属性如下：</p>\r\r<ul>\r	<li>Name：非必需属性，String类型，指定该元素的name；</li>\r	<li>List：必需属性，类型可以是Collection、Map、Enmumeration、Iterator、Array等，用于生成多选框的集合；</li>\r	<li>listKey：非必需属性，String类型，生成checkbox的value属性；</li>\r	<li>listValue：非必需属性，String类型，生成checkbox后面显示的文字。</li>\r</ul>\r\r<p>需要注意的是，listKey和listValue属性主要用在集合中，其中存放的是JavaBean，可以使用这两个从JavaBean众多属性中筛选需要的值。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;s:checkboxlist label=&quot;爱好&quot; name=&quot;interesters&quot; list=&quot;{&#39;足球&#39;,&#39;篮球&#39;,&#39;游泳&#39;}&quot; labelposition=&quot;left&quot;/&gt;\r&lt;s:checkboxlist label=&quot;课程&quot; name=&quot;class&quot; list=&quot;#{&#39;a&#39;:&#39;语文&#39;,&#39;b&#39;:&#39;数学&#39;,&#39;c&#39;:&#39;外语&#39;}&quot; labelposition=&quot;left&quot; listKey=&quot;key&quot; listValue=&quot;value&quot;/&gt;</pre>\r\r<p><strong>&lt;s:select&gt;标签</strong></p>\r\r<p>&lt;s:select&gt;标签用于创建一个下拉列表框，生成HTML中的&lt;select&gt;标签。该标签常用的属性如下：</p>\r\r<ul>\r	<li>list：必需属性，类型可以是Collection、Map、Enmumeration、Iterator、Array等，用于生成下拉框的集合；</li>\r	<li>listKey：非必需属性，String类型，生成选项的value属性；</li>\r	<li>listValue：非必需属性，String类型，生成选项的显示文字；</li>\r	<li>headerKey：非必需属性，String类型，在所有的选项前再加额外的一个选项作为其标题的value值；</li>\r	<li>headerValue：非必需属性，String类型，显示在页面中header选项的内容；</li>\r	<li>Multiple：非必需属性，Boolean类型，指定是否多选，默认为false；</li>\r	<li>emptyOption：非必需属性，Boolean类型，是否在标题和真实的选项之间加一个空选项；</li>\r	<li>Size：非必需属性，Integer类型，下拉框的高度，即最多可以同时显示多少个选项。</li>\r</ul>\r\r<p>在表中，headerKey和headerValue属性需要同时使用，可以在所有的真实选项之前加一项作为标题项。比如，选择省份的时候，可以在所有的具体省份之前加一项&ldquo;请选择&rdquo;，这个项不作为备选的值。</p>\r\r<p>multiple属性和size属性类似于HTML的&lt;select&gt;标签，size属性可以让下拉框同时显示多个值，multiple属性让用户同时选择多个值，只是在后台的Action接收下拉框值的时候，不能使用String类型，而应该使用String[]或者List&lt;String&gt;。</p>\r\r<p><strong>&lt;s:hidden&gt;标签</strong></p>\r\r<p>&lt;s:hieedn&gt;标签用于创建隐藏表单元素，生成HTML中的隐藏域标签&lt;input type=&quot;hidden&quot;&gt;。该标签在页面上没有任何显示，可以保存或交换数据。其使用也比较简单，通常只设置其name和value属性即可。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;s:hidden name=&quot;id&quot; value=&quot;%{id}&quot;/&gt;</pre>\r\r<p>该标签主要是需要提交的表单传值的时候使用，比如需要提交表单时，要传一个值到请求参数中去，就可以使用该标签。</p>\r\r<p><strong>&lt;s:reset&gt;标签</strong></p>\r\r<p>&lt;s:reset&gt;标签用来创建一个重置按钮，会生成HTML中的&lt;input type=&quot;reset&quot;/&gt;标签，该标签的使用比较简单，其常用属性为name和value。其中，name属性用于指定重置按钮的名称，在Action中，可以通过name属性来获取重置按钮的值，value属性用来显示按钮的值。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;s:reset value=&quot;reset&quot;/&gt;\r&lt;s:reset value=&quot;reset&quot; value=&quot;重置&quot;/&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 40),
(1403, 'Spring简介', '1403', 1552220760, 1561532732, '<p>本文记录Java学习过程中遇到的Spring简介～</p>\r<!--more-->\r\r<p>Spring是一个开源框架，是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者使用哪一个组件，同时为J2EE应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用户不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面编程（AOP）。简单的说，Spring是一个分层的JavaSE/EE full-stack（一站式）轻量级开源框架。</p>\r\r<p>EE开发分成三层结构：</p>\r\r<ul>\r	<li>Web层：Spring MVC；</li>\r	<li>业务层：Bean管理（IoC）；</li>\r	<li>持久层：Spring的JDBC模板。ORM模板用于整合其他的持久层框架。</li>\r</ul>\r\r<p>Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理AOP编程的支持。</p>\r\r<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截和运行监控等功能声明式事务的支持。</p>\r\r<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\r\r<p>方便程序的测试，Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>\r\r<p>方便集成各种优秀框架，Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis和Quartz等）的直接支持。</p>\r\r<p>降低了JavaEE API的使用难度，Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail和远程调用等）都提供了封装，使这些API应用难度大大降低。</p>\r\r<p>Spring是一种开源轻量级框架，是为了解决企业应用程序开发复杂性而创建的，Spring致力于解决JavaEE的各层解决方案，而不仅仅于某一层的方案。</p>\r\r<p>2003年2月Spring框架正式成为一道开源项目，Spring致力于J2EE应用的各种解决方案，而不仅仅专注于某一层解决方案。可以说Spring是企业应用开发的&ldquo;一站式&rdquo;选择， Spring贯穿于表现层、业务层、持久层，然而Spring并不想取代那些已经有的框架，而是以高度的开放性，与这些已有的框架进行整合。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1404, 'ioc底层实现.png', 'ioc底层实现-png', 1552221351, 1552221351, 'a:5:{s:4:"name";s:19:"ioc底层实现.png";s:4:"path";s:35:"/usr/uploads/2019/03/2280938726.png";s:4:"size";i:338499;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1405, 0),
(1405, 'Spring的IoC的底层实现原理', '1405', 1552221360, 1552221807, '<p>本文记录Java学习过程中遇到的Spring的IoC的底层实现原理～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/2280938726.png" style="width: 800px; height: 503px;" />​</p>\r\r<p>IoC：Inversion of Control控制反转，指的是对象的创建权反转（交给）给Spring，作用是现实了程序的解耦合。</p>\r\r<p>DI：Dependency Injection，依赖注入，需要有IoC的环境，Spring创建这个类的过程中，Spring将类的依赖属性设置进去。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 53),
(1406, 'BeanFactory.png', 'BeanFactory-png', 1552222186, 1552222186, 'a:5:{s:4:"name";s:15:"BeanFactory.png";s:4:"path";s:35:"/usr/uploads/2019/03/3359990982.png";s:4:"size";i:329456;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1407, 0),
(1407, 'Spring中的工厂（容器）', '1407', 1552222342, 1552222342, '<p>本文记录Java学习过程中遇到的Spring中的工厂（容器）～</p>\r<!--more-->\r\r<p><strong>ApplicationContext</strong></p>\r\r<p>ApplicationContext接口有两个实现类：</p>\r\r<ul>\r	<li>ClassPathXmlApplicationContext：加载类路径下Spring的配置文件；</li>\r	<li>FileSystemXmlApplicationContext：加载本地磁盘下Spring的配置文件。</li>\r</ul>\r\r<p><strong>BeanFactory</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/3359990982.png" style="width: 800px; height: 665px;" />​</p>\r\r<p>BeanFactory于ApplicationContext的区别：</p>\r\r<ul>\r	<li>BeanFactory：是在getBean的时候才能生成类的实例；</li>\r	<li>ApplicationContext：是加载ApplicationContext.xml（容器启动）的时候就会创建。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 36),
(1408, 'Spring的相关配置', '1408', 1552223803, 1552223803, '<p>本文记录Java学习过程中遇到的Spring的相关配置～</p>\r<!--more-->\r\r<p><strong>id属性和name属性标签</strong></p>\r\r<ul>\r	<li>id：bean的名字，在约束中采用ID的约束，具有唯一性。必须以字符开始，可以使用字母、数字、连字符、下划线、句号和冒号，不能出现特殊字符；</li>\r	<li>name：bean的名字，没有采用ID的约束，可以出现特殊字符，如果bean没有id，那么可以当作id使用。</li>\r</ul>\r\r<p><strong>scope属性</strong></p>\r\r<p>它指的是bean的作用范围：</p>\r\r<ul>\r	<li>singleton：默认值，单例的；</li>\r	<li>prototype：多例的；</li>\r	<li>request：Web项目中，Spring创建一个bean对象，将对象存入到request域中；</li>\r	<li>session：Web项目中，Spring创建一个bean对象，将对象存入到session域中；</li>\r	<li>globalSession：Web项目中，应用在Porlet环境。如果没有Porlet环境，那么globalSession相当于session。</li>\r</ul>\r\r<p><strong>bean的生命周期</strong></p>\r\r<p>通过配置&lt;bean&gt;标签上的init-method作为bean的初始化的时候执行的方法，配置destroy-method作为bean的销毁的时候执行的方法。</p>\r\r<p>销毁方法想要执行，需要是单例创建的bean，而且在工厂关闭的时候，bean才会被销毁。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 33),
(1409, 'Spring生成bean的方式', '1409', 1552225020, 1552225073, '<p>本文记录Java学习过程中遇到的Spring生成bean的三种方式～</p>\r<!--more-->\r\r<p><strong>无参数的构造方法的方式</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;bean&quot; class=&quot;ren.oliver.spring.Bean&quot;/&gt;</pre>\r\r<p><strong>静态工厂实例化的方式</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class BeanFactory {\r	public static Bean getBean() {\r		returen new Bean();\r	}\r}</pre>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;bean&quot; class=&quot;ren.oliver.spring.BeanFactory&quot; factory-method=&quot;getBean&quot; /&gt;</pre>\r\r<p><strong>实例工厂实例化的方式</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class BeanFactory {\r	public Bean getBean() {\r		return new Bean();\r	}\r}</pre>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;beanFactory&quot; class=&quot;ren.oliver.spring.BeanFactory&quot; /&gt;\r&lt;bean id=&quot;bean&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;getBean&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1410, 'Spring中bean的属性注入', '1410', 1552225500, 1552225846, '<p>本文记录Java学习过程中遇到的Spring中bean的属性注入～</p>\r<!--more-->\r\r<p><strong>构造方法的方式</strong></p>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;user&quot; class=&quot;ren.oliver.spring.User&quot;&gt;\r	&lt;constructor-arg name=&quot;username&quot; value=&quot;oliver&quot; /&gt;\r	&lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot; /&gt;\r&lt;/bean&gt;</pre>\r\r<p><strong>set方法的方式</strong></p>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;user&quot; class=&quot;ren.oliver.spring.User&quot;&gt;\r	&lt;property name=&quot;username&quot; value=&quot;oliver&quot; /&gt;\r	&lt;property name=&quot;age&quot; value=&quot;18&quot; /&gt;\r&lt;/bean&gt;</pre>\r\r<p><strong>对象类型的注入</strong></p>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;bean&quot; class=&quot;ren.oliver.spring.User&quot;&gt;\r	&lt;property name=&quot;username&quot; value=&quot;oliver&quot; /&gt;\r	&lt;property name=&quot;car&quot; ref=&quot;car&quot; /&gt;\r&lt;/bean&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 34),
(1411, 'Spring中名称空间p的属性注入', '1411', 1552226613, 1552226613, '<p>本文记录Java学习过程中遇到的Spring中名称空间p的属性注入～</p>\r\r<!--more-->\r\r<p><strong>第一步：引入p名称空间</strong></p>\r\r<pre class="brush:xml;">\r&lt;beans \r	xmlns=&quot;http://www.springframework.org/schema/beans&quot; \r	xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; \r	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;\r&gt;</pre>\r\r<p><strong>第二步：使用p名称空间</strong></p>\r\r<ul>\r	<li>普通属性：p:属性名称=&quot;&quot;；</li>\r	<li>对象类型属性：p:属性名称-ref=&quot;&quot;。</li>\r</ul>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;car&quot; class=&quot;ren.oliver.spring.Car&quot; p:name=&quot;奥迪&quot; p:price=&quot;20k&quot; /&gt;\r&lt;bean id=&quot;user&quot; class=&quot;ren.oliver.spring.User&quot; p:name=&quot;oliver&quot; p:car-ref=&quot;car&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 36),
(1412, 'Spring中SPEL方式的属性注入', '1412', 1552227240, 1552227423, '<p>本文记录Java学习过程中遇到的Spring中SPEL方式的属性注入～</p>\r\r<!--more-->\r\r<p>SPEL：Spring Expression Language</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:java;">\r#{spel}</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;car&quot; class=&quot;ren.oliver.spring.Car&quot;&gt;\r	&lt;property name=&quot;name&quot; value=&quot;#{&#39;奔驰&#39;}&quot; /&gt;\r	&lt;property name=&quot;price&quot; value=&quot;#{80000}&quot; /&gt;\r&lt;bean&gt;\r\r&lt;bean id=&quot;user&quot; class=&quot;ren.oliver.spring.User&quot;&gt;\r	&lt;property name=&quot;name&quot; value=&quot;#{&#39;oliver&#39;}&quot; /&gt;\r	&lt;property name=&quot;car&quot; value=&quot;#{car}&quot; /&gt;\r&lt;/bean&gt;\r\r&lt;bean id=&quot;carInfo&quot; class=&quot;ren.oliver.spring.CarInfo&quot; /&gt;\r\r&lt;bean id=&quot;car&quot; class=&quot;ren.oliver.spring.Car&quot;&gt;\r	&lt;property name=&quot;name&quot; value=&quot;#{carInfo.carName}&quot; /&gt;\r	&lt;property name=&quot;price&quot; value=&quot;#{carInfo.calculatePrice()}&quot; /&gt;\r&lt;/bean&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 54),
(1413, 'Spring中复杂类型的注入', '1413', 1552228730, 1552228730, '<p>本文记录Java学习过程中遇到的Spring中复杂类型的注入～</p>\r\r<!--more-->\r\r<p><strong>数组类型的注入</strong></p>\r\r<pre class="brush:xml;">\r&lt;property name=&quot;arrs&quot;&gt;\r	&lt;array&gt;\r		&lt;value&gt;oliver&lt;/value&gt;\r		&lt;value&gt;cathy&lt;/value&gt;\r		&lt;value&gt;hellen&lt;/value&gt;\r	&lt;/array&gt;\r&lt;/property&gt;</pre>\r\r<p><strong>List类型的注入</strong></p>\r\r<pre class="brush:xml;">\r&lt;property name=&quot;list&quot;&gt;\r	&lt;list&gt;\r		&lt;value&gt;oliver&lt;/value&gt;\r		&lt;value&gt;cathy&lt;/value&gt;\r		&lt;value&gt;hellen&lt;/value&gt;\r	&lt;/list&gt;\r&lt;/property&gt;</pre>\r\r<p><strong>Map类型的注入</strong></p>\r\r<pre class="brush:xml;">\r&lt;property name=&quot;map&quot;&gt;\r	&lt;map&gt;\r		&lt;entry key=&quot;key&quot; value=&quot;value&quot; /&gt;\r		&lt;entry key=&quot;key&quot; value=&quot;value&quot; /&gt;\r		&lt;entry key=&quot;key&quot; value=&quot;value&quot; /&gt;\r	&lt;/map&gt;\r&lt;/property&gt;</pre>\r\r<p><strong>Properties类型的注入</strong></p>\r\r<pre class="brush:xml;">\r&lt;property name=&quot;properties&quot;&gt;\r	&lt;props&gt;\r		&lt;prop key=&quot;username&quot;&gt;oliver&lt;/prop&gt;\r		&lt;prop key=&quot;age&quot;&gt;18&lt;/prop&gt;\r	&lt;/props&gt;\r&lt;/property&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 35),
(1414, 'Spring中分配置文件', '1414', 1552228977, 1552228977, '<p>本文记录Java学习过程中遇到的Spring中分配置文件～</p>\r\r<!--more-->\r\r<p>方式一：创建工厂的时候加载多个配置文件</p>\r\r<pre class="brush:java;">\rApplicationContext applicationContext = ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;);</pre>\r\r<p>方式二：在一个配置文件中包含另一个配置文件</p>\r\r<pre class="brush:xml;">\r&lt;import resource=&quot;applicationContext2.xml&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 45),
(1415, 'Spring中Bean管理的常用注解', '1415', 1552264749, 1552264749, '<p>本文记录Java学习过程中遇到的Spring中Bean管理的常用注解～</p>\r<!--more-->\r\r<p><strong>组件注解</strong></p>\r\r<p>Spring中提供了@Component的三个衍生注解：</p>\r\r<ul>\r	<li>@Controller：Web层；</li>\r	<li>@Service：Service层；</li>\r	<li>@Repository：Dao层。</li>\r</ul>\r\r<p>这三个注解是为了标识类本身的用途，功能上是一致的，Spring在后续版本会对其增强。</p>\r\r<p><strong>属性注入</strong></p>\r\r<ul>\r	<li>@Value：普通类型的注入；</li>\r	<li>@Autowired：自动装配，按类型进行装配；</li>\r	<li>@Qualifier：强制使用名称注入，与@Autowired一起使用；</li>\r	<li>@Resource：相当于@Autowired与@Qualifier一起使用。</li>\r</ul>\r\r<p><strong>作用范围</strong></p>\r\r<p>作用范围使用@Scope注解：</p>\r\r<ul>\r	<li>singleton：单例；</li>\r	<li>prototype：多例。</li>\r</ul>\r\r<p><strong>生命周期</strong></p>\r\r<ul>\r	<li>@PostConstruct：相当于init-method；</li>\r	<li>@PreDestroy：相当于destroy-method。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1416, 'Spring中Bean管理方式比较', '1416', 1552265160, 1552265264, '<p>本文记录Java学习过程中遇到的Spring中Bean的两种管理方式比较～</p>\r<!--more-->\r\r<p>Bean定义</p>\r\r<ul>\r	<li>基于XML配置：&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;；</li>\r	<li>基于注解配置：@Component，衍生类：@Controller、@Service和@Repository。</li>\r</ul>\r\r<p>Bean名称</p>\r\r<ul>\r	<li>基于XML配置：指定id或name；</li>\r	<li>基于注解配置：@Component(&quot;name&quot;)。</li>\r</ul>\r\r<p>Bean注入</p>\r\r<ul>\r	<li>基于XML配置：&lt;property&gt;或者通过p命名空间；</li>\r	<li>基于注解配置：@Autowired按类型注入，@Qualifier按名称注入。</li>\r</ul>\r\r<p>生命周期和作用范围</p>\r\r<ul>\r	<li>基于XML配置：init-method、destroy-method和scope属性；</li>\r	<li>基于注解配置：@PostConstruct初始化、@PreDestroy销毁和@Scope作用范围。</li>\r</ul>\r\r<p>适合场景</p>\r\r<ul>\r	<li>基于XML配置：Bean来自第三方；</li>\r	<li>基于注解配置：Bean的实现类自己开发。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 36);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1417, 'Spring中的AOP简介', '1417', 1552265849, 1552265849, '<p>本文记录Java学习过程中遇到的AOP简介～</p>\r<!--more-->\r\r<p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>\r\r<p>它是为了解决OOP过程中遇到的一些问题，是OOP的延续和扩展。</p>\r\r<p>AOP可以在不修改源码的情况下，对程序进行增强，比如：权限校验、日志记录、性能监控和事务控制等。</p>\r\r<p>AOP最早由AOP联盟组织提出，Spring将AOP思想引入到框架中，也遵守了AOP联盟的规范。</p>\r\r<p>Spring的AOP的底层用到两种代理机制：</p>\r\r<ul>\r	<li>JDK的动态代理：针对实现了接口的类产生代理；</li>\r	<li>Cglib的动态代理：针对没有实现接口的类产生代理，使用的是底层的字节码增强的技术，生成当前类的子类对象。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 33),
(1418, 'Spring底层AOP的实现原理', '1418', 1552266954, 1552266954, '<p>本文记录Java学习过程中遇到的Spring底层AOP的实现原理～</p>\r<!--more-->\r\r<p><strong>JDK动态代理</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class MyJDKProxy implements InvocationHandler {\r	private UserDao userDao;\r\r	public MyJDKProxy(UserDao userDao) {\r		this.userDao = userDao;\r	}\r\r	//编写工具方法生成代理\r	public UserDao createProxy() {\r		UserDao userDaoProxy = (UserDao) Proxy.newProxyInstance(userDao.getClass().getClassLoader(), userDao.getClass(),getInterfaces(), this);\r		return userDaoProxy;\r	}\r\r	@Override\r	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r		if (&quot;save&quot;.equals(method.getName())) {\r			System.out.println(&quot;权限校验&quot;);\r		}\r		return method.invoke(userDao, args);\r	}\r}</pre>\r\r<p><strong>Cglib动态代理</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class MyCglibProxy implements MethodInterceptor {\r	\r	private CustomerDao customerDao;\r\r	public MyCglibProxy(CustomerDao customerDao) {\r		this.customerDao = customerDao;\r	}\r\r	// 生成代理的方法\r	public CustomerDao createProxy() {\r\r		// 创建Cglib的核心类\r		Enhancer enhancer = new Enhancer();\r		// 设置父类\r		enhancer.setSuperclass(CustomerDao.class);\r		// 设置回掉\r		enhancer.setCallback(this);\r		// 生成代理\r		CustomerDao customerDaoProxy = (CustomerDao) enhancer.create();\r\r		return customerDaoProxy;\r	}\r\r	@Override\r	public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\r		if (&quot;delete&quot;.equals(method.getName())) {\r			Object obj = methodProxy.invokeSuper(proxy, args);\r			System.out.println(&quot;日志记录&quot;);\r			return obj;\r		}\r\r		return methodProxy.invokeSuper(proxy, args);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 69),
(1419, 'Spring的AOP开发中的相关术语', '1419', 1552267618, 1552267618, '<p>本文记录Java学习过程中遇到的Spring的AOP开发中的相关术语～</p>\r<!--more-->\r\r<p>Spring的AOP开发中常用的术语如下：</p>\r\r<ul>\r	<li>JoinPoint（连接点）：指那些被拦截到的点，在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点；</li>\r	<li>PointCut（切入点）：指要对哪些JoinPoint进行拦截的定义；</li>\r	<li>Advice（通知/增强）：指拦截到JoinPoint之后所要做的事情。分为：前置通知，后置通知，异常通知、最终通知和环绕通知（切面要完成的功能）；</li>\r	<li>Introduction（引介）：是一种特殊的通知，在不修改类代码的前提下，Introduction可以在运行期为类动态的添加一些方法或Field；</li>\r	<li>Target（目标对象）：代理的目标对象；</li>\r	<li>Weaving（织入）：把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入；</li>\r	<li>Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类；</li>\r	<li>Aspect（切面）：是切入点和通知（引介）的结合。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 36),
(1420, 'Spring中AOP的使用（XML）', '1420', 1552268987, 1552268987, '<p>本文记录Java学习过程中遇到的Spring中AOP的使用～</p>\r\r<!--more-->\r\r<p><strong>1.导包</strong></p>\r\r<p>spring传统的AOP的开发包</p>\r\r<ul>\r	<li>spring-aop-xxx.jar</li>\r	<li>com.springsource.org.aopalliance-xxx.jar</li>\r</ul>\r\r<p>AspectJ的开发包</p>\r\r<ul>\r	<li>com.springsource.org.aspectj.weaver-xxx.jar</li>\r	<li>spring-aspects-xxx.jar</li>\r</ul>\r\r<p><strong>2.XML配置文件引入AOP约束</strong></p>\r\r<pre class="brush:xml;">\r&lt;beans \r	xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; \r    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\r	http://www.springframework.org/schema/beans/spring-beans.xsd\r    http://www.springframework.org/schema/aop\r	http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\r&lt;/beans&gt;</pre>\r\r<p>3.编写目标类</p>\r\r<pre class="brush:java;">\r// 接口\rpublic interface OrderDao {\r	public void save();\r	public void update();\r	public void delete();\r	public void find();\r}\r\r// 实现类\rpublic class OrderDaoImpl implements OrderDao {\r\r	@Override\r	public void save() {\r		System.out.println(&quot;save&quot;);\r	}\r\r	@Override\r	public void update() {\r		System.out.println(&quot;update&quot;);\r	}\r\r	@Override\r	public void delete() {\r		System.out.println(&quot;delete&quot;);\r	}\r\r	@Override\r	public void find() {\r		System.out.println(&quot;find&quot;);\r	}\r}</pre>\r\r<p><strong>4.目标类的配置</strong></p>\r\r<pre class="brush:xml;">\r&lt;!-- 目标类的配置 --&gt;\r&lt;bean id=&quot;orderDao&quot; class=&quot;ren.oliver.spring.OrderDaoImpl&quot; /&gt;</pre>\r\r<p><strong>5.编写切面类</strong></p>\r\r<pre class="brush:java;">\rpublic class MyAspectXml {\r	// 前置增强\r	public void before() {\r		System.out.println(&quot;before&quot;);\r	}\r}</pre>\r\r<p><strong>6.配置完成增强</strong></p>\r\r<pre class="brush:xml;">\r&lt;!-- 配置切面类 --&gt;\r&lt;bean id=&quot;myAspectXml&quot; class=&quot;ren.oliver.spring.MyAspectXml&quot; /&gt;\r\r&lt;!-- 进行AOP配置 --&gt;\r&lt;aop:config&gt;\r	&lt;!-- 配置切入点表达式：哪些类的哪些方法需要进行增强 --&gt;\r	&lt;aop:pointcut expression=&quot;execution(*ren.oliver.spring.OrderDao.*(..))&quot; id=&quot;pointcut&quot; /&gt;\r	&lt;!-- 配置切面 --&gt;\r	&lt;aop:aspect ref=&quot;myAspectXml&quot;&gt;\r		&lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut&quot; /&gt;\r		&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointcut&quot; /&gt;\r		&lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pointcut&quot; /&gt;\r		&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointcut&quot; /&gt;\r		&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut&quot; /&gt;\r	&lt;/aop:aspect&gt;\r&lt;/aop:config&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1421, 'Spring中AOP的通知类型', '1421', 1552281318, 1552281318, '<p>本文记录Java学习过程中遇到的Spring中AOP的通知类型～</p>\r<!--more-->\r\r<p>Spring的AOP中的通知类型有如下几种：</p>\r\r<ul>\r	<li>前置通知：在目标方法执行之前执行；</li>\r	<li>后置通知：在目标方法执行之后执行；</li>\r	<li>环绕通知：在目标方法执行前和执行后执行；</li>\r	<li>异常抛出通知：在目标方法执行出现异常的时候执行；</li>\r	<li>最终通知：无论目标方法是否出现异常，最终通知都会执行。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 40),
(1422, 'Spring中AOP的切入点表达式', '1422', 1552281411, 1552281411, '<p>本文记录Java学习过程中遇到的Spring中AOP的切入点表达式～</p>\r<!--more-->\r\r<p>使用语法格式：</p>\r\r<pre class="brush:java;">\rexecuting(表达式)</pre>\r\r<p>表达式语法格式：</p>\r\r<pre class="brush:java;">\r[方法访问修饰符] 方法返回值 包名.类名.方法名(方法的参数)</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic * ren.oliver.spring.dao.*.*(..)\r* ren.oliver.spring.dao.*.*(..)\r* ren.oliver.spring.dao.UserDao+.*(..)\r* ren.oliver.spring.dao..*.*(..)</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1423, 'Spring中AOP的使用（注解）', '1423', 1552312200, 1552314316, '<p>本文记录Java学习过程中遇到的Spring中AOP的使用～</p>\r<!--more-->\r\r<p><strong>1.引入相关的Jar包</strong></p>\r\r<p>spring传统的AOP的开发包</p>\r\r<ul>\r	<li>spring-aop-xxx.jar</li>\r	<li>com.springsource.org.aopalliance-xxx.jar</li>\r</ul>\r\r<p>AspectJ的开发包</p>\r\r<ul>\r	<li>com.springsource.org.aspectj.weaver-xxx.jar</li>\r	<li>spring-aspects-xxx.jar</li>\r</ul>\r\r<p><strong>2.引入Spring的AOP约束</strong></p>\r\r<pre class="brush:xml;">\r&lt;beans \r	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; \r	xmlns=&quot;http://www.springframework.org/schema/beans&quot; \r	xmlns:context=&quot;http://www.springframework.org/schema/context&quot; \r	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; \r	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &quot;\r&gt;</pre>\r\r<p>3.编写目标类</p>\r\r<pre class="brush:java;">\rpublic class ProductDao {\r\r	public void save() {\r		System.out.println(&quot;save&quot;);\r	}\r\r	public void update() {\r		System.out.println(&quot;update&quot;);\r	}\r\r	public void delete() {\r		System.out.println(&quot;delete&quot;);\r	}\r\r	public void find() {\r		System.out.println(&quot;find&quot;);\r	}\r}</pre>\r\r<p>4.配置目标类</p>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;productDao&quot; class=&quot;ren.oliver.spring.ProductDao&quot; /&gt;</pre>\r\r<p>5.开启AOP注解的自动代理</p>\r\r<pre class="brush:xml;">\r&lt;aop:aspectj-autoproxy /&gt;</pre>\r\r<p>6.编写切面类</p>\r\r<pre class="brush:xml;">\r@Aspect\rpublic class MyAspectAnno {\r\r	@Before(&quot;MyAspectAnno.pointcut1()&quot;)\r	public void before() {\r		System.out.println(&quot;before&quot;);\r	}\r\r	@AfterReturning(&quot;MyAspectAnno.pointcut2()&quot;)\r	public void afterReturning() {\r		System.out.println(&quot;afterReturning&quot;);\r	}\r\r	@Around(&quot;MyAspectAnno.pointcut3()&quot;)\r	public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\r		System.out.println(&quot;beforeAround&quot;);\r		Object obj = joinPoint.proceed();\r		System.out.println(&quot;afterAround&quot;);\r		return obj;\r	}\r\r	@AfterThrowing(&quot;MyAspectAnno.pointcut4()&quot;)\r	public void afterThrowing() {\r		System.out.println(&quot;afterThrowing&quot;);\r	}\r\r	@After(&quot;MyAspectAnno.pointcut5()&quot;)\r	public void after() {\r		System.out.println(&quot;after&quot;);\r	}\r\r	@Pointcut(&quot;execution(* ren.oliver.spring.ProductDao.save(..))&quot;)\r	public void pointcut1() {\r\r	}\r\r	@Pointcut(&quot;execution(* ren.oliver.spring.ProductDao.save(..))&quot;)\r	public void pointcut2() {\r\r	}\r\r	@Pointcut(&quot;execution(* ren.oliver.spring.ProductDao.save(..))&quot;)\r	public void pointcut3() {\r\r	}\r\r	@Pointcut(&quot;execution(* ren.oliver.spring.ProductDao.save(..))&quot;)\r	public void pointcut4() {\r\r	}\r\r	@Pointcut(&quot;execution(* ren.oliver.spring.ProductDao.save(..))&quot;)\r	public void pointcut5() {\r\r	}\r}</pre>\r\r<p>7.配置切面</p>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;myAspectAnno&quot; class=&quot;ren.oliver.spring.MyAspectAnno&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 60),
(1425, 'Spring常见持久层技术的模板类', '1425', 1552314675, 1552314675, '<p>本文记录Java学习过程中遇到的Spring常见持久层技术的模板类～</p>\r\r<!--more-->\r\r<p>Spring常见持久层技术的模板类有：</p>\r\r<ul>\r	<li>JDBC：org.springframework.jdbc.core.JdbcTemplate；</li>\r	<li>Hibernate3.0：org.springframework.orm.hibernate3.HibernateTemplate；</li>\r	<li>IBatis(MyBatis)：org.springframework.orm.ibatis.SqlMapClientTemplate；</li>\r	<li>JPA：org.springframework.orm.jpa.JpaTemplate。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 46),
(1426, 'Spring中JdbcTemplate的常用操作', '1426', 1552317178, 1552317178, '<p>本文记录Java学习过程中遇到的Spring中JdbcTemplate的常用操作～</p>\r\r<!--more-->\r\r<p>插入操作</p>\r\r<pre class="brush:java;">\rjdbcTemplate.update(&quot;insert into account values (null, ?, ?)&quot;, &quot;oliver&quot;, 18);</pre>\r\r<p>修改操作</p>\r\r<pre class="brush:java;">\rjdbcTemplate.update(&quot;update account set name=?,age=? where id = ?&quot;, &quot;oliver&quot;, 18, 1);</pre>\r\r<p>删除操作</p>\r\r<pre class="brush:java;">\rjdbcTemplate.update(&quot;delete from account where id = ?&quot;, 1);</pre>\r\r<p>示例代码（RowMapper）：</p>\r\r<pre class="brush:java;">\rclass MyRowMapper implements RowMapper&lt;Account&gt; {\r	@Override\r	public Account mapRow(ResultSet rs, int rowNum) throws SQLException {\r		Account account = new Account();\r		account.setId(rs.getInt(id));\r		account.setName(rs.getString(&quot;name&quot;));\r		account.setAge(rs.getInt(&quot;age&quot;));\r		return account;\r	}\r}</pre>\r\r<p>查询单条记录</p>\r\r<pre class="brush:java;">\rAccount account  = jdbcTemplate.queryForObject(&quot;select * from account where id = ?&quot;, new MyRowMapper(), 1);</pre>\r\r<p>查询所有记录</p>\r\r<pre class="brush:java;">\rList&lt;Account&gt; list = jdbcTemplate.query(&quot;select * from account&quot;, new MyRowMapper(););</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1427, 'Spring事务管理的常用API', '1427', 1552318680, 1552347336, '<p>本文记录Java学习过程中遇到的Spring事务管理的常用API</p>\r<!--more-->\r\r<p><strong>PlatformTransactionManager（平台事务管理器）</strong></p>\r\r<ul>\r	<li>SpringJDBC或iBatis：org.springframework.jdbc.datasource.DataSourceTransactionManager；</li>\r	<li>Hibernate：org.springframework.orm.hibernate3.HibernateTransactionManager。</li>\r</ul>\r\r<p><strong>TransactionDefinition（事务定义信息）</strong></p>\r\r<p>事务定义信息包括：</p>\r\r<ul>\r	<li>隔离级别；</li>\r	<li>传播行为；</li>\r	<li>超时信息；</li>\r	<li>是否只读。</li>\r</ul>\r\r<p><strong>TransactionStatus（事务状态）</strong></p>\r\r<p>用于记录事务的状态。</p>\r\r<p>平台事务管理根据事务定义的信息就行事务的管理，事务管理的过程中产生一些状态，将这些状态记录到TransactionStatus中。</p>\r\r<p><strong>事务的传播行为</strong></p>\r\r<p>保证同一个事务中：</p>\r\r<ul>\r	<li>PROPAGAATION_REQUIRED：支持当前事务，如果不存在，就新建一个；</li>\r	<li>PROPAGAATION_SUPPORTS：支持当前事务，如果不存在，就不使用事务；</li>\r	<li>PROPAGAATION_MANDATORY：支持当前事务，如果不存在，就抛出异常。</li>\r</ul>\r\r<p>保证没有在同一个事务中：</p>\r\r<ul>\r	<li>PROPAGAATION_REQUIRES_NEW：如果有事务存在，挂起当前事务，创建一个新的事务；</li>\r	<li>PROPAGAATION_NOT_SUPPORTED：以非事务方式运行，如果有事务存储，挂起当前事务；</li>\r	<li>PROPAGAATION_NEVER：以非事务方式运行，如果有事务存在，抛出异常。</li>\r</ul>\r\r<p>嵌套事务：</p>\r\r<ul>\r	<li>PROPAGAATION_NESTED：如果当前事务存在，则嵌套事务执行。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 43),
(1430, 'SVN模式.png', 'SVN模式-png', 1552519490, 1552519490, 'a:5:{s:4:"name";s:13:"SVN模式.png";s:4:"path";s:35:"/usr/uploads/2019/03/2017377692.png";s:4:"size";i:132071;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1432, 0),
(1431, 'SVN服务器工作方式.png', 'SVN服务器工作方式-png', 1552519660, 1552519660, 'a:5:{s:4:"name";s:28:"SVN服务器工作方式.png";s:4:"path";s:35:"/usr/uploads/2019/03/3603913222.png";s:4:"size";i:124536;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1432, 0),
(1432, 'SVN简介', '1432', 1552519680, 1552519760, '<p>本文记录IT学习过程中遇到的SVN简介～</p>\r\r<!--more-->\r\r<p>SVN（Subversion）是近年来崛起的版本管理工具，在当前的开源项目里(J2EE)，几乎95%以上的项目都用到了SVN。Subversion 项目的初衷是为了替换当年开源社区最为流行的版本控制软件 CVS，在CVS的功能的基础上有很多的提升同时也能较好的解决CVS系统的一些不足。</p>\r\r<p>SVN是基于客户/服务器模式：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/2017377692.png" style="width: 800px; height: 599px;" /></p>\r\r<ul>\r	<li>复制-修改-合并方案(Subversion默认的模式)：在这种模型里，每一个客户读取项目配置库建立一个私有工作副本&mdash;&mdash;版本库中文件和目录的本地映射。用户并行工作，修改各自的工作副本，最终，各个私有的复制合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误；</li>\r	<li>锁定-修改-解锁方案：在这样的模型里，在一个时间段里配置库的一个文件只允许被一个人修改。 此模式不适合软件开发这种工作。</li>\r</ul>\r\r<p>SVN服务器的工作方式：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/3603913222.png" style="width: 800px; height: 759px;" /></p>\r\r<ul>\r	<li>独立服务器方式：svnserve；</li>\r	<li>借助Apache方式：mod_dav_svn。</li>\r</ul>\r\r<p>SVN版本数据存储方式：</p>\r\r<ul>\r	<li>BDB（Berkeley DB）：数据库方式；</li>\r	<li>FSFS：文件方式，推荐使用这种方式。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 53),
(1429, '版本控制', '1429', 1552519260, 1552519317, '<p>本文记录IT学习过程中遇到的版本控制～</p>\r<!--more-->\r\r<p>版本控制(Revision control)是维护工程蓝图的标准做法，能追踪工程蓝图从诞生一直到定案的过程，是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>\r\r<p>通常软件开发由多人协作开发，如果对代码文件、配置文件、文档等没有进行版本控制，将会出现很多问题：</p>\r\r<ul>\r	<li>备份多个版本，占用磁盘空间大；</li>\r	<li>解决代码冲突困难；</li>\r	<li>容易引发BUG；</li>\r	<li>难于追溯问题代码的修改人和修改时间；</li>\r	<li>难于恢复至以前正确版本；</li>\r	<li>无法进行权限控制；</li>\r	<li>项目版本发布困难。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1433, 'SVN工程目录', '1433', 1552519860, 1552520744, '<p>本文记录IT学习过程中遇到的SVN工程目录～</p>\r<!--more-->\r\r<p>SVN中常用的工程目录有三种：</p>\r\r<ul>\r	<li>trunk：项目开发代码的主体，是从项目开始直到当前都处于活动的状态，从这里可以获得项目最新的源代码以及几乎所有的变更历史信息；</li>\r	<li>branch：从trunk的某个点分离出来的代码拷贝，通常可以在不影响主干的前提下在这里进行重大bug的修改，或者做实验性的开发，以及定制功能开发等。如果分支达到了预期的目的，通常可以被合并（Mgerge）到主干中；</li>\r	<li>tag：用来表示trunk和branch的某个点的状态，以代表项目的某个稳定状态，通常为最终发布状态。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 40),
(1434, 'TortoiseSVN常用操作', '1434', 1552520705, 1552520705, '<p>本文记录IT学习过程中遇到的TortoiseSVN常用操作～</p>\r<!--more-->\r\r<p><strong>浏览仓库</strong></p>\r\r<ul>\r	<li>Repo-browser：浏览仓库中资源信息。</li>\r</ul>\r\r<p><strong>导入导出</strong></p>\r\r<ul>\r	<li>Export：导出项目，和checkout区别（checkout检出后文件，含有.svn隐藏文件夹，会和SVN仓库交互，export导出，没有.svn隐藏文件夹）；</li>\r	<li>Import：将本地资源导入到SVN服务器。</li>\r</ul>\r\r<p><strong>修改提交</strong></p>\r\r<ul>\r	<li>Checkout：检出项目，复制项目的副本到本地；在要检出的目录中右键；</li>\r	<li>Add：在检出的目录中添加文件；</li>\r	<li>Add to ignore list：添加到忽略列表（标记该文件不需要版本控制 ）；</li>\r	<li>Add：标记这个文件添加到服务器；已经标记要添加到版本库；</li>\r	<li>Commit：当检出目录或子目录中内容有修改，会有雪花标识；提交Commit提交本地修改至SVN服务器；在检出目录或要提交修改的目录右键。</li>\r	<li>Update：更新仓库的文件到本地，可以更新到最新版本，也可以更新到指定版本；</li>\r	<li>Delete ：删除版本库文件。标记删除后，本地文件删除，标记删除后需要提交；</li>\r	<li>恢复：在检出目录或子目录操作会记录操作日志，提交前可以回滚操作。</li>\r</ul>\r\r<p><strong>冲突处理</strong></p>\r\r<ul>\r	<li>两个客户端同时修改同一个文件，改动同一个位置，发生冲突情况。</li>\r	<li>如果当commit 遇到文件已经过时，说明另一个人可能改动过。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rdb.properties：将本地和服务器合并到一起的文件，建议不要直接看；\rdb.properties.mine：我本地自己修改后的文件；\rdb.properties.r16：我修改之前的文件；\rdb.properties.r17：别人修改后的文件。</pre>\r\r<p>手动Merge后，需要将编辑后冲突文件，标记为已经解决，再进行commit。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 48),
(1435, '类中如何获得范型的类型', '1435', 1552613072, 1552613072, '<p>本文记录Java学习过程中遇到的类中如何获得范型的类型～</p>\r<!--more-->\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//获得当前类型的带有泛型类型的父类\rParameterizedType ptClass = (ParameterizedType) this.getClass().getGenericSuperclass();\r//获得运行期的泛型类型\rclazz = (Class) ptClass.getActualTypeArguments()[0];</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 39),
(1436, 'Maven项目构建过程.png', 'Maven项目构建过程-png', 1552862346, 1552862346, 'a:5:{s:4:"name";s:27:"Maven项目构建过程.png";s:4:"path";s:35:"/usr/uploads/2019/03/1040306628.png";s:4:"size";i:157922;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1437, 0),
(1437, 'Maven简介', '1437', 1552862340, 1552862522, '<p>本文记录Java学习过程中遇到的Maven简介～</p>\r<!--more-->\r\r<p>Maven翻译为&ldquo;转接&rdquo;或者&ldquo;内行&rdquo;，它是Apache下的一个纯Java开发的开源项目，是一个项目管理工具，可以使用Maven对Java<br />\r项目进行构建和依赖管理。如今，使用Maven的项目越来越多。</p>\r\r<p>项目构建是一个项目从编写源代码到编译、测试、运行、打包、部署、上线的过程。</p>\r\r<p><strong>传统项目构建过程</strong></p>\r\r<p>传统的项目构建过程如下：</p>\r\r<ul>\r	<li>在Eclipse中创建一个Java Web工程；</li>\r	<li>在工程中编写源代码及配置文件等；</li>\r	<li>对源代码进行编译，将.java文件编译成.class文件；</li>\r	<li>执行Junit单元测试；</li>\r	<li>将工程打成war包部署到Tomcat中运行。</li>\r</ul>\r\r<p><strong>Maven项目构建过程</strong></p>\r\r<p>Maven将项目构建的过程进行标准化，每个阶段使用一个命令完成，如下图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/1040306628.png" style="width: 800px; height: 121px;" /></p>\r\r<p>上图中部分阶段对应的命令如下：</p>\r\r<ul>\r	<li>清理阶段对应Maven的命令是clean，清理输出的class文件；</li>\r	<li>编译阶段对应Maven的命令是compile，将.java编译成.class；</li>\r	<li>打包阶段对应Maven的命令是package，Java工程可以打成jar包，Web工程可以打成war包。</li>\r</ul>\r\r<p>注意：运行一个Maven的Web工程只需要一个命令：tomcat:run。</p>\r\r<p>使用Maven构建工程的优点：</p>\r\r<ul>\r	<li>一个命令即可完成构建和运行，方便又快捷；</li>\r	<li>Maven对每个构建阶段进行规范，有利于大型团队协作开发。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 34),
(1438, '依赖管理', '1438', 1552863032, 1552863032, '<p>本文记录Java学习过程中遇到的依赖管理～</p>\r<!--more-->\r\r<p>如果一个Java项目要使用一些第三方的Jar包才可以运行，那么就说这个Java项目依赖了这些第三方Jar包，这就是依赖。</p>\r\r<p><strong>传统项目的依赖管理</strong></p>\r\r<p>传统项目工程要管理所依赖的Jar包完全靠人工进行，例如，SSH项目需要将struts2、spring和hibernate的Jar包手工添加到工程的WEB-INF/lib目录下。</p>\r\r<p>手工拷贝Jar包添加到工程的问题：</p>\r\r<ul>\r	<li>没有对Jar包的版本统一管理，容易导致版本冲突；</li>\r	<li>从网上找Jar包非常不方便，有些Jar找不到；</li>\r	<li>Jar包添加到工程中导致工程过大。</li>\r</ul>\r\r<p><strong>Maven项目的依赖管理</strong></p>\r\r<p>Maven项目管理所依赖的Jar包不需要手动向工程添加Jar包，只需要在pom.xml（Maven工程的配置文件）中添加Jar包的坐标，就会自动从Maven仓库中下载Jar包。</p>\r\r<p>使用Maven管理Jar包的优势：</p>\r\r<ul>\r	<li>通过pom.xml文件对Jar包的版本进行统一管理，可以避免版本冲突；</li>\r	<li>Maven团队维护了一个非常全的Maven仓库，里面包括了当前使用的Jar包，Maven工程可以自动从Maven仓库下载Jar包，非常方便。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 33),
(1439, 'Maven仓库.png', 'Maven仓库-png', 1552863856, 1552863856, 'a:5:{s:4:"name";s:15:"Maven仓库.png";s:4:"path";s:34:"/usr/uploads/2019/03/333907150.png";s:4:"size";i:351233;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1440, 0),
(1440, 'Maven仓库', '1440', 1552863874, 1552863874, '<p>本文记录Java学习过程中遇到的Maven仓库～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/333907150.png" style="width: 800px; height: 285px;" />​</p>\r\r<p>Maven的工作需要从仓库下载一些Jar包，本地的项目A和项目B等都会通过Maven软件从远程仓库下载Jar包并存到本地仓库，本地仓库就是本地文件夹，当第二次需要此Jar包时在不再从远程仓库下载，可以将本地仓库理解为缓存，因为本地仓库已经存在了，有了本地仓库就不用每次从远程仓库下载了。</p>\r\r<p>Maven仓库的类型：</p>\r\r<ul>\r	<li>本地仓库：用来存储从远程仓库或中央仓库下载的插件和Jar包，项目使用一些插件或Jar包，优先从本地仓库查找。默认本地仓库的位置在：～/.m2/repository，～表示用户的根目录；</li>\r	<li>远程仓库：如果本地需要插件或者Jar包，本地仓库没有，默认去远程仓库下载，远程仓库可以在互联网内也可以在局域网内；</li>\r	<li>中央仓库：在Maven软件中内置了一个远程仓库地址：http://repo1.maven.org/maven2，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的Jar包，包含了世界上大部分流行的开源项目构件。</li>\r</ul>\r\r<p>配置本地仓库：</p>\r\r<p>在MAVEN_HOME/conf/settings.xml文件中配置本地仓库的位置：</p>\r\r<pre class="brush:xml;">\r&lt;localRepository&gt;path&lt;/localRepository&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 39),
(1441, 'Maven常用命令', '1441', 1552864200, 1554218464, '<p>本文记录Java学习过程中遇到的Maven常用命令～</p>\r<!--more-->\r\r<p>Maven的常用命令如下：</p>\r\r<ul>\r	<li>compile：Maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下；</li>\r	<li>test：Maven工程的测试命令，会执行src/test/java下的所有单元测试类；</li>\r	<li>clean：Maven工程的清理命令，会删除target目录；</li>\r	<li>package：Maven工程的打包命令，Java工程执行package会打成jar包，Web工程执行package会打成war包；</li>\r	<li>install：Maven工程的安装命令，将Maven打成的jar包或war包发布到本地仓库；</li>\r	<li>deploy：Maven工程的部署命令，将Maven打成的jar包或war包发布到远程仓库。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 44),
(1442, 'Maven生命周期与阶段', '1442', 1552865793, 1552865793, '<p>本文记录Java学习过程中遇到的Maven生命周期与阶段～</p>\r<!--more-->\r\r<p><strong>三套生命周期</strong></p>\r\r<p>Maven对项目构建过程分为三套相互独立的生命周期，分别是：</p>\r\r<ul>\r	<li>Clean Lifecycle：在进行真正的构建之前进行的一些清理工作；</li>\r	<li>Default Lifecycle：构建的核心部分，编译、测试、打包、安装和部署等；</li>\r	<li>Site Lifecycle：生成项目报告，站点和发布站点。</li>\r</ul>\r\r<p><strong>生命周期的阶段</strong></p>\r\r<p>每个生命周期都有很多阶段，每个阶段对应一个执行命令。</p>\r\r<p>1.clean生命周期的阶段</p>\r\r<ul>\r	<li>pre-clean：执行一些需要在clean之前完成的工作；</li>\r	<li>clean：移除所有上一次构建生成的文件；</li>\r	<li>post-clean：执行一些需要在clean之后立刻完成的工作。</li>\r</ul>\r\r<p>2.default生命周期的阶段</p>\r\r<ul>\r	<li>validate：；</li>\r	<li>generate-sources：；</li>\r	<li>process-sources：；</li>\r	<li>generate-resources：；</li>\r	<li>process-resources：复制并处理资源文件到目标目录，准备打包；</li>\r	<li>compile：编译项目的源代码；</li>\r	<li>process-class：；</li>\r	<li>generate-test-sources：；</li>\r	<li>process-test-sources：；</li>\r	<li>generate-test-resources：；</li>\r	<li>process-test-resources：复制并处理资源文件到目标测试目录；</li>\r	<li>test-compile：编译测试源代码；</li>\r	<li>process-test-classes：；</li>\r	<li>test：使用合适的单元测试框架运行测试，这些测试代码不会被打包或部署；</li>\r	<li>prepare-package：；</li>\r	<li>package：接受编译好的代码，打包成可发布的格式，例如：jar包或war包；</li>\r	<li>pre-integration-test：；</li>\r	<li>integration-test：；</li>\r	<li>post-integration-test：；</li>\r	<li>verify：；</li>\r	<li>install：将包安装到本地仓库，以让其他项目依赖；</li>\r	<li>deploy：将最终的包复制到远程仓库，与其他开发人员共享。</li>\r</ul>\r\r<p>3.site生命周期的阶段</p>\r\r<ul>\r	<li>pre-site：执行一些需要在生成站点文档之前完成的工作；</li>\r	<li>site：生成项目的站点文档；</li>\r	<li>post-site：执行一些需要在生成站点文档之后完成的工作，并且为部署做准备；</li>\r	<li>site-deploy：将生成的站点文档部署到特定的服务器上。</li>\r</ul>\r\r<p><strong>命令与生命周期的阶段</strong></p>\r\r<p>每个Maven命令对应生命周期的某个阶段，例如：mvn clean命令对应clean生命周期的clean阶段，mvn test命令对应default生命周期的test阶段。</p>\r\r<p>执行命令会将该命令在的在生命周期当中之前的阶段自动执行，比如：执行mvn clean命令会自动执行pre-clean和clean两个阶段，mvn test命令会自动执行validate、compile、test等阶段。</p>\r\r<p>注意：执行某个生命周期的某个阶段不回影响其他的生命周期。</p>\r\r<p>如果要同时执行多个生命周期，可以在命令行输入多个命令，中间以空格隔开，例如：clean package命令执行clean阶段和default生命周期的package阶段。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 29),
(1443, 'Maven概念模型.png', 'Maven概念模型-png', 1552866605, 1552866605, 'a:5:{s:4:"name";s:21:"Maven概念模型.png";s:4:"path";s:35:"/usr/uploads/2019/03/4050995009.png";s:4:"size";i:638233;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1445, 0),
(1444, 'Maven项目构建过程.png', 'Maven项目构建过程-png-1', 1552866637, 1552866637, 'a:5:{s:4:"name";s:27:"Maven项目构建过程.png";s:4:"path";s:35:"/usr/uploads/2019/03/1183817883.png";s:4:"size";i:157922;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1445, 0),
(1445, 'Maven概念模型', '1445', 1552866681, 1552866681, '<p>本文记录Java学习过程中遇到的Maven的概念模型～</p>\r<!--more-->\r\r<p>Maven包含了一个项目对象模型（Project Object Model），一组标准集合，一个项目生命周期（Project Lifecycle），一个依赖管理系统（Dependency Management System）和用来运行定义在生命周期阶段（phase）中插件（plugin）目标（goal）的逻辑。</p>\r\r<p>Maven的概念模型图如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/4050995009.png" style="width: 800px; height: 374px;" /></p>\r\r<p><strong>项目对象模型（Project Object Model）</strong></p>\r\r<p>每个Maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息和插件目标等。</p>\r\r<p><strong>依赖管理系统（Dependency Management System）</strong></p>\r\r<p>通过Maven的依赖管理对项目所依赖的Jar包进行统一管理。比如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即可使用junit4.9。</p>\r\r<p><strong>项目生命周期（Project Lifecycle）</strong></p>\r\r<p>使用maven完成项目的构建，项目构建包括：清理、编译、测试和部署等过程，maven将这些过程规范为一个生命周期，如下是生命周期的各个阶段：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/1183817883.png" style="width: 800px; height: 121px;" />​</p>\r\r<p>Maven通过执行一些简单命令即可实现上边生命周期的各个过程，比如执行mvn compile执行编译、执行mvn clean执行清理。</p>\r\r<p><strong>一组标准集合</strong></p>\r\r<p>Maven将整个项目管理过程定义一组标准，比如：通过Maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。</p>\r\r<p><strong>插件（plugin）目标（goal）</strong></p>\r\r<p>Maven管理项目生命周期过程都是基于插件完成的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 37),
(1446, '总结.png', '总结-png', 1552867420, 1552867420, 'a:5:{s:4:"name";s:10:"总结.png";s:4:"path";s:35:"/usr/uploads/2019/03/1824149495.png";s:4:"size";i:400110;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1447, 0),
(1447, 'Maven依赖范围', '1447', 1552867440, 1552867571, '<p>本文记录Java学习过程中遇到的Maven的依赖范围～</p>\r<!--more-->\r\r<p>A依赖B，需要在A的pom.xml文件中添加B的坐标，添加坐标时需要执行依赖的方范围。</p>\r\r<p>依赖范围的类型有：</p>\r\r<ul>\r	<li>compile：编译范围，指A在编译时依赖B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试和运行，由于运行时需要，所以编译范围的依赖会被打包；</li>\r	<li>provided：provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用，provided依赖在编译和测试时需要。由于运行时不需要，所以provided范围依赖不会被打包；</li>\r	<li>runtime：runtime依赖在运行和测试的时候需要，但在编译的时候不需要。由于运行时需要，所以runtime范围的依赖会被打包；</li>\r	<li>test：test范围依赖在编译和运行时候都不需要，它们只有在测试编译和测试运行阶段可用。由于运行时不需要，所以test范围依赖不会被打包；</li>\r	<li>system：system范围依赖与provided类似，但是必须显式的提供一个对于本地系统中Jar文件的路径，需要指定systemPath磁盘路径，system依赖不推荐使用。</li>\r</ul>\r\r<p>总结如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/1824149495.png" style="width: 800px; height: 386px;" /></p>\r\r<p>依赖范围从强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 34),
(1448, 'Maven坐标定义', '1448', 1552867985, 1552867985, '<p>本文记录Java学习过程中遇到的Maven的坐标定义～</p>\r<!--more-->\r\r<p>在pom.xml中定义坐标，内容包括：groupId、artifactId和version等，详细内容如下：</p>\r\r<ul>\r	<li>&lt;groupId&gt;：项目名称，定义为组织名+项目名，类似包名；</li>\r	<li>&lt;artifactId&gt;：模块名称；</li>\r	<li>&lt;version&gt;：当前项目版本号，snapshot为快照版本（非正式版本），release为正式发布版本；</li>\r	<li>&lt;packaging&gt;：打包类型。</li>\r</ul>\r\r<p>常见的打包类型有：</p>\r\r<ul>\r	<li>jar：执行package会打成jar包；</li>\r	<li>war：执行package会打成war包；</li>\r	<li>pom：用于maven工程的继承，通常父工程设置为pom。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 29),
(1449, 'Maven基本配置', '1449', 1552868329, 1552868329, '<p>本文记录Java学习过程中遇到的Maven的基本配置～</p>\r<!--more-->\r\r<p>pom.xml是Maven项目的核心配置文件，位于每个工程的根目录，基本配置如下：</p>\r\r<ul>\r	<li>&lt;project&gt;：文件的根节点；</li>\r	<li>&lt;modelVersion&gt;：pom.xml使用的对象模型版本；</li>\r	<li>&lt;groupId&gt;：项目名称，一般写项目的域名；</li>\r	<li>&lt;artifactId&gt;：模块名称，子项目名或模块名称；</li>\r	<li>&lt;version&gt;：产品的版本号；</li>\r	<li>&lt;packaging&gt;：打包方式；</li>\r	<li>&lt;name&gt;：项目的显示名，常用于Maven生成的文档；</li>\r	<li>&lt;description&gt;：项目的描述，常用于Maven生成的文档；</li>\r	<li>&lt;dependencies&gt;：项目依赖构件配置，配置项目依赖构件的坐标；</li>\r	<li>&lt;build&gt;：项目构建配置，配置编译和运行插件等。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 37),
(1450, 'Maven依赖传递', '1450', 1552919580, 1552919707, '<p>本文记录Java学习过程中遇到的Maven的依赖传递～</p>\r<!--more-->\r\r<p>添加一个struts2-core的依赖，然后所有关于struts2的依赖都被引进来了。因为依赖struts2-code-2.3.24.jar，而struts2-core-2.3.24.jar会依赖xwork-core-2.3.24.jar等，所以xwork-core-2.3.24.jar这些Jar包被引入了，这种现象称为依赖传递。</p>\r\r<p><strong>依赖调解原则</strong></p>\r\r<ul>\r	<li>第一声明者优先原则：在pom.xml文件定义依赖，先声明的依赖为准；</li>\r	<li>路径近者优先原则：pom.xml文件从上往下，先声明的引入依赖为准。</li>\r</ul>\r\r<p><strong>排除依赖</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;dependency&gt;\r	&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;\r	&lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt;\r	&lt;version&gt;2.3.24&lt;/version&gt;\r	&lt;exclusions&gt;\r		&lt;exclusion&gt;\r			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\r			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\r		&lt;/exclusion&gt;\r	&lt;exclusions&gt;\r&lt;/dependency&gt;</pre>\r\r<p><strong>锁定版本</strong></p>\r\r<p>面对众多的依赖，有一种方法不用考虑依赖路径和声明优化等因素可以采用直接锁定版本的方法确定依赖构件的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本的为准添加到工程中，此方法在企业开发中很常用。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;dependencyManagement&gt;\r	&lt;dependencies&gt;\r		&lt;dependency&gt;\r			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\r			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\r			&lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\r		&lt;/dependency&gt;\r		&lt;dependency&gt;\r			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\r			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;\r			&lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\r		&lt;/dependency&gt;\r	&lt;/dependencies&gt;\r&lt;/dependencyManagement&gt;</pre>\r\r<p>注意：在工程中锁定依赖的版本并不代表在工程中添加了依赖，如果工程需要添加锁定版本的依赖则需要单独添加。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;dependencies&gt;\r	&lt;dependency&gt;\r		&lt;groupId&gt;org.springframework&lt;/groupId&gt;\r		&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\r	&lt;/dependency&gt;\r	&lt;dependency&gt;\r		&lt;groupId&gt;org.springframework&lt;/groupId&gt;\r		&lt;artifactId&gt;spring-context&lt;/artifactId&gt;\r	&lt;/dependency&gt;\r&lt;/dependencies&gt;</pre>\r\r<p>上边添加的依赖并没有指定版本，原因是已在&lt;dependencyManagement&gt;中锁定了版本，所以在&lt;dependency&gt;下不需要再指定版本。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1451, 'Maven继承和聚合', '1451', 1552920067, 1552920067, '<p>本文记录Java学习过程中遇到的Maven的继承和聚合～</p>\r<!--more-->\r\r<p>通常继承和聚合同时使用。</p>\r\r<p><strong>继承</strong></p>\r\r<p>继承是为了消除重复，如果将dao、service和web分开创建独立的工程，则每个工程的pom.xml文件中的内容存在重复，比如：设置依赖版本、锁定spring的版本等，可以将这些重复的配置提取出来在父工程的pom.xml中定义。</p>\r\r<p><strong>聚合</strong></p>\r\r<p>项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如：dao、service和web三个工程最终会打一个独立的war包运行。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 40),
(1452, '依赖传递.png', '依赖传递-png', 1552920525, 1552920525, 'a:5:{s:4:"name";s:16:"依赖传递.png";s:4:"path";s:34:"/usr/uploads/2019/03/919424241.png";s:4:"size";i:242296;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1453, 0),
(1453, 'Maven依赖范围对传递依赖的影响', '1453', 1552920546, 1552920546, '<p>本文记录Java学习过程中遇到的Maven的依赖范围对传递依赖的影响～</p>\r<!--more-->\r\r<p>因为依赖会有依赖范围，依赖范围对传递依赖也有影响，例如有ABC三个模块，A依赖B，B依赖C，C是A的传递依赖。</p>\r\r<p>依赖的传递总结如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/919424241.png" style="width: 800px; height: 223px;" /></p>\r\r<p>最左边一列为直接依赖，理解为A依赖B的范围，最顶层为依赖传递，理解为B依赖C的范围，行与列的交叉即为A传递依赖C的范围。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 31);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1454, 'Maven私服nexus', '1454', 1552923238, 1552923238, '<p>本文记录Java学习过程中遇到的Maven私服nexus～</p>\r<!--more-->\r\r<p>Nexus是Maven仓库管理器，通过nexus可以搭建maven仓库，同时nexus还提供强大的仓库管理功能，构建搜索功能等。</p>\r\r<p>常用命令：</p>\r\r<pre class="brush:xml;">\r//nexus安装\rnexus.bat install\r//nexus卸载\rnexus.bat uninstall\r//nexus启动\rnexus.bat start</pre>\r\r<p>常用配置：</p>\r\r<pre class="brush:bash;">\r# Jetty Section\r# nexus的访问端口配置\rapplication-port=8081\r# nexus的主机监听配置（不用修改）\rapplication-host=0.0.0.0\r# nexus工程目录\rnexus-webapp=${bundleBasedir}/nexus\r# nexus的Web访问路径\rnexus-webapp-context-path=/nexus\r# nexus仓库目录\rnexus-work=${bundleBasedir}/../sonatype-work/nexus\r# nexus运行程序目录\rruntime=${bundleBasedir}/nexus/WEB-INF</pre>\r\r<p>nexus仓库的类型：</p>\r\r<ul>\r	<li>hosted：宿主仓库，部署自己的jar到这个类型的仓库，包括releases和snapshot两部分，releases为公司内部发布版本仓库，snapshots为公司内部测试版本仓库；</li>\r	<li>proxy：代理仓库，用于代理远程的公共仓库，如：maven中央仓库，用户连接私服，私服自动去中央仓库下载jar包或者插件；</li>\r	<li>group：仓库组，用来合并多个hosted/proxy仓库，通常会配置自己的maven连接仓库组；</li>\r	<li>virtual：虚拟的，用于兼容maven1.0版本的jar包或者插件。</li>\r</ul>\r\r<p>nexus仓库默认存放在sonatype-work目录，常用的目录如下：</p>\r\r<ul>\r	<li>central：代理仓库，代理中央仓库；</li>\r	<li>apache-snapshots：代理仓库，存储snapshots构件，代理地址为https://repository.apache.org/snapshots/；</li>\r	<li>central-m1：virtual类型仓库，兼容maven1.0版本的jar包或者插件；</li>\r	<li>releases：本地仓库，存储releases构件；</li>\r	<li>snapshots：本地仓库，存储snapshots构件；</li>\r	<li>thirdparty：第三方仓库；</li>\r	<li>public：仓库组。</li>\r</ul>\r\r<p><strong>将项目发布到maven私服</strong></p>\r\r<p>示例配置（认证相关）：</p>\r\r<pre class="brush:xml;">\r&lt;server&gt;\r	&lt;id&gt;releases&lt;/id&gt;\r	&lt;username&gt;admin&lt;/username&gt;\r	&lt;password&gt;admin123&lt;/password&gt;\r&lt;/server&gt;\r&lt;server&gt;\r	&lt;id&gt;snapshots&lt;/id&gt;\r	&lt;username&gt;admin&lt;/username&gt;\r	&lt;password&gt;admin123&lt;/password&gt;\r&lt;/server&gt;</pre>\r\r<p>示例配置（pom.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;distributionManagement&gt;\r	&lt;repository&gt;\r		&lt;id&gt;releases&lt;/id&gt;\r		&lt;url&gt;http://localhost:8081/nexus/context/repositories/releases/&lt;/url&gt;\r	&lt;/repository&gt;\r	&lt;snapshotRepository&gt;\r		&lt;id&gt;snapshots&lt;/id&gt;\r		&lt;url&gt;http://localhost:8081/nexus/context/repositories/snapshots/&lt;/url&gt;\r	&lt;/snapshotRepository&gt;\r&lt;/distributionManagement&gt;</pre>\r\r<p>注意：pom.xml中的id需要与setting.xml中配置的id对应。</p>\r\r<p><strong>管理仓库组</strong></p>\r\r<p>nexus中包括很多仓库，hosted中存放的是企业自己发布的jar包及第三方公司的jar包，proxy中存放的是中央仓库的jar，为了方便从私服下载jar包，可以将多个仓库组成一个仓库组，每个工程需要连接私服的仓库组下载jar包。</p>\r\r<p>配置仓库</p>\r\r<p>示例代码（setting.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;profile&gt;\r	&lt;id&gt;dev&lt;/id&gt;\r	&lt;repositories&gt;\r		&lt;repository&gt;\r			&lt;id&gt;nexus&lt;/id&gt;\r			&lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;\r			&lt;releases&gt;\r				&lt;enabled&gt;true&lt;/enable&gt;\r			&lt;/releases&gt;\r			&lt;snapshots&gt;\r				&lt;enabled&gt;true&lt;/enable&gt;\r			&lt;/snapshots&gt;\r		&lt;/repository&gt;\r	&lt;/repositories&gt;\r	&lt;pluginRepositories&gt;\r		&lt;pluginRepository&gt;\r			&lt;id&gt;public&lt;id&gt;\r			&lt;name&gt;public repositories&lt;/name&gt;\r			&lt;url&gt;http://localhost:8081/nexus/context/groups/public/&lt;/url&gt;\r		&lt;/pluginRepository&gt;\r	&lt;pluginRepositories&gt;\r&lt;/profile&gt;</pre>\r\r<p>使用profile定义仓库需要激活才可生效。</p>\r\r<pre class="brush:xml;">\r&lt;activeProfiles&gt;\r	&lt;activeProfile&gt;dev&lt;/activeProfile&gt;\r&lt;/activeProfiles&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 52),
(1455, 'MyBatis简介', '1455', 1553126760, 1554251155, '<p>本文记录Java学习过程中遇到的MyBatis简介～</p>\r<!--more-->\r\r<p>MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation迁移到了google code，并且改名为MyBatis ，2013年11月迁移到Github。</p>\r\r<p>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注SQL本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等JDBC繁杂的过程代码。</p>\r\r<p>Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 53),
(1456, 'JDBC存在的问题', '1456', 1553126940, 1554250751, '<p>本文记录Java学习过程中遇到的JDBC存在的问题～</p>\r<!--more-->\r\r<p>JDBC存在的问题如下：</p>\r\r<ul>\r	<li>数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能，使用数据库连接池可解决此问题；</li>\r	<li>SQL语句在代码中硬编码，造成代码不易维护，实际应用中SQL变化的可能较大，SQL变动需要改变Java代码；</li>\r	<li>使用preparedStatement向占有位符号传参数存在硬编码，因为SQL语句的where条件不一定，可能多也可能少，修改SQL还要修改代码，系统不易维护；</li>\r	<li>对结果集解析存在硬编码（查询列名），SQL变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成POJO对象解析比较方便。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 48),
(1457, 'mybatis.png', 'mybatis-png', 1553127222, 1553127222, 'a:5:{s:4:"name";s:11:"mybatis.png";s:4:"path";s:35:"/usr/uploads/2019/03/3823928707.png";s:4:"size";i:98467;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1458, 0),
(1458, 'MyBatis架构', '1458', 1553127240, 1554251141, '<p>本文记录Java学习过程中遇到的MyBatis架构～</p>\r<!--more-->\r\r<p>MyBatis的架构图如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/3823928707.png" style="width: 800px; height: 681px;" /></p>\r\r<p>1.MyBatis配置</p>\r\r<p>SqlMapConfig.xml，此文件作为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息；mapper.xml文件即sql映射文件，文件中配置了操作数据库的SQL语句。此文件需要在SqlMapConfig.xml中加载。</p>\r\r<p>2.通过MyBatis环境等配置信息构造SqlSessionFactory即会话工厂；</p>\r\r<p>3.由会话工厂创建SqlSession即会话，操作数据库需要通过SqlSession进行；</p>\r\r<p>4.MyBatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器；</p>\r\r<p>5.Mapped Statement也是MyBatis一个底层封装对象，它包装了MyBatis配置信息及sql映射信息等。mapper.xml文件中一个SQL对应一个Mapped Statement对象，SQL的id即是Mapped Statement的id；</p>\r\r<p>6.Mapped Statement对SQL执行输入参数进行定义，包括HashMap、基本类型、POJO，Executor通过Mapped Statement在执行SQL前将输入的Java对象映射至SQL中，输入参数映射就是JDBC编程中对preparedStatement设置参数；</p>\r\r<p>7.Mapped Statement对SQL执行输出结果进行定义，包括HashMap、基本类型、POJO，Executor通过Mapped Statement在执行SQL后将输出结果映射至Java对象中，输出结果映射过程相当于JDBC编程中对结果的解析处理过程。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 48),
(1459, 'MyBatis中#{}和${}的区别', '1459', 1553127600, 1554251104, '<p>本文记录Java学习过程中遇到的MyBatis中#{}和${}的区别～</p>\r<!--more-->\r\r<p>两者的区别如下：</p>\r\r<ul>\r	<li>#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行Java类型和JDBC类型转换，#{}可以有效防止SQL注入。#{}可以接收简单类型值或POJO属性值。如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称；</li>\r	<li>${}表示拼接SQL串，通过${}可以将parameterType传入的内容拼接在SQL中且不进行JDBC类型转换，${}可以接收简单类型值或POJO属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 53),
(1460, 'MyBatis中的parameterType和resultType', '1460', 1553127720, 1554251237, '<p>本文记录Java学习过程中遇到的MyBatis中的parameterType和resultType～</p>\r<!--more-->\r\r<p>两者的介绍如下：</p>\r\r<ul>\r	<li>parameterType：指定输入参数类型，MyBatis通过OGNL从输入对象中获取参数值拼接在SQL中；</li>\r	<li>resultType：指定输出结果类型，MyBatis将SQL查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 55),
(1461, 'MyBatis中的selectOne和selectList', '1461', 1553127960, 1554251286, '<p>本文记录Java学习过程中遇到的MyBatis中的selectOne和selectList～</p>\r<!--more-->\r\r<p>两者的介绍分别如下：</p>\r\r<ul>\r	<li>selectOne查询一条记录，如果使用selectOne查询多条记录则抛出如下异常：</li>\r</ul>\r\r<pre class="brush:java;">\rorg.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3\ron.selectOne(DefaultSqlSession.java:70)</pre>\r\r<ul>\r	<li>selectList可以查询一条或多条记录。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 47),
(1462, 'MyBatis自增主键返回', '1462', 1553128200, 1554251341, '<p>本文记录Java学习过程中遇到的MyBatis自增主键返回～</p>\r<!--more-->\r\r<p>查询id的SQL：</p>\r\r<pre class="brush:sql;">\rSELECT LAST_INSERT_ID()</pre>\r\r<p>通过修改User.xml映射文件，可以将MySQL自增主键返回（selectKey标签）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 保存用户 --&gt;\r&lt;insert id=&quot;saveUser&quot; parameterType=&quot;cn.itcast.mybatis.pojo.User&quot;&gt;\r	&lt;!-- selectKey 标签实现主键返回 --&gt;\r	&lt;!-- keyColumn:主键对应的表中的哪一列 --&gt;\r	&lt;!-- keyProperty：主键对应的pojo中的哪一个属性 --&gt;\r	&lt;!-- order：设置在执行insert语句前执行查询id的sql，孩纸在执行insert语句之后执行查询id的sql --&gt;\r	&lt;!-- resultType：设置返回的id的类型 --&gt;\r	&lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;\r		resultType=&quot;int&quot;&gt;\r		SELECT LAST_INSERT_ID()\r	&lt;/selectKey&gt;\r	INSERT INTO `user`\r	(username,birthday,sex,address) VALUES\r	(#{username},#{birthday},#{sex},#{address})\r&lt;/insert&gt;</pre>\r\r<p>LAST_INSERT_ID():是MySQL的函数，返回auto_increment自增列新记录id值。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 51),
(1463, 'MyBatis使用UUID实现主键', '1463', 1553128440, 1554251390, '<p>本文记录Java学习过程中遇到的MyBatis使用UUID实现主键～</p>\r<!--more-->\r\r<p>查询UUID的SQL：</p>\r\r<pre class="brush:sql;">\rselect uuid()</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 保存用户 --&gt;\r&lt;insert id=&quot;saveUser&quot; parameterType=&quot;cn.itcast.mybatis.pojo.User&quot;&gt;\r	&lt;!-- selectKey 标签实现主键返回 --&gt;\r	&lt;!-- keyColumn:主键对应的表中的哪一列 --&gt;\r	&lt;!-- keyProperty：主键对应的pojo中的哪一个属性 --&gt;\r	&lt;!-- order：设置在执行insert语句前执行查询id的sql，孩纸在执行insert语句之后执行查询id的sql --&gt;\r	&lt;!-- resultType：设置返回的id的类型 --&gt;\r	&lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;BEFORE&quot;\r		resultType=&quot;string&quot;&gt;\r		SELECT UUID()\r	&lt;/selectKey&gt;\r	INSERT INTO `user`\r	(username,birthday,sex,address) VALUES\r	(#{username},#{birthday},#{sex},#{address})\r&lt;/insert&gt;</pre>\r\r<p>注意：这里使用的order是&ldquo;BEFORE&rdquo;。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 57),
(1464, 'MyBatis如何解决了JDBC编程的问题', '1464', 1553128680, 1554251535, '<p>本文记录Java学习过程中遇到的MyBatis如何解决了JDBC编程的问题～</p>\r<!--more-->\r\r<p>1.数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，使用数据库连接池可解决此问题。</p>\r\r<ul>\r	<li>解决：在SqlMapConfig.xml中配置数据连接池，使用连接池管理数据库链接。</li>\r</ul>\r\r<p>2.SQL语句写在代码中造成代码不易维护，实际应用SQL变化的可能较大，SQL变动需要改变Java代码。</p>\r\r<ul>\r	<li>解决：将SQL语句配置在XXXXmapper.xml文件中与Java代码分离。</li>\r</ul>\r\r<p>3.向SQL语句传参数麻烦，因为SQL语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>\r\r<ul>\r	<li>解决：MyBatis自动将Java对象映射至SQL语句，通过statement中的parameterType定义输入参数的类型。</li>\r</ul>\r\r<p>4.对结果集解析麻烦，SQL变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成POJO对象解析比较方便。</p>\r\r<ul>\r	<li>解决：MyBatis自动将SQL执行结果映射至Java对象，通过statement中的resultType定义输出结果的类型。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 58),
(1465, 'MyBatis与Hibernate的不同', '1465', 1553128860, 1554251646, '<p>本文记录Java学习过程中遇到的MyBatis与Hibernate的不同～</p>\r<!--more-->\r\r<p>MyBatis和Hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写SQL语句。MyBatis可以通过XML或注解方式灵活配置要运行的SQL语句，并将Java对象和SQL语句映射生成最终执行的SQL，最后将SQL执行的结果再映射生成Java对象。</p>\r\r<p>MyBatis学习门槛低，简单易学，程序员直接编写原生态SQL，可严格控制SQL执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的代价是MyBatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套SQL映射文件，工作量大。</p>\r\r<p>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用Hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</p>\r\r<p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 47),
(1466, 'MyBatis常用的API', '1466', 1553129160, 1554251784, '<p>本文记录Java学习过程中遇到的MyBatis常用的API～</p>\r<!--more-->\r\r<p>SqlSession的使用范围：</p>\r\r<ul>\r	<li>SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等；</li>\r	<li>SqlSession通过SqlSessionFactory创建；</li>\r	<li>SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。</li>\r</ul>\r\r<p><strong>SqlSessionFactoryBuilder</strong></p>\r\r<p>SqlSessionFactoryBuilder用于创建SqlSessionFacoty，SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory创建的。所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。</p>\r\r<p><strong>SqlSessionFactory</strong></p>\r\r<p>SqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。</p>\r\r<p><strong>SqlSession</strong></p>\r\r<p>SqlSession是一个面向用户的接口，SqlSession中定义了数据库操作方法。</p>\r\r<p>每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。</p>\r\r<p>打开一个SqlSession，在使用完毕就要关闭它。通常把这个关闭操作放到finally块中以确保每次都能执行关闭。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rSqlSession session = sqlSessionFactory.openSession();\rtry {\r	 // do work\r} finally {\r	session.close();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 61),
(1467, 'MyBatis中的Mapper动态代理开发', '1467', 1553129760, 1554251901, '<p>本文记录Java学习过程中遇到的MyBatis中的Mapper动态代理开发～</p>\r<!--more-->\r\r<p><strong>开发规范</strong></p>\r\r<p>Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p>\r\r<p>Mapper接口开发需要遵循以下规范：</p>\r\r<ul>\r	<li>Mapper.xml文件中的namespace与mapper接口的类路径相同；</li>\r	<li>Mapper接口方法名和Mapper.xml中定义的每个statement的id相同；</li>\r	<li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个SQL的parameterType的类型相同；</li>\r	<li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个SQL的resultType的类型相同。</li>\r</ul>\r\r<p><strong>Mapper.xml(映射文件)</strong></p>\r\r<p>定义mapper映射文件UserMapper.xml</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r&lt;!DOCTYPE mapper\rPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\r&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\r&lt;!-- namespace：命名空间，用于隔离sql --&gt;\r&lt;!-- 还有一个很重要的作用，使用动态代理开发DAO，1. namespace必须和Mapper接口类路径一致 --&gt;\r&lt;mapper namespace=&quot;ren.oliver.mybatis.mapper.UserMapper&quot;&gt;\r	&lt;!-- 根据用户id查询用户 --&gt;\r	&lt;!-- 2. id必须和Mapper接口方法名一致 --&gt;\r	&lt;!-- 3. parameterType必须和接口方法参数类型一致 --&gt;\r	&lt;!-- 4. resultType必须和接口方法返回值类型一致 --&gt;\r	&lt;select id=&quot;queryUserById&quot; parameterType=&quot;int&quot;\r		resultType=&quot;ren.oliver.mybatis.pojo.User&quot;&gt;\r		select * from user where id = #{id}\r	&lt;/select&gt;\r\r	&lt;!-- 根据用户名查询用户 --&gt;\r	&lt;select id=&quot;queryUserByUsername&quot; parameterType=&quot;string&quot;\r		resultType=&quot;ren.oliver.mybatis.pojo.User&quot;&gt;\r		select * from user where username like &#39;%${value}%&#39;\r	&lt;/select&gt;\r\r	&lt;!-- 保存用户 --&gt;\r	&lt;insert id=&quot;saveUser&quot; parameterType=&quot;ren.oliver.mybatis.pojo.User&quot;&gt;\r		&lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; order=&quot;AFTER&quot;\r			resultType=&quot;int&quot;&gt;\r			select last_insert_id()\r		&lt;/selectKey&gt;\r		insert into user(username,birthday,sex,address) values\r		(#{username},#{birthday},#{sex},#{address});\r	&lt;/insert&gt;\r&lt;/mapper&gt;</pre>\r\r<p><strong>UserMapper(接口文件)</strong></p>\r\r<p>创建UserMapper接口代码</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic interface UserMapper {\r	/**\r	 * 根据id查询\r	 * \r	 * @param id\r	 * @return\r	 */\r	User queryUserById(int id);\r\r	/**\r	 * 根据用户名查询用户\r	 * \r	 * @param username\r	 * @return\r	 */\r	List&lt;User&gt; queryUserByUsername(String username);\r\r	/**\r	 * 保存用户\r	 * \r	 * @param user\r	 */\r	void saveUser(User user);\r}</pre>\r\r<p><strong>加载UserMapper.xml文件</strong></p>\r\r<p>修改SqlMapConfig.xml文件，添加以下所示的内容：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 加载映射文件 --&gt;\r&lt;mappers&gt;\r	&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;\r	&lt;mapper resource=&quot;mapper/UserMapper.xml&quot; /&gt;\r&lt;/mappers&gt;</pre>\r\r<p><strong>测试</strong></p>\r\r<p>编写的测试方法如下：</p>\r\r<pre class="brush:java;">\rpublic class UserMapperTest {\r	private SqlSessionFactory sqlSessionFactory;\r\r	@Before\r	public void init() throws Exception {\r		// 创建SqlSessionFactoryBuilder\r		SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\r		// 加载SqlMapConfig.xml配置文件\r		InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);\r		// 创建SqlsessionFactory\r		this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);\r	}\r\r	@Test\r	public void testQueryUserById() {\r		// 获取sqlSession，和spring整合后由spring管理\r		SqlSession sqlSession = this.sqlSessionFactory.openSession();\r\r		// 从sqlSession中获取Mapper接口的代理对象\r		UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r		// 执行查询方法\r		User user = userMapper.queryUserById(1);\r		System.out.println(user);\r\r		// 和spring整合后由spring管理\r		sqlSession.close();\r	}\r\r	@Test\r	public void testQueryUserByUsername() {\r		// 获取sqlSession，和spring整合后由spring管理\r		SqlSession sqlSession = this.sqlSessionFactory.openSession();\r\r		// 从sqlSession中获取Mapper接口的代理对象\r		UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r		// 执行查询方法\r		List&lt;User&gt; list = userMapper.queryUserByUsername(&quot;张&quot;);\r		for (User user : list) {\r			System.out.println(user);\r		}\r\r		// 和spring整合后由spring管理\r		sqlSession.close();\r	}\r\r	@Test\r	public void testSaveUser() {\r		// 获取sqlSession，和spring整合后由spring管理\r		SqlSession sqlSession = this.sqlSessionFactory.openSession();\r\r		// 从sqlSession中获取Mapper接口的代理对象\r		UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r		// 创建保存对象\r		User user = new User();\r		user.setUsername(&quot;刘备&quot;);\r		user.setBirthday(new Date());\r		user.setSex(&quot;1&quot;);\r		user.setAddress(&quot;蜀国&quot;);\r\r		// 执行查询方法\r		userMapper.saveUser(user);\r		System.out.println(user);\r\r		// 和spring整合后由spring管理\r		sqlSession.commit();\r		sqlSession.close();\r	}\r}</pre>\r\r<p><strong>小结</strong></p>\r\r<p>selectOne和selectList</p>\r\r<ul>\r	<li>动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。</li>\r</ul>\r\r<p>namespace</p>\r\r<ul>\r	<li>MyBatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 62),
(1468, 'MyBatis的SqlMapConfig.xml配置文件详解', '1468', 1553130660, 1554252063, '<p>本文记录Java学习过程中遇到的MyBatis的SqlMapConfig.xml配置文件详解～</p>\r<!--more-->\r\r<p><strong>常用配置</strong></p>\r\r<p>SqlMapConfig.xml中配置的内容和顺序如下：</p>\r\r<pre class="brush:bash;">\rproperties（属性）\rsettings（全局配置参数）\rtypeAliases（类型别名）\rtypeHandlers（类型处理器）\robjectFactory（对象工厂）\rplugins（插件）\renvironments（环境集合属性对象）\r	environment（环境子属性对象）\r		transactionManager（事务管理）\r		dataSource（数据源）\rmappers（映射器）</pre>\r\r<p><strong>properties（属性）</strong></p>\r\r<p>SqlMapConfig.xml可以引用Java属性文件中的配置信息。</p>\r\r<p>db.properties配置文件内容如下：</p>\r\r<pre class="brush:java;">\rjdbc.driver=com.mysql.jdbc.Driver\rjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\rjdbc.username=root\rjdbc.password=123456</pre>\r\r<p>SqlMapConfig.xml引用如下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r&lt;!DOCTYPE configuration\rPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\r&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\r&lt;configuration&gt;\r	&lt;!-- 是用resource属性加载外部配置文件 --&gt;\r	&lt;properties resource=&quot;db.properties&quot;&gt;\r		&lt;!-- 在properties内部用property定义属性 --&gt;\r		&lt;!-- 如果外部配置文件有该属性，则内部定义属性被外部属性覆盖 --&gt;\r		&lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot; /&gt;\r		&lt;property name=&quot;jdbc.password&quot; value=&quot;123456&quot; /&gt;\r	&lt;/properties&gt;\r\r	&lt;!-- 和spring整合后 environments配置将废除 --&gt;\r	&lt;environments default=&quot;development&quot;&gt;\r		&lt;environment id=&quot;development&quot;&gt;\r			&lt;!-- 使用jdbc事务管理 --&gt;\r			&lt;transactionManager type=&quot;JDBC&quot; /&gt;\r			&lt;!-- 数据库连接池 --&gt;\r			&lt;dataSource type=&quot;POOLED&quot;&gt;\r				&lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;\r				&lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;\r				&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;\r				&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;\r			&lt;/dataSource&gt;\r		&lt;/environment&gt;\r	&lt;/environments&gt;\r\r	&lt;!-- 加载映射文件 --&gt;\r	&lt;mappers&gt;\r		&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;\r		&lt;mapper resource=&quot;mapper/UserMapper.xml&quot; /&gt;\r	&lt;/mappers&gt;\r&lt;/configuration&gt;</pre>\r\r<p>MyBatis 将按照下面的顺序来加载属性：</p>\r\r<ul>\r	<li>在properties元素体内定义的属性首先被读取；</li>\r	<li>然后会读取properties元素中resource或url加载的属性，它会覆盖已读取的同名属性。&nbsp;</li>\r</ul>\r\r<p><strong>typeAliases（类型别名）</strong></p>\r\r<p>mybatis支持别名：</p>\r\r<ul>\r	<li>_byte：byte；</li>\r	<li>_long：long；</li>\r	<li>_short：short；</li>\r	<li>_int：int；</li>\r	<li>_integer：int；</li>\r	<li>_double：double；</li>\r	<li>_float：float；</li>\r	<li>_boolean：boolean；</li>\r	<li>string：String；</li>\r	<li>byte：Byte；</li>\r	<li>long：Long；</li>\r	<li>short：Short；</li>\r	<li>int：Integer；</li>\r	<li>integer：Integer；</li>\r	<li>double：Double；</li>\r	<li>float：Float；</li>\r	<li>boolean：Boolean；</li>\r	<li>date：Date；</li>\r	<li>decimal：BigDecimal；</li>\r	<li>bigdecimal：BigDecimal；</li>\r	<li>map：Map。</li>\r</ul>\r\r<p>自定义别名：</p>\r\r<pre class="brush:xml;">\r&lt;typeAliases&gt;\r	&lt;!-- 单个别名定义 --&gt;\r	&lt;typeAlias alias=&quot;user&quot; type=&quot;ren.oliver.mybatis.pojo.User&quot; /&gt;\r	&lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（大小写不敏感） --&gt;\r	&lt;package name=&quot;ren.oliver.mybatis.pojo&quot; /&gt;\r	&lt;package name=&quot;其它包&quot; /&gt;\r&lt;/typeAliases&gt;</pre>\r\r<p>在mapper.xml配置文件中，就可以使用设置的别名了，别名大小写不敏感。</p>\r\r<p><strong>mappers（映射器）</strong></p>\r\r<p>Mapper配置的几种方法：</p>\r\r<ul>\r	<li>&lt;mapper resource=&quot; &quot; /&gt;：使用相对于类路径的资源。</li>\r</ul>\r\r<pre class="brush:xml;">\r&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;</pre>\r\r<ul>\r	<li>&lt;mapper class=&quot; &quot; /&gt;：使用mapper接口类路径。</li>\r</ul>\r\r<pre class="brush:xml;">\r&lt;mapper class=&quot;ren.oliver.mybatis.mapper.UserMapper&quot;/&gt;</pre>\r\r<p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p>\r\r<ul>\r	<li>&lt;package name=&quot;&quot;/&gt;：注册指定包下的所有mapper接口。</li>\r</ul>\r\r<pre class="brush:xml;">\r&lt;package name=&quot;ren.oliver.mybatis.mapper&quot;/&gt;</pre>\r\r<p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 55),
(1469, 'MyBatis的输入类型parameterType', '1469', 1553177340, 1554252159, '<p>本文记录Java学习过程中遇到的MyBatis的输入类型parameterType～</p>\r<!--more-->\r\r<p><strong>传递简单类型</strong></p>\r\r<p>使用#{}占位符，或者${}进行sql拼接。</p>\r\r<p><strong>传递POJO对象</strong></p>\r\r<p>MyBatis使用OGNL表达式解析对象字段的值，#{}或者${}括号中的值为POJO属性名称。</p>\r\r<p><strong>传递POJO包装对象</strong></p>\r\r<p>开发中通过可以使用POJO传递查询条件。</p>\r\r<p>查询条件可能是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如查询用户信息的时候，将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。</p>\r\r<p>包装对象：POJO类中的一个属性是另外一个POJO。</p>\r\r<p>示例代码（查询条件类QueryVo）：</p>\r\r<pre class="brush:java;">\rpublic class QueryVo {\r\r	// 包含其他的pojo\r	private User user;\r\r	public User getUser() {\r		return user;\r	}\r\r	public void setUser(User user) {\r		this.user = user;\r	}\r}</pre>\r\r<p>示例代码（SQL语句）：</p>\r\r<pre class="brush:sql;">\rSELECT * FROM user WHERE username LIKE &#39;%张%&#39;</pre>\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 使用包装类型查询用户 --&gt;\r&lt;select id=&quot;queryUserByQueryVo&quot; parameterType=&quot;queryVo&quot; resultType=&quot;user&quot;&gt;\r	SELECT * FROM user WHERE username LIKE &#39;%${user.username}%&#39;\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; queryUserByQueryVo(QueryVo queryVo);</pre>\r\r<p>示例代码（UserMapperTest）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryUserByQueryVo() {\r	// mybatis和spring整合，整合之后，交给spring管理\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 创建Mapper接口的动态代理对象，整合之后，交给spring管理\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	// 使用userMapper执行查询，使用包装对象\r	QueryVo queryVo = new QueryVo();\r	// 设置user条件\r	User user = new User();\r	user.setUsername(&quot;张&quot;);\r	// 设置到包装对象中\r	queryVo.setUser(user);\r\r	// 执行查询\r	List&lt;User&gt; list = userMapper.queryUserByQueryVo(queryVo);\r	for (User u : list) {\r		System.out.println(u);\r	}\r\r	// mybatis和spring整合，整合之后，交给spring管理\r	sqlSession.close();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 59),
(1470, 'MyBatis的输出类型resultType', '1470', 1553178720, 1554252239, '<p>本文记录Java学习过程中遇到的MyBatis的输出类型resultType～</p>\r<!--more-->\r\r<p><strong>输出简单类型</strong></p>\r\r<p>需求:查询用户表数据条数</p>\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 查询用户表数据条数 --&gt;\r&lt;select id=&quot;queryUserCount&quot; resultType=&quot;int&quot;&gt;\r	select count(*) from\r	`user`\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper.java）：</p>\r\r<pre class="brush:java;">\rint queryUserCount();</pre>\r\r<p>示例代码（UserMapperTest）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryUserCount() {\r	// mybatis和spring整合，整合之后，交给spring管理\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 创建Mapper接口的动态代理对象，整合之后，交给spring管理\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	// 使用userMapper执行查询用户数据条数\r	int count = userMapper.queryUserCount();\r	System.out.println(count);\r\r	// mybatis和spring整合，整合之后，交给spring管理\r	sqlSession.close();\r}</pre>\r\r<p>注意：输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。</p>\r\r<p><strong>输出pojo对象</strong></p>\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 通过ID查询一个用户 --&gt;\r&lt;select id=&quot;findUserById&quot; parameterType=&quot;Integer&quot; resultType=&quot;User&quot;&gt;\r	select * from user where id = #{v}\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper.java）：</p>\r\r<pre class="brush:java;">\rpublic User findUserById(Integer id);</pre>\r\r<p>示例代码（UserMapperTest.java）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void findUserByIdTest() throws Exception {\r	// 加载核心配置文件\r	String resource = &quot;sqlMapConfig.xml&quot;;\r	InputStream in = Resources.getResourceAsStream(resource);\r	// 创建SqlSessionFactory\r	SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);\r	// 创建SqlSession\r	SqlSession sqlSession = sqlSessionFactory.openSession();\r\r	// SqlSEssion帮我生成一个实现类 （给接口）\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	User user = userMapper.findUserById(10);\r	System.out.println(user);\r}</pre>\r\r<p><strong>输出POJO列表</strong></p>\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 根据用户名称模糊查询用户列表 --&gt;\r&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;String&quot; resultType=&quot;ren.oliver.mybatis.pojo.User&quot;&gt;\r	select * from user where username like &quot;%&quot;#{haha}&quot;%&quot;\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper.java）：</p>\r\r<pre class="brush:java;">\r// 根据用户名称模糊查询用户列表\rpublic List&lt;User&gt; findUserByUsername(String username);</pre>\r\r<p>示例代码（UserMapperTest.java）：</p>\r\r<pre class="brush:java;">\r// 根据用户名称模糊查询用户列表\r@Test\rpublic void findUserByUsernameTest() throws Exception {\r	// 加载核心配置文件\r	String resource = &quot;sqlMapConfig.xml&quot;;\r	InputStream in = Resources.getResourceAsStream(resource);\r	// 创建SqlSessionFactory\r	SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);\r	// 创建SqlSession\r	SqlSession sqlSession = sqlSessionFactory.openSession();\r\r	// SqlSEssion帮我生成一个实现类 （给接口）\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	List&lt;User&gt; users = userMapper.findUserByUsername(&quot;五&quot;);\r	for (User user : users) {\r		System.out.println(user);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 47),
(1471, 'MyBatis结果映射类resultMap', '1471', 1553179560, 1554252382, '<p>本文记录Java学习过程中遇到的MyBatis结果映射类resultMap～</p>\r<!--more-->\r\r<p>resultType可以指定将查询结果映射为POJO，但需要POJO的属性名和SQL查询的列名一致方可映射成功。</p>\r\r<p>如果SQL查询字段名和POJO的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到POJO对象中。</p>\r\r<p>resultMap可以实现将查询结果映射为复杂类型的POJO，比如在查询结果映射对象中包括POJO和List实现一对一查询和一对多查询。</p>\r\r<p>需求：查询订单表order的所有数据</p>\r\r<p>示例代码（表结构）：</p>\r\r<pre class="brush:sql;">\rCREATE TABLE `orders` (\r  `id` int(11) NOT NULL AUTO_INCREMENT,\r  `user_id` int(11) NOT NULL COMMENT &#39;下单用户id&#39;,\r  `number` varchar(32) NOT NULL COMMENT &#39;订单号&#39;,\r  `createtime` datetime NOT NULL COMMENT &#39;创建订单时间&#39;,\r  `note` varchar(100) DEFAULT NULL COMMENT &#39;备注&#39;,\r  PRIMARY KEY (`id`),\r  KEY `FK_orders_1` (`user_id`),\r  CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\r) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</pre>\r\r<p>示例代码（Order对象）：</p>\r\r<pre class="brush:java;">\r@Data\rpublic class Order {\r\r	// 订单id\r	private int id;\r\r	// 用户id\r	private Integer userId;\r\r	// 订单号\r	private String number;\r\r	// 订单创建时间\r	private Date createtime;\r\r	// 备注\r	private String note;\r}</pre>\r\r<p>示例代码（OrderMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 查询所有的订单数据 --&gt;\r&lt;select id=&quot;queryOrderAll&quot; resultType=&quot;order&quot;&gt;\r	SELECT id, user_id,\r	number,\r	createtime, note FROM `order`\r&lt;/select&gt;</pre>\r\r<p>示例代码（OrderMapper.java）：</p>\r\r<pre class="brush:java;">\rList&lt;Order&gt; queryOrderAll();</pre>\r\r<p>示例代码（OrderMapperTest.java）：</p>\r\r<pre class="brush:java;">\r@Before\rpublic void init() throws Exception {\r	InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);\r	this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r}\r\r@Test\rpublic void testQueryAll() {\r	// 获取sqlSession\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 获取OrderMapper\r	OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class);\r\r	// 执行查询\r	List&lt;Order&gt; list = orderMapper.queryOrderAll();\r	for (Order order : list) {\r		System.out.println(order);\r	}\r}</pre>\r\r<p>结果发现userid中都是null，因为表中是user_id，而类中是userId。此时，就需要resultMap了。</p>\r\r<p>由于上边的mapper.xml中sql查询列(user_id)和Order类属性(userId)不一致，所以查询结果不能映射到pojo中。</p>\r\r<p>需要定义resultMap，把orderResultMap将sql查询列(user_id)和Order类属性(userId)对应起来。</p>\r\r<p>示例代码（OrderMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- resultMap最终还是要将结果映射到POJO上，type就是指定映射到哪一个POJO --&gt;\r&lt;!-- id：设置ResultMap的id --&gt;\r&lt;resultMap type=&quot;order&quot; id=&quot;orderResultMap&quot;&gt;\r	&lt;!-- 定义主键 ,非常重要。如果是多个字段,则定义多个id --&gt;\r	&lt;!-- property：主键在POJO中的属性名 --&gt;\r	&lt;!-- column：主键在数据库中的列名 --&gt;\r	&lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;\r\r	&lt;!-- 定义普通属性 --&gt;\r	&lt;result property=&quot;userId&quot; column=&quot;user_id&quot; /&gt;\r	&lt;result property=&quot;number&quot; column=&quot;number&quot; /&gt;\r	&lt;result property=&quot;createtime&quot; column=&quot;createtime&quot; /&gt;\r	&lt;result property=&quot;note&quot; column=&quot;note&quot; /&gt;\r&lt;/resultMap&gt;\r\r&lt;!-- 查询所有的订单数据 --&gt;\r&lt;select id=&quot;queryOrderAll&quot; resultMap=&quot;orderResultMap&quot;&gt;\r	SELECT id, user_id,\r	number,\r	createtime, note FROM `order`\r&lt;/select&gt;</pre>\r\r<p>至此，问题解决。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 48),
(1472, 'MyBatis动态SQL——if标签', '1472', 1553180400, 1554252450, '<p>本文记录Java学习过程中遇到的MyBatis动态SQL&mdash;&mdash;if标签～</p>\r<!--more-->\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 根据条件查询用户 --&gt;\r&lt;select id=&quot;queryUserByWhere&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;\r	SELECT id, username, birthday, sex, address FROM `user`\r	WHERE sex = #{sex} AND username LIKE\r	&#39;%${username}%&#39;\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper.java）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; queryUserByWhere(User user);</pre>\r\r<p>示例代码（UserMapperTest.java）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryUserByWhere() {\r	// mybatis和spring整合，整合之后，交给spring管理\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 创建Mapper接口的动态代理对象，整合之后，交给spring管理\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	// 使用userMapper执行根据条件查询用户\r	User user = new User();\r	user.setSex(&quot;1&quot;);\r	user.setUsername(&quot;张&quot;);\r\r	List&lt;User&gt; list = userMapper.queryUserByWhere(user);\r\r	for (User u : list) {\r		System.out.println(u);\r	}\r\r	// mybatis和spring整合，整合之后，交给spring管理\r	sqlSession.close();\r}</pre>\r\r<p>但是，如果注释掉user.setSex(&quot;1&quot;)，结果就为0了，这肯定是不合理的。</p>\r\r<p>按照之前所学的，要解决这个问题，需要编写多个SQL，查询条件越多，需要编写的SQL就更多了，显然这样是不靠谱的。</p>\r\r<p>可以使用动态SQL的if标签来解决这个问题。</p>\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:java;">\r&lt;!-- 根据条件查询用户 --&gt;\r&lt;select id=&quot;queryUserByWhere&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;\r	SELECT id, username, birthday, sex, address FROM `user`\r	WHERE 1=1\r	&lt;if test=&quot;sex != null and sex != &#39;&#39;&quot;&gt;\r		AND sex = #{sex}\r	&lt;/if&gt;\r	&lt;if test=&quot;username != null and username != &#39;&#39;&quot;&gt;\r		AND username LIKE &#39;%${username}%&#39;\r	&lt;/if&gt;\r&lt;/select&gt;</pre>\r\r<p>注意：字符串类型的数据需要要做不等于空字符串校验。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 54),
(1473, 'MyBatis动态SQL——where标签', '1473', 1553180580, 1554252490, '<p>本文记录Java学习过程中遇到的MyBatis动态SQL&mdash;&mdash;where标签～</p>\r<!--more-->\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 根据条件查询用户 --&gt;\r&lt;select id=&quot;queryUserByWhere&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;\r	SELECT id, username, birthday, sex, address FROM `user`\r&lt;!-- where标签可以自动添加where，同时处理sql语句中第一个and关键字 --&gt;\r	&lt;where&gt;\r		&lt;if test=&quot;sex != null&quot;&gt;\r			AND sex = #{sex}\r		&lt;/if&gt;\r		&lt;if test=&quot;username != null and username != &#39;&#39;&quot;&gt;\r			AND username LIKE\r			&#39;%${username}%&#39;\r		&lt;/if&gt;\r	&lt;/where&gt;\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper.java）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; queryUserByWhere(User user);</pre>\r\r<p>示例代码（UserMapperTest.java）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryUserByWhere() {\r	// mybatis和spring整合，整合之后，交给spring管理\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 创建Mapper接口的动态代理对象，整合之后，交给spring管理\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	// 使用userMapper执行根据条件查询用户\r	User user = new User();\r	user.setSex(&quot;1&quot;);\r	user.setUsername(&quot;张&quot;);\r\r	List&lt;User&gt; list = userMapper.queryUserByWhere(user);\r\r	for (User u : list) {\r		System.out.println(u);\r	}\r\r	// mybatis和spring整合，整合之后，交给spring管理\r	sqlSession.close();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 60),
(1474, 'MyBatis动态SQL——SQL片段', '1474', 1553181106, 1553181106, '<p>本文记录Java学习过程中遇到的MyBatis动态SQL&mdash;&mdash;SQL片段～</p>\r<!--more-->\r\r<p>可以将SQL中重复的SQL提取出来，使用时用include引用即可，最终达到sql重用的目的。</p>\r\r<p>可以把查询用户的SQL语句的id, username, birthday, sex, address提取出来，作为sql片段。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 根据条件查询用户 --&gt;\r&lt;select id=&quot;queryUserByWhere&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;\r	&lt;!-- SELECT id, username, birthday, sex, address FROM `user` --&gt;\r	&lt;!-- 使用include标签加载sql片段；refid是sql片段id --&gt;\r	SELECT &lt;include refid=&quot;userFields&quot; /&gt; FROM `user`\r	&lt;!-- where标签可以自动添加where关键字，同时处理sql语句中第一个and关键字 --&gt;\r	&lt;where&gt;\r		&lt;if test=&quot;sex != null&quot;&gt;\r			AND sex = #{sex}\r		&lt;/if&gt;\r		&lt;if test=&quot;username != null and username != &#39;&#39;&quot;&gt;\r			AND username LIKE\r			&#39;%${username}%&#39;\r		&lt;/if&gt;\r	&lt;/where&gt;\r&lt;/select&gt;\r&lt;!-- 声明sql片段 --&gt;\r&lt;sql id=&quot;userFields&quot;&gt;\r	id, username, birthday, sex, address\r&lt;/sql&gt;</pre>\r\r<p>如果要使用别的Mapper.xml配置的sql片段，可以在refid前面加上对应的Mapper.xml的namespace。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 根据性别和用户名查询 --&gt;\r&lt;select id=&quot;queryUserByWhere&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt;\r	select &lt;include refid=&quot;ren.oliver.mybatis.mapper.OrderMapper.userFields&quot; /&gt; from `user`\r	&lt;where&gt;\r		&lt;if test=&quot;sex != null&quot;&gt;\r			AND sex = #{sex}\r		&lt;/if&gt;\r		&lt;if test=&quot;username != null and username != &#39;&#39;&quot;&gt;\r			AND username LIKE &#39;%${username}%&#39;\r		&lt;/if&gt;\r	&lt;/where&gt;\r&lt;/select&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 45),
(1475, 'MyBatis动态SQL——foreach标签', '1475', 1553181480, 1554252537, '<p>本文记录Java学习过程中遇到的MyBatis动态SQL&mdash;&mdash;foreach标签～</p>\r<!--more-->\r\r<p>向SQL传递数组或List，MyBatis使用foreach解析。</p>\r\r<p>例如：根据多个id查询用户信息</p>\r\r<p>示例代码（SQL）：</p>\r\r<pre class="brush:sql;">\rSELECT * FROM user WHERE id IN (1,10,24)</pre>\r\r<p>示例代码（QueryVo）：</p>\r\r<pre class="brush:java;">\r@Data\rpublic class QueryVo {\r\r	private User user;\r\r	private List&lt;Interger&gt; ids;\r}</pre>\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 根据ids查询用户 --&gt;\r&lt;select id=&quot;queryUserByIds&quot; parameterType=&quot;queryVo&quot; resultType=&quot;user&quot;&gt;\r	SELECT * FROM `user`\r	&lt;where&gt;\r		&lt;!-- foreach标签，进行遍历 --&gt;\r		&lt;!-- collection：遍历的集合，这里是QueryVo的ids属性 --&gt;\r		&lt;!-- item：遍历的项目，可以随便写，，但是和后面的#{}里面要一致 --&gt;\r		&lt;!-- open：在前面添加的sql片段 --&gt;\r		&lt;!-- close：在结尾处添加的sql片段 --&gt;\r		&lt;!-- separator：指定遍历的元素之间使用的分隔符 --&gt;\r		&lt;foreach collection=&quot;ids&quot; item=&quot;item&quot; open=&quot;id IN (&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;\r			#{item}\r		&lt;/foreach&gt;\r	&lt;/where&gt;\r&lt;/select&gt;</pre>\r\r<p>示例代码（测试代码）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryUserByIds() {\r	// mybatis和spring整合，整合之后，交给spring管理\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 创建Mapper接口的动态代理对象，整合之后，交给spring管理\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	// 使用userMapper执行根据条件查询用户\r	QueryVo queryVo = new QueryVo();\r	List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();\r	ids.add(1);\r	ids.add(10);\r	ids.add(24);\r	queryVo.setIds(ids);\r\r	List&lt;User&gt; list = userMapper.queryUserByIds(queryVo);\r\r	for (User u : list) {\r		System.out.println(u);\r	}\r\r	// mybatis和spring整合，整合之后，交给spring管理\r	sqlSession.close();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 52);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1476, 'MyBatis关联查询——一对一查询', '1476', 1553211780, 1554252650, '<p>本文记录Java学习过程中遇到的MyBatis关联查询&mdash;&mdash;一对一查询～</p>\r<!--more-->\r\r<p>需求：查询所有订单信息，关联查询下单用户信息。</p>\r\r<p>注意：</p>\r\r<ul>\r	<li>因为一个订单信息只会是一个人下的订单，所以从查询订单信息出发关联查询用户信息为一对一查询。</li>\r	<li>如果从用户信息出发查询用户下的订单信息则为一对多查询，因为一个用户可以下多个订单。</li>\r</ul>\r\r<p>示例代码（SQL语句）：</p>\r\r<pre class="brush:sql;">\rSELECT\r	o.id,\r	o.user_id userId,\r	o.number,\r	o.createtime,\r	o.note,\r	u.username,\r	u.address\rFROM\r	`order` o\rLEFT JOIN `user` u ON o.user_id = u.id</pre>\r\r<p><strong>实现方式一：使用resultType</strong></p>\r\r<p>使用resultType，改造订单POJO类，此POJO类中包括了订单信息和用户信息。这样返回对象的时候，MyBatis自动把用户信息也注入进来了。</p>\r\r<p>示例代码（OrderUser）：</p>\r\r<pre class="brush:java;">\rpublic class OrderUser extends Order {\r	private String username;\r	private String address;\r}</pre>\r\r<p>示例代码（Mapper.xml）：</p>\r\r<pre class="brush:java;">\r&lt;!-- 查询订单，同时包含用户数据 --&gt;\r&lt;select id=&quot;queryOrderUser&quot; resultType=&quot;orderUser&quot;&gt;\r	SELECT\r	o.id,\r	o.user_id\r	userId,\r	o.number,\r	o.createtime,\r	o.note,\r	u.username,\r	u.address\r	FROM\r	`order` o\r	LEFT JOIN `user` u ON o.user_id = u.id\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper）：</p>\r\r<pre class="brush:java;">\rList&lt;OrderUser&gt; queryOrderUser();</pre>\r\r<p>示例代码（UserMapperTest）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryOrderUser() {\r	// mybatis和spring整合，整合之后，交给spring管理\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 创建Mapper接口的动态代理对象，整合之后，交给spring管理\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	// 使用userMapper执行根据条件查询用户\r	List&lt;OrderUser&gt; list = userMapper.queryOrderUser();\r\r	for (OrderUser ou : list) {\r		System.out.println(ou);\r	}\r\r	// mybatis和spring整合，整合之后，交给spring管理\r	sqlSession.close();\r}</pre>\r\r<p>总结：定义专门的POJO类作为输出类型，其中定义了SQL查询结果集所有的字段。该方法较为简单，企业中使用普遍。</p>\r\r<p><strong>实现方式二：使用resultMap</strong></p>\r\r<p>使用resultMap，定义专门的resultMap用于映射一对一查询结果。</p>\r\r<p>在Order类中加入User属性，User属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。</p>\r\r<p>示例代码（Order）：</p>\r\r<pre class="brush:java;">\r@Data\rpublic class Order {\r\r	private int id;\r	private Interger userId;\r	private String number;\r	private Date createtime;\r	private String note;\r	private User user;\r}</pre>\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap type=&quot;order&quot; id=&quot;orderUserResultMap&quot;&gt;\r	&lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;\r	&lt;result property=&quot;userId&quot; column=&quot;user_id&quot; /&gt;\r	&lt;result property=&quot;number&quot; column=&quot;number&quot; /&gt;\r	&lt;result property=&quot;createtime&quot; column=&quot;createtime&quot; /&gt;\r	&lt;result property=&quot;note&quot; column=&quot;note&quot; /&gt;\r\r	&lt;!-- association ：配置一对一属性 --&gt;\r	&lt;!-- property:order里面的User属性名 --&gt;\r	&lt;!-- javaType:属性类型 --&gt;\r	&lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt;\r		&lt;!-- id:声明主键，表示user_id是关联查询对象的唯一标识--&gt;\r		&lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt;\r		&lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;\r		&lt;result property=&quot;address&quot; column=&quot;address&quot; /&gt;\r	&lt;/association&gt;\r&lt;/resultMap&gt;\r\r&lt;!-- 一对一关联，查询订单，订单内部包含用户属性 --&gt;\r&lt;select id=&quot;queryOrderUserResultMap&quot; resultMap=&quot;orderUserResultMap&quot;&gt;\r	SELECT\r	o.id,\r	o.user_id,\r	o.number,\r	o.createtime,\r	o.note,\r	u.username,\r	u.address\r	FROM\r	`order` o\r	LEFT JOIN `user` u ON o.user_id = u.id\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper.java）：</p>\r\r<pre class="brush:java;">\rList&lt;Order&gt; queryOrderUserResultMap();</pre>\r\r<p>示例代码（UserMapperTest.java）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryOrderUserResultMap() {\r	// mybatis和spring整合，整合之后，交给spring管理\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 创建Mapper接口的动态代理对象，整合之后，交给spring管理\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	// 使用userMapper执行根据条件查询用户\r	List&lt;Order&gt; list = userMapper.queryOrderUserResultMap();\r\r	for (Order o : list) {\r		System.out.println(o);\r	}\r\r	// mybatis和spring整合，整合之后，交给spring管理\r	sqlSession.close();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 54),
(1477, 'MyBatis关联查询——一对多查询', '1477', 1553212200, 1554252685, '<p>本文记录Java学习过程中遇到的MyBatis关联查询&mdash;&mdash;一对多查询～</p>\r<!--more-->\r\r<p>案例：查询所有用户信息及用户关联的订单信息。</p>\r\r<p>注意：用户信息和订单信息为一对多关系。</p>\r\r<p>示例代码（SQL语句）：</p>\r\r<pre class="brush:sql;">\rSELECT\r	u.id,\r	u.username,\r	u.birthday,\r	u.sex,\r	u.address,\r	o.id oid,\r	o.number,\r	o.createtime,\r	o.note\rFROM\r	`user` u\rLEFT JOIN `order` o ON u.id = o.user_id</pre>\r\r<p>示例代码（User类）：</p>\r\r<pre class="brush:java;">\rpublic class User {\r	private int id;\r	private String username;\r	private String sex;\r	private Date birthday;\r	private String address;\r\r	private List&lt;Order&gt; ordes;\r}</pre>\r\r<p>示例代码（UserMapper.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap type=&quot;user&quot; id=&quot;userOrderResultMap&quot;&gt;\r	&lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;\r	&lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;\r	&lt;result property=&quot;birthday&quot; column=&quot;birthday&quot; /&gt;\r	&lt;result property=&quot;sex&quot; column=&quot;sex&quot; /&gt;\r	&lt;result property=&quot;address&quot; column=&quot;address&quot; /&gt;\r\r	&lt;!-- 配置一对多的关系 --&gt;\r	&lt;collection property=&quot;orders&quot; javaType=&quot;list&quot; ofType=&quot;order&quot;&gt;\r		&lt;!-- 配置主键，是关联Order的唯一标识 --&gt;\r		&lt;id property=&quot;id&quot; column=&quot;oid&quot; /&gt;\r		&lt;result property=&quot;number&quot; column=&quot;number&quot; /&gt;\r		&lt;result property=&quot;createtime&quot; column=&quot;createtime&quot; /&gt;\r		&lt;result property=&quot;note&quot; column=&quot;note&quot; /&gt;\r	&lt;/collection&gt;\r&lt;/resultMap&gt;\r\r&lt;!-- 一对多关联，查询订单同时查询该用户下的订单 --&gt;\r&lt;select id=&quot;queryUserOrder&quot; resultMap=&quot;userOrderResultMap&quot;&gt;\r	SELECT\r	u.id,\r	u.username,\r	u.birthday,\r	u.sex,\r	u.address,\r	o.id oid,\r	o.number,\r	o.createtime,\r	o.note\r	FROM\r	`user` u\r	LEFT JOIN `order` o ON u.id = o.user_id\r&lt;/select&gt;</pre>\r\r<p>示例代码（UserMapper.java）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; queryUserOrder();</pre>\r\r<p>示例代码（UserMapperTest.java）：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryUserOrder() {\r	// mybatis和spring整合，整合之后，交给spring管理\r	SqlSession sqlSession = this.sqlSessionFactory.openSession();\r	// 创建Mapper接口的动态代理对象，整合之后，交给spring管理\r	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\r	// 使用userMapper执行根据条件查询用户\r	List&lt;User&gt; list = userMapper.queryUserOrder();\r\r	for (User u : list) {\r		System.out.println(u);\r	}\r\r	// mybatis和spring整合，整合之后，交给spring管理\r	sqlSession.close();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 49),
(1478, 'spring整体框架.png', 'spring整体框架-png', 1553258635, 1553258635, 'a:5:{s:4:"name";s:22:"spring整体框架.png";s:4:"path";s:35:"/usr/uploads/2019/03/2233009945.png";s:4:"size";i:121803;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1480, 0),
(1479, 'Springmvc处理流程.png', 'Springmvc处理流程-png', 1553258666, 1553258666, 'a:5:{s:4:"name";s:25:"Springmvc处理流程.png";s:4:"path";s:35:"/usr/uploads/2019/03/1800187835.png";s:4:"size";i:54830;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1480, 0),
(1480, 'SpringMVC简介', '1480', 1553258678, 1553258678, '<p>本文记录Java学习过程中遇到的SpringMVC简介～</p>\r<!--more-->\r\r<p>Spring Web MVC和Struts2都属于表现层的框架，它是Spring框架的一部分，我们可以从Spring的整体结构中看得出来，如下图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/2233009945.png" style="width: 800px; height: 637px;" /></p>\r\r<p>SpringMVC处理流程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/1800187835.png" style="width: 800px; height: 368px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1481, 'SpringMVC框架.png', 'SpringMVC框架-png', 1553262052, 1553262052, 'a:5:{s:4:"name";s:19:"SpringMVC框架.png";s:4:"path";s:35:"/usr/uploads/2019/03/4175008229.png";s:4:"size";i:138110;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1482, 0),
(1482, 'SpringMVC架构', '1482', 1553262060, 1553264179, '<p>本文记录Java学习过程中遇到的SpringMVC的架构～</p>\r<!--more-->\r\r<p>SpringMVC的框架结构如下图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/4175008229.png" style="width: 800px; height: 498px;" />​</p>\r\r<p>SpringMVC的架构流程：</p>\r\r<ul>\r	<li>用户发送请求至前端控制器DispatcherServlet；</li>\r	<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器；</li>\r	<li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</li>\r	<li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器；</li>\r	<li>执行处理器(Controller，也叫后端控制器)；</li>\r	<li>Controller执行完成返回ModelAndView；</li>\r	<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet；</li>\r	<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器；</li>\r	<li>ViewReslover解析后返回具体View；</li>\r	<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）；</li>\r	<li>DispatcherServlet响应用户。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 35),
(1483, 'SpringMVC组件', '1483', 1553264400, 1553297955, '<p>本文记录Java学习过程中遇到的SpringMVC的组件～</p>\r<!--more-->\r\r<p>以下组件通常使用框架提供实现：</p>\r\r<p><strong>DispatcherServlet：前端控制器</strong></p>\r\r<p>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>\r\r<p><strong>HandlerMapping：处理器映射器</strong></p>\r\r<p>HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\r\r<p><strong>Handler：处理器</strong></p>\r\r<p>Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br />\r由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p>\r\r<p><strong>HandlAdapter：处理器适配器</strong></p>\r\r<p>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。<br />\r&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\r<strong>ViewResolver：视图解析器</strong></p>\r\r<p>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。&nbsp;</p>\r\r<p><strong>View：视图</strong></p>\r\r<p>SpringMVC框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br />\r一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>\r\r<p>说明：在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开发的组件有handler、view。</p>\r\r<p><strong>默认加载的组件</strong></p>\r\r<p>指的是没有做任何配置，就可以使用这些组件。这是因为框架已经默认加载这些组件了，配置文件在spring-webmvc包下的DispatcherServlet.properties中。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r# Default implementation classes for DispatcherServlet&#39;s strategy interfaces.\r# Used as fallback when no matching beans are found in the DispatcherServlet context.\r# Not meant to be customized by application developers.\r\rorg.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver\r\rorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver\r\rorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\r\rorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\r\rorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver\r\rorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator\r\rorg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver\r\rorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</pre>\r\r<p><strong>组件扫描器</strong></p>\r\r<p>使用组件扫描器省去在spring容器配置每个Controller类的繁琐。</p>\r\r<p>可以使用&lt;context:component-scan&gt;自动扫描标记@Controller的控制器类。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 配置controller扫描包，多个包之间用,分隔 --&gt;\r&lt;context:component-scan base-package=&quot;ren.oliver.springmvc.controller&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 49),
(1484, 'SpringMVC注解映射器和适配器', '1484', 1553298338, 1553298338, '<p>本文记录Java学习过程中遇到的SpringMVC注解映射器和适配器～</p>\r<!--more-->\r\r<p><strong>配置处理器映射器</strong></p>\r\r<p>注解式处理器映射器，对类中标记了@ResquestMapping的方法进行映射。根据@ResquestMapping定义的url匹配@ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器。<br />\rHandlerMethod对象中封装url对应的方法Method。&nbsp;</p>\r\r<p>从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。</p>\r\r<p>示例代码（springmvc.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 配置处理器映射器 --&gt;\r&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot; /&gt;</pre>\r\r<p>注解描述：@RequestMapping：定义请求url到处理器功能方法的映射。</p>\r\r<p><strong>配置处理器适配器</strong></p>\r\r<p>注解式处理器适配器，对标记@ResquestMapping的方法进行适配。</p>\r\r<p>从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。</p>\r\r<p>示例代码（springmvc.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 配置处理器适配器 --&gt;\r&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt;</pre>\r\r<p><strong>注解驱动</strong></p>\r\r<p>直接配置处理器映射器和处理器适配器比较麻烦，可以使用注解驱动来加载。</p>\r\r<p>SpringMVC使用&lt;mvc:annotation-driven&gt;自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter。可以在springmvc.xml配置文件中使用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 注解驱动 --&gt;\r&lt;mvc:annotation-driven /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 43),
(1485, 'SpringMVC视图解析器', '1485', 1553298987, 1553298987, '<p>本文记录Java学习过程中遇到的SpringMVC视图解析器～</p>\r<!--more-->\r\r<p>视图解析器使用SpringMVC框架默认的InternalResourceViewResolver，这个视图解析器支持JSP视图解析。</p>\r\r<p>示例代码（springmvc.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- Example: prefix=&quot;/WEB-INF/jsp/&quot;, suffix=&quot;.jsp&quot;, viewname=&quot;test&quot; -&gt; \r	&quot;/WEB-INF/jsp/test.jsp&quot; --&gt;\r&lt;!-- 配置视图解析器 --&gt;\r&lt;bean\r	class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\r	&lt;!-- 配置逻辑视图的前缀 --&gt;\r	&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;\r	&lt;!-- 配置逻辑视图的后缀 --&gt;\r	&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;\r&lt;/bean&gt;</pre>\r\r<p>逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为ItemList，则最终返回的jsp视图地址为&ldquo;WEB-INF/jsp/itemList.jsp&rdquo;。即最终jsp物理地址：前缀+逻辑视图名+后缀。</p>\r\r<p>示例代码（ItemController）：</p>\r\r<pre class="brush:java;">\r// @RequestMapping：里面放的是请求的url，和用户请求的url进行匹配\r// action可以写也可以不写\r@RequestMapping(&quot;/itemList.action&quot;)\rpublic ModelAndView queryItemList() {\r	// 创建页面需要显示的商品数据\r	List&lt;Item&gt; list = new ArrayList&lt;&gt;();\r	list.add(new Item(1, &quot;1华为 荣耀8&quot;, 2399, new Date(), &quot;质量好！1&quot;));\r	list.add(new Item(2, &quot;2华为 荣耀8&quot;, 2399, new Date(), &quot;质量好！2&quot;));\r	list.add(new Item(3, &quot;3华为 荣耀8&quot;, 2399, new Date(), &quot;质量好！3&quot;));\r	list.add(new Item(4, &quot;4华为 荣耀8&quot;, 2399, new Date(), &quot;质量好！4&quot;));\r	list.add(new Item(5, &quot;5华为 荣耀8&quot;, 2399, new Date(), &quot;质量好！5&quot;));\r	list.add(new Item(6, &quot;6华为 荣耀8&quot;, 2399, new Date(), &quot;质量好！6&quot;));\r\r	// 创建ModelAndView，用来存放数据和视图\r	ModelAndView modelAndView = new ModelAndView();\r	// 设置数据到模型中\r	modelAndView.addObject(&quot;itemList&quot;, list);\r	// 设置视图jsp，需要设置视图的物理地址\r	// modelAndView.setViewName(&quot;/WEB-INF/jsp/itemList.jsp&quot;);\r	// 配置好视图解析器前缀和后缀，这里只需要设置逻辑视图就可以了。\r	// 视图解析器根据前缀+逻辑视图名+后缀拼接出来物理路径\r	modelAndView.setViewName(&quot;itemList&quot;);\r\r	return modelAndView;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 39),
(1486, 'SpringMVC参数绑定-默认类型', '1486', 1553305149, 1553305149, '<p>本文记录Java学习过程中遇到的SpringMVC参数绑定-默认类型～</p>\r<!--more-->\r\r<p>SpringMVC默认支持的参数绑定类型有如下三个：</p>\r\r<ul>\r	<li>HttpServletRequest：通过request对象获取请求信息；</li>\r	<li>HttpServletResponse：通过response处理响应信息；</li>\r	<li>HttpSession：通过session对象得到session中存放的对象。</li>\r</ul>\r\r<p>注意：处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 根据id查询商品\r * \r * @param request\r * @return\r */\r@RequestMapping(&quot;/itemEdit&quot;)\rpublic ModelAndView queryItemById(HttpServletRequest request) {\r	// 从request中获取请求参数\r	String strId = request.getParameter(&quot;id&quot;);\r	Integer id = Integer.valueOf(strId);\r\r	// 根据id查询商品数据\r	Item item = this.itemService.queryItemById(id);\r\r	// 把结果传递给页面\r	ModelAndView modelAndView = new ModelAndView();\r	// 把商品数据放在模型中\r	modelAndView.addObject(&quot;item&quot;, item);\r	// 设置逻辑视图\r	modelAndView.setViewName(&quot;itemEdit&quot;);\r\r	return modelAndView;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 32),
(1487, 'SpringMVC返回值传递', '1487', 1553305255, 1553305255, '<p>本文记录Java学习过程中遇到的SpringMVC返回值传递～</p>\r<!--more-->\r\r<p><strong>Model</strong></p>\r\r<p>除了ModelAndView以外，还可以使用Model来向页面传递数据，Model是一个接口，在参数里直接声明model即可。</p>\r\r<p>如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。</p>\r\r<p>不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 根据id查询商品,使用Model\r * \r * @param request\r * @param model\r * @return\r */\r@RequestMapping(&quot;/itemEdit&quot;)\rpublic String queryItemById(HttpServletRequest request, Model model) {\r	// 从request中获取请求参数\r	String strId = request.getParameter(&quot;id&quot;);\r	Integer id = Integer.valueOf(strId);\r\r	// 根据id查询商品数据\r	Item item = this.itemService.queryItemById(id);\r\r	// 把结果传递给页面\r	// ModelAndView modelAndView = new ModelAndView();\r	// 把商品数据放在模型中\r	// modelAndView.addObject(&quot;item&quot;, item);\r	// 设置逻辑视图\r	// modelAndView.setViewName(&quot;itemEdit&quot;);\r\r	// 把商品数据放在模型中\r	model.addAttribute(&quot;item&quot;, item);\r\r	return &quot;itemEdit&quot;;\r}</pre>\r\r<p><strong>ModelMap</strong></p>\r\r<p>ModelMap是Model接口的实现类，也可以通过ModelMap向页面传递数据。</p>\r\r<p>使用Model和ModelMap的效果一样，如果直接使用Model，SpringMVC会实例化ModelMap。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 根据id查询商品,使用ModelMap\r * \r * @param request\r * @param model\r * @return\r */\r@RequestMapping(&quot;/itemEdit&quot;)\rpublic String queryItemById(HttpServletRequest request, ModelMap model) {\r	// 从request中获取请求参数\r	String strId = request.getParameter(&quot;id&quot;);\r	Integer id = Integer.valueOf(strId);\r\r	// 根据id查询商品数据\r	Item item = this.itemService.queryItemById(id);\r\r	// 把结果传递给页面\r	// ModelAndView modelAndView = new ModelAndView();\r	// 把商品数据放在模型中\r	// modelAndView.addObject(&quot;item&quot;, item);\r	// 设置逻辑视图\r	// modelAndView.setViewName(&quot;itemEdit&quot;);\r\r	// 把商品数据放在模型中\r	model.addAttribute(&quot;item&quot;, item);\r\r	return &quot;itemEdit&quot;;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 45),
(1488, 'SpringMVC参数绑定-简单类型', '1488', 1553305842, 1553305842, '<p>本文记录Java学习过程中遇到的SpringMVC参数绑定-简单类型～</p>\r<!--more-->\r\r<p>当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。这样，从Request取参数的方法就可以进一步简化。</p>\r\r<p><strong>支持的数据类型</strong></p>\r\r<p>SpringMVC支持绑定的简单类型为：</p>\r\r<ul>\r	<li>整形：Integer、int</li>\r	<li>字符串：String</li>\r	<li>单精度：Float、float</li>\r	<li>双精度：Double、double</li>\r	<li>布尔型：Boolean、boolean</li>\r</ul>\r\r<p>说明：对于布尔类型的参数，请求的参数值为true或false，也可以是1或0。</p>\r\r<p>注意：参数类型推荐使用包装数据类型，因为基础数据类型不可以为null。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 根据id查询商品,绑定简单数据类型\r * \r * @param id\r * @param model\r * @return\r */\r@RequestMapping(&quot;/itemEdit&quot;)\rpublic String queryItemById(Integer id, ModelMap model) {\r	// 根据id查询商品数据\r	Item item = this.itemService.queryItemById(id);\r\r	// 把商品数据放在模型中\r	model.addAttribute(&quot;item&quot;, item);\r\r	return &quot;itemEdit&quot;;\r}</pre>\r\r<p><strong>@RequestParam注解</strong></p>\r\r<p>@RequestParam注解常用于处理简单类型的绑定。</p>\r\r<p>常用的参数有：</p>\r\r<ul>\r	<li>value：参数名字，即入参的请求参数名字，如value=&ldquo;itemId&rdquo;表示请求的参数，缓存区中名字为itemId的参数的值将传入；</li>\r	<li>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报错HTTP Status 400 - Required Integer parameter &#39;XXXX&#39; is not present；</li>\r	<li>defaultValue：默认值，表示如果请求中没有同名参数时的默认值。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@RequestMapping(&quot;/itemEdit&quot;)\rpublic String queryItemById(@RequestParam(value = &quot;itemId&quot;, required = true, defaultValue = &quot;1&quot;) Integer id,\r		ModelMap modelMap) {\r	// 根据id查询商品数据\r	Item item = this.itemService.queryItemById(id);\r\r	// 把商品数据放在模型中\r	modelMap.addAttribute(&quot;item&quot;, item);\r\r	return &quot;itemEdit&quot;;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 37),
(1489, 'SpringMVC参数绑定-POJO类型', '1489', 1553312770, 1553312770, '<p>本文记录Java学习过程中遇到的SpringMVC参数绑定-POJO类型～</p>\r<!--more-->\r\r<p>如果提交的参数很多，或者提交的表单中的内容很多的时候,可以使用简单类型接受数据,也可以使用pojo接收数据。</p>\r\r<p>要求：pojo对象中的属性名和表单中input的name属性一致。</p>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;form id=&quot;itemForm&quot; action=&quot;${pageContext.request.contextPath }/updateItem.action&quot;&gt;\r	&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${item.id}&quot; /&gt;修改商品信息\r	&lt;table width=&quot;100%&quot; border=1&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品名称&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;${item.name}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品价格&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;${item.price}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品详情&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;${item.detail}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r	&lt;/table&gt;\r&lt;/from&gt;</pre>\r\r<p>示例代码（ItemController）：</p>\r\r<pre class="brush:java;">\r/**\r * 更新商品,绑定pojo类型\r * \r * @param item\r * @param model\r * @return\r */\r@RequestMapping(&quot;/updateItem&quot;)\rpublic String updateItem(Item item) {\r	// 调用服务更新商品\r	this.itemService.updateItemById(item);\r\r	// 返回逻辑视图\r	return &quot;success&quot;;\r}</pre>\r\r<p>注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到自定义参数绑定的内容。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1490, 'SpringMVC解决POST乱码问题', '1490', 1553313082, 1553313082, '<p>本文记录Java学习过程中遇到的SpringMVC解决POST乱码问题～</p>\r<!--more-->\r\r<p>在提交的时候发现，可以保存成功，但是保存的是乱码。</p>\r\r<p>可以通过springmvc提供的filer来解决乱码问题。</p>\r\r<p>示例代码（web.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 解决post乱码问题 --&gt;\r&lt;filter&gt;\r	&lt;filter-name&gt;encoding&lt;/filter-name&gt;\r	&lt;filter-class&gt;\r		org.springframework.web.filter.CharacterEncodingFilter\r	&lt;/filter-class&gt;\r	&lt;!-- 设置编码参是UTF8 --&gt;\r	&lt;init-param&gt;\r		&lt;param-name&gt;encoding&lt;/param-name&gt;\r		&lt;param-value&gt;UTF-8&lt;/param-value&gt;\r	&lt;/init-param&gt;\r&lt;/filter&gt;\r&lt;filter-mapping&gt;\r	&lt;filter-name&gt;encoding&lt;/filter-name&gt;\r	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\r&lt;/filter-mapping&gt;</pre>\r\r<p>以上可以解决post请求乱码问题。</p>\r\r<p>对于get请求中文参数出现乱码解决方法有两个：</p>\r\r<ul>\r	<li>修改tomcat配置文件添加编码与工程编码一致，如下：</li>\r</ul>\r\r<pre class="brush:xml;">\r&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</pre>\r\r<ul>\r	<li>另外一种方法对参数进行重新编码：</li>\r</ul>\r\r<pre class="brush:java;">\rString userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;);</pre>\r\r<p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 34),
(1491, 'SpringMVC参数绑定-包装POJO类型', '1491', 1553313462, 1553313462, '<p>本文记录Java学习过程中遇到的SpringMVC参数绑定-包装POJO类型～</p>\r<!--more-->\r\r<p>可以使用包装的POJO接收查询条件等。</p>\r\r<p>示例代码（包装POJO）：</p>\r\r<pre class="brush:java;">\r@Data\rpublic class QueryVo {\r\r	private Item item;\r}</pre>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;form id=&quot;itemForm&quot; action=&quot;${pageContext.request.contextPath }/queryItem.action&quot;&gt;\r	查询条件：\r	&lt;table width=&quot;100%&quot; border=1&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品名称&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;${item.name}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品价格&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;${item.price}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r	&lt;/table&gt;\r&lt;/from&gt;</pre>\r\r<p>示例代码（ItemController）：</p>\r\r<pre class="brush:java;">\r// 绑定包装数据类型\r@RequestMapping(&quot;/queryItem&quot;)\rpublic String queryItem(QueryVo queryVo) {\r\r	System.out.println(queryVo.getItem().getId());\r	System.out.println(queryVo.getItem().getName());\r\r	return &quot;success&quot;;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 33),
(1492, 'SpringMVC参数绑定-自定义类型', '1492', 1553314020, 1554279543, '<p>本文记录Java学习过程中遇到的SpringMVC参数绑定-自定义类型～</p>\r<!--more-->\r\r<p>由于日期数据有很多种格式，springmvc没办法把字符串转换成日期类型，所以需要自定义参数绑定。</p>\r\r<p>前端控制器接收到请求后，找到注解形式的处理器适配器，对RequestMapping标记的方法进行适配，并对方法中的形参进行参数绑定。可以在springmvc处理器适配器上自定义转换器Converter进行参数绑定。</p>\r\r<p>一般使用&lt;mvc:annotation-driven/&gt;注解驱动加载处理器适配器，可以在此标签上进行配置。</p>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;form id=&quot;itemForm&quot; action=&quot;${pageContext.request.contextPath }/updateItem.action&quot;&gt;\r	&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${item.id}&quot; /&gt;修改商品信息\r	&lt;table width=&quot;100%&quot; border=1&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品名称&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;${item.name}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品价格&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;${item.price}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品详情&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;${item.detail}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品生产日期&lt;/td&gt;\r			&lt;td&gt;\r				&lt;input type=&quot;text&quot; name=&quot;createtime&quot; value=&quot;&lt;fmt:formatDate value=&#39;${item.createtime}&#39; pattern=&#39;yyyy-MM-dd HH:mm:ss&#39;&quot; /&gt;\r			&lt;/td&gt;\r	&lt;/table&gt;\r&lt;/from&gt;</pre>\r\r<p>示例代码（DateConverter.java）：</p>\r\r<pre class="brush:java;">\r//Converter&lt;S, T&gt;\r//S:source,需要转换的源的类型\r//T:target,需要转换的目标类型\rpublic class DateConverter implements Converter&lt;String, Date&gt; {\r\r	@Override\r	public Date convert(String source) {\r		try {\r			// 把字符串转换为日期类型\r			SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyy-MM-dd HH:mm:ss&quot;);\r			Date date = simpleDateFormat.parse(source);\r\r			return date;\r		} catch (ParseException e) {\r			// TODO Auto-generated catch block\r			e.printStackTrace();\r		}\r		// 如果转换异常则返回空\r		return null;\r	}\r}</pre>\r\r<p>示例代码（springmvc.xml：使用annotation-driven）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 配置注解驱动 --&gt;\r&lt;!-- 如果配置此标签,可以不用配置... --&gt;\r&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; /&gt;\r\r&lt;!-- 转换器配置 --&gt;\r&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;\r	&lt;property name=&quot;converters&quot;&gt;\r		&lt;set&gt;\r			&lt;bean class=&quot;ren.oliver.springmvc.converter.DateConverter&quot; /&gt;\r		&lt;/set&gt;\r	&lt;/property&gt;\r&lt;/bean&gt;</pre>\r\r<p>示例代码（springmvc.xml：自定义转化器）：</p>\r\r<pre class="brush:xml;">\r&lt;!--注解适配器 --&gt;\r&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;\r	&lt;property name=&quot;webBindingInitializer&quot; ref=&quot;customBinder&quot;&gt;&lt;/property&gt;\r&lt;/bean&gt;\r\r&lt;!-- 自定义webBinder --&gt;\r&lt;bean id=&quot;customBinder&quot; class=&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&gt;\r	&lt;property name=&quot;conversionService&quot; ref=&quot;conversionService&quot; /&gt;\r&lt;/bean&gt;\r\r&lt;!-- 转换器配置 --&gt;\r&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;\r	&lt;property name=&quot;converters&quot;&gt;\r		&lt;set&gt;\r			&lt;bean class=&quot;cn.itcast.springmvc.convert.DateConverter&quot; /&gt;\r		&lt;/set&gt;\r	&lt;/property&gt;\r&lt;/bean&gt;</pre>\r\r<p>注意：此方法需要独立配置处理器映射器、适配器，不再使用&lt;mvc:annotation-driven/&gt;。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 52),
(1493, 'SpringMVC与Struts2的区别', '1493', 1553314254, 1553314254, '<p>本文记录Java学习过程中遇到的SpringMVC与Struts2的区别～</p>\r<!--more-->\r\r<p>SpringMVC与Struts2的区别可以总结为如下三点：</p>\r\r<ul>\r	<li>SpringMVC的入口是一个Servlet即前端控制器，而Struts2入口是一个filter过滤器；</li>\r	<li>SpringMVC是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，Struts2是基于类开发，传递参数是通过类的属性，只能设计为多例；</li>\r	<li>Struts2采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面，Jsp视图解析器默认使用jstl。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 29),
(1494, 'SpringMVC参数绑定——数组类型', '1494', 1553316300, 1553316442, '<p>本文记录Java学习过程中遇到的SpringMVC参数绑定&mdash;&mdash;数组类型～</p>\r<!--more-->\r\r<p>在列表页面选择多个选项，然后批量删除。</p>\r\r<p>这个功能要求列表页面中的每个选项前有一个checkbok，选中多个商品后点击删除按钮把选项id传递给Controller，根据选项id删除商品信息，这个使用id的数组来实现。</p>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;form action=&quot;${pageContext.request.contextPath }/queryItem.action&quot; method=&quot;post&quot;&gt;\r	查询条件：\r	&lt;table width=&quot;100%&quot; border=1&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品id&lt;input type=&quot;text&quot; name=&quot;item.id&quot; /&gt;&lt;/td&gt;\r			&lt;td&gt;商品名称&lt;input type=&quot;text&quot; name=&quot;item.name&quot; /&gt;&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r	&lt;/table&gt;\r	商品列表：\r	&lt;table width=&quot;100%&quot; border=1&gt;\r		&lt;tr&gt;\r			&lt;td&gt;选择&lt;/td&gt;\r			&lt;td&gt;商品名称&lt;/td&gt;\r			&lt;td&gt;商品价格&lt;/td&gt;\r			&lt;td&gt;生产日期&lt;/td&gt;\r			&lt;td&gt;商品描述&lt;/td&gt;\r			&lt;td&gt;操作&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt;\r			&lt;tr&gt;\r				&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;${item.id}&quot;/&gt;&lt;/td&gt;\r				&lt;td&gt;${item.name }&lt;/td&gt;\r				&lt;td&gt;${item.price }&lt;/td&gt;\r				&lt;td&gt;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;\r				&lt;td&gt;${item.detail }&lt;/td&gt;\r				&lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;\r			&lt;/tr&gt;\r		&lt;/c:forEach&gt;\r	&lt;/table&gt;\r&lt;/form&gt;</pre>\r\r<p>页面选中多个checkbox向controller方法传递，本身属于一个form表单，提交url是queryItem.action。</p>\r\r<p>示例代码（QueryVo）：</p>\r\r<pre class="brush:java;">\rpublic class QueryVo {\r\r	private Item item;\r	private Integer[] ids;\r}</pre>\r\r<p>示例代码（ItemController）：</p>\r\r<pre class="brush:java;">\r/**\r * 包装类型 绑定数组类型，可以使用两种方式，pojo的属性接收，和直接接收\r * \r * @param queryVo\r * @return\r */\r@RequestMapping(&quot;queryItem&quot;)\rpublic String queryItem(QueryVo queryVo, Integer[] ids) {\r\r	System.out.println(queryVo.getItem().getId());\r	System.out.println(queryVo.getItem().getName());\r\r	System.out.println(queryVo.getIds().length);\r	System.out.println(ids.length);\r\r	return &quot;success&quot;;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 36),
(1495, 'SpringMVC参数绑定——List类型', '1495', 1553317068, 1553317068, '<p>本文记录Java学习过程中遇到的SpringMVC参数绑定&mdash;&mdash;List类型～</p>\r<!--more-->\r\r<p>需求：实现商品数据的批量修改。</p>\r\r<p>分析实现：</p>\r\r<ul>\r	<li>在商品列表页面中可以对商品信息进行修改；</li>\r	<li>可以批量提交修改后的商品数据。</li>\r</ul>\r\r<p>示例代码（QueryVo）：</p>\r\r<pre class="brush:java;">\rpublic class QueryVo {\r\r	private Item item;\r	private Integer[] ids;\r	private List&lt;Item&gt; itemList;\r}</pre>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot; varStatus=&quot;s&quot;&gt;\r	&lt;tr&gt;\r		&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;${item.id}&quot;/&gt;&lt;/td&gt;\r		&lt;td&gt;\r			&lt;input type=&quot;hidden&quot; name=&quot;itemList[${s.index}].id&quot; value=&quot;${item.id }&quot;/&gt;\r			&lt;input type=&quot;text&quot; name=&quot;itemList[${s.index}].name&quot; value=&quot;${item.name }&quot;/&gt;\r		&lt;/td&gt;\r		&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemList[${s.index}].price&quot; value=&quot;${item.price }&quot;/&gt;&lt;/td&gt;\r		&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemList[${s.index}].createtime&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot;/&gt;&lt;/td&gt;\r		&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;itemList[${s.index}].detail&quot; value=&quot;${item.detail }&quot;/&gt;&lt;/td&gt;\r		&lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;\r	&lt;/tr&gt;\r&lt;/c:forEach&gt;</pre>\r\r<p>foreach标签常用的变量如下：</p>\r\r<ul>\r	<li>${current}：当前这次迭代的（集合中的）项；</li>\r	<li>${status.first}：判断当前项是否为集合中的第一项，返回值为true或false；</li>\r	<li>${status.last}：判断当前项是否为集合中的最后一项，返回值为true或false；</li>\r	<li>begin、end、step分别表示：起始序号，结束序号，跳跃步伐。</li>\r</ul>\r\r<p>varStatus属性常用参数总结下：</p>\r\r<ul>\r	<li>${status.index}：输出行号，从0开始；</li>\r	<li>${status.count}：输出行号，从1开始。</li>\r</ul>\r\r<p>注意：接收List类型的数据必须是pojo的属性，如果方法的形参为ArrayList类型无法正确接收到数据。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 33),
(1496, 'SpringMVC中的@RequestMapping注解', '1496', 1553317567, 1553317567, '<p>本文记录Java学习过程中遇到的SpringMVC中的@RequestMapping注解～</p>\r<!--more-->\r\r<p>通过@RequestMapping注解可以定义不同的处理器映射规则。</p>\r\r<p><strong>URL路径映射</strong></p>\r\r<pre class="brush:java;">\r@RequestMapping(value=&quot;item&quot;)或@RequestMapping(&quot;/item&quot;）</pre>\r\r<p>value的值是数组，可以将多个url映射到同一个方法</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 查询商品列表\r * @return\r */\r@RequestMapping(value = { &quot;itemList&quot;, &quot;itemListAll&quot; })\rpublic ModelAndView queryItemList() {\r	// 查询商品数据\r	List&lt;Item&gt; list = this.itemService.queryItemList();\r\r	// 创建ModelAndView,设置逻辑视图名\r	ModelAndView mv = new ModelAndView(&quot;itemList&quot;);\r\r	// 把商品数据放到模型中\r	mv.addObject(&quot;itemList&quot;, list);\r	return mv;\r}</pre>\r\r<p><strong>添加在类上面</strong></p>\r\r<p>在class上添加@RequestMapping(url)指定通用请求前缀，限制此类下的所有方法请求url必须以请求前缀开头。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Controller\r@RequestMapping(&quot;item&quot;)\rpublic class ItemController {\r	\r	@RequestMapping(value = {&quot;itemList&quot;, &quot;itemListAll&quot;})\r	public ModelAndView queryItemList() {\r		//查询代码等\r	}\r}</pre>\r\r<p><strong>请求方法限定</strong></p>\r\r<p>除了可以对url进行设置，还可以限定请求进来的方法。</p>\r\r<ul>\r	<li>限定GET方法：@RequestMapping(method = RequestMethod.GET)</li>\r</ul>\r\r<p>如果通过POST访问则报错：HTTP Status 405 - Request method &#39;POST&#39; not supported</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@RequestMapping(value = &quot;itemList&quot;,method = RequestMethod.POST)</pre>\r\r<ul>\r	<li>限定POST方法：@RequestMapping(method = RequestMethod.POST)</li>\r</ul>\r\r<p>如果通过GET访问则报错：HTTP Status 405 - Request method &#39;GET&#39; not supported</p>\r\r<ul>\r	<li>GET和POST都可以：@RequestMapping(method = {RequestMethod.GET,RequestMethod.POST})</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 44);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1497, 'SpringMVC的Controller方法返回值', '1497', 1553318268, 1553318268, '<p>本文记录Java学习过程中遇到的SpringMVC的Controller方法返回值～</p>\r<!--more-->\r\r<p><strong>返回ModelAndView</strong></p>\r\r<p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@RequestMapping(value = &quot;/item/itemlist.action&quot;)\rpublic ModelAndView itemList(){\r		\r	// 创建页面需要显示的商品数据\r	List&lt;Items&gt; list = new ArrayList&lt;Items&gt;();\r	list.add(new Items(1, &quot;1华为 荣耀8&quot;, 2399f, new Date(), &quot;质量好！1&quot;));\r	list.add(new Items(2, &quot;2华为 荣耀8&quot;, 2399f, new Date(), &quot;质量好！2&quot;));\r	list.add(new Items(3, &quot;3华为 荣耀8&quot;, 2399f, new Date(), &quot;质量好！3&quot;));\r	list.add(new Items(4, &quot;4华为 荣耀8&quot;, 2399f, new Date(), &quot;质量好！4&quot;));\r	list.add(new Items(5, &quot;5华为 荣耀8&quot;, 2399f, new Date(), &quot;质量好！5&quot;));\r	list.add(new Items(6, &quot;6华为 荣耀8&quot;, 2399f, new Date(), &quot;质量好！6&quot;));\r		\r	ModelAndView mav = new ModelAndView();\r	//数据\r	mav.addObject(&quot;itemList&quot;, list);\r	mav.setViewName(&quot;itemList&quot;);\r	return mav;\r}</pre>\r\r<p>返回void</p>\r\r<p>在Controller方法形参上可以定义request和response，使用request或response指定响应结果：</p>\r\r<ul>\r	<li>使用request转发页面</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rrequest.getRequestDispatcher(&quot;/WEB-INF/jsp/success.jsp&quot;).forward(request, response);</pre>\r\r<ul>\r	<li>通过response页面重定向</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rresponse.sendRedirect(&quot;/SpringMVC/itemEdit.action&quot;);</pre>\r\r<ul>\r	<li>通过response指定响应结果</li>\r</ul>\r\r<p>示例代码（返回json）：</p>\r\r<pre class="brush:java;">\rresponse.getWriter().print(&quot;{\\&quot;abc\\&quot;:123}&quot;);</pre>\r\r<p><strong>返回字符串</strong></p>\r\r<ul>\r	<li>逻辑视图名</li>\r</ul>\r\r<p>controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/itemList.jsp\rreturn &quot;itemList&quot;;</pre>\r\r<ul>\r	<li>Redirect重定向</li>\r</ul>\r\r<p>Contrller方法返回字符串可以重定向到一个url地址。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 更新商品\r * \r * @param item\r * @return\r */\r@RequestMapping(&quot;updateItem&quot;)\rpublic String updateItemById(Item item) {\r	// 更新商品\r	this.itemService.updateItemById(item);\r\r	// 修改商品成功后，重定向到商品编辑页面\r	// 重定向后浏览器地址栏变更为重定向的地址，\r	// 重定向相当于执行了新的request和response，所以之前的请求参数都会丢失\r	// 如果要指定请求参数，需要在重定向的url后面添加 ?itemId=1 这样的请求参数\r	return &quot;redirect:/itemEdit.action?itemId=&quot; + item.getId();\r}</pre>\r\r<ul>\r	<li>forward转发</li>\r</ul>\r\r<p>Controller方法执行后继续执行另一个Controller方法。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 更新商品\r * \r * @param item\r * @return\r */\r@RequestMapping(&quot;updateItem&quot;)\rpublic String updateItemById(Item item) {\r	// 更新商品\r	this.itemService.updateItemById(item);\r\r	// 修改商品成功后，继续执行另一个方法\r	// 使用转发的方式实现。转发后浏览器地址栏还是原来的请求地址，\r	// 转发并没有执行新的request和response，所以之前的请求参数都存在\r	return &quot;forward:/itemEdit.action&quot;;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 46),
(1499, 'exception.png', 'exception-png', 1553320712, 1553320712, 'a:5:{s:4:"name";s:13:"exception.png";s:4:"path";s:35:"/usr/uploads/2019/03/3340017305.png";s:4:"size";i:83780;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1500, 0),
(1500, 'SpringMVC异常处理器', '1500', 1553321021, 1553321021, '<p>本文记录Java学习过程中遇到的SpringMVC异常处理器～</p>\r<!--more-->\r\r<p>SpringMVC在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。</p>\r\r<p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p>\r\r<p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/03/3340017305.png" style="width: 800px; height: 674px;" /></p>\r\r<p>示例代码（自定义异常类）：</p>\r\r<pre class="brush:java;">\rpublic class MyException extends Exception {\r\r	private String message;\r\r	public MyException() {\r		super();\r	}\r\r	public MyException(String message) {\r		super();\r		this.message = message;\r	}\r\r	public String getMessage() {\r		return message;\r	}\r\r	public void setMessage(String message) {\r		this.message = message;\r	}\r}</pre>\r\r<p>示例代码（自定义异常处理器）：</p>\r\r<pre class="brush:java;">\rpublic class CustomHandleException implements HandlerExceptionResolver {\r\r	@Override\r	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,\r			Exception exception) {\r		// 定义异常信息\r		String msg;\r\r		// 判断异常类型\r		if (exception instanceof MyException) {\r			// 如果是自定义异常，读取异常信息\r			msg = exception.getMessage();\r		} else {\r			// 如果是运行时异常，则取错误堆栈，从堆栈中获取异常信息\r			Writer out = new StringWriter();\r			PrintWriter s = new PrintWriter(out);\r			exception.printStackTrace(s);\r			msg = out.toString();\r\r		}\r\r		// 把错误信息发给相关人员,邮件,短信等方式\r\r		// 返回错误页面，给用户友好页面显示错误信息\r		ModelAndView modelAndView = new ModelAndView();\r		modelAndView.addObject(&quot;msg&quot;, msg);\r		modelAndView.setViewName(&quot;error&quot;);\r\r		return modelAndView;\r	}\r}</pre>\r\r<p>示例代码（异常处理器配置-springmvc.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 配置全局异常处理器 --&gt;\r&lt;bean id=&quot;customHandleException&quot; class=&quot;cn.itcast.ssm.exception.CustomHandleException&quot;/&gt;</pre>\r\r<p>示例代码（错误页面）：</p>\r\r<pre class="brush:xml;">\r&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;\r	pageEncoding=&quot;UTF-8&quot;%&gt;\r&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\r&lt;html&gt;\r&lt;head&gt;\r&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\r&lt;title&gt;Insert title here&lt;/title&gt;\r&lt;/head&gt;\r&lt;body&gt;\r	&lt;h1&gt;系统发生异常了！&lt;/h1&gt;\r	&lt;br /&gt;\r	&lt;h1&gt;异常信息&lt;/h1&gt;\r	&lt;br /&gt;\r	&lt;h2&gt;${msg }&lt;/h2&gt;\r&lt;/body&gt;\r&lt;/html&gt;</pre>\r\r<p>示例代码（异常测试）：</p>\r\r<pre class="brush:java;">\r/**\r * 查询商品列表\r * \r * @return\r * @throws Exception\r */\r@RequestMapping(value = { &quot;itemList&quot;, &quot;itemListAll&quot; })\rpublic ModelAndView queryItemList() throws Exception {\r	// 自定义异常\r	if (true) {\r		throw new MyException(&quot;自定义异常出现了~&quot;);\r	}\r\r	// 运行时异常\r	int a = 1 / 0;\r\r	// 查询商品数据\r	List&lt;Item&gt; list = this.itemService.queryItemList();\r	// 创建ModelAndView,设置逻辑视图名\r	ModelAndView mv = new ModelAndView(&quot;itemList&quot;);\r	// 把商品数据放到模型中\r	mv.addObject(&quot;itemList&quot;, list);\r\r	return mv;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 46),
(1501, 'SpringMVC图片上传', '1501', 1553322838, 1553322838, '<p>本文记录Java学习过程中遇到的SpringMVC的图片上传～</p>\r<!--more-->\r\r<p>SpringMVC提供了图片上传的API，为了方便图片的存储，可以在Tomcat上先配置一个虚拟目录。</p>\r\r<p>示例代码（tomcat的conf/server.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;Context docBase=&quot;D:\\develop\\upload\\temp&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt;</pre>\r\r<p>这样就可以通过访问http://localhost:8080/pic来访问D:\\develop\\upload\\temp下的图片了。</p>\r\r<p><strong>添加jar包</strong></p>\r\r<p>文件上传需要两个jar包：</p>\r\r<pre class="brush:java;">\rcommons-fileupload-*.jar\rcommons-io-*.jar</pre>\r\r<p>示例代码（上传解析器：springmvc.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 文件上传,id必须设置为multipartResolver --&gt;\r&lt;bean id=&quot;multipartResolver&quot;\r	class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\r	&lt;!-- 设置文件上传大小 --&gt;\r	&lt;property name=&quot;maxUploadSize&quot; value=&quot;5000000&quot; /&gt;\r&lt;/bean&gt;</pre>\r\r<p>示例代码（前端页面）：</p>\r\r<pre class="brush:xml;">\r&lt;form id=&quot;itemForm&quot; action=&quot;${pageContext.request.contextPath }/updateItem.action&quot; enctype=&quot;nultipart/form-data&quot;&gt;\r	&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${item.id}&quot; /&gt;修改商品信息\r	&lt;table width=&quot;100%&quot; border=1&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品名称&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;${item.name}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品价格&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;${item.price}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品图片&lt;/td&gt;\r			&lt;td&gt;\r				&lt;c:if test=&quot;${item.pic != null}&quot;&gt;\r					&lt;img src=&quot;/pic/${item/pic}&quot; width=100% height=100% /&gt;\r					&lt;br/&gt;\r				&lt;/c:if&gt;\r				&lt;input type=&quot;file&quot; name=&quot;pictureFile&quot; /&gt;\r			&lt;/td&gt;\r		&lt;tr&gt;\r			&lt;td&gt;商品详情&lt;/td&gt;\r			&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;${item.detail}&quot; /&gt;&lt;/td&gt;\r		&lt;/tr&gt;\r	&lt;/table&gt;\r&lt;/from&gt;</pre>\r\r<p>示例代码（图片上传）：</p>\r\r<pre class="brush:java;">\r/**\r * 更新商品\r * \r * @param item\r * @return\r * @throws Exception\r */\r@RequestMapping(&quot;updateItem&quot;)\rpublic String updateItemById(Item item, MultipartFile pictureFile) throws Exception {\r	// 图片上传\r	// 设置图片名称，不能重复，可以使用uuid\r	String picName = UUID.randomUUID().toString();\r\r	// 获取文件名\r	String oriName = pictureFile.getOriginalFilename();\r	// 获取图片后缀\r	String extName = oriName.substring(oriName.lastIndexOf(&quot;.&quot;));\r\r	// 开始上传\r	pictureFile.transferTo(new File(&quot;C:/upload/image/&quot; + picName + extName));\r\r	// 设置图片名到商品中\r	item.setPic(picName + extName);\r	// ---------------------------------------------\r	// 更新商品\r	this.itemService.updateItemById(item);\r\r	return &quot;forward:/itemEdit.action&quot;;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 35),
(1502, 'SpringMVC使用JSON交互', '1502', 1553323675, 1553323675, '<p>本文记录Java学习过程中遇到的SpringMVC使用json交互～</p>\r<!--more-->\r\r<p><strong>@RequestBody注解</strong></p>\r\r<p>作用：</p>\r\r<ul>\r	<li>@RequestBody注解用于读取http请求的内容(字符串)，通过SpringMVC提供的HttpMessageConverter接口将读到的内容（json数据）转换为Java对象并绑定到Controller方法的参数上。</li>\r</ul>\r\r<p>传统的请求参数：</p>\r\r<pre class="brush:java;">\ritemEdit.action?id=1&amp;name=zhangsan&amp;age=12</pre>\r\r<p>现在的请求参数（使用POST请求，在请求体里面加入json数据）：</p>\r\r<pre class="brush:java;">\r{\r	&quot;id&quot;: 1,\r	&quot;name&quot;: &quot;测试商品&quot;,\r	&quot;price&quot;: 99.9,\r	&quot;detail&quot;: &quot;测试商品描述&quot;,\r	&quot;pic&quot;: &quot;123456.jpg&quot;\r}</pre>\r\r<p>@ResponseBody注解</p>\r\r<p>作用：</p>\r\r<ul>\r	<li>@ResponseBody注解用于将Controller的方法返回的对象，通过springmvc提供的HttpMessageConverter接口转换为指定格式的数据如：json，xml等，通过Response响应给客户端。</li>\r</ul>\r\r<p>添加Jar包</p>\r\r<pre class="brush:java;">\rjackson-annotations-*.jar\rjackson-core-*.jar\rjackson-databind-*.jar</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 测试json的交互\r * @param item\r * @return\r */\r@RequestMapping(&quot;testJson&quot;)\rpublic @ResponseBody Item testJson(@RequestBody Item item) {\r	return item;\r}</pre>\r\r<p>示例代码（配置json转换器：springmvc.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!--处理器适配器 --&gt;\r&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;\r	&lt;property name=&quot;messageConverters&quot;&gt;\r		&lt;list&gt;\r			&lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;\r		&lt;/list&gt;\r	&lt;/property&gt;\r&lt;/bean&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 56),
(1503, 'SpringMVC支持RestfulAPI', '1503', 1553324235, 1553324235, '<p>本文记录Java学习过程中遇到的SpringMVC支持RestfulAPI～</p>\r<!--more-->\r\r<p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>\r\r<p>资源：互联网所有的事物都可以被抽象为资源。</p>\r\r<p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作，分别对应 添加、 删除、修改、查询。</p>\r\r<p>传统方式操作资源：</p>\r\r<ul>\r	<li>http://127.0.0.1/item/queryItem.action?id=1：查询，GET；</li>\r	<li>http://127.0.0.1/item/saveItem.action：新增，POST；</li>\r	<li>http://127.0.0.1/item/updateItem.action：更新，POST；</li>\r	<li>http://127.0.0.1/item/deleteItem.action?id=1：删除，GET或POST。</li>\r</ul>\r\r<p>使用RESTful操作资源：</p>\r\r<ul>\r	<li>http://127.0.0.1/item/1：查询，GET；</li>\r	<li>http://127.0.0.1/item：新增，POST；</li>\r	<li>http://127.0.0.1/item：更新，PUT；</li>\r	<li>http://127.0.0.1/item/1：删除，DELETE。</li>\r</ul>\r\r<p><strong>从URL上获取参数</strong></p>\r\r<p>使用RESTful风格开发的接口，根据id查询商品，接口地址是：</p>\r\r<pre class="brush:java;">\rhttp://localhost:8080/springmvc/item/1</pre>\r\r<p>需要从url上获取商品id，步骤如下：</p>\r\r<ol>\r	<li>使用注解@RequestMapping(&quot;item/{id}&quot;)声明请求的url，{xxx}叫做占位符，请求的URL可以是&ldquo;item /1&rdquo;或&ldquo;item/2&rdquo;；</li>\r	<li>使用(@PathVariable() Integer id)获取url上的数据。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 使用RESTful风格开发接口，实现根据id查询商品\r * \r * @param id\r * @return\r */\r@RequestMapping(&quot;item/{id}&quot;)\r@ResponseBody\rpublic Item queryItemById(@PathVariable() Integer id) {\r	Item item = this.itemService.queryItemById(id);\r	return item;\r}</pre>\r\r<p>注意：如果@RequestMapping中表示为&quot;item/{id}&quot;，id和形参名称一致，@PathVariable不用指定名称。如果不一致，例如&quot;item/{ItemId}&quot;则需要指定名称@PathVariable(&quot;itemId&quot;)。</p>\r\r<p>注意两个区别：</p>\r\r<ol>\r	<li>@PathVariable是获取url上数据的，@RequestParam获取请求参数的（包括post表单提交）；</li>\r	<li>如果加上@ResponseBody注解，就不会走视图解析器，不会返回页面，目前返回的json数据。如果不加，就走视图解析器，返回页面。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 35),
(1504, 'SpringMVC拦截器', '1504', 1553324640, 1554281694, '<p>本文记录Java学习过程中遇到的SpringMVC拦截器～</p>\r<!--more-->\r\r<p>Spring Web MVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。</p>\r\r<p>示例代码（拦截器定义）：</p>\r\r<pre class="brush:java;">\rpublic class HandlerInterceptor1 implements HandlerInterceptor {\r	// controller执行后且视图返回后调用此方法\r	// 这里可得到执行controller时的异常信息\r	// 这里可记录操作日志\r	@Override\r	public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)\r			throws Exception {\r		System.out.println(&quot;HandlerInterceptor1....afterCompletion&quot;);\r	}\r\r	// controller执行后但未返回视图前调用此方法\r	// 这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示\r	@Override\r	public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)\r			throws Exception {\r		System.out.println(&quot;HandlerInterceptor1....postHandle&quot;);\r	}\r\r	// Controller执行前调用此方法\r	// 返回true表示继续执行，返回false中止执行\r	// 这里可以加入登录校验、权限拦截等\r	@Override\r	public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception {\r		System.out.println(&quot;HandlerInterceptor1....preHandle&quot;);\r		// 设置为true，测试使用\r		return true;\r	}\r}</pre>\r\r<p>示例代码（拦截器配置：springmvc.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 配置拦截器 --&gt;\r&lt;mvc:interceptors&gt;\r	&lt;mvc:interceptor&gt;\r		&lt;!-- 所有的请求都进入拦截器 --&gt;\r		&lt;mvc:mapping path=&quot;/**&quot; /&gt;\r		&lt;!-- 配置具体的拦截器 --&gt;\r		&lt;bean class=&quot;ren.oliver.ssm.interceptor.HandlerInterceptor1&quot; /&gt;\r	&lt;/mvc:interceptor&gt;\r	&lt;mvc:interceptor&gt;\r		&lt;!-- 所有的请求都进入拦截器 --&gt;\r		&lt;mvc:mapping path=&quot;/**&quot; /&gt;\r		&lt;!-- 配置具体的拦截器 --&gt;\r		&lt;bean class=&quot;ren.oliver.ssm.interceptor.HandlerInterceptor2&quot; /&gt;\r	&lt;/mvc:interceptor&gt;\r&lt;/mvc:interceptors&gt;</pre>\r\r<p>拦截器的执行顺序：</p>\r\r<ul>\r	<li>preHandle按拦截器定义顺序调用；</li>\r	<li>postHandler按拦截器定义逆序调用，在拦截器链内所有拦截器返回成功才调用；</li>\r	<li>afterCompletion按拦截器定义逆序调用，只有preHandle返回true才调用。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 60),
(1521, 'Oracle简介', '1521', 1554430857, 1554430857, '<p>本文记录Oracle学习过程中遇到的Oracle简介～</p>\r<!--more-->\r\r<p>Oracle数据库系统是美国ORACLE公司（甲骨文）提供的以分布式数据库为核心的一组软件产品，是目前最流行的C/S或B/S体系结构的数据库之一。</p>\r\r<p>Oracle数据库是目前世界上使用最为广泛的数据库管理系统。作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库，它实现了分布式处理功能。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 27),
(1505, '冒泡排序.jpg', '冒泡排序-jpg', 1553959044, 1553959044, 'a:5:{s:4:"name";s:16:"冒泡排序.jpg";s:4:"path";s:35:"/usr/uploads/2019/03/2181851257.jpg";s:4:"size";i:11102;s:4:"type";s:3:"jpg";s:4:"mime";s:10:"image/jpeg";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 596, 0),
(1522, 'Oracle结构体系.png', 'Oracle结构体系-png', 1554431816, 1554431816, 'a:5:{s:4:"name";s:22:"Oracle结构体系.png";s:4:"path";s:35:"/usr/uploads/2019/04/1520856043.png";s:4:"size";i:652954;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1523, 0),
(1523, 'Oracle体系结构', '1523', 1554431831, 1554431831, '<p>本文记录Oracle学习过程中遇到的Oracle体系结构～</p>\r<!--more-->\r\r<p><strong>数据库（DataBase）</strong></p>\r\r<p>Oracle数据库是数据的物理存储，包括数据文件（ORA或者DBF）、控制文件、联机日志和参数文件。Oracle数据库的概念和其他数据库不一样，这里的数据库是一个操作系统只有一个库，可以看作是Oracle就只有一个大数据库。</p>\r\r<p><strong>实例</strong></p>\r\r<p>一个Oracle实例（Instance）有一系列的后台进程（Background Process）和内存结构（Memory Structure）组成，一个数据库可以有多个实例。</p>\r\r<p><strong>数据文件（DBF）</strong></p>\r\r<p>数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的，真正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入某个表空间后，就不能删除；如果要删除某个数据文件，只能删除其所属的表空间。</p>\r\r<p><strong>表空间</strong></p>\r\r<p>表空间是Oracle对物理数据库上相关数据文件（ORA或DBF）的逻辑映射。一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构，每个数据库至少有一个表空间。</p>\r\r<p><strong>用户</strong></p>\r\r<p>用户是在实例下建立的，不同实例中可以建相同名字的用户。表的数据，是由用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。</p>\r\r<p>由于Oracle数据库不是普通的概念，Oracle是由用户和表空间对数据进行管理和存放的。但是表不是由表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立统一个名字的表，所以这就需要区分用户了。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/1520856043.png" style="width: 800px; height: 664px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 21),
(1524, 'Oracle查询语句——基本查询', '1524', 1554433274, 1554433274, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;基本查询～</p>\r<!--more-->\r\r<p>语句格式：</p>\r\r<pre class="brush:sql;">\rselect *|{[distinct] column|expression [alias],...} from table;</pre>\r\r<p>示例代码（查询所有列）：</p>\r\r<pre class="brush:sql;">\rselect * from emp;</pre>\r\r<p>示例代码（别名）：</p>\r\r<pre class="brush:sql;">\rselect empno 部门编号, ename 部门名称 from emp;</pre>\r\r<p>示例代码（消除重复数据）：</p>\r\r<pre class="brush:sql;">\rselect distinct job from emp;</pre>\r\r<p>示例代码（四则运算）：</p>\r\r<pre class="brush:sql;">\rselect ename, sal*12 from emp;\rselect ename, sal*12, income from emp;</pre>\r\r<p><strong>空值</strong></p>\r\r<ul>\r	<li>空值是无效的、未指定的、未知的或不可预知的值；</li>\r	<li>空值不是空格，也不是0；</li>\r	<li>包含null的表达式都为null；</li>\r	<li>空值永远不等于空值。</li>\r</ul>\r\r<p><strong>连接符||</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rselect &#39;编号是：&#39; || empno || &#39;的雇员，姓名是：&#39; || ename || &#39;，工作是：&#39; || job from emp;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 29),
(1525, 'Oracle查询语句——条件查询', '1525', 1554434460, 1554434609, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;条件查询～</p>\r\r<!--more-->\r\r<p>语句格式：</p>\r\r<pre class="brush:sql;">\rselect *|{[distinct] column|expression [alias],...} from table [where condition(s)];</pre>\r\r<p>比较运算符</p>\r\r<ul>\r	<li>=：等于，注意不是==；</li>\r	<li>&gt;：大于；</li>\r	<li>&gt;=：大于等于；</li>\r	<li>&lt;：小于；</li>\r	<li>&lt;=：小于等于；</li>\r	<li>&lt;&gt;或!=：不等于；</li>\r	<li>between ... and ...：在两个值之间，包含边界；</li>\r	<li>in (set)：等于值列表中的一个；</li>\r	<li>like：模糊查询；</li>\r	<li>is null：是否为空值。</li>\r</ul>\r\r<p>逻辑运算符</p>\r\r<ul>\r	<li>and：逻辑并；</li>\r	<li>or：逻辑或；</li>\r	<li>not：逻辑否。</li>\r</ul>\r\r<p>模糊查询的两种通配符：</p>\r\r<ul>\r	<li>%：可以匹配任意长度的内容；</li>\r	<li>_：可以匹配一个长度的内容。</li>\r</ul>\r\r<p>示例代码（空与非空）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where comm is null;\rselect * from emp where comm is not null;</pre>\r\r<p>实例代码（逻辑并）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where comm is not null and sal &gt; 1500;</pre>\r\r<p>示例代码（逻辑或）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where comm is null or sal &gt; 1500;</pre>\r\r<p>示例代码（逻辑非）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where comm is null and not (sal &gt; 1500);</pre>\r\r<p>示例代码（范围限制）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where sal between 1500 and 3000;\rselect * from emp where hiredate between &#39;1-1月-1981&#39; and &#39;31-12月-1981&#39;;</pre>\r\r<p>示例代码（等于）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where ename = &#39;smith&#39;;</pre>\r\r<p>示例代码（范围查询）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where empno in (7369, 7499, 7521);\rselect * from emp where ename in (&#39;SMITH&#39;, &#39;ALLEN&#39;, &#39;WARD&#39;);</pre>\r\r<p>示例代码（模糊查询）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where ename like &#39;_M%&#39;;\rselect * from emp where ename like &#39;%&#39;;\rselect * from emp where ename like &#39;%M%&#39;;</pre>\r\r<p>示例代码（不等于）：</p>\r\r<pre class="brush:sql;">\rselect * from emp where empno &lt;&gt; 7369;\rselect * from emp where empno != 7369;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24),
(1528, 'Oracle查询语句——条件表达式', '1528', 1554447183, 1554447183, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;条件表达式～</p>\r<!--more-->\r\r<p>条件表达式：在SQL语句中使用if-then-else。</p>\r\r<p>两种实现方式：</p>\r\r<ul>\r	<li>case表达式：SQL99的语法，类似Basic，比较繁琐；</li>\r	<li>decode函数：Oracle自己的语法，类似Java，比较简洁。</li>\r</ul>\r\r<p>case表达式语法格式：</p>\r\r<pre class="brush:sql;">\rcase expr when comparison_expr1 then return_expr1\r	[when comparison_expr2 then return_expr2\r	 when comparison_exprn then return_exprn\r	 else else_expr]\rend</pre>\r\r<p>decode函数语法格式：</p>\r\r<pre class="brush:sql;">\rdecode(col|expression, search1, result1\r	[, search2, result2, ...,]\r	[, default])</pre>\r\r<p>示例代码（根据10号部分员工的工资，显示税率）：</p>\r\r<pre class="brush:sql;">\rselect ename, sal\r	decode (trunc(sal/2000, 0),\r		0, 0.00,\r		1, 0.09,\r		2, 0.20,\r		3, 0.30,\r		4, 0.40,\r		5, 0.42,\r		6, 0.44,\r		   0.45) TAX_RATE\rfrom emp\rwhere deptno = 10;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1529, 'Oracle查询语句——多行函数', '1529', 1554447578, 1554447578, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;多行函数～</p>\r<!--more-->\r\r<p>多行函数：作用于一组数据，并对一组数据返回一个值。也叫做组函数或者分组函数。组函数会忽略空值，但nvl函数可以使分组函数无法忽略空值。</p>\r\r<p>常用的多行函数：</p>\r\r<ul>\r	<li>avg：平均值；</li>\r	<li>count：统计总数；</li>\r	<li>max：取最大值；</li>\r	<li>min：取最小值；</li>\r	<li>sum：求和。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rselect count(*) from emp;\rselect count(ename) from emp;\rselect min(sal) from emp;\rselect max(sal) from emp;\rselect avg(sal) from emp;\rselect sum(sal) from emp e where e.deptno = 20;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 32),
(1530, 'Oracle查询语句——分组', '1530', 1554448153, 1554448153, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;分组～</p>\r<!--more-->\r\r<p>分组数据的语法格式：</p>\r\r<pre class="brush:sql;">\rselect column, group_function(column)\rfrom table\r[where condition]\r[group by group_by_expression]\r[order by colume];</pre>\r\r<p>示例代码（查询每个部门的人数）：</p>\r\r<pre class="brush:sql;">\rselect deptno, count(ename) from emp group by deptno;</pre>\r\r<p>示例代码（查询每个部门的平均工资）：</p>\r\r<pre class="brush:sql;">\rselect deptno, avg(sal) from emp group by deptno;</pre>\r\r<p>示例代码（过滤分组函数）：</p>\r\r<pre class="brush:sql;">\rselect deptno, avg(sal) from emp group by deptno having avg(sal) &gt; 2000;</pre>\r\r<p>注意：where与having的最大的区别是，where后面不能有组函数。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 27),
(1531, 'Oracle查询语句——多表查询', '1531', 1554449283, 1554449283, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;多表查询～</p>\r<!--more-->\r\r<p>Oracle连接条件的类型：</p>\r\r<ul>\r	<li>等值连接；</li>\r	<li>不等值连接；</li>\r	<li>外连接；</li>\r	<li>自连接。</li>\r</ul>\r\r<p><strong>自连接</strong></p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rselect {distinct} *|column... from table1 as t1, table2 as t2\r{where expression order by order_express asc|desc...}</pre>\r\r<p>示例代码（全连接）：</p>\r\r<pre class="brush:sql;">\rselect * from emp, dept;</pre>\r\r<p>示例代码（等值连接）：</p>\r\r<pre class="brush:sql;">\rselect * from emp, dept where emp.deptno = dept.deptno;\rselect * from emp e, dept d where e.deptno = d.deptno;\rselect e.empno, e.ename, d.deptno, d.dname, d.loc from emp e, dept d where e.deptno = d.deptno;\rselect e1.epmno,e1.ename,e2.empno,e2.ename from epm e1, emp e2 where e1.mgr = e2.empno;\rselect e1.empno, e1.ename, e2.empno, e2.ename, d.dname from emp e1, emp e2, dept d where e1.mgr = e2.empno and e1.deptno = d.deptno;</pre>\r\r<p>外连接（左右连接）</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rselect e.empno, e.ename, d.deptno, d.dname from emp e, dept d where e.deptno(+) = d.deptno;\rselect e.empno, e.ename, m.empno, m.ename from emp e, emp m where e.mgr = m.empno(+);\rselect e.deptno, e.ename, m.deptno, m.ename from emp e left join emp m on e.mgr = m.empno;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 31),
(1532, 'Oracle查询语句——子查询', '1532', 1554538007, 1554538007, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;子查询～</p>\r<!--more-->\r\r<p>基本语法格式：</p>\r\r<pre class="brush:sql;">\rselect select_list\rfrom table\rwhere expr operator\r	(select select_list\r	from table);</pre>\r\r<p>注意：</p>\r\r<ul>\r	<li>子查询（内查询）在主查询之前一次执行完成；</li>\r	<li>子查询的结果被主查询使用（外查询）。</li>\r</ul>\r\r<p>子查询的类型：</p>\r\r<ul>\r	<li>单行子查询；</li>\r	<li>多行子查询。</li>\r</ul>\r\r<p><strong>单行子查询</strong></p>\r\r<p>只返回一条记录。</p>\r\r<p>常用的单行操作符：</p>\r\r<ul>\r	<li>=：等于；</li>\r	<li>&gt;：大于</li>\r	<li>&gt;=：大于等于；</li>\r	<li>&lt;：小于</li>\r	<li>&lt;=：小于等于；</li>\r	<li>&lt;&gt;：不等于。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rselect ename, job, sal\rfrom emp\rwhere job = \r	(select job\r	from emp\r	where empno = 7566)\rand sal &gt;\r	(select sal\r	from emp\r	where epmno = 7782);\r\rselect ename, job, sal\rfrom emp\rwhere sal = \r(select min(sal)\rfrom emp);\r\rselect deptno, min(sal)\rfrom emp\rgroup by deptno\rhaving min(sal) &gt;\r	(select min(sal)\r	from emp\r	where deptno = 10);\r\rselect d.dname, a,minsal, e.ename\rfrom dept d, \r(select deptno, min(sal) minsal from emp group by deptno) a,\remp e\rwhere d.deptno = a.deptno and e.sal = a.minsal;</pre>\r\r<p><strong>多行子查询</strong></p>\r\r<p>返回多条记录。</p>\r\r<p>常用多行操作符：</p>\r\r<ul>\r	<li>in：等于列表中的任何一个；</li>\r	<li>any：和子查询返回的任意一个值比较；</li>\r	<li>all：和子查询返回的所有值比较。</li>\r</ul>\r\r<p><strong>子查询中的null值问题</strong></p>\r\r<p>示例代码（单行子查询中的null）：</p>\r\r<pre class="brush:sql;">\rselect ename, job\rfrom emp\rwhere job =\r(select job\rfrom emp\rwhere ename = &#39;Mike&#39;);</pre>\r\r<p>示例代码（多行子查询中的null）：</p>\r\r<pre class="brush:sql;">\rselect *\rfrom emp\rwhere empno not in\r	(select mgr\r	from emp\r	where mgr is not null);</pre>\r\r<p>注意：not in后面的列表中不能有null。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 21),
(1533, 'Oracle查询语句——集合运算', '1533', 1554540316, 1554540316, '<p>本文记录Oracle学习过程中遇到的Oracle查询语句&mdash;&mdash;集合运算～</p>\r<!--more-->\r\r<p>常见集合运算：</p>\r\r<ul>\r	<li>并集：union运算符返回两个集合去掉重复元素后的所有记录；union all返回两个集合的所有记录，包括重复的；</li>\r	<li>交集：intersect运算符返回同时属于两个集合的记录；</li>\r	<li>差集：minus运算符返回属于第一个集合，但不属于第二个集合的记录。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24),
(1534, 'Oracle的DDL语句', '1534', 1554543454, 1554543454, '<p>本文记录Oracle学习过程中遇到的Oracle的DDL语句～</p>\r<!--more-->\r\r<p><strong>创建表空间</strong></p>\r\r<p>表空间是Oracle的逻辑单元。一个表空间可以与多个数据文件（物理结构）关联，一个数据库下可以建立多个表空间，一个表空间可以建立多个用户，一个用户可以建立多个表。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate tablespace spacename\rdatafile &#39;/home/work/data/spacename001.dbf&#39;\rsize 100m\rautoextend on\rnext 10m;</pre>\r\r<p>常用参数：</p>\r\r<ul>\r	<li>spacename：表空间名称；</li>\r	<li>datafile：表空间对应的数据文件；</li>\r	<li>size：表空间的初始大小；</li>\r	<li>autoextend on：当表空间存储都占满时自动增长；</li>\r	<li>next：一次自动增长的大小。</li>\r</ul>\r\r<p><strong>用户相关操作</strong></p>\r\r<p>创建用户</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate user username\ridentified by password\rdefault tablespace spacename;</pre>\r\r<p>常用参数：</p>\r\r<ul>\r	<li>username：用户名；</li>\r	<li>password：用户的密码；</li>\r	<li>spacename：默认的表空间名称。</li>\r</ul>\r\r<p>注意：Oracle数据库与其他数据库产品的区别在于，表和其它的数据库对象都是存储在用户下的。</p>\r\r<p>用户权限管理</p>\r\r<p>Oracle中三个重要的角色：</p>\r\r<ul>\r	<li>connect角色；</li>\r	<li>resource角色；</li>\r	<li>dba角色。</li>\r</ul>\r\r<p>connect角色是最终授予用户的典型权利，也是最基本的，主要包括：</p>\r\r<ul>\r	<li>alter session：修改会话；</li>\r	<li>create cluster：建立聚簇；</li>\r	<li>create database link：建立数据库连接；</li>\r	<li>create sequence：建立序列；</li>\r	<li>create session：建立会话；</li>\r	<li>create synonym：建立同义词；</li>\r	<li>create view：建立视图。</li>\r</ul>\r\r<p>resource角色是授予开发人员的，主要包括：</p>\r\r<ul>\r	<li>create cluster：建立聚簇；</li>\r	<li>create procedure：建立过程；</li>\r	<li>create sequence：建立序列；</li>\r	<li>create table：建表；</li>\r	<li>create trigger：建立触发器；</li>\r	<li>create type：建立类型。</li>\r</ul>\r\r<p>dba角色拥有全部特权，是系统最高权限，只有dba才可以创建数据库结构，并且系统权限也需要dba授出，dba用户可以操作全体用户的任意表，包括删除。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rgrant dba to oliver;</pre>\r\r<p>注意：进入system用户下才可以给用户赋予dba权限，否则无法正常登录。</p>\r\r<p>创建表</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate table [schema.] table\r(column datatype [default expr][, ...]);</pre>\r\r<p>常见的数据类型：</p>\r\r<ul>\r	<li>varchar2(size)：可变长字符数据；</li>\r	<li>char(size)：定长字符数据；</li>\r	<li>number(p,s)：可变长数值数据；</li>\r	<li>date：日期型数据；</li>\r	<li>long：可变长字符数据，最大可达到2G；</li>\r	<li>clob：字符数据，最大可达到4G；</li>\r	<li>raw and long raw：原始的二进制数据；</li>\r	<li>blob：二进制数据，最大可达到4G；</li>\r	<li>bfile：存储外部文件的二进制数据，最大可达到4G；</li>\r	<li>rowid：行地址。</li>\r</ul>\r\r<p>使用子查询创建表的语法格式：</p>\r\r<pre class="brush:sql;">\rcreate table tablename [(column, column...)] as subquery;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate table person (pid number(10), name varchar2(10), gender number(1) default 1, birthday date);\rinsert into person(pid, name, gender, birthday) values(1, &#39;oliver&#39;, 1, to_date(&#39;2018-04-06&#39;, &#39;yyyy-MM-dd&#39;));</pre>\r\r<p>修改表</p>\r\r<p>常见的修改表操作有：</p>\r\r<ul>\r	<li>添加字段：alter table tablename add (columnname datatype default value, ...)；</li>\r	<li>修改字段：alter table tablename modify (columnname datatype default value, ...)；</li>\r	<li>修改列名：alter table tablename rename column old to new；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\ralter table person add(address varchar2(10));\ralter table person modify(address varchar2(20));\ralter table person rename column name to username;</pre>\r\r<p>删除表</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rdrop table tablename;</pre>\r\r<p><strong>约束</strong></p>\r\r<p>常见的约束类型有：</p>\r\r<ul>\r	<li>主键约束：primary key；</li>\r	<li>非空约束：not null；</li>\r	<li>唯一约束：unique；</li>\r	<li>外键约束：foreign key；</li>\r	<li>检查性约束：check。</li>\r</ul>\r\r<p>主键约束</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate table person(\r	pid number(10) primary key,\r	name varchar2(10),\r	gender number(1) default 1,\r	birthday date\r);\r\rcreate table person(\r	pid number(10),\r	name varchar2(10),\r	gender number(1) default 1,\r	birthday date,\r	constraint person_pk_pid primary key(pid)\r);</pre>\r\r<p>注意：主键不能重复。</p>\r\r<p>非空约束</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate table person(\r	pid number(10) not null,\r	name varchar2(10) not null,\r	gender number(1) default 1,\r	birthday date\r);</pre>\r\r<p>唯一约束</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate table person(\r	pid number(10),\r	name varchar2(10) unique,\r	gender number(1) default 1,\r	birthday date\r);\r\rcreate table person(\r	pid number(10),\r	name varchar2(10),\r	gender number(1) default 1,\r	birthday date,\r	constraint person_uk_name unique(name)\r);</pre>\r\r<p>检查约束</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate table person(\r	pid number(10),\r	name varchar2(10),\r	gender number(1) check(gender in (1,2)),\r	birthday date\r);\r\rcreate table person(\r	pid number(10),\r	name varchar2(10),\r	gender number(1),\r	birthday date,\r	constraint person_ck_gender check(gender in (1,2))\r);</pre>\r\r<p>外键约束</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate table orders(\r	order_id number(10),\r	total_price number(10,2),\r	order_time date,\r	constraint orders_pk_order_id primary key(order_id)\r);\r\rcreate table order_detail(\r	detail_id number(10),\r	order_id number(10),\r	item_name varchar2(10),\r	quantity number(10),\r	constraint order_detail_pk_detail_id primary key(detail_id),\r	constraint order_detail_fk_order_id foreign key(order_id) references orders(order_id)\r);</pre>\r\r<p>注意：</p>\r\r<ul>\r	<li>外键一定是主表的主键；</li>\r	<li>一定要先删除子表再删除主表；</li>\r	<li>可以强制删除主表，但不推荐（drop table orders cascade constraint）；</li>\r	<li>级联删除可以在外键约束上加上on delete cascade。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 26),
(1535, '事务保存点.png', '事务保存点-png', 1554544248, 1554544248, 'a:5:{s:4:"name";s:19:"事务保存点.png";s:4:"path";s:33:"/usr/uploads/2019/04/46548768.png";s:4:"size";i:267139;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1536, 0),
(1536, 'Oracle的DML语句', '1536', 1554544268, 1554544268, '<p>本文记录Oracle学习过程中遇到的Oracle的DML语句～</p>\r<!--more-->\r\r<p><strong>插入数据</strong></p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rinsert into tablename[(column, ...)] values(value, ...);</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rinsert into person(pid, name, gender birthday, address) values(1, &#39;张三&#39;, 1, &#39;9-5月-1988&#39;, &#39;北京海淀&#39;);\rinsert into person values(1, &#39;张三&#39;, 1, &#39;9-5月-1988&#39;, &#39;北京海淀&#39;);</pre>\r\r<p>注意：可以使用简单写法，但是如果有为空的字段需要使用null。</p>\r\r<p><strong>更新数据</strong></p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rupdate tablename set column = value[, ...] [where condition];</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rupdate emp set sal=sal+100 where deptno in (select deptno from dept where loc=&#39;NEW YORK&#39;);</pre>\r\r<p><strong>删除数据</strong></p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rdelete from tablename where condition;</pre>\r\r<p>truncate与delete的区别：</p>\r\r<ul>\r	<li>delete删除的数据可以rollback，也可以闪回；</li>\r	<li>delete删除可能产生碎片，并且不能释放空间；</li>\r	<li>truncate是先摧毁表结构，再重构表结构。</li>\r</ul>\r\r<p><strong>事务相关</strong></p>\r\r<p>常用的操作语句：</p>\r\r<ul>\r	<li>commit：提交；</li>\r	<li>rollback：回滚。</li>\r</ul>\r\r<p>Oracle中事务的保存点：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/46548768.png" style="width: 800px; height: 359px;" />​</p>\r\r<p>Oracle支持三种事务隔离级别：read commited, serializable, read only。默认的隔离级别是read commited。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 23),
(1537, 'Oracle数据库对象——视图', '1537', 1554546291, 1554546291, '<p>本文记录Oracle学习过程中遇到的Oracle数据库对象&mdash;&mdash;视图～</p>\r<!--more-->\r\r<p>视图就是封装了一条复杂查询的语句，它是一个虚表，最大的优点就是简化复杂的查询。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate [or replace] [force|noforce] view viewname\r[(alias[, alisa]...)]\ras subquery\r[with check option [constraint constraint]]\r[with read only [constraint constraint]];</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate view empvd20 as select * from emp e where e.deptno = 20;\rcreate or replace view empvd20 as select * from emp e where e.deptno = 20;</pre>\r\r<p>注意：不建议通过视图对表中的数据进行修改，因为会受到很多限制。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 23),
(1538, 'Oracle数据库对象——序列', '1538', 1554546780, 1554546809, '<p>本文记录Oracle学习过程中遇到的Oracle数据库对象&mdash;&mdash;序列～</p>\r<!--more-->\r\r<p>在很多数据库中都存在一个自动增长的列。在Oracle中完成自动增长的功能只能依靠序列，所有的自动增长操作都需要用户手工处理，并且Oracle将序列的值装入内存来提高访问效率。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate sequence sequencename\r	[increment by n]\r	[start with n]\r	[{maxvalue n|nomaxvalue}]\r	[{minvalue n|nominvalue}]\r	[{cycle|nocycle}]\r	[{cache n|nochache}];</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate sequence dept_deptid_seq\r	increment by 10\r	start with 120\r	maxvalue 9999\r	nochache\r	nocycle;</pre>\r\r<p>序列提供了两种操作：</p>\r\r<ul>\r	<li>nextval：下一个；</li>\r	<li>currval：当前内容。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rinsert into person values(dept_deptid_seq.nextval, &#39;oliver&#39;, 1, null, &#39;北京&#39;);</pre>\r\r<p>序列有可能产生裂缝，原因有：</p>\r\r<ul>\r	<li>回滚；</li>\r	<li>系统异常；</li>\r	<li>多个表共用一个序列。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 21),
(1539, 'Oracle数据库对象——索引', '1539', 1554547294, 1554547294, '<p>本文记录Oracle学习过程中遇到的Oracle数据库对象&mdash;&mdash;索引～</p>\r<!--more-->\r\r<p>索引是用于加速数据存取的数据对象，合理的使用索引可以大大降低IO次数，从而提高数据访问性能。</p>\r\r<p><strong>单列索引</strong></p>\r\r<p>单列索引是基于单个列所建立的索引。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate index indexname on tablename(columnname);</pre>\r\r<p><strong>复合索引</strong></p>\r\r<p>复合索引是基于两个列或多个列的索引。在同一张表上可以有多个索引，但是要求列的组合必须不同。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate index indexname on tablename(columnname1, columnname2);</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate index index_pname on person(name);\rcreate index index_pname_index on person(name, gender);</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24),
(1540, 'Oracle数据库对象——同义词', '1540', 1554547504, 1554547504, '<p>本文记录Oracle学习过程中遇到的Oracle数据库对象&mdash;&mdash;同义词～</p>\r<!--more-->\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate [public] synonym synonymname for object;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate public synonym emp for scott.emp;\rselect * from emp;\rdrop public synonym emp;</pre>\r\r<p>同义词的作用：</p>\r\r<ul>\r	<li>方便访问其他用户的数据库对象；</li>\r	<li>缩短了对象名字的长度。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 23),
(1541, 'PL/SQL简介和语法', '1541', 1554548400, 1554548438, '<p>本文记录Oracle学习过程中遇到的PL/SQL简介和语法～</p>\r<!--more-->\r\r<p>PL/SQL（Procedure Language/SQL）是Oracle对SQL语言的过程化扩展，指在SQL命令语言中增加了过程处理语句（如分支和循环等），使SQL语言具有过程处理能力。把SQL语言的数据操纵能力与过程语言的数据处理能力结合起来，使得PL/SQL面向过程，但比过程语言简单、高效、灵活和实用。</p>\r\r<p>PL/SQL的语法格式：</p>\r\r<pre class="brush:sql;">\rdeclare\r	说明部分（变量定义、光标申明和例外说明）\rbegin\r	语句序列（DML语句）\rexception\r	例外处理语句\rend;\r/</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 26);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1542, 'PL/SQL常量和变量', '1542', 1554548880, 1554548936, '<p>本文记录Oracle学习过程中遇到的PL/SQL常量和变量～</p>\r<!--more-->\r\r<p><strong>说明变量</strong></p>\r\r<p>常见格式：</p>\r\r<ul>\r	<li>char;</li>\r	<li>varchar2;</li>\r	<li>date;</li>\r	<li>number;</li>\r	<li>boolean;</li>\r	<li>long.</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rvar char(15);</pre>\r\r<p><strong>引用变量</strong></p>\r\r<p>指新定义的变量的类型与旧表中的列的类型一样。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rmyname emp.ename%type;</pre>\r\r<p><strong>记录型变量</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rdeclare\r	p emp%rowtype;\rbegin\r	select * into p from emp t where t.empno = 7369;\r	dbms_output.put_line(p.ename || &#39;   &#39; || p.sal);\rend;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 25),
(1543, 'PL/SQL的if语句', '1543', 1554556929, 1554556929, '<p>本文记录Oracle学习过程中遇到的PL/SQL的if语句～</p>\r<!--more-->\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rif 条件 then 语句1;\r语句2;\rend if;\r\rif 条件 then 语句序列1;\relse 语句序列2;\rend if;\r\rif 条件 then 语句;\relsif 语句 then 语句;\relse 语句\rend if;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rdeclare\r	pnum number := &amp;num;\rbegin\r	if pnum = 1 then\r		dbms_output.put_line(&#39;我是1&#39;);\r	end if;\rend;\r\rdeclare\r	mynum number := &amp;num;\rbegin\r	if mynum = 1 then\r		dbms_output.put_line(&#39;我是1&#39;);\r	else\r		dbms_output.put_line(&#39;我不是1&#39;);\r	end if;\rend;\r\rdeclare\r	mynum number := &amp;num;\rbegin\r	if mynum &lt; 18 then\r		dbms_output.put_line(&#39;未成年人&#39;);\r	elsif mynum &gt;= 18 and mynum &lt; 40 then\r		dbms_output.put_line(&#39;中年人&#39;);\r	elsif mynum &gt;= 40 then\r		dbms_output.put_line(&#39;老年人&#39;);\r	end if;\rend;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 26),
(1544, 'PL/SQL的循环', '1544', 1554557378, 1554557378, '<p>本文记录Oracle学习过程中遇到的PL/SQL的循环～</p>\r<!--more-->\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rwhile total &lt;= 25000\rloop\r	total := total + 100;\rend loop;\r\rloop\r	exit [when a &gt; b];\rend loop;\r\rfor i in a..b\rloop\r	expression;\rend loop;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rdeclare\r	step number := 1;\rbegin\r	while step &lt;= 10\r	loop\r		dbms_output.put_line(step);\r		step := step + 1;\r	end loop;\rend;\r\rdeclare\r	step number := 1;\rbegin\r	loop\r		exit when step &gt; 10;\r		dbms_output.put_line(step);\r		step := step + 1;\r	end loop\rend;\r\rdeclare\r	step number := 1;\rbegin\r	for step in 1 .. 10\r	loop\r		dbms_output.put_line(step);\r	end loop;\rend;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 29),
(1545, 'PL/SQL的游标', '1545', 1554558076, 1554558076, '<p>本文记录Oracle学习过程中遇到的PL/SQL的游标～</p>\r<!--more-->\r\r<p>在写Java程序的时候，有实用ResultSet集合，在PL/SQL中也会用到多条记录，这时就需要使用游标，游标可以存储查询返回的多条数据。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcursor cursorname [(column type, ....)] is select ...;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcursor c is select ename from emp;</pre>\r\r<p>使用步骤：</p>\r\r<ul>\r	<li>打开游标：open c；</li>\r	<li>取一行数据：fetch c into var;</li>\r	<li>关闭游标：close c;</li>\r	<li>游标的结束方式：exit when c%notfound。</li>\r</ul>\r\r<p>注意：存储游标的取值的变量必须与查询中使用的变量的类型一致。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rdeclare\r	cursor pc is select * from emp;\r	pemp emp%rowtype;\rbegin\r	open pc;\r	loop\r		fetch pc into pemp;\r		exit when pc%notfound;\r		dbms_output.put_line(pemp.empno || &#39;   &#39; || pemp.ename);\r	end loop;\r	close pc;\rend;\r\rdeclare\r	cursor pc(dno myemp.deptno%type) is select empno from myemp where deptno = dno;\r	pno myemp.empno%type;\rbegin\r	open pc(20);\r	loop\r		fetch pc into pno;\r		exit when pc%notfound;\r		update myemp t set t.sal = t.sal + 1000 where t.empno = pno;\r	end loop;\r	close pc;\rend;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 27),
(1546, 'PL/SQL的例外', '1546', 1554559769, 1554559769, '<p>本文记录Oracle学习过程中遇到的PL/SQL的例外～</p>\r<!--more-->\r\r<p>例外，即异常，是程序设计语言提供的一种功能，用来增强程序的健壮性和容错性。</p>\r\r<p>系统定义异常</p>\r\r<ul>\r	<li>no_data_found：没有找到数据；</li>\r	<li>too_many_rows：select-into语句匹配多个行；</li>\r	<li>zero_divide：被0除；</li>\r	<li>value_error：算术或转换错误；</li>\r	<li>timeout_on_resource：在等待资源时发生超时。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rdeclare\r	pnum number;\rbegin\r	pnum := 1/0;\rexception\r	when zero_divide then\r		dbms_output.put_line(&#39;被0除&#39;);\r	when value_error then\r		dbms_output.put_line(&#39;数值转换错误&#39;);\r	when others then\r		dbms_output.put_line(&#39;其他错误&#39;);\rend;</pre>\r\r<p>自定义异常</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rxxx exception;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rdeclare\r	no_emp_found exception;\r	cursor pemp is select t.ename from emp t where t.deptno = 50;\r	pename emp.ename%type;\rbegin\r	open pemp;\r	fetch pemp into pename;\r	if pemp%notfound then\r		raise no_emp_found;\r	end if;\r	close pemp;\rexception\r	when no_emp_found then\r		dbms_output.put_line(&#39;没有找到员工&#39;);\r	when others then\r		dbms_output.put_line(&#39;其他错误&#39;);\rend;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 26),
(1547, 'Oracle存储过程', '1547', 1554560270, 1554560270, '<p>本文记录Oracle学习过程中遇到的存储过程～</p>\r<!--more-->\r\r<p>存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate [or replace] procedure procedurename[(var in/out type)]\ras\rbegin\r	pl/sqls;\rend;\r\rcreate [or replace] procedure procedurename[(var in/out type)]\ras\rbegin\r	pl/sqls;\rend procedurename;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate or replace procedure addSal(eno in number) is pemp myemp%rowtype;\rbegin\r	select * into pemp from myemp where empno = eno;\r	update myemp set sal = sal + 100 where enpno = eno;\r	dbms_output.put_line(&#39;涨工资前&#39; || pemp.sal || &#39;涨工资后&#39; || (pemp.sal + 100));\rend addSal;\r\rbegin\r	addSal(eno =&gt; 7920);\r	commit;\rend;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 25),
(1548, 'Oracle存储函数', '1548', 1554560699, 1554560699, '<p>本文记录Oracle学习过程中遇到的存储函数～</p>\r<!--more-->\r\r<p>存储过程与存储函数的区别与联系：</p>\r\r<p>过程和函数的区别在于函数可以有一个返回值，而过程没有返回值；<br />\r但是，过程和函数都可以通过out指定一个或多个输出参数，可以利用out参数在过程和函数中实现返回多个值。</p>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate [or replace] function funcname(var in/out type, ...) return type is\r	resultVal resultType;\rbegin\r	return resultVal;\rend funcname;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate or replace function empincome(eno in emp.empno%type)\rreturn number is \r	psal emp.sal%type;\r	pcomm emp.comm%type;\rbegin\r	select t.sal into psal from emp t where t.empno = eno;\r	return psal * 12 + nvl(pcomm, 0);\rend;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 26),
(1549, 'Oracle触发器', '1549', 1554561659, 1554561659, '<p>本文记录Oracle学习过程中遇到的触发器～</p>\r\r<!--more-->\r\r<p>触发器是一个与表相关联的、存储的PL/SQL程序。每当一个特定的数据操作语句（insert、update、delete）在指定的表上执行时，Oracle会自动的执行触发器中定义的语句序列。</p>\r\r<p>触发器作用：</p>\r\r<ul>\r	<li>数据确认；</li>\r	<li>实施复杂的安全性检查；</li>\r	<li>做审计，跟踪表上所做的数据操作等；</li>\r	<li>数据的备份和同步。</li>\r</ul>\r\r<p>触发器的类型：</p>\r\r<ul>\r	<li>语句级别触发器：在指定的操作语句操作之前或之后执行一次，不过这条语句影响了多少行；</li>\r	<li>行级别触发器：触发语句作用的每一条记录都被触发，在行级别触发器中使用old和new伪记录变量，识别值的状态。</li>\r</ul>\r\r<p>语法格式：</p>\r\r<pre class="brush:sql;">\rcreate [or replace] trigger triggername\r	{before|after}\r	{delete|insert|update[of columnname]}\r	on tablename\r	[for each row [when(condition)]]\rdeclare\r	expr;\rbegin\r	pl/sqls;\rend triggername;</pre>\r\r<p>触发器中伪记录变量的值(:old与:new）：</p>\r\r<ul>\r	<li>insert：old中所有字段都是null，new是将要插入的数据；</li>\r	<li>update：old是更新以前该行的值，new是更新后的值；</li>\r	<li>delete：old删除以前该行的值，new中所有字段都是null。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:sql;">\rcreate or replace trigger testTrigger\r	after insert on person\rdeclare\r	\rbegin\r	dbms_output.put_line(&#39;一个员工被插入&#39;);\rend testTrigger;\r\rcreate or replace trigger validInsertPerson\r	before insert on person\rdeclare\r	weekend varchar2(10);\rbegin\r	select to_char(sysdate, &#39;day&#39;) into weekend from dual;\r	if weekend in (&#39;星期六&#39;, &#39;星期日&#39;) then\r		raise_application_error(-20001, &#39;不能在非工作时间插入员工&#39;);\r	end if;\rend validInsertPerson;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 34),
(1550, '连接并操作Oracle数据库', '1550', 1554561960, 1554561998, '<p>本文记录Java学习过程中遇到的连接并操作Oracle数据库～</p>\r<!--more-->\r\r<p>示例代码（JDBCUtils.java）：</p>\r\r<pre class="brush:java;">\rimport java.sql.Connection;\rimport java.sql.DriverManager;\rimport java.sql.ResultSet;\rimport java.sql.SQLException;\rimport java.sql.Statement;\r\rpublic class JDBCUtils {\r\r	private static String driver = &quot;oracle.jdbc.OracleDriver&quot;;\r	private static String url = &quot;jdbc:oracle:thin:@localhost:1521/orcl&quot;;\r	private static String user = &quot;scott&quot;;\r	private static String password = &quot;tiger&quot;;\r	\r	static{\r		try {\r			Class.forName(driver);\r		} catch (ClassNotFoundException e) {\r			throw new ExceptionInInitializerError(e);\r		}\r	}\r\r	public static Connection getConnection(){\r		try {\r			return DriverManager.getConnection(url, user, password);\r		} catch (SQLException e) {\r			e.printStackTrace();\r		}\r		return null;\r	}\r\r	public static void release(Connection conn,Statement st,ResultSet rs){\r		if(rs != null){\r			try {\r				rs.close();\r			} catch (SQLException e) {\r				e.printStackTrace();\r			}finally{\r				rs = null;\r			}\r		}\r		if(st != null){\r			try {\r				st.close();\r			} catch (SQLException e) {\r				e.printStackTrace();\r			}finally{\r				st = null;\r			}\r		}\r		if(conn != null){\r			try {\r				conn.close();\r			} catch (SQLException e) {\r				e.printStackTrace();\r			}finally{\r				conn = null;\r			}\r		}\r	}\r}</pre>\r\r<p>示例代码（测试连接）：</p>\r\r<pre class="brush:java;">\rimport java.sql.CallableStatement;\rimport java.sql.Connection;\rimport java.sql.ResultSet;\r\rimport oracle.jdbc.OracleCallableStatement;\rimport oracle.jdbc.OracleTypes;\r\rimport org.junit.Test;\r\rpublic class TestOracle {\r/*\r * create or replace procedure queryEmpInformation(eno in number,\r                                                pename out varchar2,\r                                                psal   out number,\r                                                pjob   out varchar2)\r */\r	@Test\r	public void testProcedure(){\r		//{call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]}\r		String sql = &quot;{call queryEmpInformation(?,?,?,?)}&quot;;\r		\r		Connection conn = null;\r		CallableStatement call = null;\r		try {\r			conn = JDBCUtils.getConnection();\r			call = conn.prepareCall(sql);\r\r			call.setInt(1,7839);\r\r			call.registerOutParameter(2, OracleTypes.VARCHAR);\r			call.registerOutParameter(3, OracleTypes.NUMBER);\r			call.registerOutParameter(4, OracleTypes.VARCHAR);\r\r			call.execute();\r\r			String name = call.getString(2);\r			double sal = call.getDouble(3);\r			String job = call.getString(4);\r			\r			System.out.println(name+&quot;\\t&quot;+sal+&quot;\\t&quot;+job);\r		} catch (Exception e) {\r			e.printStackTrace();\r		}finally{\r			JDBCUtils.release(conn, call, null);\r		}\r	}\r\r/*\r * create or replace function queryEmpIncome(eno in number) \rreturn number\r */\r	@Test\r	public void testFunction(){\r		//{?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]}\r		String sql = &quot;{?=call queryEmpIncome(?)}&quot;;\r		\r		Connection conn = null;\r		CallableStatement call = null;\r		try {\r			conn = JDBCUtils.getConnection();\r			call = conn.prepareCall(sql);\r			\r			call.registerOutParameter(1, OracleTypes.NUMBER);\r			call.setInt(2, 7839);\r\r			call.execute();\r\r			double income = call.getDouble(1);\r			\r			System.out.println(income);\r		} catch (Exception e) {\r			e.printStackTrace();\r		}finally{\r			JDBCUtils.release(conn, call, null);\r		}		\r	}\r\r\r	@Test\r	public void testCursor(){\r		String sql = &quot;{call mypackage.QUERYEMPLIST(?,?)}&quot;;\r		\r		Connection conn = null;\r		CallableStatement call = null;\r		ResultSet rs = null;\r		try {\r			conn = JDBCUtils.getConnection();\r			call = conn.prepareCall(sql);\r\r			call.setInt(1,20);\r\r			call.registerOutParameter(2, OracleTypes.CURSOR);\r\r			call.execute();\r\r			rs = ((OracleCallableStatement)call).getCursor(2);\r			while(rs.next()){\r				String name = rs.getString(&quot;ename&quot;);\r				double sal = rs.getDouble(&quot;sal&quot;);\r				System.out.println(name+&quot;\\t&quot;+sal);\r			}\r		} catch (Exception e) {\r			e.printStackTrace();\r		}finally{\r			JDBCUtils.release(conn, call, rs);\r		}		\r		\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 42),
(1553, 'SOAP简介', '1553', 1555149161, 1555149161, '<p>本文记录IT学习过程中遇到的SOAP简介～</p>\r<!--more-->\r\r<p>SOAP（Simple Object Access Protocol）：简单对象访问协议，它在网络上使用HTTP协议传输基于XML编码的数据。</p>\r\r<p>SOAP有以下几部分组成：</p>\r\r<ul>\r	<li>Envelope：必须的部分，以XML的根元素出现；</li>\r	<li>Headers：可选的，非必须的；</li>\r	<li>Body：必须的部分，包含要执行的方法和发送的数据。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 26),
(1554, 'WSDL简介', '1554', 1555149300, 1555170568, '<p>本文记录IT学习过程中遇到的WSDL简介～</p>\r<!--more-->\r\r<p>WSDL（WebService Description Language）：Web服务描述语言，使用的是XML格式，用于描述当前服务的一些信息（服务名称、服务的发布地址、服务提供的方法、方法的参数类型、方法的返回值类型等）。</p>\r\r<p>它具有如下作用：</p>\r\r<ul>\r	<li>说明服务在什么地方，即地址；</li>\r	<li>说明服务提供什么样的方法，即如何调用。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 29),
(1555, 'CXF简介', '1555', 1555178038, 1555178038, '<p>本文记录Java学习过程中遇到的CXF简介～</p>\r<!--more-->\r\r<p>Apache CXF = Celtix + XFire，开始叫 Apache CeltiXfire，后来更名为 Apache CXF 了，以下简称为 CXF。CXF 继承了 Celtix 和 XFire 两大开源项目的精华，提供了对 JAX-WS 全面的支持，并且提供了多种 Binding 、DataBinding、Transport 以及各种 Format 的支持，并且可以根据实际项目的需要，采用代码优先（Code First）或者 WSDL 优先（WSDL First）来轻松地实现 Web Services 的发布和使用。Apache CXF已经是一个正式的Apache顶级项目。</p>\r\r<p>它支持多种协议：</p>\r\r<ul>\r	<li>SOAP1.1,1.2；</li>\r	<li>XML/HTTP；</li>\r	<li>CORBA（Common Object Request Broker Architecture公共对象请求代理体系结构,早期语言使用的WS。C,c++,C#）。</li>\r</ul>\r\r<p>它可以与Spring进行快速无缝的整合，也可以灵活的部署，可以运行在Tomcat,Jboss,Jetty(内置),IBMWS,BeaWL上面。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 22),
(1557, 'URL拦截.png', 'URL拦截-png', 1555632748, 1555632748, 'a:5:{s:4:"name";s:13:"URL拦截.png";s:4:"path";s:35:"/usr/uploads/2019/04/3748563543.png";s:4:"size";i:322864;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1559, 0),
(1558, '方法注解.png', '方法注解-png', 1555632828, 1555632828, 'a:5:{s:4:"name";s:16:"方法注解.png";s:4:"path";s:35:"/usr/uploads/2019/04/3104325673.png";s:4:"size";i:428946;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1559, 0),
(1559, '常见权限控制方式', '1559', 1555632841, 1555632841, '<p>本文记录IT学习过程中遇到的常见权限控制方式～</p>\r<!--more-->\r\r<p><strong>URL拦截</strong></p>\r\r<p>底层基于拦截器或者过滤器实现，对客户端发送的请求进行拦截，在拦截器或者过滤器中进行权限校验。</p>\r\r<p>在页面中提供了菜单和按钮，菜单和按钮就是访问功能的入口。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/3748563543.png" style="width: 800px; height: 280px;" /></p>\r\r<p><strong>方法注解</strong></p>\r\r<p>底层基于代理技术实现。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/3104325673.png" style="width: 800px; height: 322px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 25),
(1560, 'Shiro核心功能.png', 'Shiro核心功能-png', 1555633428, 1555633428, 'a:5:{s:4:"name";s:21:"Shiro核心功能.png";s:4:"path";s:34:"/usr/uploads/2019/04/658423205.png";s:4:"size";i:487766;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1563, 0),
(1561, 'Shiro框架调用流程.png', 'Shiro框架调用流程-png', 1555633465, 1555633465, 'a:5:{s:4:"name";s:27:"Shiro框架调用流程.png";s:4:"path";s:34:"/usr/uploads/2019/04/486111291.png";s:4:"size";i:242086;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1563, 0),
(1562, '3.png', '3-png-1', 1555633492, 1555633492, 'a:5:{s:4:"name";s:5:"3.png";s:4:"path";s:35:"/usr/uploads/2019/04/4270237625.png";s:4:"size";i:946185;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1563, 0),
(1563, 'Shiro简介', '1563', 1555633507, 1555633507, '<p>本文记录Java学习过程中遇到的Shiro简介～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/658423205.png" style="width: 800px; height: 320px;" />​</p>\r\r<p>Shiro框架的核心功能：</p>\r\r<ul>\r	<li>认证功能；</li>\r	<li>授权功能；</li>\r	<li>会话管理；</li>\r	<li>加密功能。</li>\r</ul>\r\r<p>Shiro框架的调用流程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/486111291.png" style="width: 800px; height: 287px;" /></p>\r\r<ul>\r	<li>Application Code：应用程序代码，由开发人员编写；</li>\r	<li>Subject：代表当前用户，由Shiro框架提供；</li>\r	<li>SecurityManager：安全管理器，核心对象，由Shiro框架提供，负责管理Shiro框架内部的对象；</li>\r	<li>Realm：类似DAO，由框架提供，也可以自定义，负责访问安全数据。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/4270237625.png" style="width: 800px; height: 526px;" />​</p>\r\r<p>Shiro框架可以单独使用，也可以和Spring整合使用。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 30),
(1564, 'Shiro的四种权限控制方式', '1564', 1555765860, 1555765929, '<p>本文记录Java学习过程中遇到的Shiro的四种权限控制方式～</p>\r<!--more-->\r\r<p><strong>方式一：URL拦截</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 配置shiro框架的过滤器工厂对象 --&gt;\r&lt;bean id=&quot;shiro&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;\r	&lt;!-- 注入安全管理器对象 --&gt;\r	&lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;\r	&lt;!-- 注入相关页面访问URL --&gt;\r	&lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt;\r	&lt;property name=&quot;successUrl&quot; value=&quot;/index.jsp&quot;/&gt;\r	&lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;\r	&lt;!--注入URL拦截规则 --&gt;\r	&lt;property name=&quot;filterChainDefinitions&quot;&gt;\r		&lt;value&gt;\r			/css/** = anon\r			/js/** = anon\r			/images/** = anon\r			/validatecode.jsp* = anon\r			/login.jsp = anon\r			/userAction_login.action = anon\r			/page_base_staff.action = perms[&quot;staff-list&quot;]\r			/* = authc\r		&lt;/value&gt;\r	&lt;/property&gt;\r&lt;/bean&gt;</pre>\r\r<p><strong>方式二：方法注解</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 开启shiro框架注解支持 --&gt;\r&lt;bean id=&quot;defaultAdvisorAutoProxyCreator&quot; class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&gt;\r    &lt;!-- 必须使用cglib方式为Action对象创建代理对象 --&gt;\r    &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt;\r&lt;/bean&gt;\r\r&lt;!-- 配置shiro框架提供的切面类，用于创建代理对象 --&gt;\r&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot; /&gt;</pre>\r\r<pre class="brush:java;">\r@RequiresPermissions(&quot;staff-edit&quot;)\rpublic String edit() {\r\r    staffService.update(model);\r    return LIST;\r}</pre>\r\r<p><strong>方式三：页面标签</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;\r&lt;shiro:hasPermission name=&quot;staff-delete&quot;&gt;\r          {\r            id : &#39;button-delete&#39;,\r            text : &#39;删除&#39;,\r            iconCls : &#39;icon-cancel&#39;,\r            handler : doDelete\r        },\r&lt;/shiro:hasPermission&gt;</pre>\r\r<p><strong>方式四：业务代码</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic String deleteBatch(){\r\r    // 使用业务代码进行权限拦截\r    Subject subject = SecurityUtils.getSubject();\r    subject.checkPermission(&quot;staff-delete&quot;);\r\r    staffService.deleteBatch(ids);\r    return LIST;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 51),
(1565, '《互联网轻量级SSM框架解密：Spring、SpringMVC、MyBatis源码深度剖析》PDF完整版下载', '1565', 1555789482, 1555789482, '<p>本文分享一本Java框架学习相关书籍&mdash;&mdash;《互联网轻量级SSM框架解密：Spring、SpringMVC、MyBatis源码深度剖析》～</p>\r<!--more-->\r\r<p>SSM 是Spring、Spring MVC 和MyBatis 框架的组合，是目前Java 领域使用非常广泛也非常稳定的开源Web 框架。《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》以SSM 的核心代码剖析为基础，突破Java Web 研发瓶颈的束缚，选取Spring、SpringMVC 和MyBatis 框架中易于理解的版本，深入剖析了其中各个模块的实现，从代码中挖掘常用的设计模式，为读者理解Spring 系列框架的可扩展设计艺术提供了方法论和优秀实践。</p>\r\r<p>《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》Spring 源码剖析篇基于Spring 4.3.2 版本，剖析了Spring 上下文、Spring AOP 和Spring 事务的实现，并通过实例展示了框架陷阱的隐蔽性及学习框架原理的必要性。Spring MVC 源码剖析篇基于SpringMVC 3.0 版本，这个版本比较简单、核心清晰，便于读者理解透彻，这里主要讲解其中的设计模式及可插拔的设计思路。MyBatis 源码剖析篇基于MyBatis 3.4 版本，帮助读者对SQL 语言、JDBC 及数据访问方式有更深入的了解，也能看到工厂、Builder、代理、装饰者等设计模式在MyBatis 中的大量应用。</p>\r\r<p>《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》对于互联网从业者，或者传统行业的IT 工程师、架构师、技术经理、技术总监，以及想深耕IT行业的技术人员都有很强的借鉴性和实用价值。</p>\r\r<p><strong>目录：</strong></p>\r\r<p>第1篇&nbsp;深入剖析Spring源码</p>\r\r<p>第1章&nbsp;Spring基础介绍&nbsp;2</p>\r\r<p>1.1&nbsp;Spring的核心结构&nbsp;2</p>\r\r<p>1.2&nbsp;Spring的领域模型&nbsp;6</p>\r\r<p>第2章&nbsp;Spring上下文和容器&nbsp;7</p>\r\r<p>2.1&nbsp;Spring上下文的设计&nbsp;7</p>\r\r<p>2.2&nbsp;Spring容器BeanFactory的设计&nbsp;11</p>\r\r<p>2.3&nbsp;Spring父子上下文与容器&nbsp;13</p>\r\r<p>第3章&nbsp;Spring加载机制的设计与实现&nbsp;18</p>\r\r<p>3.1&nbsp;Spring&nbsp;ApplicationContext的加载及源码实现&nbsp;18</p>\r\r<p>3.2&nbsp;Spring&nbsp;XML文件标签加载解析及自定义&nbsp;27</p>\r\r<p>3.3&nbsp;Spring注解的加载及自动注入&nbsp;31</p>\r\r<p>第4章&nbsp;Spring&nbsp;Bean探秘&nbsp;45</p>\r\r<p>4.1&nbsp;Spring&nbsp;Bean的定义和注册设计&nbsp;45</p>\r\r<p>4.2&nbsp;Spring&nbsp;Bean的定义模型&nbsp;47</p>\r\r<p>4.3&nbsp;Spring&nbsp;Bean的运行（获取、创建）实现&nbsp;48</p>\r\r<p>4.4&nbsp;Spring&nbsp;Bean的依赖注入的实现&nbsp;59</p>\r\r<p>4.5&nbsp;Spring&nbsp;Bean的初始化&nbsp;70</p>\r\r<p>第5章&nbsp;Spring代理与AOP&nbsp;74</p>\r\r<p>5.1&nbsp;Spring代理的设计及JDK、CGLIB动态代理&nbsp;75</p>\r\r<p>5.2&nbsp;Spring&nbsp;AOP的设计&nbsp;82</p>\r\r<p>5.3&nbsp;Spring&nbsp;AOP的加载和执行机制&nbsp;83</p>\r\r<p>5.3.1&nbsp;Spring&nbsp;AOP的加载及源码解析&nbsp;83</p>\r\r<p>5.3.2&nbsp;Spring&nbsp;AOP的创建执行及源码解析&nbsp;88</p>\r\r<p>5.4&nbsp;Spring事务管理设计及源码&nbsp;101</p>\r\r<p>5.5&nbsp;Spring事务传播机制&nbsp;115</p>\r\r<p>第6章&nbsp;Spring实战&nbsp;118</p>\r\r<p>6.1&nbsp;对Spring重复AOP问题的分析&nbsp;118</p>\r\r<p>6.2&nbsp;Spring&nbsp;Bean循环依赖的问题&nbsp;125</p>\r\r<p>第2篇&nbsp;深入剖析Spring&nbsp;MVC源码</p>\r\r<p>第7章&nbsp;MVC简介&nbsp;138</p>\r\r<p>7.1&nbsp;MVC的体系结构和工作原理&nbsp;138</p>\r\r<p>7.1.1&nbsp;控制器&nbsp;139</p>\r\r<p>7.1.2&nbsp;视图&nbsp;139</p>\r\r<p>7.1.3&nbsp;模型&nbsp;140</p>\r\r<p>7.2&nbsp;Web&nbsp;MVC的体系结构和工作原理&nbsp;140</p>\r\r<p>第8章&nbsp;Spring&nbsp;Web&nbsp;MVC工作流&nbsp;142</p>\r\r<p>8.1&nbsp;组件及其接口&nbsp;142</p>\r\r<p>8.1.1&nbsp;DispatcherServlet&nbsp;143</p>\r\r<p>8.1.2&nbsp;处理器映射&nbsp;143</p>\r\r<p>8.1.3&nbsp;处理器适配器&nbsp;144</p>\r\r<p>8.1.4&nbsp;处理器与控制器&nbsp;145</p>\r\r<p>8.1.5&nbsp;视图解析器&nbsp;145</p>\r\r<p>8.1.6&nbsp;视图&nbsp;146</p>\r\r<p>8.2&nbsp;组件间的协调通信&nbsp;146</p>\r\r<p>第9章&nbsp;DispatcherServlet的实现&nbsp;148</p>\r\r<p>9.1&nbsp;深入剖析GenericServlet和HttpServlet&nbsp;150</p>\r\r<p>9.1.1&nbsp;HTTP和Servlet规范简介&nbsp;150</p>\r\r<p>9.1.2&nbsp;Servlet和GenericServlet详解&nbsp;152</p>\r\r<p>9.1.3&nbsp;HttpServlet详解&nbsp;152</p>\r\r<p>9.2&nbsp;深入剖析DispatcherServlet&nbsp;159</p>\r\r<p>9.2.1&nbsp;HttpServletBean详解&nbsp;161</p>\r\r<p>9.2.2&nbsp;FrameworkServlet详解&nbsp;162</p>\r\r<p>9.2.3&nbsp;DispatchServlet详解&nbsp;166</p>\r\r<p>9.3&nbsp;根共享环境的加载&nbsp;182</p>\r\r<p>9.3.1&nbsp;基于Servlet环境监听器的实现结构&nbsp;182</p>\r\r<p>9.3.2&nbsp;多级Spring环境的加载方式&nbsp;189</p>\r\r<p>第10章&nbsp;基于简单控制器的流程实现&nbsp;194</p>\r\r<p>10.1&nbsp;通过Bean名称URL处理器映射获取处理器执行链&nbsp;194</p>\r\r<p>10.1.1&nbsp;抽象处理器映射&nbsp;196</p>\r\r<p>10.1.2&nbsp;抽象URL处理器映射&nbsp;199</p>\r\r<p>10.1.3&nbsp;抽象探测URL处理器映射&nbsp;209</p>\r\r<p>10.1.4&nbsp;Bean名称URL处理器映射&nbsp;210</p>\r\r<p>10.2&nbsp;通过处理器适配器把请求转接给处理器&nbsp;211</p>\r\r<p>10.2.1&nbsp;简单控制处理适配器的设计&nbsp;211</p>\r\r<p>10.2.2&nbsp;表单控制器处理HTTP请求的流程&nbsp;212</p>\r\r<p>10.3&nbsp;对控制器类体系结构的深入剖析&nbsp;214</p>\r\r<p>10.3.1&nbsp;Web内容产生器&nbsp;215</p>\r\r<p>10.3.2&nbsp;抽象控制器类&nbsp;217</p>\r\r<p>10.3.3&nbsp;基本命令控制器&nbsp;218</p>\r\r<p>10.3.4&nbsp;抽象表单控制器&nbsp;222</p>\r\r<p>10.3.5&nbsp;简单表单控制器&nbsp;229</p>\r\r<p>第11章&nbsp;基于注解控制器的流程实现&nbsp;230</p>\r\r<p>11.1&nbsp;默认注解处理器映射的实现&nbsp;230</p>\r\r<p>11.2&nbsp;注解处理器适配器的架构设计&nbsp;237</p>\r\r<p>11.3&nbsp;深入剖析注解控制器的处理流程&nbsp;238</p>\r\r<p>11.3.1&nbsp;解析处理器方法&nbsp;241</p>\r\r<p>11.3.2&nbsp;解析处理器方法的参数&nbsp;253</p>\r\r<p>11.3.3&nbsp;绑定、初始化领域模型和管理领域模型&nbsp;272</p>\r\r<p>11.3.4&nbsp;调用处理器方法&nbsp;278</p>\r\r<p>11.3.5&nbsp;处理方法返回值和隐式模型到模型或视图的映射&nbsp;281</p>\r\r<p>11.3.6&nbsp;如何更新模型数据&nbsp;286</p>\r\r<p>第12章&nbsp;基于HTTP请求处理器实现RPC&nbsp;288</p>\r\r<p>12.1&nbsp;深入剖析RPC客户端的实现&nbsp;289</p>\r\r<p>12.2&nbsp;深入剖析RPC服务端的实现&nbsp;299</p>\r\r<p>第13章&nbsp;深入剖析处理器映射、处理器适配器及处理器的实现&nbsp;311</p>\r\r<p>13.1&nbsp;处理器映射的实现架构&nbsp;311</p>\r\r<p>13.1.1&nbsp;处理器映射实现类&nbsp;312</p>\r\r<p>13.1.2&nbsp;处理器映射抽象类&nbsp;313</p>\r\r<p>13.1.3&nbsp;对处理器映射类的代码剖析&nbsp;315</p>\r\r<p>13.2&nbsp;处理器适配器的实现架构&nbsp;322</p>\r\r<p>13.3&nbsp;深入剖析处理器&nbsp;325</p>\r\r<p>13.3.1&nbsp;简单控制器&nbsp;325</p>\r\r<p>13.3.2&nbsp;注解控制器&nbsp;339</p>\r\r<p>13.3.3&nbsp;HTTP请求处理器&nbsp;342</p>\r\r<p>13.4&nbsp;拦截器的实现架构&nbsp;344</p>\r\r<p>第14章&nbsp;视图解析和视图显示&nbsp;353</p>\r\r<p>14.1&nbsp;基于URL的视图解析器和视图&nbsp;353</p>\r\r<p>14.1.1&nbsp;内部资源视图解析器和内部资源视图&nbsp;365</p>\r\r<p>14.1.2&nbsp;瓦块视图解析器和瓦块视图&nbsp;371</p>\r\r<p>14.1.3&nbsp;模板视图解析器和模板视图&nbsp;373</p>\r\r<p>14.1.4&nbsp;XSLT视图解析器和XSLT视图&nbsp;377</p>\r\r<p>14.2&nbsp;更多的视图解析器&nbsp;378</p>\r\r<p>14.2.1&nbsp;Bean名称视图解析器&nbsp;378</p>\r\r<p>14.2.2&nbsp;内容选择视图解析器&nbsp;379</p>\r\r<p>14.2.3&nbsp;资源绑定视图解析器&nbsp;383</p>\r\r<p>14.2.4&nbsp;XML视图解析器&nbsp;385</p>\r\r<p>第3篇&nbsp;深入剖析MyBatis源码</p>\r\r<p>第15章&nbsp;MyBatis介绍&nbsp;388</p>\r\r<p>15.1&nbsp;MyBatis的历史&nbsp;388</p>\r\r<p>15.2&nbsp;MyBatis子项目&nbsp;389</p>\r\r<p>15.3&nbsp;MyBatis的自身定位&nbsp;389</p>\r\r<p>15.3.1&nbsp;JPA持久化框架&nbsp;390</p>\r\r<p>15.3.2&nbsp;MyBatis的功能&nbsp;390</p>\r\r<p>15.3.3&nbsp;MyBatis与JPA的异同&nbsp;390</p>\r\r<p>15.4&nbsp;MyBatis的架构&nbsp;391</p>\r\r<p>15.4.1&nbsp;模块&nbsp;391</p>\r\r<p>15.4.2&nbsp;MyBatis的项目包&nbsp;392</p>\r\r<p>第16章&nbsp;构建阶段&nbsp;394</p>\r\r<p>16.1&nbsp;关键类&nbsp;394</p>\r\r<p>16.2&nbsp;关键时序&nbsp;395</p>\r\r<p>16.3&nbsp;构建的入口：SqlSessionFactoryBuilder和SqlSessionFactory&nbsp;396</p>\r\r<p>16.4&nbsp;配置（Configuration）和配置构造器（XmlConfigBuilder）&nbsp;397</p>\r\r<p>16.4.1&nbsp;XmlConfigBuilder的初始化&nbsp;397</p>\r\r<p>16.4.2&nbsp;完整的mybatis-3-config.dtd&nbsp;399</p>\r\r<p>16.4.3&nbsp;解析配置文件构建Configuration配置&nbsp;399</p>\r\r<p>16.5&nbsp;SQL简介&nbsp;418</p>\r\r<p>16.6&nbsp;SQL映射的构建&nbsp;419</p>\r\r<p>16.6.1&nbsp;通过XML定义的SQL&nbsp;Mapper&nbsp;419</p>\r\r<p>16.6.2&nbsp;Configuration类中与SQL&nbsp;Mapping相关的类&nbsp;420</p>\r\r<p>16.6.3&nbsp;XmlMapperBuilder是如何工作的&nbsp;421</p>\r\r<p>16.6.4&nbsp;映射注解器定义的SQL&nbsp;Mapper&nbsp;438</p>\r\r<p>16.6.5&nbsp;小结&nbsp;440</p>\r\r<p>第17章&nbsp;执行阶段&nbsp;441</p>\r\r<p>17.1&nbsp;关键类&nbsp;441</p>\r\r<p>17.2&nbsp;关键接口及默认实现初始化&nbsp;442</p>\r\r<p>17.2.1&nbsp;SqlSession及其关联类的构建过程&nbsp;442</p>\r\r<p>17.2.2&nbsp;StatementHandler语句处理器&nbsp;446</p>\r\r<p>17.3&nbsp;DQL语句是如何执行的&nbsp;448</p>\r\r<p>17.3.1&nbsp;查询接口&nbsp;448</p>\r\r<p>17.3.2&nbsp;关键时序&nbsp;449</p>\r\r<p>17.3.3&nbsp;程序执行查询的入口：DefaultSqlSession#selectList(statement)&nbsp;450</p>\r\r<p>17.3.4&nbsp;生成执行语句：getMappedStatement()&nbsp;450</p>\r\r<p>17.3.5&nbsp;执行器查询：Executor#query()&nbsp;451</p>\r\r<p>17.3.6&nbsp;JDBC执行语句：SimpleStatementHandler#query()&nbsp;455</p>\r\r<p>17.3.7&nbsp;结果集处理：DefaultResultSetHandler#handlerResultSets()&nbsp;455</p>\r\r<p>17.4&nbsp;DML语句是如何执行的&nbsp;460</p>\r\r<p>17.4.1&nbsp;操作接口&nbsp;460</p>\r\r<p>17.4.2&nbsp;关键时序&nbsp;460</p>\r\r<p>17.4.3&nbsp;程序执行更新的入口：DefaultSqlSession#update()&nbsp;461</p>\r\r<p>17.4.4&nbsp;执行器执行方法：Executor#update()&nbsp;461</p>\r\r<p>17.4.5&nbsp;SQL语句执行：SimpleStatementHandler#update()&nbsp;464</p>\r\r<p>17.4.6&nbsp;结果集主键逻辑：Jdbc3KeyGenerator#processAfter()&nbsp;464</p>\r\r<p>17.5&nbsp;小结&nbsp;466</p>\r\r<p>第18章&nbsp;专题特性解析&nbsp;467</p>\r\r<p>18.1&nbsp;动态SQL支持&nbsp;467</p>\r\r<p>18.1.1&nbsp;XmlScriptBuilder解析配置&nbsp;467</p>\r\r<p>18.1.2&nbsp;NodeHandler构建SqlNode树&nbsp;468</p>\r\r<p>18.1.3&nbsp;SqlNode处理SQL语句&nbsp;471</p>\r\r<p>18.2&nbsp;MyBatis的缓存支持&nbsp;477</p>\r\r<p>18.2.1&nbsp;本地缓存&nbsp;478</p>\r\r<p>18.2.2&nbsp;二级缓存&nbsp;482</p>\r\r<p>18.3&nbsp;结果集支持：Object、List、Map和Cursor&nbsp;491</p>\r\r<p>18.4&nbsp;自定义扩展点及接口&nbsp;496</p>\r\r<p>第19章&nbsp;作为中间件如何承上启下&nbsp;498</p>\r\r<p>19.1&nbsp;MyBatis与底层的JDBC&nbsp;498</p>\r\r<p>19.1.1&nbsp;java.sql.DataSource&nbsp;498</p>\r\r<p>19.1.2&nbsp;java.sql.Connection&nbsp;499</p>\r\r<p>19.1.3&nbsp;java.sql.Statement&nbsp;500</p>\r\r<p>19.1.4&nbsp;java.sql.Resultset&nbsp;502</p>\r\r<p>19.2&nbsp;MyBatis的主流集成方式&nbsp;502</p>\r\r<p>19.2.1&nbsp;mybatis-spring简介&nbsp;502</p>\r\r<p>19.2.2&nbsp;Spring对JDBC的支持&nbsp;502</p>\r\r<p>19.2.3&nbsp;mybatis-spring与Spring&nbsp;504</p>\r\r<p>下载地址：&nbsp;<a href="https://pan.baidu.com/s/13VJA6tnjSjQvpKdy2ILxng" target="_blank">pprn</a>&nbsp;</p>\r\r<hr />\r<p>由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 82);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1566, '《JUnit实战（第二版）》PDF完整版下载', '1566', 1555825920, 1555826076, '<p>本文分享一本Java程序员必备书籍&mdash;&mdash;《JUnit实战（第二版）》～</p>\r<!--more-->\r\r<p>本书从认识JUnit、不同的测试策略、JUnit与构建过程、JUnit扩展4个方面，由浅入深、由易到难地对JUnit展开了系统的讲解，包括探索JUnit的核心、软件测试原则、测试覆盖率与开发、使用stub进行粗粒度测试、使用mockobjects进行测试、容器内测试、从Ant中运行JUnit测试、从Maven2中运行JUnit测试、持续集成工具、表示层的测试、Ajax测试、使用Cactus进行服务器端的Java测试、测试JSF应用程序、测试OSGi组件、测试数据库访问、测试基于JPA的应用程序、JUnit的其他用法等内容。</p>\r\r<p>本书不仅仅介绍了使用JUnit框架测试项目必须掌握的核心概念，还指导读者如何使用JUnit框架编写自己的测试用例，并针对在编写代码的过程中如何使得代码可测试给出建议。本书还介绍了基础的软件开发原则，如测试驱动开发(TDD)等，以便指导用户如何使用不同的工具来测试典型JavaEE应用程序的每一层。此外，本书也提供了几个附录，以帮助读者快速转换到*版本的JUnit，并且能够轻松地集成自己喜欢的IDE。</p>\r\r<p>本书适合于已具有一定Java编程基础的读者，以及在Java平台下进行各类软件开发的开发人员、测试人员。对于单元测试学习者和编程爱好者来说，本书则具有极高的学习参考价值。</p>\r\r<p>目录：</p>\r\r<p>第1部分　认识JUnit<br />\r第1章　JUnit起步<br />\r1.1　证实它能运行<br />\r1.2　从零开始<br />\r1.3　理解单元测试框架<br />\r1.4　JUnit的设计目标<br />\r1.5　安装JUnit<br />\r1.6　使用JUnit测试<br />\r1.7　小结<br />\r第2章　探索JUnit的核心<br />\r2.1　探索JUnit核心<br />\r2.2　运行参数化测试<br />\r2.3　JUnit的测试运行器<br />\r2.3.1　测试运行器简介<br />\r2.3.2　JUnitCore fa？ade<br />\r2.3.3　自定义测试运行器<br />\r2.4　用Suite来组合测试<br />\r2.4.1　组合一组测试类<br />\r2.4.2　组合一组测试集<br />\r2.4.3　Suite、IDE、Ant与Maven<br />\r2.5　小结<br />\r第3章　掌握JUnit<br />\r3.1　引入controller组件<br />\r3.1.1　设计接口<br />\r3.1.2　实现基类<br />\r3.2　让我们来测试它<br />\r3.2.1　测试DefaultController<br />\r3.2.2　添加一个处理器<br />\r3.2.3　请求处理<br />\r3.2.4　改进testProcessRequest<br />\r3.3　测试异常处理<br />\r3.3.1　模拟异常条件<br />\r3.3.2　测试异常<br />\r3.4　超时测试<br />\r3.5　引入Hamcrest匹配器<br />\r3.6　创建测试项目<br />\r3.7　小结<br />\r第4章　软件测试原则<br />\r4.1　单元测试的必要性<br />\r4.1.1　带来更高的测试覆盖率<br />\r4.1.2　提高团队效率<br />\r4.1.3　监测衰退和减少调试<br />\r4.1.4　自信地重构<br />\r4.1.5　改进实现<br />\r4.1.6　将预期的行为文档化<br />\r4.1.7　启用代码覆盖率以及其他指标<br />\r4.2　测试类型<br />\r4.2.1　软件测试的4种类型<br />\r4.2.2　单元测试的3种类型<br />\r4.3　黑盒测试与白盒测试<br />\r4.4　小结<br />\r第2部分　不同的测试策略<br />\r第5章　测试覆盖率与开发<br />\r5.1　测量测试覆盖率<br />\r5.1.1　测试覆盖率简介<br />\r5.1.2　Cobertura简介<br />\r5.1.3　生成测试覆盖率报告<br />\r5.1.4　结合黑盒与白盒测试<br />\r5.2　编写可测试的代码<br />\r5.2.1　公共API是协议<br />\r5.2.2　减少依赖关系<br />\r5.2.3　创建简单的构造函数<br />\r5.2.4　遵循少知识原则<br />\r5.2.5　避免隐藏的依赖关系与全局状态<br />\r5.2.6　单态模式的优点和缺点<br />\r5.2.7　优先使用通用方法<br />\r5.2.8　组合优先于继承<br />\r5.2.9　多态优先于条件语句<br />\r5.3　 测试驱动开发<br />\r5.3.1　 调整开发周期<br />\r5.3.2　TDD的两个步骤<br />\r5.4　 在开发周期中的测试<br />\r5.5　 小结<br />\r第6章　使用stub进行粗粒度测试<br />\r6.1　stub简介<br />\r6.2　使用stub测试一个连接<br />\r6.2.1　选择使用stub的方案<br />\r6.2.2　使用Jetty作为嵌入式服务器<br />\r6.3　使用stub替换Web服务器资源<br />\r6.3.1　建立个stub测试<br />\r6.3.2　针对故障情况进行测试<br />\r6.3.3　回顾个stub测试<br />\r6.4　替换连接<br />\r6.4.1　创建自定义的URL协议处理器<br />\r6.4.2　创建一个K的HttpURLConnection stub<br />\r6.4.3　运行测试<br />\r6.5　小结<br />\r第7章　使用mock objects进行测试<br />\r7.1　 mock objects简介<br />\r7.2　使用mock objects进行单元测试<br />\r7.3　使用mock objects来重构<br />\r7.3.1　重构示例<br />\r7.4　替换一个连接<br />\r7.4.1　定义mock objects<br />\r7.4.2　测试一个简单的方法<br />\r7.4.3　次尝试：简单的方法重构技巧<br />\r7.4.4　第二个尝试：使用类工厂来重构<br />\r7.5　把mocks用作特洛伊木马<br />\r7.6　介绍mock框架<br />\r7.6.1　使用EasyMock<br />\r7.6.2　使用JMock<br />\r7.7　小结<br />\r第8章　容器内测试<br />\r8.1　标准单元测试的局限性<br />\r8.2　mock objects解决方案<br />\r8.3　容器内测试<br />\r8.3.1　实现策略<br />\r8.3.2　容器内测试框架<br />\r8.4　比较stub、mock objects和容器内测试<br />\r8.4.1　stub的优点与缺点<br />\r8.4.2　mock objects的优点和缺点<br />\r8.4.3　容器内测试的优点与缺点<br />\r8.4.4　容器内测试与容器外测试<br />\r8.5　小结<br />\r第3部分　JUnit与构建过程<br />\r第9章　从Ant中运行JUnit测试<br />\r9.1　生命中的一天<br />\r9.2　从Ant中运行测试<br />\r9.3　认识并安装Ant<br />\r9.4　Ant的目标、项目、属性以及任务<br />\r9.4.1　javac任务<br />\r9.4.2　JUnit任务<br />\r9.5　让Ant来执行任务<br />\r9.6　使用Ivy进行依赖管理<br />\r9.7　创建HTML报告<br />\r9.8　批处理测试<br />\r9.9　小结<br />\r0章　从Maven2中运行JUnit测试<br />\r10.1　Maven的功能<br />\r10.1.1　约定优于配置<br />\r10.1.2　强大的依赖管理<br />\r10.1.3　Maven的构建生命周期<br />\r10.1.4　基于插件的架构<br />\r10.1.5　Maven项目对象模型<br />\r10.2　建立一个Maven项目<br />\r10.3　Maven插件的引入<br />\r10.3.1　Maven的Compiler插件<br />\r10.3.2　Maven的Surefire插件<br />\r10.3.3　使用Maven生成HTML格式的JUnit报告<br />\r10.4　Maven的不足<br />\r10.5　小结<br />\r1章　持续集成工具<br />\r11.1　尝试持续集成<br />\r11.1.1　持续集成测试<br />\r11.2　拯救用户的CruiseControl<br />\r11.2.1　开始使用CruiseControl<br />\r11.2.2　创建一个示例项目<br />\r11.2.3　解析CruiseControl配置文件<br />\r11.3　另一个持续集成工具--Hudson<br />\r11.3.1　Hudson简介<br />\r11.3.2　安装<br />\r11.3.3　配置Hudson<br />\r11.3.4　配置Hudson中的项目<br />\r11.4　持续集成的优势<br />\r11.5　小结<br />\r第4部分　JUnit扩展<br />\r2章　表示层的测试<br />\r12.1　选择测试框架<br />\r12.2　HtmlUnit简介<br />\r12.2.1　一个实例<br />\r12.3　编写HtmlUnit测试<br />\r12.3.1　HTML断言<br />\r12.3.2　对特定的Web浏览器进行测试<br />\r12.3.3　测试多个Web浏览器<br />\r12.3.4　创建独立的测试<br />\r12.3.5　导航对象模型<br />\r12.3.6　通过特定的元素类型访问元素<br />\r12.3.7　通过名字与索引访问元素<br />\r12.3.8　通过引用访问元素<br />\r12.3.9　使用XPath<br />\r12.3.10　测试失败和异常<br />\r12.3.11　应用程序与网络导航<br />\r12.3.12　使用HtmlUnit测试表单<br />\r12.3.13　测试框架(frame)<br />\r12.3.14　测试<br />\r12.3.15　测试CSS<br />\r12.3.16　SSL错误<br />\r12.4　集成HtmlUnit和Cactus<br />\r12.4.1　在Cactus中编写测试<br />\r12.5　Selenium简介<br />\r12.6　生成Selenium测试<br />\r12.6.1　一个实例<br />\r12.7　运行Selenium测试<br />\r12.7.1　管理Selenium服务器<br />\r12.7.2　使用JUnit 4运行Selenium测试<br />\r12.8　编写Selenium测试<br />\r12.8.1　针对特定的Web浏览器进行测试<br />\r12.8.2　测试多个浏览器<br />\r12.8.3　应用程序和网络导航<br />\r12.8.4　通过引用访问元素<br />\r12.8.5　通过异常使测试失败<br />\r12.8.6　使用Selenium测试表单<br />\r12.8.7　测试告警<br />\r12.8.8　捕获一个JUnit 3测试失败的截屏<br />\r12.8.9　捕获一个JUnit 4测试失败的截屏<br />\r12.9　HtmlUnit与Selenium<br />\r12.10　小结<br />\r3章　Ajax测试<br />\r13.1　Ajax应用程序难以测试的原因<br />\r13.1.1　传统的Web交互<br />\r13.1.2　Ajax交互<br />\r13.1.3　一个崭新的世界<br />\r13.1.4　测试的挑战<br />\r13.2　Ajax的测试模式<br />\r13.2.1　功能测试<br />\r13.2.2　客户端脚本单元测试<br />\r13.2.3　服务测试<br />\r13.3　功能测试<br />\r13.3.1　使用Seleniun进行功能测试<br />\r13.3.2　使用HtmlUnit进行功能测试<br />\r13.4　测试<br />\r13.4.1　使用RhinoUnit测试<br />\r13.4.2　使用JsUnit测试<br />\r13.4.3　编写JsUnit测试用例<br />\r13.4.4　编写JsUnit测试集<br />\r13.4.5　手动运行JsUnit测试用例<br />\r13.4.6　使用Ant自动运行JsUnit测试用例<br />\r13.5　RhinoUnit与JsUnit<br />\r13.6　使用JSLint检验佳实践<br />\r13.7　使用HttpClient测试服务<br />\r13.7.1　调用XML服务<br />\r13.7.2　验证XML响应<br />\r13.7.3　验证JSON响应<br />\r13.8　测试Google Web工具箱应用程序<br />\r13.8.1　为GWT应用程序选择测试框架<br />\r13.8.2　手动创建GWTTestCase<br />\r13.8.3　使用junitCreator创建GWTTestCase<br />\r13.8.4　运行测试用例<br />\r13.8.5　安装和拆卸测试<br />\r13.8.6　创建测试集<br />\r13.8.7　运行测试集<br />\r13.9　小结<br />\r4章　使用Cactus进行服务器端的Java测试<br />\r14.1　什么是Cactus？<br />\r14.2　使用Cactus进行测试<br />\r14.2.1　你可以使用Cactus测试的Java组件<br />\r14.2.2　一般原则<br />\r14.2.3　Cactus如何工作<br />\r14.3　测试servlet和filters<br />\r14.3.1　介绍管理应用程序<br />\r14.3.2　使用Cactus编写servlet测试<br />\r14.4　测试JSP<br />\r14.4.1　回顾管理应用程序<br />\r14.4.2　什么是JSP单元测试？<br />\r14.4.3　单独使用Cactus对JSP进行单元测试<br />\r14.4.4　利用SQL结果数据执行JSP<br />\r14.5　测试EJB<br />\r14.6　什么是Cargo？<br />\r14.7　使用Ant执行Cactus测试<br />\r14.7.1　用来准备文件的Cactus<br />\r14.8　使用Maven2x执行Cactus测试<br />\r14.8.1　Maven2 cactifywar MOJO<br />\r14.8.2　Maven2 cactifyear MOJO<br />\r14.9　从浏览器执行Cactus测试<br />\r14.10　小结<br />\r5章　测试JSF应用程序<br />\r15.1　引入JSF<br />\r15.2　介绍示例应用程序<br />\r15.3　测试JSF应用程序时的典型问题<br />\r15.4　测试JSF应用程序的策略<br />\r15.4.1　黑盒方法<br />\r15.4.2　Mock object援救<br />\r15.5　使用JSUnit测试示例应用程序<br />\r15.5.1　从浏览器执行一个JSFUnit测试<br />\r15.5.2　使用JSFUnit测试Ajax<br />\r15.6　使用HtmlUnit与JSFUnit<br />\r15.7　JSF应用程序的性能测试<br />\r15.8　小结<br />\r6章　测试OSGi组件<br />\r16.1　OSGi简介<br />\r16.2　个OSGi服务<br />\r16.2.1　示例应用程序<br />\r16.3　测试OSGi服务<br />\r16.3.1　Mock objects<br />\r16.4　引入JUnit4OSGi<br />\r16.5　小结<br />\r7章　测试数据库访问<br />\r17.1　数据库单元测试的阻抗不匹配<br />\r17.1.1　单元测试必须执行隔离的代码<br />\r17.1.2　单元测试必须易于编写和运行<br />\r17.1.3　单元测试必须运行快速<br />\r17.2　DbUnit介绍<br />\r17.2.1　示例应用程序<br />\r17.2.2　设置DbUnit并运行示例应用程序<br />\r17.3　使用数据集来填充数据库<br />\r17.3.1　剖析DatabaseOperation<br />\r17.4　用数据集断言数据库状态<br />\r17.4.1　过滤数据集<br />\r17.4.2　忽略数据列<br />\r17.5　使用ReplacementDataSet转换数据<br />\r17.5.1　使用ReplacementDataSet处理不同的ID问题<br />\r17.5.2　处理NULL值<br />\r17.6　从已有的数据库数据中创建数据集<br />\r17.7　高级技术<br />\r17.7.1　DbUnit与模板设计模式<br />\r17.7.2　通过自定义注释提高重用<br />\r17.7.3　在数据集中使用表达式语言<br />\r17.8　数据库访问测试的佳做法<br />\r17.8.1　每个开发者使用一个数据库<br />\r17.8.2　确保目标数据库被测试<br />\r17.8.3　为加载和存储数据创建互补测试<br />\r17.8.4　编写加载测试用例时，应涵盖所有基本场景<br />\r17.8.5　计划数据集的使用<br />\r17.8.6　测试清理<br />\r17.9　小结<br />\r8章　测试基于JPA的应用程序<br />\r18.1　测试多层应用程序<br />\r18.1.1　示例应用程序<br />\r18.1.2　多层、多种测试策略<br />\r18.2　JPA测试的方方面面<br />\r18.3　准备基础设施<br />\r18.4　测试JPA实体映射<br />\r18.4.1　使用JPA ID生成器集成测试用例<br />\r18.5　测试基于JPA的DAO<br />\r18.6　测试外键名字<br />\r18.7　小结<br />\r9章　JUnit的其他用法<br />\r19.1　介绍<br />\r19.1.1　工具概述<br />\r19.1.2　运行示例<br />\r19.2　透明地使用mock<br />\r19.2.1　Unitils的EasyMock支持<br />\r19.2.2　FEST-Mocks<br />\r19.2.3　Mycila<br />\r19.3　DbUnit集成<br />\r19.4　使断言更简单<br />\r19.4.1　JUnit-addons断言包<br />\r19.4.2　Unitlis的ReflectionAssert<br />\r19.4.3　FEST流畅断言模块<br />\r19.4.4　Mylica继承断言<br />\r19.5　使用反射绕过封装<br />\r19.5.1　内部替代物<br />\r19.5.2　JUnit-addons<br />\r19.5.3　FEST-Reflect<br />\r19.6　小结<br />\r附录A　JUnit 3和JUnit 4之间的不同<br />\rA.1　全球的需求变化<br />\rA.1.1　K的要求<br />\rA.1.2　向后/向前兼容<br />\rA.2　API中的变化<br />\rA.2.1　包结构<br />\rA.2.2　构造函数<br />\rA.2.3　扩展TestCase<br />\rA.2.4　测试方法名称<br />\rA.3　注释与新增的静态导入<br />\rA.3.1　@Before与@After注释<br />\rA.3.2　@BeforeClass和@AfterClass注释<br />\rA.3.3　忽略测试的差异<br />\rA.3.4　静态导入<br />\rA.3.5　异常测试<br />\rA.3.6　超时测试<br />\rA.4　新的JUnit runners<br />\rA.4.1　测试运行器(Test runner)<br />\rA.4.2　测试集<br />\rA.4.3　参数化测试<br />\rA.5　新的断言和假设<br />\rA.5.1　Hamcrest断言<br />\rA.5.2　假设<br />\rA.5.3　新断言<br />\rA.5.4　断言错误<br />\r附录B　使用自定义的运行器和匹配器扩展JUnitAPI<br />\rB.1　介绍拦截器模式<br />\rB.2　实现自定义运行器<br />\rB.3　实现自定义匹配器<br />\r附录C　本书源代码<br />\rC.1　获取源代码<br />\rC.2　源代码概览<br />\rC.3　外部库<br />\rC.4　JAR版本<br />\rC.5　目录结构约定<br />\r附录D　JUnit IDE集成<br />\rD.1　JUnit与Eclipse的集成<br />\rD.1.1　安装Eclipse<br />\rD.1.2　从源代码创建Eclipse项目<br />\rD.1.3　从Eclipse运行JUnit测试<br />\rD.1.4　从Eclipse运行Ant脚本<br />\rD.2　引入JUnitMAX Eclipse插件<br />\rD.2.1　集成在你的开发周期中<br />\rD.2.2　执行顺序<br />\rD.2.3　恢复到上一个稳定版本<br />\rD.3　JUnit与NetBeans集成<br />\rD.3.1　安装NetBeans<br />\rD.3.2　从源代码中创建NetBeans项目<br />\rD.3.3　从NetBeans运行JUnit测试<br />\rD.3.4　从NetBeans运行Ant脚本<br />\r附录E　安装软件<br />\rE.1　安装HtmlUnit<br />\rE.1.1　标准配置<br />\rE.1.2　Eclipse的配置<br />\rE.2　使用HtmlUnit配置Cactus<br />\rE.3　安装Selenium<br />\rE.4　安装RhinoUnit<br />\rE.5　安装JsUnit</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1JxtJWPpbTnw2eG6cRraNow" target="_blank">j4rx</a></p>\r\r<hr style="margin: 1.5em auto; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-color: rgb(233, 233, 233); color: rgb(102, 102, 102); font-family: &quot;microsoft yahei&quot;, Georgia, &quot;Times New Roman&quot;, STHeiti, serif; font-size: 14px;" />\r<p style="color: rgb(102, 102, 102); font-family: &quot;microsoft yahei&quot;, Georgia, &quot;Times New Roman&quot;, STHeiti, serif; font-size: 14px;">由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 38),
(1567, 'Quartz执行顺序.png', 'Quartz执行顺序-png', 1555833961, 1555833961, 'a:5:{s:4:"name";s:22:"Quartz执行顺序.png";s:4:"path";s:35:"/usr/uploads/2019/04/1301201992.png";s:4:"size";i:87535;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1568, 0),
(1568, 'Quartz简介', '1568', 1555833979, 1555833979, '<p>本文记录Java学习过程中遇到的Quartz简介~</p>\r<!--more-->\r\r<p>Quartz是一个开源项目，它可以与J2EE或J2SE应用程序相结合，也可以单独使用。</p>\r\r<p>常用的API有：</p>\r\r<ul>\r	<li>Jobs：代表一个工作，即要执行的具体内容，此接口只有一个方法void execute(JobExecutionContext context)；</li>\r	<li>JobDetail：代表一个具体的可执行的调度程序，Job是这个可执行调度程序所要执行的内容，另外JobDetail还包含了这个任务调度的方案和策略。</li>\r	<li>Trigger：代表一个调度参数的配置，什么时候去调用；</li>\r	<li>Scheduler：代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger，当Trigger与JobDetail组合，就可以被Scheduller容器调度了；</li>\r	<li>SchedulerFactory：代表一个调度容器工厂，用来创建一个Scheduler调度容器。</li>\r</ul>\r\r<p>Quartz的执行流程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/1301201992.png" style="width: 800px; height: 359px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 21),
(1569, '七个域.png', '七个域-png', 1555835420, 1555835420, 'a:5:{s:4:"name";s:13:"七个域.png";s:4:"path";s:35:"/usr/uploads/2019/04/3192314818.png";s:4:"size";i:104654;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1570, 0),
(1570, 'Quartz的cron表达式的格式', '1570', 1555835696, 1555835696, '<p>本文记录Java学习过程中遇到的Quartz的cron表达式的格式~</p>\r<!--more-->\r\r<p>Quartz的cron表达式的格式十分类似于UNIX的cron的格式，但还是有少许明显的区别。区别之一就是Quartz的cron表达式向下支持到秒级别的计划，而UNIX cron计划仅支持到分钟级。许多我们的触发计划要基于秒级递增的(例如，每45秒)，因此这是一个非常好的差异。</p>\r\r<p>在UNIX的cron里，要执行的作业（或者说命令）是存放在cron表达式中的，在第六个域位置上。Quartz用cron表达式存放执行计划。引用了cron表达式的CronTrigger在计划的时间里会与job关联上。</p>\r\r<p>另一个与UNIX的cron表达式的不同点是在表达式中支持域的数目。UNIX给出五个域(分、时、日、月和周)，Quartz提供七个域。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/3192314818.png" style="width: 800px; height: 397px;" /></p>\r\r<p>月份和星期的名称是不区分大小写的，例如：FRI和fri是一样的。&nbsp;</p>\r\r<p>域之间有空格分隔，这和UNIX的cron一样。</p>\r\r<p>无可争辩的，我们能写的最简单的表达式看起来就是这个了：&nbsp;</p>\r\r<pre class="brush:bash;">\r* * * ? * * </pre>\r\r<p>这个表达会每秒钟(每分种的、每小时的、每天的)激发一个部署的 job。&nbsp;</p>\r\r<p><strong>常用特殊字符&nbsp;</strong></p>\r\r<p>同UNIX的cron一样，Quartz的cron表达式支持用特殊字符来创建更为复杂的执行计划。然而，Quartz在特殊字符的支持上比标准UNIX的cron表达式更丰富了。&nbsp;</p>\r\r<p><strong>*星号</strong></p>\r\r<p>使用星号(*)指示着你想在这个域上包含所有合法的值。例如，在月份域上使用星号意味着每个月都会触发这个trigger。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r0 * 17 * * ? </pre>\r\r<p>意义：每天从下午5点到下午5:59中的每分钟激发一次trigger。它停在下午5:59是因为值17在小时域上，在下午6点时，小时变为18了，也就不再理会这个trigger，直到下一天的下午5点。&nbsp;</p>\r\r<p>在希望trigger在该域的所有有效值上被激发时使用*字符。&nbsp;</p>\r\r<p><strong>?问号&nbsp;</strong></p>\r\r<p>?号只能用在日和周域上，但是不能在这两个域上同时使用。可以认为?字符是 &quot;我并不关心在该域上是什么值。&quot; 这不同于星号，星号是指示着该域上的每一个值。?是说不为该域指定值。&nbsp;</p>\r\r<p>不能同时这两个域上指定值的理由是难以解释甚至是难以理解的。基本上，假定同时指定值的话，意义就会变得含混不清了：考虑一下，如果一个表达式在日域上有值11，同时在周域上指定了WED。那么是要trigger仅在每个月的11号，且正好又是星期三那天被激发？还是在每个星期三的11号被激发呢？要去除这种不明确性的办法就是不能同时在这两个域上指定值。</p>\r\r<p>只要记住，假如你为这两域的其中一个指定了值，那就必须在另一个字值上放一个?。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r0 10,44 14 ? 3 WEB </pre>\r\r<p>意义：在三月中的每个星期三的下午2:10和下午2:44被触发。&nbsp;</p>\r\r<p><strong>,逗号&nbsp;</strong></p>\r\r<p>逗号(,)是用来在给某个域上指定一个值列表的。例如，使用值0,15,30,45在秒域上意味着每15秒触发一个trigger。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r0 0,15,30,45 * * * ? </pre>\r\r<p>意义：每刻钟触发一次trigger。&nbsp;</p>\r\r<p><strong>/斜杠&nbsp;</strong></p>\r\r<p>斜杠 (/) 是用于时间表的递增的。我们刚刚用了逗号来表示每15分钟的递增，但是我们也能写成这样0/15。&nbsp;</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r0/15 0/30 * * * ? </pre>\r\r<p>意义：在整点和半点时每15秒触发trigger。&nbsp;</p>\r\r<p><strong>-中划线&nbsp;</strong></p>\r\r<p>中划线(-)用于指定一个范围。例如，在小时域上的3-8意味着&quot;3,4,5,6,7和8点。&quot;域的值不允许回卷，所以像50-10这样的值是不允许的。&nbsp;</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r0 45 3-8 ? * * </pre>\r\r<p>意义：在上午的3点至上午的8点的45分时触发trigger。&nbsp;</p>\r\r<p><strong>L字母</strong></p>\r\r<p>L说明了某域上允许的最后一个值。它仅被日和周域支持。当用在日域上，表示的是在月域上指定的月份的最后一天。例如，当月域上指定了JAN时，在日域上的L会促使trigger在1月31号被触发。假如月域上是SEP，那么L会预示着在9月30号触发。换句话说，就是不管指定了哪个月，都是在相应月份的时最后一天触发trigger。&nbsp;</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r0 0 8 L * ?</pre>\r\r<p>意义是在每个月最后一天的上午8:00触发trigger。在月域上的 * 说明是 &quot;每个月&quot;。&nbsp;</p>\r\r<p>当L字母用于周域上，指示着周的最后一天，就是星期六 (或者数字7)。所以如果你需要在每个月的最后一个星期六下午的11:59触发trigger，你可以用这样的表达式0 59 23 ? * L。&nbsp;</p>\r\r<p>当使用于周域上，你可以用一个数字与L连起来表示月份的最后一个星期X。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r0 0 12 ? * 2L</pre>\r\r<p>意义：在每个月的最后一个星期一触发trigger，不要让范围和列表值与L连用。</p>\r\r<p>虽然你能用星期数(1-7)与L连用，但是不允许你用一个范围值和列表值与L连用，这会产生不可预知的结果。</p>\r\r<p><strong>W字母&nbsp;</strong></p>\r\r<p>W字符代表着平日(Mon-Fri)，并且仅能用于日域中。它用来指定离指定日的最近的一个平日。大部分的商业处理都是基于工作周的，所以W字符可能是非常重要的。例如，日域中的 15W意味着 &quot;离该月15号的最近一个平日。&quot;假如15号是星期六，那么trigger会在14号(星期四)触发，因为距15号最近的是星期一，这个例子中也会是17号（译者Unmi注：不会在17号触发的，如果是15W，可能会是在14号(15号是星期六)或者15号(15号是星期天)触发，也就是只能出现在邻近的一天，如果15号当天为平日直接就会当日执行）。W只能用在指定的日域为单天，不能是范围或列表值。&nbsp;</p>\r\r<p><strong>#井号&nbsp;</strong></p>\r\r<p>#字符仅能用于周域中。它用于指定月份中的第几周的哪一天。例如，如果你指定周域的值为6#3，它意思是某月的第三个周五(6=星期五，#3意味着月份中的第三周)。另一个例子 2#1意思是某月的第一个星期一(2=星期一，#1意味着月份中的第一周)。注意，假如你指定#5，然而月份中没有第5周，那么该月不会触发。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r#每天中午12点触发\r&quot;0 0 12 * *?&quot;\r\r#每天上午10:15触发\r&quot;0 15 10 ? **&quot;\r\r#每天上午10:15触发\r&quot;0 15 10 * *?&quot;\r\r#每天上午10:15触发\r&quot;0 15 10 * * ?*&quot;\r\r#2005年的每天上午10:15触发\r&quot;0 15 10 * * ?2005&quot;\r\r#在每天下午2点到下午2:59期间的每1分钟触发\r&quot;0 * 14 * *?&quot;\r\r#在每天下午2点到下午2:55期间的每5分钟触发\r&quot;0 0/5 14 * *?&quot;\r\r#在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发\r&quot;0 0/5 14,18 ** ?&quot;\r\r#在每天下午2点到下午2:05期间的每1分钟触发\r&quot;0 0-5 14 * *?&quot;\r\r#每年三月的星期三的下午2:10和2:44触发\r&quot;0 10,44 14 ? 3WED&quot;\r\r#周一至周五的上午10:15触发\r&quot;0 15 10 ? *MON-FRI&quot;\r\r#每月15日上午10:15触发\r&quot;0 15 10 15 *?&quot;\r\r#每月最后一日的上午10:15触发\r&quot;0 15 10 L *?&quot;\r\r#每月的最后一个星期五上午10:15触发\r&quot;0 15 10 ? *6L&quot;\r\r#2002年至2005年的每月的最后一个星期五上午10:15触发\r&quot;0 15 10 ? * 6L2002-2005&quot;\r\r#每月的第三个星期五上午10:15触发\r&quot;0 15 10 ? *6#3&quot;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 33),
(1571, '数据分类', '1571', 1556414064, 1556414064, '<p>本文记录Java学习过程中遇到的数据分类～</p>\r<!--more-->\r\r<p>生活中的数据总体分为两种：结构化数据和非结构化数据。</p>\r\r<ul>\r	<li>结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等；</li>\r	<li>非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 18),
(1572, '非结构化数据查询方法', '1572', 1556414226, 1556414226, '<p>本文记录Java学习过程中遇到的非结构化数据查询方法～</p>\r<!--more-->\r\r<p><strong>顺序扫描法(Serial Scanning)</strong></p>\r\r<p>所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。</p>\r\r<p><strong>全文检索(Full-text Search)</strong></p>\r\r<p>将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。</p>\r\r<p>例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据&mdash;&mdash;也即对字的解释。</p>\r\r<p>这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。</p>\r\r<p>虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 22),
(1573, 'lucene.png', 'lucene-png', 1556414457, 1556414457, 'a:5:{s:4:"name";s:10:"lucene.png";s:4:"path";s:35:"/usr/uploads/2019/04/3323234979.png";s:4:"size";i:100650;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1574, 0),
(1574, 'Lucene实现全文检索的流程', '1574', 1556414569, 1556414569, '<p>本文记录Java学习过程中遇到的Lucene实现全文检索的流程～</p>\r<!--more-->\r\r<p>索引和搜索流程图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/3323234979.png" style="width: 800px; height: 255px;" />​</p>\r\r<ol>\r	<li>绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：确定原始内容即要搜索的内容-&gt;采集文档-&gt;创建文档-&gt;分析文档-&gt;索引文档；</li>\r	<li>红色表示搜索过程，从索引库中搜索内容，搜索过程包括：用户通过搜索界面-&gt;创建查询-&gt;执行搜索，从索引库搜索-&gt;渲染搜索结果。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 20),
(1575, 'Lucene创建索引', '1575', 1556414940, 1556415745, '<p>本文记录Java学习过程中遇到的Lucene创建索引～</p>\r<!--more-->\r\r<p>创建索引是对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。</p>\r\r<p><strong>获得原始文档</strong></p>\r\r<p>原始文档是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。<br />\r&nbsp;<br />\r从互联网上、数据库、文件系统中等获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。<br />\r在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来。</p>\r\r<p>Lucene不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，如下：</p>\r\r<ul>\r	<li>Nutch（<a href="http://nutch.apache.org/" target="_blank">http://nutch.apache.org/</a>）, Nutch是Apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。</li>\r	<li>jsoup（<a href="http://jsoup.org/" target="_blank">http://jsoup.org/</a> ），jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li>\r	<li>heritrix（<a href="http://sourceforge.net/projects/archive-crawler/files/" target="_blank">http://sourceforge.net/projects/archive-crawler/files/</a>），Heritrix 是一个由Java开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。</li>\r</ul>\r\r<p><strong>创建文档对象</strong></p>\r\r<p>获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/1401427531.png" style="width: 800px; height: 472px;" /></p>\r\r<p>注意：每个Document可以有多个Field，不同的Document可以有不同的Field，同一个Document可以有相同的Field（域名和域值都相同），每个文档都有一个唯一的编号，就是文档id。</p>\r\r<p><strong>分析文档</strong></p>\r\r<p>将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。</p>\r\r<p>示例过程：</p>\r\r<pre class="brush:bash;">\r#原文档内容\rLucene is a Java full-text search engine.  Lucene is not a complete\rapplication, but rather a code library and API that can easily be used\rto add search capabilities to applications.\r\r#分析后得到的语汇单元\rlucene、java、full、search、engine。。。。</pre>\r\r<p>每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的Term。Term中包含两部分一部分是文档的域名，另一部分是单词的内容。例如：文件名中包含apache和文件内容中包含的apache是不同的Term。</p>\r\r<p><strong>创建索引</strong></p>\r\r<p>对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到Document（文档）。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/1371907710.png" style="width: 800px; height: 480px;" /></p>\r\r<p>注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。</p>\r\r<p>传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。</p>\r\r<p>倒排索引结构是根据内容（词语）找文档，如下图：&nbsp;</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/3836788476.png" style="width: 800px; height: 227px;" /></p>\r\r<p>倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 90),
(1576, 'Document.png', 'Document-png-1', 1556415197, 1556415197, 'a:5:{s:4:"name";s:12:"Document.png";s:4:"path";s:35:"/usr/uploads/2019/04/1401427531.png";s:4:"size";i:109715;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1575, 0),
(1577, '索引.png', '索引-png', 1556415630, 1556415630, 'a:5:{s:4:"name";s:10:"索引.png";s:4:"path";s:35:"/usr/uploads/2019/04/1371907710.png";s:4:"size";i:130475;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1575, 0),
(1578, '倒排索引.png', '倒排索引-png', 1556415726, 1556415726, 'a:5:{s:4:"name";s:16:"倒排索引.png";s:4:"path";s:35:"/usr/uploads/2019/04/3836788476.png";s:4:"size";i:544713;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1575, 0),
(1579, '用户查询接口.png', '用户查询接口-png', 1556416839, 1556416839, 'a:5:{s:4:"name";s:22:"用户查询接口.png";s:4:"path";s:35:"/usr/uploads/2019/04/3599341048.png";s:4:"size";i:304988;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1580, 0),
(1580, 'Lucene查询索引', '1580', 1556416800, 1556426534, '<p>本文记录Java学习过程中遇到的Lucene查询索引～</p>\r<!--more-->\r\r<p>查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。&nbsp;</p>\r\r<p><strong>查询接口</strong></p>\r\r<p>全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/3599341048.png" style="width: 800px; height: 398px;" />​</p>\r\r<p>Lucene不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面。</p>\r\r<p><strong>创建查询</strong></p>\r\r<p>用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的Field文档域、查询关键字等，查询对象会生成具体的查询语法，例如：语法 &ldquo;fileName:lucene&rdquo;表示要搜索Field域的内容为&ldquo;lucene&rdquo;的文档。</p>\r\r<p><strong>执行查询</strong></p>\r\r<p>搜索索引过程：根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。比如搜索语法为&ldquo;fileName:lucene&rdquo;表示搜索出fileName域中包含Lucene的文档。搜索过程就是在索引上查找域为fileName，并且关键字为Lucene的Term，并根据term找到文档id列表。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/2073409939.png" style="width: 800px; height: 227px;" /></p>\r\r<p><strong>渲染结果</strong></p>\r\r<p>以一个友好的界面将查询结果展示给用户，用户根据搜索结果找自己想要的信息，为了帮助用户很快找到自己的结果，提供了很多展示的效果，比如搜索结果中将关键字高亮显示，百度提供的快照等。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/1079755240.png" style="width: 800px; height: 500px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 29),
(1581, '执行查询.png', '执行查询-png', 1556426414, 1556426414, 'a:5:{s:4:"name";s:16:"执行查询.png";s:4:"path";s:35:"/usr/uploads/2019/04/2073409939.png";s:4:"size";i:544482;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1580, 0),
(1582, '渲染结果.png', '渲染结果-png', 1556426502, 1556426502, 'a:5:{s:4:"name";s:16:"渲染结果.png";s:4:"path";s:35:"/usr/uploads/2019/04/1079755240.png";s:4:"size";i:426204;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1580, 0),
(1583, 'Lucene中Field域属性', '1583', 1556438580, 1556438670, '<p>本文记录Java学习过程中遇到的Lucene中Field域属性～</p>\r<!--more-->\r\r<p>Field域常用的属性有：</p>\r\r<ul>\r	<li>是否分析：是否对域的内容进行分词处理，前提是要对域的内容进行查询；</li>\r	<li>是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件；</li>\r	<li>是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储；</li>\r	<li>是否存储的标准：是否要将内容展示给用户。</li>\r</ul>\r\r<p>常用的Field类：</p>\r\r<table border="1" cellpadding="1" cellspacing="1" style="width: 800px;">\r	<thead>\r		<tr>\r			<th scope="col">Field类</th>\r			<th scope="col">数据类型</th>\r			<th scope="col">Analyzed<br />\r			是否分析</th>\r			<th scope="col">Indexed<br />\r			是否索引</th>\r			<th scope="col">Stored<br />\r			是否存储</th>\r			<th scope="col">说明</th>\r		</tr>\r	</thead>\r	<tbody>\r		<tr>\r			<td>StringField(FieldName, FieldValue,Store.YES))</td>\r			<td>字符串</td>\r			<td>N</td>\r			<td>Y</td>\r			<td>Y/N</td>\r			<td>用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)，是否存储在文档中用Store.YES或Store.NO决定。</td>\r		</tr>\r		<tr>\r			<td>LongField(FieldName, FieldValue,Store.YES)</td>\r			<td>Long型</td>\r			<td>Y</td>\r			<td>Y</td>\r			<td>Y/N</td>\r			<td>这个Field用来构建一个Long数字型Field，进行分析和索引，比如(价格)，是否存储在文档中用Store.YES或Store.NO决定。</td>\r		</tr>\r		<tr>\r			<td>StoredField(FieldName, FieldValue)&nbsp;</td>\r			<td>重载方法，支持多种类型</td>\r			<td>N</td>\r			<td>N</td>\r			<td>Y</td>\r			<td>这个Field用来构建不同类型Field，不分析，不索引，但要Field存储在文档中。</td>\r		</tr>\r		<tr>\r			<td>\r			<p align="center">TextField(FieldName, FieldValue, Store.NO)或TextField(FieldName, reader)</p>\r			</td>\r			<td>字符串或流</td>\r			<td>Y</td>\r			<td>Y</td>\r			<td>Y/N</td>\r			<td>如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略.</td>\r		</tr>\r	</tbody>\r</table>\r\r<p>&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 20),
(1584, 'Lucene的IndexSearcher常用搜索方法', '1584', 1556454339, 1556454339, '<p>本文记录Java学习过程中遇到的Lucene的IndexSearcher常用搜索方法～</p>\r<!--more-->\r\r<p>IndexSearcher常用搜索方法有：</p>\r\r<ul>\r	<li>indexSearcher.search(query, n)：根据Query搜索，返回评分最高的n条记录；</li>\r	<li>indexSearcher.search(query, filter, n)：根据Query搜索，添加过滤策略，返回评分最高的n条记录；</li>\r	<li>indexSearcher.search(query, n, sort)：根据Query搜索，添加排序策略，返回评分最高的n条记录；</li>\r	<li>indexSearcher.search(booleanQuery, filter, n, sort)：根据Query搜索，添加过滤策略，添加排序策略，返回评分最高的n条记录。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 23),
(1585, 'Lucene的TopDocs遍历搜索结果', '1585', 1556456224, 1556456224, '<p>本文记录Java学习过程中遇到的Lucene的TopDocs遍历搜索结果～</p>\r<!--more-->\r\r<p>Lucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下：</p>\r\r<ul>\r	<li>totalHits：匹配搜索条件的总记录数；</li>\r	<li>scoreDocs：顶部匹配记录。</li>\r</ul>\r\r<p>注意：</p>\r\r<p>Search方法需要指定匹配记录数量n：indexSearcher.search(query, n)，TopDocs.totalHits：是匹配索引库中所有记录的数量，<br />\rTopDocs.scoreDocs匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 23),
(1586, 'Lucene常用中文分词器', '1586', 1556457681, 1556457681, '<p>本文记录Java学习过程中遇到的Lucene常用中文分词器～</p>\r<!--more-->\r\r<p><strong>Lucene自带中文分词器</strong></p>\r\r<ul>\r	<li>StandardAnalyzer：单字分词：就是按照中文一个字一个字地进行分词。如：&ldquo;我爱中国&rdquo;，</li>\r	<li>效果：&ldquo;我&rdquo;、&ldquo;爱&rdquo;、&ldquo;中&rdquo;、&ldquo;国&rdquo;；</li>\r	<li>CJKAnalyzer：二分法分词：按两个字进行切分。如：&ldquo;我是中国人&rdquo;，效果：&ldquo;我是&rdquo;、&ldquo;是中&rdquo;、&ldquo;中国&rdquo;&ldquo;国人&rdquo;；</li>\r	<li>SmartChineseAnalyzer：对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理。</li>\r</ul>\r\r<p><strong>第三方中文分析器</strong></p>\r\r<ul>\r	<li>paoding：庖丁解牛最新版在<a href="https://github.com/cslinmiso/paoding-analysis" target="_blank">https://github.com/cslinmiso/paoding-analysis</a>中最多支持Lucene3.0，且最新提交的代码在 2008-06-03，在svn中最新也是2010年提交，已经过时，不予考虑；</li>\r	<li>mmseg4j：最新版在<a href="https://github.com/chenlb/mmseg4j-solr" target="_blank">https://github.com/chenlb/mmseg4j-solr</a>，支持Lucene 4.10，且在github中最新提交代码是2014年6月，从09年～14年一共有：18个版本，也就是一年几乎有3个大小版本，有较大的活跃度；</li>\r	<li>IK-analyzer： 最新版在<a href="https://code.google.com/p/ik-analyzer/" target="_blank">https://code.google.com/p/ik-analyzer/</a>上，支持Lucene 4.10从2006年12月推出1.0版开始， IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开 始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词 歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 但是也就是2012年12月后没有在更新；</li>\r	<li>ansj_seg：最新版本在<a href="https://github.com/NLPchina/ansj_seg" target="_blank">https://github.com/NLPchina/ansj_seg</a>，tags仅有1.1版本，从2012年到2014年更新了大小6次，但是作者本人在2014年10月10日说明：&ldquo;可能我以后没有精力来维护ansj_seg了&rdquo;，现在由&rdquo;nlp_china&rdquo;管理。2014年11月有更新。并未说明是否支持Lucene，是一个由CRF（条件随机场）算法所做的分词算法；</li>\r	<li>imdict-chinese-analyzer：最新版在 <a href="https://code.google.com/p/imdict-chinese-analyzer/" target="_blank">https://code.google.com/p/imdict-chinese-analyzer/ </a>， 最新更新也在2009年5月，下载源码，不支持Lucene 4.10 。是利用HMM（隐马尔科夫链）算法;</li>\r	<li>Jcseg：最新版本在<a href="https://github.com/lionsoul2014/jcseg" target="_blank">https://github.com/lionsoul2014/jcseg</a>，支持Lucene 4.10，作者有较高的活跃度，利用mmseg算法。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 26),
(1587, 'Analyzer.png', 'Analyzer-png', 1556458158, 1556458158, 'a:5:{s:4:"name";s:12:"Analyzer.png";s:4:"path";s:35:"/usr/uploads/2019/04/1425237236.png";s:4:"size";i:599079;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1588, 0),
(1588, 'Lucene中的Analyzer使用时机', '1588', 1556458271, 1556458271, '<p>本文记录Java学习过程遇到的Lucene中的Analyzer使用时机～</p>\r<!--more-->\r\r<p><strong>索引时使用Analyzer</strong></p>\r\r<p>输入关键字进行搜索，当需要让该关键字与文档域内容所包含的词进行匹配时需要对文档域内容进行分析，需要经过Analyzer分析器处理生成语汇单元（Token）。分析器分析的对象是文档中的Field域。当Field的属性tokenized（是否分词）为true时会对Field值进行分析，如下图：&nbsp;</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/1425237236.png" style="width: 800px;" /><br />\r&nbsp;<br />\r对于一些Field可以不用分析：</p>\r\r<ol>\r	<li>不作为查询条件的内容，比如文件路径；</li>\r	<li>不是匹配内容中的词而匹配Field的整体内容，比如订单号、身份证号等。</li>\r</ol>\r\r<p><strong>搜索时使用Analyzer</strong></p>\r\r<p>对搜索关键字进行分析和索引分析一样，使用Analyzer对搜索关键字进行分析、分词处理，使用分析后每个词语进行搜索。比如：搜索关键字：spring web ，经过分析器进行分词，得出：spring&nbsp; web拿词去索引词典表查找 ，找到索引链接到Document，解析Document内容。对于匹配整体Field域的查询可以在搜索时不分析，比如根据订单号、身份证号查询等。</p>\r\r<p>注意：搜索使用的分析器要和索引使用的分析器一致。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 19);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1589, 'Lucene索引库的维护', '1589', 1556495592, 1556495592, '<p>本文记录Java学习过程中遇到的Lucene索引库的维护～</p>\r<!--more-->\r\r<p><strong>索引库的添加</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r//添加索引\r@Test\rpublic void addDocument() throws Exception {\r\r	// 索引库存放路径\r	Directory directory = FSDirectory.open(new File(&quot;D:\\\\temp\\\\0108\\\\index&quot;));\r	IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, new IKAnalyzer());\r	// 创建一个indexwriter对象\r	IndexWriter indexWriter = new IndexWriter(directory, config);\r	// 创建一个Document对象\r	Document document = new Document();\r	// 向document对象中添加域。\r	// 不同的document可以有不同的域，同一个document可以有相同的域。\r	document.add(new TextField(&quot;filename&quot;, &quot;新添加的文档&quot;, Store.YES));\r	document.add(new TextField(&quot;content&quot;, &quot;新添加的文档的内容&quot;, Store.NO));\r	document.add(new TextField(&quot;content&quot;, &quot;新添加的文档的内容第二个content&quot;, Store.YES));\r	document.add(new TextField(&quot;content1&quot;, &quot;新添加的文档的内容要能看到&quot;, Store.YES));\r	// 添加文档到索引库\r	indexWriter.addDocument(document);\r	// 关闭indexwriter\r	indexWriter.close();	\r}</pre>\r\r<p><strong>索引库的删除</strong></p>\r\r<p>示例代码（指定查询条件删除）：</p>\r\r<pre class="brush:java;">\r// 根据查询条件删除索引\r@Test\rpublic void deleteIndexByQuery() throws Exception {\r\r	IndexWriter indexWriter = getIndexWriter();\r	// 创建一个查询条件\r	Query query = new TermQuery(new Term(&quot;filename&quot;, &quot;apache&quot;));\r	// 根据查询条件删除\r	indexWriter.deleteDocuments(query);\r	// 关闭indexwriter\r	indexWriter.close();\r}</pre>\r\r<p>示例代码（删除全部）：</p>\r\r<pre class="brush:java;">\r// 删除全部索引\r@Test\rpublic void deleteAllIndex() throws Exception {\r\r	IndexWriter indexWriter = getIndexWriter();\r	// 删除全部索引\r	indexWriter.deleteAll();\r	// 关闭indexwriter\r	indexWriter.close();\r}</pre>\r\r<p><strong>索引库的修改</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 修改索引库\r@Test\rpublic void updateIndex() throws Exception {\r\r	IndexWriter indexWriter = getIndexWriter();\r	// 创建一个Document对象\r	Document document = new Document();\r	// 向document对象中添加域。\r	// 不同的document可以有不同的域，同一个document可以有相同的域。\r	document.add(new TextField(&quot;filename&quot;, &quot;要更新的文档&quot;, Store.YES));\r	document.add(new TextField(&quot;content&quot;, &quot;2013年11月18日 - Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。&quot;, Store.YES));\r	indexWriter.updateDocument(new Term(&quot;content&quot;, &quot;java&quot;), document);\r	// 关闭indexWriter\r	indexWriter.close();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 20),
(1590, 'Lucene索引库的查询', '1590', 1556496863, 1556496863, '<p>本文记录Java学习过程中遇到的Lucene索引库的查询～</p>\r<!--more-->\r\r<p>对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法，类似关系数据库Sql语法一样Lucene也有自己的查询语法，比如：&ldquo;name:lucene&rdquo;表示查询Field的name为&ldquo;lucene&rdquo;的文档信息。</p>\r\r<p>可通过两种方法创建查询对象：</p>\r\r<ul>\r	<li>使用Lucene提供Query子类；</li>\r	<li>使用QueryParse解析查询表达式。</li>\r</ul>\r\r<p><strong>使用Query的子类查询</strong></p>\r\r<p>MatchAllDocsQuery：查询索引目录中的所有文档。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testMatchAllDocsQuery() throws Exception {\r\r	IndexSearcher indexSearcher = getIndexSearcher();\r	// 创建查询条件\r	Query query = new MatchAllDocsQuery();\r	// 执行查询\r	printResult(query, indexSearcher);\r}</pre>\r\r<p>TermQuery：通过项查询，TermQuery不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等，需要指定要查询的域和要查询的关键词。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testTermQuery() throws Exception {\r\r	IndexSearcher indexSearcher = getIndexSearcher();\r	// 创建查询对象\r	Query query = new TermQuery(new Term(&quot;content&quot;, &quot;lucene&quot;));\r	// 执行查询\r	TopDocs topDocs = indexSearcher.search(query, 10);\r	// 共查询到的document个数\r	System.out.println(&quot;查询结果总数量：&quot; + topDocs.totalHits);\r	// 遍历查询结果\r	for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\r		Document document = indexSearcher.doc(scoreDoc.doc);\r		System.out.println(document.get(&quot;filename&quot;));\r		System.out.println(document.get(&quot;content&quot;));\r		System.out.println(document.get(&quot;path&quot;));\r		System.out.println(document.get(&quot;size&quot;));\r	}\r	// 关闭indexReader\r	indexSearcher.getIndexReader().close();\r}</pre>\r\r<p>NumericRangeQuery：根据数值范围查询。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testNumericRangeQuery() throws Exception {\r	IndexSearcher indexSearcher = getIndexSearcher();\r	//创建查询\r	//参数：\r	// 1.域名\r	// 2.最小值\r	// 3.最大值\r	// 4.是否包含最小值\r	// 5.是否包含最大值\r	Query query = NumericRangeQuery.newLongRange(&quot;size&quot;, 1l, 1000l, true, true);\r	// 执行查询\r	printResult(query, indexSearcher);\r}</pre>\r\r<p>BooleanQuery：可以组合查询条件。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testBooleanQuery() throws Exception {\r\r	IndexSearcher indexSearcher = getIndexSearcher();\r	// 创建一个布尔查询对象\r	BooleanQuery query = new BooleanQuery();\r	// 创建第一个查询条件\r	Query query1 = new TermQuery(new Term(&quot;filename&quot;, &quot;apache&quot;));\r	Query query2 = new TermQuery(new Term(&quot;content&quot;, &quot;apache&quot;));\r	// 组合查询条件\r	query.add(query1, Occur.MUST);\r	query.add(query2, Occur.MUST);\r	// 执行查询\r	printResult(query, indexSearcher);\r}</pre>\r\r<p>常用的选项取值：</p>\r\r<ul>\r	<li>Occur.MUST：必须满足此条件，相当于and；</li>\r	<li>Occur.SHOULD：应该满足，但是不满足也可以，相当于or；</li>\r	<li>Occur.MUST_NOT：必须不满足。相当于not。</li>\r</ul>\r\r<p>使用QueryParser查询</p>\r\r<p>通过QueryParser也可以创建Query，QueryParser提供一个Parse方法，此方法可以直接根据查询语法来查询。Query对象执行的查询语法可通过System.out.println(query);查询。需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testQueryParser() throws Exception {\r\r	IndexSearcher indexSearcher = getIndexSearcher();\r	// 创建queryparser对象\r	// 第一个参数默认搜索的域\r	// 第二个参数就是分析器对象\r	QueryParser queryParser = new QueryParser(&quot;content&quot;, new IKAnalyzer());\r	Query query = queryParser.parse(&quot;Lucene是java开发的&quot;);\r	// 执行查询\r	printResult(query, indexSearcher);\r}</pre>\r\r<p>查询语法：</p>\r\r<ol>\r	<li>基础的查询语法，关键词查询：域名+&ldquo;：&rdquo;+搜索的关键字，例如：content:java；</li>\r	<li>范围查询：域名+&ldquo;:&rdquo;+[最小值 TO 最大值]，例如：size:[1 TO 1000]，范围查询在lucene中支持数值类型，不支持字符串类型，但在solr中支持字符串类型；</li>\r	<li>组合条件查询 ：</li>\r</ol>\r\r<ul style="margin-left: 40px;">\r	<li>+条件1 +条件2：两个条件之间是并且的关系and，例如：+filename:apache +content:apache；</li>\r	<li>+条件1 条件2：必须满足第一个条件，应该满足第二个条件，例如：+filename:apache content:apache；</li>\r	<li>条件1 条件2：两个条件满足其一即可，例如：filename:apache content:apache；</li>\r	<li>-条件1 条件2：必须不满足条件1，要满足条件2，例如：-filename:apache content:apache。</li>\r</ul>\r\r<p>注意：也可以使用AND、OR和NOT，即：条件1 AND 条件2；条件1 OR 条件2；条件1 NOT 条件2。</p>\r\r<p>MultiFieldQueryParser：可以指定多个默认搜索域</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Test\rpublic void testMultiFiledQueryParser() throws Exception {\r\r	IndexSearcher indexSearcher = getIndexSearcher();\r	// 可以指定默认搜索的域是多个\r	String[] fields = {&quot;filename&quot;, &quot;content&quot;};\r	// 创建一个MulitFiledQueryParser对象\r	MultiFieldQueryParser queryParser = new MultiFieldQueryParser(fields, new IKAnalyzer());\r	Query query = queryParser.parse(&quot;java AND apache&quot;);\r	System.out.println(query);\r	// 执行查询\r	printResult(query, indexSearcher);\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 22),
(1591, 'Solr简介', '1591', 1556497620, 1556497711, '<p>本文记录Java学习过程中遇到的Solr简介～</p>\r<!--more-->\r\r<p>Solr是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。&nbsp;</p>\r\r<p>Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr索引的实现方法很简单，用POST方法向Solr服务器发送一个描述Field及其内容的XML文档，Solr根据xml文档添加、删除、更新索引。Solr搜索只需要发送HTTP的GET请求，然后对Solr返回XML、JSON等格式的查询结果进行解析，组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。</p>\r\r<p>Solr与Lucene的区别：</p>\r\r<ul>\r	<li>Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎；</li>\r	<li>Solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/2054149928.png" style="width: 800px; height: 484px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24),
(1592, 'Solr简介.png', 'Solr简介-png', 1556497693, 1556497693, 'a:5:{s:4:"name";s:14:"Solr简介.png";s:4:"path";s:35:"/usr/uploads/2019/04/2054149928.png";s:4:"size";i:719459;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1591, 0),
(1593, 'Solr常见目录结构', '1593', 1556503910, 1556503910, '<p>本文记录Java学习过程中遇到的Solr常见目录结构～</p>\r<!--more-->\r\r<p>Solr安装包的目录结构：</p>\r\r<ul>\r	<li>bin：solr的运行脚本；</li>\r	<li>contrib：solr的一些贡献软件/插件，用于增强solr的功能；</li>\r	<li>dist：该目录包含build过程中产生的war和jar文件，以及相关的依赖文件；</li>\r	<li>docs：solr的API文档；</li>\r	<li>licenses：solr相关的一些许可信息；</li>\r	<li>example：solr工程的示例目录：</li>\r</ul>\r\r<ol style="margin-left: 40px;">\r	<li>example/solr：该目录是一个包含了默认配置信息的Solr的Core目录；</li>\r	<li>example/multicore：该目录包含了在Solr的multicore中设置的多个Core目录；</li>\r	<li>example/webapps：该目录中包括一个solr.war，该war可作为solr的运行实例工程。</li>\r</ol>\r\r<p>SolrHome与SolrCore</p>\r\r<p>创建一个SolrHome目录，SolrHome是Solr运行的主目录，目录中包括了运行Solr实例所有的配置文件和数据文件，Solr实例就是SolrCore，一个SolrHome可以包括多个SolrCore（Solr实例），每个SolrCore提供单独的搜索和索引服务。</p>\r\r<p>example\\solr是一个SolrHome目录结构，里面的&ldquo;collection1&rdquo;是一个SolrCore（Solr实例）目录。</p>\r\r<p>SolrCore主要包括：</p>\r\r<ul>\r	<li>conf：SolrCore的配置文件目录；</li>\r	<li>data：用来存放索引文件。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 25),
(1594, 'Field.png', 'Field-png', 1556528735, 1556528735, 'a:5:{s:4:"name";s:9:"Field.png";s:4:"path";s:35:"/usr/uploads/2019/04/2553389250.png";s:4:"size";i:217522;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1597, 0),
(1595, '创建索引.png', '创建索引-png', 1556528862, 1556528862, 'a:5:{s:4:"name";s:16:"创建索引.png";s:4:"path";s:35:"/usr/uploads/2019/04/1585981364.png";s:4:"size";i:106113;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1597, 0),
(1596, '搜索索引.png', '搜索索引-png', 1556528885, 1556528885, 'a:5:{s:4:"name";s:16:"搜索索引.png";s:4:"path";s:34:"/usr/uploads/2019/04/953236991.png";s:4:"size";i:238514;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1597, 0),
(1597, 'Solr数据表配置文件schema.xml', '1597', 1556528880, 1556528940, '<p>本文记录Java学习过程中遇到的Solr数据表配置文件schema.xml～</p>\r<!--more-->\r\r<p>schema.xml在SolrCore的conf目录下，是Solr数据表配置文件，它定义了加入索引的数据的数据类型的。主要包括FieldTypes、Fields和其他的一些缺省设置。</p>\r\r<p><strong>FieldType域类型定义</strong></p>\r\r<p>下边&ldquo;text_general&rdquo;是Solr默认提供的FieldType，通过它说明FieldType定义的内容：</p>\r\r<pre class="brush:xml;">\r&lt;fieldType name=&quot;text_general&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt;\r  &lt;analyzer type=&quot;index&quot;&gt;\r    &lt;tokenizer class=&quot;solr.StandardTokenizerFactory&quot;/&gt;\r    &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt;\r    &lt;!-- in this example, we will only use synonyms at query time\r    &lt;filter class=&quot;solr.SynonymFilterFactory&quot; synonyms=&quot;index_synonyms.txt&quot; ignoreCase=&quot;true&quot; expand=&quot;false&quot;/&gt;\r    --&gt;\r    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;\r   &lt;/analyzer&gt;\r   &lt;analyzer type=&quot;query&quot;&gt;\r    &lt;tokenizer class=&quot;solr.StandardTokenizerFactory&quot;/&gt;\r    &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt;\r    &lt;filter class=&quot;solr.SynonymFilterFactory&quot; synonyms=&quot;synonyms.txt&quot; ignoreCase=&quot;true&quot; expand=&quot;true&quot;/&gt;\r    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;\r  &lt;/analyzer&gt;\r&lt;/fieldType&gt;</pre>\r\r<p>FieldType子结点包括：name,class,positionIncrementGap等一些参数：</p>\r\r<ul>\r	<li>name：是这个FieldType的名称；</li>\r	<li>class：是Solr提供的包solr.TextField，solr.TextField允许用户通过分析器来定制索引和查询，分析器包括一个分词器（tokenizer）和多个过滤器（filter）；</li>\r	<li>positionIncrementGap：可选属性，定义在同一个文档中此类型数据的空白间隔，避免短语匹配错误，此值相当于Lucene的短语查询设置slop值，根据经验设置为100。</li>\r</ul>\r\r<p>在FieldType定义的时候最重要的就是定义这个类型的数据在建立索引和进行查询的时候要使用的分析器analyzer,包括分词和过滤：</p>\r\r<ul>\r	<li>索引分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilterFactory停用词过滤器，solr.LowerCaseFilterFactory小写过滤器；</li>\r	<li>搜索分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilterFactory停用词过滤器，这里还用到了solr.SynonymFilterFactory同义词过滤器。</li>\r</ul>\r\r<p><strong>Field定义</strong></p>\r\r<p>在fields结点内定义具体的Field，filed定义包括name,type（为之前定义过的各种FieldType）,indexed（是否被索引）,stored（是否被储存），multiValued（是否存储多个值）等属性。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;field name=&quot;name&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;\r&lt;field name=&quot;features&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot; /&gt;</pre>\r\r<p>multiValued：该Field如果要存储多个值时设置为true，solr允许一个Field存储多个值，比如存储一个用户的好友id（多个），商品的图片（多个，大图和小图），通过使用solr查询要看出返回给客户端是数组：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/2553389250.png" style="width: 800px; height: 438px;" /></p>\r\r<p><strong>uniqueKey</strong></p>\r\r<p>Solr中默认定义唯一主键key为id域，如下：</p>\r\r<pre class="brush:xml;">\r&lt;uniqueKey&gt;id&lt;/uniqueKey&gt;</pre>\r\r<p>Solr在删除、更新索引时使用id域进行判断，也可以自定义唯一主键。</p>\r\r<p>注意：在创建索引时必须指定唯一约束。</p>\r\r<p><strong>copyField复制域</strong></p>\r\r<p>copyField复制域，可以将多个Field复制到一个Field中，以便进行统一的检索，比如，输入关键字搜索title标题内容content，定义title、content、text的域：</p>\r\r<pre class="brush:xml;">\r&lt;field name=&quot;title&quot; type=&quot;text_grneral&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValue=&quot;true&quot; /&gt;\r&lt;field name=&quot;context&quot; type=&quot;text_grneral&quot; indexed=&quot;false&quot; stored=&quot;true&quot; multiValue=&quot;true&quot; /&gt;\r&lt;field name=&quot;text&quot; type=&quot;text_grneral&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValue=&quot;true&quot; /&gt;</pre>\r\r<p>根据关键字只搜索text域的内容就相当于搜索title和content，将title和content复制到text中，如下：</p>\r\r<pre class="brush:xml;">\r&lt;copyField source=&quot;title&quot; dest=&quot;text&quot; /&gt;\r&lt;copyField source=&quot;author&quot; dest=&quot;text&quot; /&gt;\r&lt;copyField source=&quot;description&quot; dest=&quot;text&quot; /&gt;\r&lt;copyField source=&quot;keywords&quot; dest=&quot;text&quot; /&gt;\r&lt;copyField source=&quot;content&quot; dest=&quot;text&quot; /&gt;</pre>\r\r<p><strong>dynamicField（动态字段）</strong></p>\r\r<p>动态字段就是不用指定具体的名称，只要定义字段名称的规则，例如定义一个dynamicField，name为*_i，定义它的type为text，那么在使用这个字段的时候，任何以_i结尾的字段都被认为是符合这个定义的，例如：name_i，gender_i，school_i等。</p>\r\r<p>自定义Field名为：product_title_t，&ldquo;product_title_t&rdquo;和scheam.xml中的dynamicField规则匹配成功，如下：</p>\r\r<pre class="brush:xml;">\r&lt;dynamicField name=&quot;*_t&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;</pre>\r\r<p>&ldquo;product_title_t&rdquo;是以&ldquo;_t&rdquo;结尾。</p>\r\r<p>创建索引：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/1585981364.png" style="width: 800px; height: 412px;" /></p>\r\r<p>搜索索引：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/953236991.png" style="width: 800px; height: 660px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 31),
(1598, 'Solr安装中文分词器', '1598', 1556545235, 1556545235, '<p>本文记录Java学习过程中遇到的Solr安装中文分词器～</p>\r<!--more-->\r\r<p>1.把IKAnalyzer2012FF_u1.jar添加到solr/WEB-INF/lib目录下；<br />\r2.复制IKAnalyzer的配置文件和自定义词典和停用词词典到solr的classpath下；<br />\r3.在schema.xml中添加一个自定义的fieldType，使用中文分析器：</p>\r\r<pre class="brush:xml;">\r&lt;!-- IKAnalyzer --&gt;\r&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;\r  &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;\r&lt;/fieldType&gt;</pre>\r\r<p>4.定义field，指定field的type属性为text_ik：</p>\r\r<pre class="brush:xml;">\r&lt;!-- IKAnalyzer Field --&gt;\r&lt;field name=&quot;title_ik&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;\r&lt;field name=&quot;content_ik&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot; /&gt;</pre>\r\r<p>5.重启solr。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 25),
(1599, '添加更新.png', '添加更新-png', 1556548259, 1556548259, 'a:5:{s:4:"name";s:16:"添加更新.png";s:4:"path";s:34:"/usr/uploads/2019/04/833267214.png";s:4:"size";i:82064;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1600, 0),
(1600, 'Solr索引库管理', '1600', 1556548519, 1556548519, '<p>本文记录Java学习过程中遇到的Solr索引库管理～</p>\r<!--more-->\r\r<p><strong>添加/更新文档</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/833267214.png" style="width: 800px; height: 587px;" /></p>\r\r<p><strong>批量导入数据</strong></p>\r\r<p>使用dataimport插件批量导入数据：</p>\r\r<p>1.把dataimport插件依赖的jar包和mysql的驱动包添加到solrcore（collection1\\lib）中；<br />\r2.配置solrconfig.xml文件，添加一个requestHandler：</p>\r\r<pre class="brush:xml;">\r&lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;\r	&lt;lst name=&quot;defaults&quot;&gt;\r    	&lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;\r    &lt;/lst&gt;\r&lt;/requestHandler&gt;</pre>\r\r<p>3.创建一个data-config.xml，保存到collection1\\conf\\目录下：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  \r&lt;dataConfig&gt;\r	&lt;dataSource type=&quot;JdbcDataSource&quot; driver=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/lucene&quot; user=&quot;root&quot; password=&quot;123456&quot; /&gt;   \r	&lt;document&gt;   \r		&lt;entity name=&quot;product&quot; query=&quot;SELECT pid,name,catalog_name,price,description,picture FROM products &quot;&gt;\r			&lt;field column=&quot;pid&quot; name=&quot;id&quot;/&gt;\r			&lt;field column=&quot;name&quot; name=&quot;product_name&quot;/&gt;\r			&lt;field column=&quot;catalog_name&quot; name=&quot;product_catalog_name&quot;/&gt;\r			&lt;field column=&quot;price&quot; name=&quot;product_price&quot;/&gt;\r			&lt;field column=&quot;description&quot; name=&quot;product_description&quot;/&gt;\r			&lt;field column=&quot;picture&quot; name=&quot;product_picture&quot;/&gt;\r		&lt;/entity&gt;\r	&lt;/document&gt;\r&lt;/dataConfig&gt;</pre>\r\r<p>4.重启solr；<br />\r5.点击&ldquo;execute&rdquo;按钮导入数据。</p>\r\r<p>注意：导入数据前会先清空索引库，然后再导入。</p>\r\r<p><strong>删除文档</strong></p>\r\r<p>示例代码（删除指定ID的索引 ）：</p>\r\r<pre class="brush:xml;">\r&lt;delete&gt;\r	&lt;id&gt;8&lt;/id&gt;\r&lt;/delete&gt;\r&lt;commit/&gt;</pre>\r\r<p>示例代码（删除查询到的索引数据）：</p>\r\r<pre class="brush:xml;">\r&lt;delete&gt;\r	&lt;query&gt;product_catalog_name:幽默杂货&lt;/query&gt;\r&lt;/delete&gt;</pre>\r\r<pre class="brush:xml;">\r示例代码（删除所有索引数据）：</pre>\r\r<pre class="brush:xml;">\r&lt;delete&gt;\r	&lt;query&gt;*:*&lt;/query&gt;\r&lt;/delete&gt;</pre>\r\r<p>查询索引</p>\r\r<p>通过/select搜索索引，Solr制定一些参数完成不同需求的搜索：</p>\r\r<p>1.q：查询字符串，必须的，如果查询所有使用*:*；</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\rproduct_keywords:浪漫樱花 AND\rproduct_keywords:韩国 OR\rproduct_catalog_name:与众不同</pre>\r\r<p>2.fq：（filter query）过滤查询，作用：在q查询符合结果中同时是fq查询符合的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r#过滤查询价格从1到20的记录\rproduct_price:[1 TO 20]\r#20以上\rproduct_price:[20 TO *]\r#20以下\rproduct_price:[* TO 20]</pre>\r\r<p>3.sort：排序，格式：sort=&lt;field name&gt;+&lt;desc|asc&gt;[,&lt;field name&gt;+&lt;desc|asc&gt;]&hellip; 。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r#按价格降序\rproduct_price desc</pre>\r\r<p>4.start：分页显示使用，开始记录下标，从0开始；</p>\r\r<p>5.rows：指定返回结果最多有多少条记录，配合start来实现分页；</p>\r\r<p>6.fl：指定返回那些字段内容，用逗号或空格分隔多个；</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:bash;">\r#显示商品图片、商品名称、商品价格\rproduct_picture,product_name,product_price</pre>\r\r<p>7.df：指定一个默认搜索Field，指定后就可以直接在q中收入关键字了。</p>\r\r<p>8.wt：(writer type)指定输出格式，可以有XML，JSON，php，phps；</p>\r\r<p>9.hl：是否高亮，需要设置高亮Field，格式前缀和后缀。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 22),
(1601, 'solrj.png', 'solrj-png', 1556550682, 1556550682, 'a:5:{s:4:"name";s:9:"solrj.png";s:4:"path";s:35:"/usr/uploads/2019/04/1111775038.png";s:4:"size";i:94998;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1602, 0),
(1602, 'SolrJ简介', '1602', 1556550660, 1556779489, '<p>本文记录Java学习过程中遇到的SolrJ简介～</p>\r<!--more-->\r\r<p>SolrJ是访问Solr服务的Java客户端，提供索引和搜索的请求方法，SolrJ通常在嵌入在业务系统中，通过SolrJ的API接口操作Solr服务，如下图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/04/1111775038.png" style="width: 800px; height: 284px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24),
(1603, 'Dubbo简介', '1603', 1556785740, 1556787013, '<p>本文记录Java学习过程中遇到的Dubbo简介～</p>\r<!--more-->\r\r<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2633045295.png" style="width: 800px; height: 237px;" /></p>\r\r<p>单一应用架构</p>\r\r<ul>\r	<li>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本；</li>\r	<li>此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</li>\r</ul>\r\r<p>垂直应用架构</p>\r\r<ul>\r	<li>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率；</li>\r	<li>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</li>\r</ul>\r\r<p>分布式服务架构</p>\r\r<ul>\r	<li>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求；</li>\r	<li>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</li>\r</ul>\r\r<p>流动计算架构</p>\r\r<ul>\r	<li>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率；</li>\r	<li>此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。</li>\r</ul>\r\r<p>Dubbo就是资源调度和治理中心的管理工具。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 18),
(1604, 'dubbo简介.png', 'dubbo简介-png', 1556785855, 1556785855, 'a:5:{s:4:"name";s:15:"dubbo简介.png";s:4:"path";s:35:"/usr/uploads/2019/05/2633045295.png";s:4:"size";i:397769;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1603, 0),
(1605, 'dubbo架构.png', 'dubbo架构-png', 1556786564, 1556786564, 'a:5:{s:4:"name";s:15:"dubbo架构.png";s:4:"path";s:35:"/usr/uploads/2019/05/2765156365.png";s:4:"size";i:318611;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1606, 0),
(1606, 'Dubbo的架构', '1606', 1556786580, 1556787002, '<p>本文记录Java学习过程中遇到的Dubbo的架构～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2765156365.png" style="width: 800px;" /></p>\r\r<p>节点角色说明：</p>\r\r<ul>\r	<li>Provider: 暴露服务的服务提供方；</li>\r	<li>Consumer: 调用远程服务的服务消费方；</li>\r	<li>Registry: 服务注册与发现的注册中心；</li>\r	<li>Monitor: 统计服务的调用次调和调用时间的监控中心；</li>\r	<li>Container: 服务运行容器。</li>\r</ul>\r\r<p>调用关系说明：</p>\r\r<ol>\r	<li>服务容器负责启动，加载，运行服务提供者；</li>\r	<li>服务提供者在启动时，向注册中心注册自己提供的服务；</li>\r	<li>服务消费者在启动时，向注册中心订阅自己所需的服务；</li>\r	<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者；</li>\r	<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用；</li>\r	<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 16),
(1607, 'Dubbo的使用', '1607', 1556786958, 1556786958, '<p>本文记录Java学习过程中遇到的Dubbo的使用～</p>\r<!--more-->\r\r<p>Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。</p>\r\r<p>示例代码（单一工程中Spring的配置）：</p>\r\r<pre class="brush:xml;">\r&lt;bean id=&quot;xxxService&quot; class=&quot;com.xxx.XxxServiceImpl&quot; /&gt;\r&lt;bean id=&quot;xxxAction&quot; class=&quot;com.xxx.XxxAction&quot;&gt;\r	&lt;property name=&quot;xxxService&quot; ref=&quot;xxxService&quot; /&gt;\r&lt;/bean&gt;</pre>\r\r<p><strong>远程服务的配置</strong></p>\r\r<p>在本地服务的基础上，只需做简单配置，即可完成远程化：将上面的local.xml配置拆分成两份，将服务定义部分放在服务提供方remote-provider.xml，将服务引用部分放在服务消费方remote-consumer.xml，并在提供方增加暴露服务配置&lt;dubbo:service&gt;，在消费方增加引用服务配置&lt;dubbo:reference&gt;。</p>\r\r<p>示例代码（发布服务）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 和本地服务一样实现远程服务 --&gt;\r&lt;bean id=&quot;xxxService&quot; class=&quot;com.xxx.XxxServiceImpl&quot; /&gt;\r&lt;!-- 增加暴露远程服务配置 --&gt;\r&lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; ref=&quot;xxxService&quot; /&gt;</pre>\r\r<p>示例代码（调用服务）：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 增加引用远程服务配置 --&gt;\r&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;com.xxx.XxxService&quot; /&gt;\r&lt;!-- 和本地服务一样使用远程服务 --&gt;\r&lt;bean id=&quot;xxxAction&quot; class=&quot;com.xxx.XxxAction&quot;&gt;\r	&lt;property name=&quot;xxxService&quot; ref=&quot;xxxService&quot; /&gt;\r&lt;/bean&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 17),
(1612, 'Nginx简介', '1612', 1556797380, 1556804312, '<p>本文记录IT学习过程中遇到的Nginx简介～</p>\r<!--more-->\r\r<p>Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p>\r\r<p>应用场景：</p>\r\r<ul>\r	<li>HTTP服务器：Nginx是一个http服务可以独立提供HTTP服务。可以做网页静态服务器；</li>\r	<li>虚拟主机：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机；</li>\r	<li>反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用Nginx做反向代理，并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 18),
(1613, '正向代理.png', '正向代理-png', 1556804170, 1556804170, 'a:5:{s:4:"name";s:16:"正向代理.png";s:4:"path";s:35:"/usr/uploads/2019/05/1616265945.png";s:4:"size";i:84882;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1615, 0),
(1614, '反向代理.png', '反向代理-png', 1556804271, 1556804271, 'a:5:{s:4:"name";s:16:"反向代理.png";s:4:"path";s:35:"/usr/uploads/2019/05/1388780239.png";s:4:"size";i:95085;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1615, 0),
(1615, '正向代理与反向代理', '1615', 1556804296, 1556804296, '<p>本文记录IT学习过程中遇到的正向代理与反向代理～</p>\r<!--more-->\r\r<p>正向代理：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1616265945.png" style="width: 800px; height: 403px;" /></p>\r\r<p>反向代理：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1388780239.png" style="width: 800px; height: 443px;" />​</p>\r\r<p>总结：</p>\r\r<ul>\r	<li>正向代理是多对一，决定机器怎么出；</li>\r	<li>反向代理是一对多，决定哪个机器提供服务。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 22),
(1610, 'ZooKeeper简介', '1610', 1556788735, 1556788735, '<p>本文记录Java学习过程中遇到的ZooKeeper简介～</p>\r<!--more-->\r\r<p>Dubbo官方推荐使用ZooKeeper注册中心。</p>\r\r<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。使用dubbo-2.3.3以上版本，建议使用zookeeper注册中心。</p>\r\r<p>ZooKeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境。</p>\r\r<p>ZooKeeper的功能：</p>\r\r<ul>\r	<li>可以作为集群的管理工具使用；</li>\r	<li>可以集中管理配置文件。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 17),
(1611, 'Mybatis分页插件PageHelper', '1611', 1556794471, 1556794471, '<p>本文记录Java学习过程中遇到的Mybatis分页插件PageHelper～</p>\r<!--more-->\r\r<p>该插件目前支持Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库分页。</p>\r\r<p>使用方法：</p>\r\r<p>第一步：把PageHelper依赖的jar包添加到工程中：</p>\r\r<pre class="brush:xml;">\r&lt;dependency&gt;\r    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;\r    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;\r    &lt;version&gt;3.4.2-SNAPSHOT&lt;/version&gt;\r&lt;/dependency&gt;</pre>\r\r<p>第二步：在MyBatis的xml配置文件中配置拦截器插件：</p>\r\r<pre class="brush:xml;">\r&lt;plugins&gt;\r    &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;\r    &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;\r        &lt;!-- 设置数据库类型 --&gt;        \r        &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;\r    &lt;/plugin&gt;\r&lt;/plugins&gt;</pre>\r\r<p>第三步：在代码中使用：</p>\r\r<pre class="brush:java;">\r// 1、设置分页信息：\r\r// 获取第1页，10条内容，默认查询总数count\rPageHelper.startPage(1, 10);\r\r// 紧跟着的第一个select方法会被分页\rList&lt;Country&gt; list = countryMapper.selectIf(1);\r\r// 2、取分页信息\r\r// 方式一\r\r// 分页后，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt;，\rPage&lt;Country&gt; listCountry = (Page&lt;Country&gt;)list;\rlistCountry.getTotal();\r\r// 方式二\r\r// 获取第1页，10条内容，默认查询总数count\rPageHelper.startPage(1, 10);\rList&lt;Country&gt; list = countryMapper.selectAll();\r// 用PageInfo对结果进行包装\rPageInfo page = new PageInfo(list);\r// 测试PageInfo全部属性，PageInfo包含了非常全面的分页属性\rassertEquals(1, page.getPageNum());\rassertEquals(10, page.getPageSize());\rassertEquals(1, page.getStartRow());\rassertEquals(10, page.getEndRow());\rassertEquals(183, page.getTotal());\rassertEquals(19, page.getPages());\rassertEquals(1, page.getFirstPage());\rassertEquals(8, page.getLastPage());\rassertEquals(true, page.isFirstPage());\rassertEquals(false, page.isLastPage());\rassertEquals(false, page.isHasPreviousPage());\rassertEquals(true, page.isHasNextPage());</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 19),
(1616, 'FastDFS.png', 'FastDFS-png', 1556805175, 1556805175, 'a:5:{s:4:"name";s:11:"FastDFS.png";s:4:"path";s:34:"/usr/uploads/2019/05/375199485.png";s:4:"size";i:647078;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1617, 0),
(1617, 'FastDFS简介', '1617', 1556805196, 1556805196, '<p>本文记录IT学习过程中遇到的FastDFS简介～</p>\r<!--more-->\r\r<p>FastDFS是用C语言编写的一款开源的分布式文件系统。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p>\r\r<p>FastDFS架构包括Tracker Server和Storage Server。客户端请求Tracker Server进行文件上传、下载，通过Tracker Server调度最终由Storage server完成文件上传和下载。</p>\r\r<p>Tracker Server作用是负载均衡和调度，通过Tracker Server在文件上传时可以根据一些策略找到Storage Server提供文件上传服务，可以将Tracker称为追踪服务器或调度服务器。</p>\r\r<p>Storage Server作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage Server没有实现自己的文件系统而是利用操作系统的文件系统来管理文件，可以将Storage称为存储服务器。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/375199485.png" style="width: 800px;" /></p>\r\r<p>服务端两个角色：</p>\r\r<ul>\r	<li>Tracker：管理集群，Tracker也可以实现集群，每个tracker节点地位平等，收集Storage集群的状态；</li>\r	<li>Storage：实际保存文件，Storage分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 17),
(1618, 'FastDFS文件上传.png', 'FastDFS文件上传-png', 1556805621, 1556805621, 'a:5:{s:4:"name";s:23:"FastDFS文件上传.png";s:4:"path";s:35:"/usr/uploads/2019/05/3947075543.png";s:4:"size";i:235731;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1619, 0),
(1619, 'FastDFS文件上传', '1619', 1556805651, 1556805651, '<p>本文记录IT学习过程中遇到的FastDFS文件上传～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/3947075543.png" style="width: 800px; height: 410px;" />​</p>\r\r<p>客户端上传文件后存储服务器将文件ID返回给客户端，此文件ID用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p>\r\r<ul>\r	<li>组名：文件上传后所在的storage组名称，在文件上传成功后有storage服务器返回，需要客户端自行保存；</li>\r	<li>虚拟磁盘路径：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推；</li>\r	<li>数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件；</li>\r	<li>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 22),
(1620, 'FastDFS文件下载.png', 'FastDFS文件下载-png', 1556805770, 1556805770, 'a:5:{s:4:"name";s:23:"FastDFS文件下载.png";s:4:"path";s:35:"/usr/uploads/2019/05/4102238850.png";s:4:"size";i:216908;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1621, 0),
(1621, 'FastDFS文件下载', '1621', 1556805795, 1556805795, '<p>本文记录IT学习过程中遇到的FastDFS文件下载～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/4102238850.png" style="width: 800px; height: 360px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 21),
(1622, 'Redis集群架构.png', 'Redis集群架构-png', 1556947134, 1556947134, 'a:5:{s:4:"name";s:21:"Redis集群架构.png";s:4:"path";s:35:"/usr/uploads/2019/05/2891758623.png";s:4:"size";i:600024;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1624, 0),
(1623, 'Redis集群容错.png', 'Redis集群容错-png', 1556947163, 1556947163, 'a:5:{s:4:"name";s:21:"Redis集群容错.png";s:4:"path";s:35:"/usr/uploads/2019/05/1867206395.png";s:4:"size";i:440981;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1624, 0),
(1624, 'Redis集群简介', '1624', 1556947184, 1556947184, '<p>本文记录Redis学习过程中遇到的Redis集群简介～</p>\r<!--more-->\r\r<p>Redis集群架构</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2891758623.png" style="width: 800px; height: 907px;" /></p>\r\r<p>Redis投票容错</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1867206395.png" style="width: 800px; height: 653px;" />​</p>\r\r<p>Redis集群架构细节：</p>\r\r<ol>\r	<li>所有的redis节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽；</li>\r	<li>节点的fail是通过集群中超过半数的节点检测失效时才生效；</li>\r	<li>客户端与redis节点直连，不需要中间proxy层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可；</li>\r	<li>redis-cluster把所有的物理节点映射到[0-16383]slot上，cluster负责维护node&lt;-&gt;slot&lt;-&gt;value。</li>\r</ol>\r\r<p>注意：Redis集群中内置了16384个哈希槽，当需要在Redis集群中放置一个key-value时，redis先对key使用crc16算法算出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 19),
(1625, 'Redis集群搭建', '1625', 1556947980, 1556948550, '<p>本文记录Redis学习过程中遇到的Redis集群搭建～</p>\r<!--more-->\r\r<p>Redis集群中至少应该有三个节点（至多有16384个节点）。要保证集群的高可用，需要每个节点有一个备份机，也就是Redis集群至少需要6台服务器。</p>\r\r<p>1、使用ruby脚本搭建集群，需要ruby的运行环境</p>\r\r<pre class="brush:bash;">\r# 安装ruby\ryum install ruby\ryum install rubygems</pre>\r\r<p>2、安装ruby脚本运行使用的包</p>\r\r<pre class="brush:bash;">\rgem install redis.gem</pre>\r\r<p>3、启动6个Redis实例</p>\r\r<pre class="brush:bash;">\rredis-server 7001.conf\rredis-server 7002.conf\rredis-server 7003.conf\rredis-server 7004.conf\rredis-server 7005.conf\rredis-server 7006.conf</pre>\r\r<p>4、创建集群</p>\r\r<pre class="brush:bash;">\rredis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006\rredis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1</pre>\r\r<p>5、连接集群</p>\r\r<pre class="brush:bash;">\rredis-cli -p 7001 -c</pre>\r\r<p>注意：-c代表连接的是redis集群。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 27),
(1626, 'SolrCloud简介', '1626', 1557065053, 1557065053, '<p>本文记录Java学习过程中遇到的SolrCloud简介～</p>\r<!--more-->\r\r<p>SolrCloud(solr 云)是Solr提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用SolrCloud的，当索引量很大，搜索请求并发很高，这时需要使用SolrCloud来满足这些需求。</p>\r\r<p>SolrCloud是基于Solr和ZooKeeper的分布式搜索方案，它的主要思想是使用Zookeeper作为集群的配置信息中心。</p>\r\r<p>它有几个特色功能：</p>\r\r<ol>\r	<li>集中式的配置信息；</li>\r	<li>自动容错；</li>\r	<li>近实时搜索；</li>\r	<li>查询时自动负载均衡。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 17),
(1627, 'Solr集群架构.png', 'Solr集群架构-png', 1557065618, 1557065618, 'a:5:{s:4:"name";s:20:"Solr集群架构.png";s:4:"path";s:35:"/usr/uploads/2019/05/2264394277.png";s:4:"size";i:422811;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1628, 0),
(1628, 'Solr集群架构', '1628', 1557065676, 1557065676, '<p>本文记录Java学习过程中遇到的Solr集群架构～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2264394277.png" style="width: 800px;" /></p>\r\r<p>物理结构：三个Solr实例（每个实例包括两个Core），组成一个SolrCloud。</p>\r\r<p>逻辑结构</p>\r\r<ul>\r	<li>索引集合包括两个Shard（shard1和shard2），shard1和shard2分别由三个Core组成，其中，一个Leader和两个Replication，Leader是由ZooKeeper选举产生，ZooKeeper控制每个Shard上三个Core的索引数据一致，解决高可用问题。</li>\r	<li>用户发起索引请求分别从shard1和shard2上获取，解决高并发问题。</li>\r</ul>\r\r<p><strong>Collection</strong></p>\r\r<p>Collection在SolrCloud集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个Shard（分片），它们使用相同的配置信息。</p>\r\r<p>比如：针对商品信息搜索可以创建一个collection。</p>\r\r<pre class="brush:bash;">\rcollection=shard1+shard2+...+shardn</pre>\r\r<p><strong>Core</strong></p>\r\r<p>每个Core是Solr中一个独立运行单位，提供索引和搜索服务。一个Shard需要由一个Core或多个Core组成。由于collection由多个shard组成，所以Collection一般由多个Core组成。</p>\r\r<p><strong>Master或Slave</strong></p>\r\r<p>Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。</p>\r\r<p><strong>Shard</strong></p>\r\r<p>Collection的逻辑分片。每个Shard被化成一个或者多个Replication，通过选举确定哪个是Leader。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1629, 'ZooKeeper集群搭建', '1629', 1557066440, 1557066440, '<p>本文记录Java学习过程中遇到的ZooKeeper集群搭建～</p>\r<!--more-->\r\r<p>第一步：需要安装JDK环境。</p>\r\r<p>第二步：把ZooKeeper的压缩包上传到服务器，并解压缩。</p>\r\r<pre class="brush:bash;">\rtar xf zookeeper-3.4.6.tar.gz</pre>\r\r<p>第三步：把ZooKeeper复制三份。</p>\r\r<pre class="brush:java;">\rmkdir solr-cloud\rcp -r zookeeper-3.4.6 solr-cloud/zookeeper01\rcp -r zookeeper-3.4.6 solr-cloud/zookeeper02\rcp -r zookeeper-3.4.6 solr-cloud/zookeeper03</pre>\r\r<p>第四步：在每个ZooKeeper目录下创建一个data目录，并在里面创建一个myid文件，依次写入1、2和3。</p>\r\r<pre class="brush:bash;">\rcd solr-cloud/zookeeper01\rmkdir data\recho 1 &gt; data/myid\rcd -\rcd solr-cloud/zookeeper02\rmkdir data\recho 2 &gt; data/myid\rcd -\rcd solr-cloud/zookeeper03\rmkdir data\recho 3 &gt; data/myid\rcd -</pre>\r\r<p>第五步：修改配置文件，把conf目录下的zoo_sample.cfg文件改名为zoo.cfg， 并修改内容如下。</p>\r\r<pre class="brush:bash;">\rclientPort=2881/2882/2883（看是哪个实例）\r\rserver.1=192.168.25.154:2881:3881\rserver.2=192.168.25.154:2882:3882\rserver.3=192.168.25.154:2883:3883</pre>\r\r<p>第六步：启动每个ZooKeeper实例。</p>\r\r<pre class="brush:bash;">\rsolr-cloud/zookeeper01/bin/zkServer.sh start\rsolr-cloud/zookeeper02/bin/zkServer.sh start\rsolr-cloud/zookeeper03/bin/zkServer.sh start</pre>\r\r<p>第七步：查看ZooKeeper的状态。</p>\r\r<pre class="brush:bash;">\rsolr-cloud/zookeeper01/bin/zkServer.sh status\rsolr-cloud/zookeeper02/bin/zkServer.sh status\rsolr-cloud/zookeeper03/bin/zkServer.sh status</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24),
(1630, 'Solr集群搭建', '1630', 1557067260, 1557067310, '<p>本文记录Java学习过程中遇到的Solr集群搭建～</p>\r<!--more-->\r\r<p>第一步：创建四个tomcat实例。每个tomcat运行在不同的端口（8180、8280、8380、8480）。</p>\r\r<p>第二步：部署solr的war包，把单机版的solr工程复制到集群中的tomcat中。</p>\r\r<p>第三步：为每个solr实例创建一个对应的solrhome，可以使用单机版的solrhome复制四份。</p>\r\r<p>第四步：需要修改solr的web.xml文件，把solrhome关联起来。</p>\r\r<p>第五步：配置solrCloud相关的配置。每个solrhome下都有一个solr.xml，把其中的ip及端口号配置好。</p>\r\r<pre class="brush:xml;">\r&lt;solrcloud&gt;\r	&lt;str name=&quot;host&quot;&gt;127.0.0.1&lt;/str&gt;\r	&lt;int name=&quot;hostPort&quot;&gt;8180/8280/8380/8480&lt;/int&gt;\r	...\r&lt;/solrcloud&gt;</pre>\r\r<p>第六步：让zookeeper统一管理配置文件。需要把solrhome/collection1/conf目录上传到zookeeper,上传任意solrhome中的配置文件即可。</p>\r\r<pre class="brush:bash;">\rcd solr-4.10.3/example/scripts/cloud-scripts\r./zkcli.sh -zkhost 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183 -cmd upconfig -confdir solr-cloud/solrhome01/collection1/conf -confname myconf\rcd -</pre>\r\r<p>第七步：查看ZooKeeper上的配置文件。</p>\r\r<pre class="brush:bash;">\rcd zookeeper-3.4.6/bin\r./zkCli.sh\rls /configs/myconf\rquit\rcd -</pre>\r\r<p>第八步：修改tomcat/bin目录下的catalina.sh 文件，关联solr和ZooKeeper。</p>\r\r<pre class="brush:bash;">\r# 把此配置添加到配置文件中\rJAVA_OPTS=&quot;-DzkHost=127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183&quot;</pre>\r\r<p>第九步：启动每个tomcat实例，要保证zookeeper集群是启动状态。</p>\r\r<p>第十步：访问集群。</p>\r\r<p>第十一步：创建新的Collection进行分片处理。</p>\r\r<pre class="brush:bash;">\rhttp://localhost:8180/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2</pre>\r\r<p>第十二步：删除不用的Collection。</p>\r\r<pre class="brush:bash;">\rhttp://localhost:8180/solr/admin/collections?action=DELETE&amp;name=collection1</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 23),
(1631, 'ActiveMQ简介', '1631', 1557157195, 1557157195, '<p>本文记录Java学习过程中遇到的ActiveMQ简介～</p>\r<!--more-->\r\r<p>ActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ是一个完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p>\r\r<p>主要特点：</p>\r\r<ol>\r	<li>多种语言和协议编写客户端，语言：Java、C、C++、C#、Ruby、Perl、Python、PHP，应用协议：OpenWire、Stomp REST、WS Notification、XMPP、AMQP；</li>\r	<li>完全支持JMS1.1和J2EE 1.4规范 (持久化、XA消息和事务)；</li>\r	<li>对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性；</li>\r	<li>通过了常见J2EE服务器(如Geronimo、JBoss 4、GlassFish、WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上；</li>\r	<li>支持多种传送协议：in-VM、TCP、SSL、NIO、UDP、JGroups和JXTA；</li>\r	<li>支持通过JDBC和journal提供高速的消息持久化；</li>\r	<li>从设计上保证了高性能的集群，客户端-服务器，点对点；</li>\r	<li>支持Ajax；</li>\r	<li>支持与Axis的整合；</li>\r	<li>可以很容易得调用内嵌JMS Provider进行测试。</li>\r</ol>\r\r<p>ActiveMQ对于消息的传递有两种类型：</p>\r\r<ul>\r	<li>点对点的，即一个生产者和一个消费者一一对应；</li>\r	<li>发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。</li>\r</ul>\r\r<p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性：</p>\r\r<ul>\r	<li>StreamMessage--Java原始值的数据流；</li>\r	<li>MapMessage--一套名称-值对；</li>\r	<li>TextMessage--一个字符串对象；</li>\r	<li>ObjectMessage--一个序列化的Java对象；</li>\r	<li>BytesMessage--一个字节的数据流。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 20),
(1632, 'FreeMarker原理.png', 'FreeMarker原理-png', 1557362620, 1557362620, 'a:5:{s:4:"name";s:20:"FreeMarker原理.png";s:4:"path";s:35:"/usr/uploads/2019/05/1465188559.png";s:4:"size";i:111395;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1633, 0),
(1633, 'FreeMarker简介', '1633', 1557362655, 1557362655, '<p>本文记录Java学习过程中遇到的FreeMarker简介～</p>\r\r<!--more-->\r\r<p>FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java等。</p>\r\r<p>FreeMarker原理</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1465188559.png" style="width: 800px; height: 342px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 20),
(1634, 'FreeMarker模板语法', '1634', 1557363500, 1557363500, '<p>本文记录Java学习过程中遇到的FreeMarker模板语法～</p>\r<!--more-->\r\r<p><strong>访问map中的key</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r${key}</pre>\r\r<p><strong>访问pojo中的属性</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r${person.id}\r${person.name}\r${person.sex}</pre>\r\r<p><strong>取集合中的数据</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;#list personList as person&gt;\r	${person.id}/${person.name}\r&lt;/#list&gt;</pre>\r\r<p><strong>取循环中的下标</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;#list personList as person&gt;\r	${person_index}\r&lt;/#list&gt;</pre>\r\r<p><strong>判断</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;#if person_index % 2 == 0&gt;\r	blue\r&lt;#else&gt;\r	red\r&lt;/#if&gt;</pre>\r\r<p><strong>日期类型格式化</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r当前日期：${date?date}\r当前时间：${date?time}\r当前日期时间：${date?datetime}\r自定义日期格式：${date?string(&quot;yyyy/MM/dd HH:mm:ss&quot;)}</pre>\r\r<p><strong>null值的处理</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r${key!&quot;key is null&quot;}\r\r&lt;#if key??&gt;\r	key not null\r&lt;#else&gt;\r	key is null\r&lt;/#if&gt;</pre>\r\r<p><strong>include标签</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;#include &ldquo;include.ftl&rdquo;&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 22),
(1635, '传统登录.png', '传统登录-png', 1557365429, 1557365429, 'a:5:{s:4:"name";s:16:"传统登录.png";s:4:"path";s:34:"/usr/uploads/2019/05/320131562.png";s:4:"size";i:89303;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1637, 0),
(1636, '集群的登录方式.png', '集群的登录方式-png', 1557365464, 1557365464, 'a:5:{s:4:"name";s:25:"集群的登录方式.png";s:4:"path";s:35:"/usr/uploads/2019/05/3837909149.png";s:4:"size";i:117608;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1637, 0),
(1637, 'SSO系统简介', '1637', 1557365501, 1557365501, '<p>本文记录Java学习过程中遇到的SSO系统简介～</p>\r<!--more-->\r\r<p>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。</p>\r\r<p>传统的登录实现方式</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/320131562.png" style="width: 800px; height: 1238px;" /></p>\r\r<p>此方式在只有一个web工程时是没有问题。</p>\r\r<p>集群环境下的登录实现方式</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/3837909149.png" style="width: 800px; height: 691px;" />​</p>\r\r<p>集群环境下会出现要求用户多次登录的情况。</p>\r\r<p>解决方案：</p>\r\r<ol>\r	<li>修改tomcat集群设置，配置tomcatSession复制，但是节点数不要超过5个；</li>\r	<li>可以使用Session服务器，保存Session信息，使每个节点是无状态，需要模拟Session。</li>\r</ol>\r\r<p>单点登录系统是使用redis模拟Session，实现Session的统一管理。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 22),
(1638, 'jsonp原理.png', 'jsonp原理-png', 1557559111, 1557559111, 'a:5:{s:4:"name";s:15:"jsonp原理.png";s:4:"path";s:33:"/usr/uploads/2019/05/45332649.png";s:4:"size";i:109593;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1639, 0),
(1639, 'JSONP简介', '1639', 1557559080, 1557559150, '<p>本文记录WEB前端学习过程中遇到的JSONP简介～</p>\r<!--more-->\r\r<p>JSONP(JSON with Padding)是JSON的一种&ldquo;使用模式&rdquo;，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于server1.example.com的网页无法与不是server1.example.com的服务器沟通，而HTML的&lt;script&gt; 元素是一个例外。利用&lt;script&gt;元素的这个开放策略，网页可以得到从其他来源动态产生的JSON资料，而这种使用模式就是所谓的 JSONP。用JSONP抓到的资料并不是JSON，而是任意的JavaScript，用JavaScript直译器执行而不是用JSON解析器解析。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/45332649.png" style="width: 800px; height: 643px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 18),
(1640, '垂直切分.png', '垂直切分-png', 1557622661, 1557622661, 'a:5:{s:4:"name";s:16:"垂直切分.png";s:4:"path";s:34:"/usr/uploads/2019/05/818660924.png";s:4:"size";i:67306;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1642, 0),
(1641, '水平切分.png', '水平切分-png', 1557622691, 1557622691, 'a:5:{s:4:"name";s:16:"水平切分.png";s:4:"path";s:34:"/usr/uploads/2019/05/130755182.png";s:4:"size";i:166408;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1642, 0),
(1642, '数据库分片', '1642', 1557622706, 1557622706, '<p>本文记录MySQL学习过程中遇到的数据库分片～</p>\r<!--more-->\r\r<p>如今随着互联网的发展，数据的量级也是撑指数的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求。这个时候NoSQL的出现暂时解决了这一危机，它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升。</p>\r\r<p>但是，在有些场合NoSQL一些折衷是无法满足使用场景的，就比如有些使用场景是绝对要有事务与安全指标的。这个时候NoSQL肯定是无法满足的，所以还是需要使用关系性数据库。如果使用关系型数据库解决海量存储的问题呢？此时就需要做数据库集群，为了提高查询性能将一个数据库的数据分散到不同的数据库中存储。</p>\r\r<p>数据库分片，简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。&nbsp;</p>\r\r<p>数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式：</p>\r\r<p>一种是按照不同的表（或者Schema）来切分到不同的数据库（主机）之上，这种切可以称之为数据的垂直（纵向）切分。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/818660924.png" style="width: 800px; height: 602px;" /></p>\r\r<p>另一种则是根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/130755182.png" style="width: 800px; height: 1329px;" />​</p>\r\r<p>当数据库分片后，数据由一个数据库分散到多个数据库中。此时系统要查询时需要切换不同的数据库进行查询，那么系统如何知道要查询的数据在哪个数据库中？当添加一条记录时要向哪个数据库中插入呢？这些问题处理起来都是非常的麻烦。这种情况下可以使用一个数据库中间件MyCat来解决相关的问题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 13),
(1643, 'MyCat简介.png', 'MyCat简介-png', 1557623425, 1557623425, 'a:5:{s:4:"name";s:15:"MyCat简介.png";s:4:"path";s:35:"/usr/uploads/2019/05/3196183337.png";s:4:"size";i:219398;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1645, 0),
(1644, 'MyCat分片策略.png', 'MyCat分片策略-png', 1557623460, 1557623460, 'a:5:{s:4:"name";s:21:"MyCat分片策略.png";s:4:"path";s:35:"/usr/uploads/2019/05/3401895133.png";s:4:"size";i:96900;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1645, 0),
(1645, 'MyCat简介', '1645', 1557623460, 1557623504, '<p>本文记录Java学习过程中遇到的MyCat简介～</p>\r<!--more-->\r\r<p>MyCat背后是阿里曾经开源的知名产品&mdash;&mdash;Cobar。Cobar的核心功能和优势是MySQL数据库分片，此产品曾经广为流传，据说最早的发起者对 MySql很精通，后来从阿里跳槽了，阿里随后开源Cobar，并维持到2013年年初，然后就没有然后了。&nbsp;</p>\r\r<p>Cobar的思路和实现路径的确不错。基于Java开发的，实现了MySQL公开的二进制传输协议，巧妙地将自己伪装成一个MySQL-Server，目前市面上绝大多数MySQL客户端工具和应用都能兼容。这比自己实现一个新的数据库协议要明智的多，因为生态环境在哪里摆着。&nbsp;</p>\r\r<p>MyCat是基于Cobar演变而来，对Cobar的代码进行了彻底的重构，使用NIO重构了网络模块，并且优化了Buffer内核，增强了聚合，Join 等基本特性，同时兼容绝大多数数据库成为通用的数据库中间件。</p>\r\r<p>简单的说，MyCat就是一个新颖的数据库中间件产品，支持MySQL集群，或者MariaDB-Cluster，提供高可用性数据分片集群。你可以像使用MySQL一样使用MyCat，对于开发人员来说根本感觉不到MyCat的存在。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/3196183337.png" style="width: 800px; height: 547px;" /></p>\r\r<p>MyCat支持的数据库：</p>\r\r<ul>\r	<li>MySQL；</li>\r	<li>Oracle；</li>\r	<li>SQL Server；</li>\r	<li>PostgreSQL；</li>\r	<li>mongoDB；</li>\r	<li>等等。</li>\r</ul>\r\r<p>MyCat的分片策略：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/3401895133.png" style="width: 800px; height: 611px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 24),
(1646, 'MyCat常用概念', '1646', 1557623805, 1557623805, '<p>本文记录Java学习过程中遇到的MyCat常用概念～</p>\r<!--more-->\r\r<p><strong>逻辑库(schema)&nbsp;</strong></p>\r\r<p>数据库中间件，通常对实际应用来说，并不需要知道中间件的存在，业务开发人员只需要知道数据库的概念，所以数据库中间件可以被看做是一个或多个数据库集群构成的逻辑库。</p>\r\r<p><strong>逻辑表（table）</strong></p>\r\r<p>既然有逻辑库，那么就会有逻辑表，分布式数据库中，对应用来说，读写数据的表就是逻辑表。逻辑表，可以是数据切分后，分布在一个或多个分片库中，也可以不做数据切分，不分片，只有一个表构成。</p>\r\r<ul>\r	<li>分片表：是指那些原有的很大数据的表，需要切分到多个数据库的表，这样，每个分片都有一部分数据，所有分片构成了完整的数据。 总而言之就是需要进行分片的表。</li>\r	<li>非分片表：一个数据库中并不是所有的表都很大，某些表是可以不用进行切分的，非分片是相对分片表来说的，就是那些不需要进行数据切分的表。&nbsp;</li>\r</ul>\r\r<p><strong>分片节点（dataNode）</strong></p>\r\r<p>数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点（dataNode）。</p>\r\r<p><strong>节点主机（dataHost）</strong></p>\r\r<p>数据切分后，每个分片节点（dataNode）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（dataNode）所在的机器就是节点主机（dataHost），为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）。</p>\r\r<p><strong>分片规则（rule）</strong></p>\r\r<p>前面说了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 15),
(1647, 'Tomcat热部署', '1647', 1557624510, 1557624510, '<p>本文记录Java学习过程中遇到的Tomcat热部署～</p>\r<!--more-->\r\r<p>可以使用maven实现tomcat热部署，即Tomcat启动时 部署工程。</p>\r\r<p>Tomcat有个后台管理功能，可以实现工程热部署，配置方法：</p>\r\r<p>第一步：需要修改tomcat的conf/tomcat-users.xml配置文件。添加用户名、密码、权限。</p>\r\r<pre class="brush:xml;">\r&lt;role rolename=&quot;manager-gui&quot; /&gt;\r&lt;role rolename=&quot;manager-script&quot; /&gt;\r&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui, manager-script&quot; /&gt;</pre>\r\r<p>第二步：重新启动tomcat。</p>\r\r<p>使用maven的tomcat插件实现热部署：</p>\r\r<p>第一步：配置tomcat插件，需要修改工程的pom文件：</p>\r\r<pre class="brush:xml;">\r&lt;build&gt;\r	&lt;plugins&gt;\r		&lt;!-- 配置Tomcat插件 --&gt;\r		&lt;plugin&gt;\r			&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\r			&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\r			&lt;configuration&gt;\r				&lt;port&gt;8081&lt;/port&gt;\r				&lt;path&gt;/&lt;/path&gt;\r				&lt;url&gt;http://127.0.0.1:8080/manager/text&lt;/url&gt;\r				&lt;username&gt;tomcat&lt;/username&gt;\r				&lt;password&gt;tomcat&lt;/password&gt;\r			&lt;/configuration&gt;		\r		&lt;/plugin&gt;\r	&lt;/plugins&gt;\r&lt;/build&gt;</pre>\r\r<p>第二步：使用maven命令进行部署。</p>\r\r<pre class="brush:bash;">\r# 部署\rmvn tomcat7:deploy\r# 重新部署\rmvn tomcat7:redeploy\r# 跳过测试，重新部署\rmvn clean tomcat7:redeploy -DskipTests</pre>\r\r<p>注意：部署的路径是&ldquo;/&rdquo;，会把系统部署到webapps/ROOT目录下。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 17),
(1648, 'CPU核心数和线程的关系', '1648', 1557935112, 1557935112, '<p>本文记录Java学习过程中遇到的CPU核心数和线程的关系～</p>\r<!--more-->\r\r<p>一般情况下CPU的核心数等于线程数，例如：8核的CPU仅支持8个线程同时运行。后来，Intel引入了超线程技术，CPU的核心数:线程数就可以达到1:2了。</p>\r\r<p>我们在一般的开发过程中并没有感觉线程的存在以及限制，这是因为CPU采用了时间片轮转机制，也就是RR调度算法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 7),
(1649, 'CPU时间片轮转机制', '1649', 1557935340, 1557992265, '<p>本文记录Java学习过程中遇到的CPU时间片轮转机制～</p>\r<!--more-->\r\r<p>我们在一般的开发过程中并没有感觉线程的存在以及限制，这是因为CPU采用了时间片轮转机制，即给每一个进程分配一个时间段。</p>\r\r<p>这个时间段就称为进程的时间片，也就是进程允许运行的时间，如果到了这个时间片允许结束的时候进程还在运行，操作系统就会把分配给这个进程的CPU剥夺分配给另外一个进程；如果进程在这个时间片还没用完之前就阻塞或运行完了，那么CPU就会进行一个切换来继续执行其他的进程。</p>\r\r<p>CPU在两个进程之间的切换称为&ldquo;上下文切换&rdquo;，上下文切换是需要时间的，大约需要花费5000~20000（5毫秒到20毫秒，这个花费的时间是由操作系统决定）个时钟周期，尽管我们平时感觉不到，但是在开发过程中要注意上下文切换（两个进程之间的切换）对我们程序性能的影响，不要让上下文切换占用太多的时间。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 12),
(1650, '进程和线程', '1650', 1557992392, 1557992392, '<p>本文记录Java学习过程中遇到的进程和线程～</p>\r<!--more-->\r\r<ul>\r	<li>进程：它是属于程序调度/运行的资源分配的最小单位，一个进程的内部可能有多个线程，多个线程之间会共享这个进程的资源，进程与进程直线是相互独立的；</li>\r	<li>线程：它是CPU调度的最小单位，线程本身是不能独立进行的，它必须依附某个进程，线程本身是不拥有系统资源的。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 7),
(1651, '并行和并发', '1651', 1557992558, 1557992558, '<p>本文记录Java学习过程中遇到的并行和并发～</p>\r<!--more-->\r\r<ul>\r	<li>并行：同一时刻，可以同时处理事情的能力。例如：一个饭堂有八个窗口，也就是说，同一时刻可以有8个人进行打饭，那么也就说这个饭堂的并行度是8 ；</li>\r	<li>并发：它严格说起来是要与一个时间单位相关的，简单来说就是一个时间段内可以同时处理的事情数。例如：一个饭堂有8个窗口，每个人打饭需要花费30秒钟，那么一分钟内（8个窗口*60秒/每人打饭需要30秒=16）这个饭堂的并发度就是16。</li>\r</ul>\r\r<p>总结：并行是同一时刻可以处理多少件事；并发是在单位时间内可以处理多少件事情。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 8),
(1652, '高并发编程的意义、好处和注意事项', '1652', 1557992819, 1557992819, '<p>本文记录Java学习过程中遇到的高并发编程的意义、好处和注意事项～</p>\r<!--more-->\r\r<p>意义和好处：</p>\r\r<ul>\r	<li>高并发编程可以充分利用CPU的资源。例如：一个8核的CPU跑一个单线的程序，那么意味着在任意时刻有7个CPU是浪费的；</li>\r	<li>可以充分地加快响应用户的时间；</li>\r	<li>同时使用并发编程可以使代码模块化、异步化。&nbsp;</li>\r</ul>\r\r<p>注意事项：</p>\r\r<ul>\r	<li>线程之间会共享进程的资源，既然说是共享资源，就有可能存在冲突；</li>\r	<li>在高并发编程中如果控制不好，还有可能会造成线程的死锁；</li>\r	<li>每启动一个线程，操作系统就需要为这个线程分配一定的资源，线程数太多还可能会把内容消耗完毕，会导致系统死机。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1653, '线程的启动和终止', '1653', 1557996180, 1558006670, '<p>本文记录Java学习过程中遇到的线程的启动和终止～</p>\r<!--more-->\r\r<p>启动线程的方式：&nbsp;</p>\r\r<ul>\r	<li>类Thread；</li>\r	<li>接口Runnable；</li>\r	<li>接口Callable。</li>\r</ul>\r\r<p>注意：实现Runnabble接口里的run方法是没有返回值的，而Callable是允许有返回值的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.startend;\r\rimport java.util.concurrent.Callable;\rimport java.util.concurrent.ExecutionException;\rimport java.util.concurrent.FutureTask;\r\r/**\r * 新建线程\r */\rpublic class NewThread {\r\r    // 扩展自Thread类\r    private static class UseThread extends Thread {\r\r        @Override\r        public void run(){\r\r            System.out.println(&quot;I am extends Thread&quot;);\r        }\r    }\r\r    // 实现Runnable接口\r    private static class UseRun implements Runnable {\r\r        @Override\r        public void run() {\r\r            System.out.println(&quot;I am implements Runnable&quot;);\r        }\r\r    }\r\r    // 实现Callable接口，允许有返回值\r    private static class UseCall implements Callable&lt;String&gt; {\r\r        @Override\r        public String call() throws Exception {\r\r            System.out.println(&quot;I am implements Callable&quot;);\r            return &quot;CallResult&quot;;\r        }\r\r    }\r\r    public static void main(String[] args) throws InterruptedException, ExecutionException {\r\r        // Thread\r        new UseThread().start();\r\r        // Runnable\r        UseRun useRun = new UseRun();\r        new Thread(useRun).start();\r        Thread t = new Thread(useRun);\r        t.interrupt();\r\r        // Callable\r        UseCall useCall = new UseCall();\r        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(useCall);\r        new Thread(futureTask).start();\r        System.out.println(futureTask.get());\r    }\r}</pre>\r\r<p>线程结束的方法：</p>\r\r<ul>\r	<li>方法执行完自动终止；</li>\r	<li>抛出异常，又没有捕获异常；</li>\r	<li>早期还提出过三个方法终止线程stop()，resume()，suspend()，这三个方法都不建议用于终止线程，因为一旦调用stop会强行终止线程，无法保证线程的资源正常释放，suspend()调用后线程是不会释放资源的，很容易引起死锁。</li>\r</ul>\r\r<p>正确的终止线程的方法：</p>\r\r<ul>\r	<li>interrupt()；</li>\r	<li>isinterrupted()；</li>\r	<li>静态方法interrupted()。</li>\r</ul>\r\r<p>三者的区别：</p>\r\r<ul>\r	<li>interrupt()：是属于Thread类的方法，作用：终止一个线程，但并不是强行关闭一个线程（Java的线程是协作式的，不是强迫式的，调用一个线程的interrupt()方法并不会强制关闭一个线程，它就好比其他线程对要关闭的线程打了一声招呼，告诉被关闭线程要中断了，但被关闭线程什么时候关闭完全由它自身做主），线程调用该方法并不会立刻终止。调用interrupt()方法并起不到终止线程的目的，这样设计是为了让每个线程有充分的时间去做线程的清理工作。进行开发的时候要对线程的中断请求进行处理，否则就不是一个设计良好的并发程序。总的来说，它只是把线程中的&ldquo;中断标志位&rdquo;置为true；</li>\r	<li>isInterrupted()：判定当前线程是否处于中断状态，可以通过这个方法判断中断标志位是否为true；</li>\r	<li>static方法isInterrupted()：也是判断当前线程是否处于中断状态，当调用此方法时，它会把中断标志位改为false。</li>\r</ul>\r\r<p>示例代码（Thread）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.startend;\r\r/**\r * 安全的中断线程Thread\r */\rpublic class EndThread {\r\r    private static class UseThread extends Thread {\r\r        public UseThread(String name) {\r\r            super(name);\r        }\r\r        @Override\r        public void run() {\r\r            String threadName = Thread.currentThread().getName();\r            while(!isInterrupted()) {\r                System.out.println(threadName + &quot; is run!&quot;);\r            }\r            System.out.println(threadName + &quot; interrput flag is &quot;+isInterrupted());\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        Thread endThread = new UseThread(&quot;endThread&quot;);\r        endThread.start();\r        Thread.sleep(20);\r        endThread.interrupt();\r    }\r}</pre>\r\r<p>示例代码（Runnable）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.startend;\r\r/**\r * 安全的中断线程Runnable\r */\rpublic class EndRunnable {\r\r    private static class UseRunnable implements Runnable {\r\r        @Override\r        public void run() {\r\r            String threadName = Thread.currentThread().getName();\r            while(!Thread.currentThread().isInterrupted()) {\r                System.out.println(threadName + &quot; is run!&quot;);\r            }\r            System.out.println(threadName + &quot; interrput flag is &quot; + Thread.currentThread().isInterrupted());\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        UseRunnable useRunnable = new UseRunnable();\r        Thread endRunnable = new Thread(useRunnable,&quot;endRunnable&quot;);\r        endRunnable.start();\r        Thread.sleep(20);\r        endRunnable.interrupt();\r    }\r}</pre>\r\r<p>示例代码（Callable）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.startend;\r\rimport java.util.concurrent.Callable;\rimport java.util.concurrent.ExecutionException;\rimport java.util.concurrent.FutureTask;\r\r/**\r * 安全的中断线程Callable\r */\rpublic class EndCallable {\r\r    private static class UseCall implements Callable&lt;String&gt; {\r\r        @Override\r        public String call() throws Exception {\r\r            String threadName = Thread.currentThread().getName();\r            while(!Thread.currentThread().isInterrupted()) {\r                System.out.println(threadName + &quot; is run!&quot;);\r            }\r            System.out.println(threadName + &quot; interrput flag is &quot; + Thread.currentThread().isInterrupted());\r            return &quot;CallResult&quot;;\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException, ExecutionException {\r\r        EndCallable.UseCall useCall = new EndCallable.UseCall();\r        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(useCall);\r        Thread endCallable = new Thread(futureTask);\r        endCallable.start();\r        Thread.sleep(20);\r        endCallable.interrupt();\r        System.out.println(futureTask.get());\r    }\r}</pre>\r\r<p>注意：run方法里如果抛出InterruptedException（调用了wait(),join(),sleep()方法时），线程的中断标志位会被复位成false，如果确实是需要中断线程，要在catch语句块里再次调用interrupt()。</p>\r\r<p>示例代码（EndHasInterrputExceptionThread）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.startend;\r\rimport java.text.SimpleDateFormat;\rimport java.util.Date;\r\r/**\r * 中断抛出InterruptedException异常Tread\r */\rpublic class EndHasInterrputExceptionThread {\r\r    private static SimpleDateFormat formater = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss_SSS&quot;);\r\r    private static class UseThread extends Thread {\r\r        public UseThread(String name) {\r            super(name);\r        }\r\r        @Override\r        public void run() {\r\r            String threadName = Thread.currentThread().getName();\r            while(!isInterrupted()) {\r                try {\r                    System.out.println(&quot;UseThread:&quot; + formater.format(new Date()));\r                    Thread.sleep(3000);\r                } catch (InterruptedException e) {\r                    System.out.println(threadName + &quot; catch interrput flag is &quot; + isInterrupted() + &quot; at &quot; + (formater.format(new Date())));\r                    // catch里面需要再改一次中断标志位\r                    interrupt();\r                    e.printStackTrace();\r                }\r                System.out.println(threadName);\r            }\r            System.out.println(threadName + &quot; interrput flag is &quot; + isInterrupted());\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        Thread endThread = new UseThread(&quot;HasInterrputEx&quot;);\r        endThread.start();\r        System.out.println(&quot;Main:&quot; + formater.format(new Date()));\r        Thread.sleep(800);\r        System.out.println(&quot;Main begin interrupt thread:&quot; + formater.format(new Date()));\r        endThread.interrupt();\r    }\r}</pre>\r\r<p>示例代码（EndHasInterrputExceptionRunnable）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.startend;\r\rimport java.text.SimpleDateFormat;\rimport java.util.Date;\r\r/**\r * 中断抛出InterruptedException异常Runnable\r */\rpublic class EndHasInterrputExceptionRunnable {\r\r    private static SimpleDateFormat formater = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss_SSS&quot;);\r\r    private static class UseRun implements Runnable {\r\r        @Override\r        public void run() {\r\r            String threadName = Thread.currentThread().getName();\r            while(!Thread.currentThread().isInterrupted()) {\r                try {\r                    System.out.println(&quot;UseThread:&quot; + formater.format(new Date()));\r                    Thread.sleep(3000);\r                } catch (InterruptedException e) {\r                    System.out.println(threadName + &quot; catch interrput flag is &quot; + Thread.currentThread().isInterrupted() + &quot; at &quot; + (formater.format(new Date())));\r                    // catch里面需要再改一次中断标志位\r                    Thread.currentThread().interrupt();\r                    e.printStackTrace();\r                }\r                System.out.println(threadName);\r            }\r            System.out.println(threadName + &quot; interrput flag is &quot; + Thread.currentThread().isInterrupted());\r        }\r\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        EndHasInterrputExceptionRunnable.UseRun useRun = new EndHasInterrputExceptionRunnable.UseRun();\r        Thread endThread = new Thread(useRun);\r        endThread.start();\r        System.out.println(&quot;Main:&quot; + formater.format(new Date()));\r        Thread.sleep(800);\r        System.out.println(&quot;Main begin interrupt thread:&quot; + formater.format(new Date()));\r        endThread.interrupt();\r    }\r}</pre>\r\r<p>示例代码（EndHasInterrputExceptionCallable）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.startend;\r\rimport java.text.SimpleDateFormat;\rimport java.util.Date;\rimport java.util.concurrent.Callable;\rimport java.util.concurrent.ExecutionException;\rimport java.util.concurrent.FutureTask;\r\r/**\r * 中断抛出InterruptedException异常Callable\r */\rpublic class EndHasInterrputExceptionCallable {\r\r    private static SimpleDateFormat formater = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss_SSS&quot;);\r\r    // 实现Callable接口，允许有返回值\r    private static class UseCall implements Callable&lt;String&gt; {\r\r        @Override\r        public String call() throws Exception {\r\r            String threadName = Thread.currentThread().getName();\r            while(!Thread.currentThread().isInterrupted()) {\r                try {\r                    System.out.println(&quot;UseThread:&quot; + formater.format(new Date()));\r                    Thread.sleep(3000);\r                } catch (InterruptedException e) {\r                    System.out.println(threadName + &quot; catch interrput flag is &quot; + Thread.currentThread().isInterrupted() + &quot; at &quot; + (formater.format(new Date())));\r                    // catch里面需要再改一次中断标志位\r                    Thread.currentThread().interrupt();\r                    e.printStackTrace();\r                }\r                System.out.println(threadName);\r            }\r            System.out.println(threadName + &quot; interrput flag is &quot; + Thread.currentThread().isInterrupted());\r            return &quot;CallResult&quot;;\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException, ExecutionException {\r\r        EndHasInterrputExceptionCallable.UseCall useCall = new EndHasInterrputExceptionCallable.UseCall();\r        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(useCall);\r        Thread endThread = new Thread(futureTask);\r        endThread.start();\r        System.out.println(&quot;Main:&quot; + formater.format(new Date()));\r        Thread.sleep(800);\r        System.out.println(&quot;Main begin interrupt thread:&quot; + formater.format(new Date()));\r        endThread.interrupt();\r        System.out.println(futureTask.get());\r    }\r}</pre>\r\r<p>另外，有人喜欢在类里定义一个boolean的标志来中断线程。这种方式一般情况下能工作，但有些情况又不能工作、比如在线程内调用了一个阻塞的方法（sleep\\wait&hellip;）,那么线程会一直阻塞在那个地方，这个时候即使你改变了自己定义的标志，它也不会去判断while的条件的，一定要线程从阻塞中被唤醒、并且执行完阻塞后的代码后才会回到while的判断，这就造成了线程在处理响应时非常不及时。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 26),
(1654, '线程的优先级', '1654', 1558007584, 1558007584, '<p>本文记录Java学习过程中遇到的线程的优先级～</p>\r<!--more-->\r\r<p>开发过程中也可为线程设置优先级，线程的优先级的范围为1~10，缺省值为5，优先级较高的线程获得分配的时间片就较高。</p>\r\r<p>可以调用Thread.setPriority()方法进行设置。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.startend;\r\rpublic class ThreadPriority {\r\r    private static class UseThread extends Thread {\r\r        @Override\r        public void run(){\r\r            System.out.println(Thread.currentThread().getPriority());\r        }\r    }\r\r    public static void main(String[] args) {\r\r        Thread t1 = new ThreadPriority.UseThread();\r        t1.setPriority(1);\r        Thread t2 = new ThreadPriority.UseThread();\r        t2.setPriority(10);\r        \r        t1.start();\r        t2.start();\r    }\r}</pre>\r\r<p>注意：这个优先级的设置在不同的操作系统中会有不一样的结果，有些系统设置会忽略这个优先级的设定，有些系统可能全部给你设置为5，所以在程序开发过程中，不能指望这个操作。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 6),
(1655, '守护线程', '1655', 1558008028, 1558008028, '<p>本文记录Java学习过程中遇到的守护线程～</p>\r<!--more-->\r\r<p>守护线程的线程和主线程是同时销毁的，主线程退出了，守护进程就一定会结束。</p>\r\r<p>设置守护进程是通过Thread.setDaemon(true)进行设置的，而且需要在调用start()方法之前设置。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.deamon;\r\rimport java.util.concurrent.ExecutionException;\r\rpublic class DaemonThread {\r\r    private static class UseThread extends Thread {\r\r        @Override\r        public void run() {\r            try {\r                while (!isInterrupted()) {\r                    System.out.println(Thread.currentThread().getName() + &quot; I am extends Thread.&quot;);\r                }\r                System.out.println(Thread.currentThread().getName() + &quot; interrupt flag is &quot; + isInterrupted());\r            } finally {\r                System.out.println(&quot;finally&quot;);\r            }\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException, ExecutionException {\r\r        UseThread useThread = new UseThread();\r        useThread.setDaemon(true);\r        useThread.start();\r        Thread.sleep(5);\r        // useThread.interrupt();\r    }\r}</pre>\r\r<p>注意：守护进程里try..finally是不能保证一定执行finally的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 7),
(1656, '线程的状态和常用方法.png', '线程的状态和常用方法-png', 1558009546, 1558009546, 'a:5:{s:4:"name";s:34:"线程的状态和常用方法.png";s:4:"path";s:35:"/usr/uploads/2019/05/3532657422.png";s:4:"size";i:280548;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1657, 0),
(1657, '线程常用方法和状态', '1657', 1558009576, 1558009576, '<p>本文记录Java学习过程中遇到的线程状态和常用方法～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/3532657422.png" style="width: 800px; height: 409px;" /></p>\r\r<p>线程只有5种状态：</p>\r\r<ul>\r	<li>新建（New）：新创建了一个线程对象；</li>\r	<li>就绪（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于&ldquo;可运行线程池&rdquo;中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得；</li>\r	<li>运行（Running）：就绪状态的线程获取了CPU，执行程序代码；</li>\r	<li>阻塞（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态；</li>\r	<li>死亡（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>\r</ul>\r\r<p>阻塞的情况分三种：</p>\r\r<ul>\r	<li>等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入&ldquo;等待池&rdquo;中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒；</li>\r	<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入&ldquo;锁池&rdquo;中；</li>\r	<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>\r</ul>\r\r<p>整个生命周期就是这几种状态的切换，常用的方法有：</p>\r\r<ul>\r	<li>run()和start() ：run方法就是普通对象的普通方法，只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法；</li>\r	<li>yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行；</li>\r	<li>suspend()和resume()：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态；</li>\r	<li>wait()和notify()：当线程调用wait()方法后会进入等待队列（进入这个状态会释放所占有的所有资源，与阻塞状态不同），进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒（由于notify()只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒，因此在实际使用时，一般都用notifyAll()方法，唤醒所有线程），线程被唤醒后会进入锁池，等待获取锁标记。&nbsp;</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 6);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1658, '线程间的共享——synchronized内置锁', '1658', 1558015504, 1558015504, '<p>本文记录Java学习过程中遇到的线程间的共享&mdash;&mdash;synchronized内置锁～</p>\r<!--more-->\r\r<p>synchronized（内置锁），要么加在方法上面，要么是用作同步块的形式来使用，最大的作用是确保在多个线程在同一时刻只能有一个线程处于方法或同步块之中，这样它就保证了线程对变量访问的可见性与排差性。注意，它锁的是对象，不是代码块，每个对象在内存的对象头上有一个标志位，标志位上有1~2个字节标志它为一个锁，synchronized的作用就是当所有的线程去抢这个对象的标志位，谁把这个标志位指向了自己，那就认为这个线程抢到了这个锁。</p>\r\r<p>对象锁和类锁：Java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的。对象锁是用于对象实例方法，或者一个对象实例上的；类锁是用于类的静态方法或者一个类的class对象上的。类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.synchronize;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\r/**\r * 演示对象锁和类锁\r */\rpublic class UseSynchronized {\r\r    // 使用类锁的线程\r    private static class SynClass extends Thread{\r\r        @Override\r        public void run() {\r\r            System.out.println(this.getName()+&quot; TestClass is running...&quot;);\r            synClass();\r        }\r    }\r\r    // 使用对象锁的线程\r    private static class InstanceSyn implements Runnable {\r\r        private UseSynchronized useSynchronized;\r\r        public InstanceSyn(UseSynchronized useSynchronized) {\r\r            this.useSynchronized = useSynchronized;\r        }\r\r        @Override\r        public void run() {\r\r            System.out.println(&quot;TestInstance is running...&quot;+useSynchronized);\r            useSynchronized.instance();\r        }\r    }\r\r    // 使用对象锁的线程\r    private static class Instance2Syn implements Runnable{\r\r        private UseSynchronized useSynchronized;\r\r        public Instance2Syn(UseSynchronized useSynchronized) {\r\r            this.useSynchronized = useSynchronized;\r        }\r\r        @Override\r        public void run() {\r\r            System.out.println(&quot;TestInstance2 is running...&quot;+useSynchronized);\r            useSynchronized.instance2();\r        }\r    }\r\r    // 锁对象\r    private synchronized void instance(){\r\r        SleepTools.second(3);\r        System.out.println(&quot;synInstance is going...&quot;+this.toString());\r        SleepTools.second(3);\r        System.out.println(&quot;synInstance ended &quot;+this.toString());\r    }\r\r    // 锁对象\r    private synchronized void instance2(){\r\r        SleepTools.second(3);\r        System.out.println(&quot;synInstance2 is going...&quot;+this.toString());\r        SleepTools.second(3);\r        System.out.println(&quot;synInstance2 ended &quot;+this.toString());\r    }\r\r    // 类锁，实际是锁类的class对象\r    private static synchronized void synClass(){\r\r        SleepTools.second(1);\r        System.out.println(&quot;synClass going...&quot;);\r        SleepTools.second(1);\r        System.out.println(&quot;synClass end&quot;);\r    }\r\r    public static void main(String[] args) {\r\r        // 对象锁测试\r        UseSynchronized useSynchronized1 = new UseSynchronized();\r        Thread t1 = new Thread(new InstanceSyn(useSynchronized1));\r\r        UseSynchronized useSynchronized2 = new UseSynchronized();\r        Thread t2 = new Thread(new Instance2Syn(useSynchronized2));\r\r        t1.start();\r        t2.start();\r\r        // 类锁测试\r        SynClass synClass1 = new SynClass();\r        SynClass synClass2 = new SynClass();\r\r        synClass1.start();\r        synClass2.start();\r    }\r}</pre>\r\r<p>注意：在WEB框架开发过程中，常使用到spring框架，在spring框架里面没有做特殊设置的话，sping为我们创建的对象缺省是只有一个的，所以这个时候可以保证锁住的是同一个对象，但是如果在配置中，sping配置了多个对象，这个时候加锁的时候就要考虑锁的是不是同一个对象了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1659, '线程间的共享——volatile关键字', '1659', 1558017103, 1558017103, '<p>本文记录Java学习过程中遇到的线程间的共享&mdash;&mdash;volatile关键字～</p>\r<!--more-->\r\r<p>volatile是虚拟机提供的最轻量的同步机制（因为它的读取和写入并没有做synchronized处理），声明了该变量为volatile的话，就是告诉虚拟机，每次要用该变量时，总是要在主内存中读取。</p>\r\r<p>volatile并不是线程安全的，只能保证变量的可见性，不能保证原子性，例如：age = age+20，虚拟机不能保证你这个操作是原子的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.volatiled;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\r/**\r * violate无法提供操作的原子性\r */\rpublic class VolatileUnsafe {\r\r    private static class UseVolatile implements Runnable {\r\r        private volatile int a = 0;\r\r        @Override\r        public void run() {\r            String threadName = Thread.currentThread().getName();\r            a = a++;\r            System.out.println(threadName+&quot;:======&quot;+a);\r            SleepTools.ms(100);\r            a = a+1;\r            System.out.println(threadName+&quot;:======&quot;+a);\r        }\r    }\r\r    public static void main(String[] args) {\r\r        UseVolatile v = new UseVolatile();\r        Thread t1 = new Thread(v);\r        Thread t2 = new Thread(v);\r        Thread t3 = new Thread(v);\r        Thread t4 = new Thread(v);\r        t1.start();\r        t2.start();\r        t3.start();\r        t4.start();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 10),
(1660, '线程间的共享——ThreadLocal', '1660', 1558019176, 1558019176, '<p>本文记录Java学习过程中遇到的线程间的共享&mdash;&mdash;ThreadLocal～</p>\r<!--more-->\r\r<p>ThreadLocal(线程变量)：可以确保每个线程只使用自己那一部分的东西。例如：一个变量使用ThreadLocal包装的话，那么每个线程都是使用自己的那一份变量的拷贝。可以将理解为Map，key是线程的ID，value是线程自己的东西。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.threadlocal;\r\r/**\r * 演示ThreadLocal的使用\r */\rpublic class UseThreadLocal {\r\r    // 可以理解为 一个map，类型Map&lt;Thread,Integer&gt;\r    static ThreadLocal&lt;Integer&gt; threadLaocl = new ThreadLocal&lt;Integer&gt;(){\r\r        @Override\r        protected Integer initialValue() {\r\r            return 1;\r        }\r    };\r\r    // 运行3个线程\r    public void StartThreadArray(){\r\r        Thread[] runs = new Thread[3];\r        for(int i=0;i&lt;runs.length;i++){\r            runs[i]=new Thread(new TestThread(i));\r        }\r        for(int i=0;i&lt;runs.length;i++){\r            runs[i].start();\r        }\r    }\r\r    // 类说明：测试线程，线程的工作是将ThreadLocal变量的值变化，并写回，看看线程之间是否会互相影响\r    public static class TestThread implements Runnable{\r\r        int id;\r\r        public TestThread(int id){\r\r            this.id = id;\r        }\r\r        public void run() {\r\r            System.out.println(Thread.currentThread().getName()+&quot;:start&quot;);\r            // 获得变量的值\r            Integer s = threadLaocl.get();\r            s = s+id;\r            threadLaocl.set(s);\r            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+threadLaocl.get());\r            threadLaocl.remove();\r        }\r    }\r\r    public static void main(String[] args){\r\r        UseThreadLocal test = new UseThreadLocal();\r        test.StartThreadArray();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 8),
(1661, '线程间的协作——join', '1661', 1558021166, 1558021166, '<p>本文记录Java学习过程中遇到的线程间的协作&mdash;&mdash;join～</p>\r<!--more-->\r\r<p>Thread.join：假如线程A调用了线程B的join方法，那么线程A必须等到线程B执行完成才能继续执行。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.join;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\r/**\r * join方法的使用\r */\rpublic class UseJoin {\r\r    static class JumpQueue implements Runnable {\r        private Thread thread;//用来插队的线程\r\r        public JumpQueue(Thread thread) {\r            this.thread = thread;\r        }\r\r        public void run()  {\r            try {\r                System.out.println(thread.getName()+&quot; will be join before &quot;\r                        +Thread.currentThread().getName());\r                thread.join();\r            } catch (InterruptedException e) {\r                e.printStackTrace();\r            }\r            System.out.println(Thread.currentThread().getName()+&quot; terminted.&quot;);\r        }\r    }\r\r    public static void main(String[] args) throws Exception {\r\r        // 现在是主线程\r        Thread previous = Thread.currentThread();\r        for (int i = 0; i &lt; 10; i++) {\r            // i=0,previous 是主线程，i=1;previous是i=0这个线程\r            Thread thread =\r                    new Thread(new JumpQueue(previous), String.valueOf(i));\r            System.out.println(previous.getName()+&quot; jump a queue the thread:&quot;\r                    +thread.getName());\r            thread.start();\r            previous = thread;\r        }\r\r        // 让主线程休眠2秒\r        SleepTools.second(2);\r        System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 6),
(1662, '线程间的协作——等待和通知', '1662', 1558022505, 1558022505, '<p>本文记录Java学习过程中遇到的线程间的协作&mdash;&mdash;等待和通知～</p>\r<!--more-->\r\r<p>轮询无法保证及时性，资源的开销也比较大，大部分时间都在做无用功。</p>\r\r<p>为了解决这种情况，Java里提供了一种等待和通知机制，当线程调用wait方法会进入等待状态，当调用notify或notifyAll（首选notifyAll,因为notify通知的是等待队列中的一个线程，有可能发生信号丢失的情况。）方法就会唤醒线程。wait、notify、notifyAll这三个方法是对象本身的方法，并不是线程的方法。</p>\r\r<p>示例代码（Express实体类）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.waitnotify;\r\r/**\r * 快递实体类\r */\rpublic class Express {\r\r    public final static String CITY = &quot;ShangHai&quot;;\r\r    // 快递运输里程数\r    private int km;\r\r    // 快递到达地点\r    private String site;\r\r    public Express() {\r\r    }\r\r    public Express(int km, String site) {\r\r        this.km = km;\r        this.site = site;\r    }\r\r    // 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理\r    public synchronized void changeKm(){\r\r        this.km = 101;\r        notifyAll();\r        // 其他的业务代码\r        System.out.println(&quot;busi...&quot;);\r    }\r\r    // 变化地点，然后通知处于wait状态并需要处理地点的线程进行业务处理\r    public synchronized void changeSite(){\r\r        this.site = &quot;BeiJing&quot;;\r        notify();\r    }\r\r    public synchronized void waitKm(){\r\r        while(this.km&lt;=100) {\r            try {\r                wait();\r                System.out.println(&quot;check km thread[&quot; + Thread.currentThread().getId() + &quot;] is be notifed.&quot;);\r            } catch (InterruptedException e) {\r                e.printStackTrace();\r            }\r        }\r        System.out.println(&quot;the km is&quot;+this.km+&quot;,I will change db.&quot;);\r    }\r\r    public synchronized void waitSite(){\r\r        while(CITY.equals(this.site)) {\r            try {\r                wait();\r                System.out.println(&quot;check site thread[&quot; + Thread.currentThread().getId() + &quot;] is be notifed.&quot;);\r            } catch (InterruptedException e) {\r                e.printStackTrace();\r            }\r        }\r        System.out.println(&quot;the site is&quot;+this.site+&quot;,I will call user.&quot;);\r    }\r}</pre>\r\r<p>示例代码（等待和通知）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.waitnotify;\r\r/**\r * 测试wait/notify/notifyAll\r */\rpublic class UseWaitNotify {\r\r    private static Express express = new Express(0,Express.CITY);\r\r    // 检查里程数变化的线程,不满足条件，线程一直等待\r    private static class CheckKm extends Thread {\r\r        @Override\r        public void run() {\r\r            express.waitKm();\r        }\r    }\r\r    // 检查地点变化的线程,不满足条件，线程一直等待\r    private static class CheckSite extends Thread {\r\r        @Override\r        public void run() {\r\r            express.waitSite();\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        // 三个线程\r        for(int i=0;i&lt;3;i++){\r            new CheckSite().start();\r        }\r\r        // 里程数的变化\r        for(int i=0;i&lt;3;i++){\r            new CheckKm().start();\r        }\r\r        Thread.sleep(1000);\r\r        // 快递地点变化\r        express.changeKm();\r        // 快递公里数变化\r        express.changeKm();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 8),
(1663, '等待通知对锁的影响', '1663', 1558022940, 1558022991, '<p>本文记录Java学习过程中遇到的等待通知对锁的影响～</p>\r<!--more-->\r\r<p>调用yield()、sleep()、wait()、notify()等方法对锁有何影响？</p>\r\r<ul>\r	<li>调用yield()方法和sleep()方法以后，持有的锁是不释放的，所以一般调用这两个方法的良好写法是不要写在synchronized代码块外面；</li>\r	<li>调用wait()方法和notify()方法是会释放锁的，调用这两个方法的前提是必须持有锁，而且调用这两个方法之后，还是会把这两个方法所在的synchronized代码块中的代码执行完成才释放锁（调用这两个方法是不会释放锁的），所以良好的写法是写在synchronized代码块中的最后一行；</li>\r	<li>wait()、notify()、notifyAll()方法是和对象绑定一起的，话句话来说，就是你在object上调用了notifyAll方法，那么通知的就是在object上等待的线程，并不能通知到object2对象上的线程。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 13),
(1664, 'fork:join.png', 'fork-join-png', 1558068830, 1558068830, 'a:5:{s:4:"name";s:13:"fork:join.png";s:4:"path";s:34:"/usr/uploads/2019/05/675806843.png";s:4:"size";i:375782;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1667, 0),
(1665, '工作窃取-new.png', '工作窃取-new-png', 1558068868, 1558068868, 'a:5:{s:4:"name";s:20:"工作窃取-new.png";s:4:"path";s:34:"/usr/uploads/2019/05/729166821.png";s:4:"size";i:81516;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1667, 0),
(1666, '标准范式.png', '标准范式-png', 1558068907, 1558068907, 'a:5:{s:4:"name";s:16:"标准范式.png";s:4:"path";s:35:"/usr/uploads/2019/05/2895021385.png";s:4:"size";i:258943;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1667, 0),
(1667, '线程的并发工具类——Fork/Join', '1667', 1558068960, 1558073020, '<p>本文记录Java学习过程中遇到的线程的并发工具类&mdash;&mdash;Fork/Join～</p>\r<!--more-->\r\r<p>分而治之：规模为N的问题，N&lt;阈值，直接解决；N&gt;阈值，将N分解为K个小规模子问题，子问题互相对立，与原问题形式相同，将子问题的解合并得到原问题的解。</p>\r\r<p>Fork/Join：JAVA的并行框架，一个大任务划分成多个小任务，其执行的类要实现ForkJoinTask接口下的实现类（RecursiveTask&lt;V&gt;/RecursiveAction），在执行该类的时候需要使用ForkJoinPool来执行，其中的invoke方法是同步方法，execute是异步方法，调用task的join()获取到结果，它使用UNSAFE类来完成线程安全。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/675806843.png" style="width: 800px; height: 364px;" /></p>\r\r<p>工作窃取（work-stealing）:</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/729166821.png" style="width: 400px; height: 428px;" /></p>\r\r<p>Fork/Join使用的标准范式：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2895021385.png" style="width: 800px; height: 467px;" /></p>\r\r<p><strong>同步用法同时返回结果值：统计整形数组中所有元素的和</strong></p>\r\r<p>示例代码（产生整形数组）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.forkjoin;\r\rimport java.util.Random;\r\r/**\r * 产生整形数组\r */\rpublic class MakeArray {\r\r    // 数组长度\r    public static final int ARRAY_LENGTH  = 100000000;\r\r    public static int[] makeArray() {\r\r        // new一个随机数发生器\r        Random r = new Random();\r        int[] result = new int[ARRAY_LENGTH];\r        for(int i=0;i&lt;ARRAY_LENGTH;i++){\r            // 用随机数填充数组\r            result[i] =  r.nextInt(ARRAY_LENGTH*3);\r        }\r        return result;\r    }\r}</pre>\r\r<p>示例代码（普通方式计算结果）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.forkjoin;\r\rimport ren.oliver.concurrent.ch01.tools.SleepTools;\r\rpublic class SumNormal {\r\r    public static void main(String[] args) {\r\r        int count = 0;\r        int[] src = MakeArray.makeArray();\r        long start = System.currentTimeMillis();\r        for(int i= 0;i&lt;src.length;i++){\r            SleepTools.ms(1);\r            count = count + src[i];\r        }\r        long end = System.currentTimeMillis();\r        System.out.println(&quot;The count is &quot; + count);\r        System.out.println(&quot;Spend time:&quot; + (end - start) + &quot;ms&quot;);\r    }\r}</pre>\r\r<p>示例代码（fork-join计算结果）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.forkjoin;\r\rimport ren.oliver.concurrent.ch01.tools.SleepTools;\r\rimport java.util.concurrent.ForkJoinPool;\rimport java.util.concurrent.RecursiveTask;\r\r/**\r * 统计结果\r */\rpublic class SumArray {\r\r    private static class SumTask extends RecursiveTask&lt;Integer&gt; {\r\r        private final static int THRESHOLD = MakeArray.ARRAY_LENGTH/10;\r        // 表示我们要实际统计的数组\r        private int[] src;\r        // 开始统计的下标\r        private int fromIndex;\r        // 统计到哪里结束的下标\r        private int toIndex;\r\r        public SumTask(int[] src, int fromIndex, int toIndex) {\r\r            this.src = src;\r            this.fromIndex = fromIndex;\r            this.toIndex = toIndex;\r        }\r\r        @Override\r        protected Integer compute() {\r\r            if(toIndex-fromIndex &lt; THRESHOLD) {\r                int count = 0;\r                for(int i=fromIndex;i&lt;=toIndex;i++) {\r                    SleepTools.ms(1);\r                    count = count + src[i];\r                }\r                return count;\r            }else {\r                int mid = (fromIndex+toIndex)/2;\r                SumTask left = new SumTask(src,fromIndex,mid);\r                SumTask right = new SumTask(src,mid+1,toIndex);\r                invokeAll(left,right);\r                return left.join()+right.join();\r            }\r        }\r    }\r\r\r    public static void main(String[] args) {\r\r        ForkJoinPool pool = new ForkJoinPool();\r        int[] src = MakeArray.makeArray();\r\r        SumTask innerFind = new SumTask(src,0,src.length-1);\r\r        long start = System.currentTimeMillis();\r        // 同步调用\r        pool.invoke(innerFind);\r        System.out.println(&quot;Task is Running.....&quot;);\r        long end = System.currentTimeMillis();\r\r        // 输出结果和时间统计\r        System.out.println(&quot;The count is &quot; + innerFind.join());\r        System.out.println(&quot;Spend time:&quot; + (end - start) + &quot;ms&quot;);\r    }\r}</pre>\r\r<p><strong>异步用法同时不要求返回值：遍历指定目录（含子目录）寻找指定类型文件</strong></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.forkjoin.file;\r\rimport java.io.File;\rimport java.util.ArrayList;\rimport java.util.List;\rimport java.util.concurrent.ForkJoinPool;\rimport java.util.concurrent.RecursiveAction;\r\r/**\r * 遍历指定目录（含子目录）找寻指定类型文件\r */\rpublic class FindDirsFiles extends RecursiveAction {\r\r    // 当前任务需要搜寻的目录\r    private File path;\r\r    public FindDirsFiles(File path) {\r\r        this.path = path;\r    }\r\r    @Override\r    protected void compute() {\r\r        List&lt;FindDirsFiles&gt; subTasks = new ArrayList&lt;&gt;();\r\r        File[] files = path.listFiles();\r        if(files!=null) {\r            for(File file:files) {\r                if(file.isDirectory()) {\r                    // 遇到文件夹，创建子任务\r                    subTasks.add(new FindDirsFiles(file));\r                }else {\r                    // 遇到文件，检查\r                    if(file.getAbsolutePath().endsWith(&quot;txt&quot;)) {\r                        System.out.println(&quot;文件：&quot;+file.getAbsolutePath());\r                    }\r                }\r            }\r            if(!subTasks.isEmpty()) {\r                for(FindDirsFiles subTask:invokeAll(subTasks)) {\r                    // 等待子任务执行完成\r                    subTask.join();\r                }\r            }\r        }\r    }\r\r    public static void main(String [] args){\r\r        try {\r\r            // 用一个 ForkJoinPool 实例调度总任务\r            ForkJoinPool pool = new ForkJoinPool();\r            FindDirsFiles task = new FindDirsFiles(new File(&quot;/tmp/&quot;));\r\r            // 异步调用\r            pool.execute(task);\r            System.out.println(&quot;Task is Running......&quot;);\r\r            Thread.sleep(1);\r            int otherWork = 0;\r            for(int i=0;i&lt;100;i++){\r                otherWork = otherWork+i;\r            }\r            System.out.println(&quot;Main Thread done sth......,otherWork=&quot;+otherWork);\r\r            // 阻塞的方法\r            task.join();\r            System.out.println(&quot;Task end&quot;);\r        } catch (Exception e) {\r            e.printStackTrace();\r        }\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 12),
(1668, '线程的并发工具类——CoundDownLatch', '1668', 1558168961, 1558168961, '<p>本文记录Java学习过程中遇到的线程的并发工具类&mdash;&mdash;CoundDownLatch～</p>\r<!--more-->\r\r<p>CoundDownLatch的作用：使一组线程等待其他的线程完成工作以后在执行，可以理解为加强版的join。该类的底层实现是内部类，继承了AQS来实现的线程安全。</p>\r\r<p>构造函数：</p>\r\r<ul>\r	<li>CountDownLatch(int count)：count可以当作计数器，每次执行countDown的时候count就会减1。</li>\r</ul>\r\r<p>常用函数：</p>\r\r<ul>\r	<li>await()：阻塞当前线程，直到count变成零；</li>\r	<li>countDown()：count的数值会减一。</li>\r</ul>\r\r<p>常用场景：</p>\r\r<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。例如：解析一个excel，一个线程解析一个sheet页，当所有线程解析完成之后，提示解析完成。这个可以使用join来实现，也可以用CountDownLatch。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.countdownlatch;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\rimport java.util.concurrent.CountDownLatch;\r\r/**\r * 演示CountDownLatch，有5个初始化的线程，6个扣除点，扣除完毕以后，主线程和业务线程才能继续自己的工作。\r */\rpublic class UseCountDownLatch {\r\r    static CountDownLatch latch = new CountDownLatch(6);\r\r    // 初始化线程(只有一步，有4个)\r    private static class InitThread implements Runnable{\r\r        @Override\r        public void run() {\r\r            System.out.println(&quot;Thread_&quot;+Thread.currentThread().getId() + &quot; ready init work......&quot;);\r            // 初始化线程完成工作了，countDown方法只扣减一次\r            latch.countDown();\r            for(int i =0;i&lt;2;i++) {\r                System.out.println(&quot;Thread_&quot; + Thread.currentThread().getId() + &quot; ........continue do its work&quot;);\r            }\r        }\r    }\r\r    // 业务线程\r    private static class BusiThread implements Runnable{\r\r        @Override\r        public void run() {\r\r            try {\r                latch.await();\r            } catch (InterruptedException e) {\r                e.printStackTrace();\r            }\r            for(int i =0;i&lt;3;i++) {\r                System.out.println(&quot;BusiThread_&quot; + Thread.currentThread().getId() + &quot; do business-----&quot;);\r            }\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        // 单独的初始化线程,初始化分为2步，需要扣减两次\r        new Thread(new Runnable() {\r\r            @Override\r            public void run() {\r\r                SleepTools.ms(1);\r                System.out.println(&quot;Thread_&quot; + Thread.currentThread().getId() + &quot; ready init work step 1st......&quot;);\r                // 每完成一步初始化工作，扣减一次\r                latch.countDown();\r                System.out.println(&quot;begin step 2nd.......&quot;);\r                SleepTools.ms(1);\r                System.out.println(&quot;Thread_&quot; + Thread.currentThread().getId() + &quot; ready init work step 2nd......&quot;);\r                // 每完成一步初始化工作，扣减一次\r                latch.countDown();\r            }\r        }).start();\r        // 启动业务线程\r        new Thread(new BusiThread()).start();\r        for(int i=0;i&lt;=3;i++){\r            Thread thread = new Thread(new InitThread());\r            thread.start();\r        }\r        // 主线程等待所有初始化线程完成\r        latch.await();\r        System.out.println(&quot;Main do ites work........&quot;);\r    }\r}</pre>\r\r<p>注意：扣减数一般大于等于初始化线程数，不一定要相等，可以一个初始化线程扣减多次。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 8),
(1669, '线程的并发工具类——CyclicBarrier', '1669', 1558171020, 1558171539, '<p>本文记录Java学习过程中遇到的线程的并发工具类&mdash;&mdash;CyclicBarrier～</p>\r<!--more-->\r\r<p>CyclicBarrier的作用：让一组线程达到某个屏障被阻塞，一直到组内最后一个线程达到屏障时，屏障开放，所有被阻塞的线程会继续运行。</p>\r\r<p>构造函数：</p>\r\r<ul>\r	<li>CyclicBarrier(int parties)：parties是要达到屏障的线程的总数；</li>\r	<li>CyclicBarrier(int parties, Runnable barrierAction)：屏障开放后，barrierAction定义的任务会执行。</li>\r</ul>\r\r<p>常用函数：</p>\r\r<ul>\r	<li>await()：达到屏障时候调用；</li>\r	<li>getNumberWaiting：获取阻塞的线程数量；</li>\r	<li>isBroken()：用来了解阻塞的线程是否被中断。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.cyclicbarrier;\r\rimport java.util.Map;\rimport java.util.Random;\rimport java.util.concurrent.ConcurrentHashMap;\rimport java.util.concurrent.CyclicBarrier;\r\r/**\r * CyclicBarrier的使用\r */\rpublic class UseCyclicBarrier {\r\r    private static CyclicBarrier barrier = new CyclicBarrier(5,new CollectThread());\r\r    // 存放子线程工作结果的容器\r    private static ConcurrentHashMap&lt;String,Long&gt; resultMap = new ConcurrentHashMap&lt;&gt;();\r\r    // 工作线程\r    private static class SubThread implements Runnable{\r\r        @Override\r        public void run() {\r\r            // 线程本身的处理结果\r            long id = Thread.currentThread().getId();\r            resultMap.put(Thread.currentThread().getId()+&quot;&quot;, id);\r            // 随机决定工作线程的是否睡眠\r            Random r = new Random();\r            try {\r                if(r.nextBoolean()) {\r                    Thread.sleep(2000+id);\r                    System.out.println(&quot;Thread_&quot;+id+&quot; ....do something &quot;);\r                }\r                System.out.println(id+&quot;....is await&quot;);\r                barrier.await();\r                Thread.sleep(1000+id);\r                System.out.println(&quot;Thread_&quot;+id+&quot; ....do its business &quot;);\r            } catch (Exception e) {\r                e.printStackTrace();\r            }\r        }\r    }\r\r    // 负责屏障开放以后的工作\r    private static class CollectThread implements Runnable{\r\r        @Override\r        public void run() {\r            StringBuilder result = new StringBuilder();\r            for(Map.Entry&lt;String,Long&gt; workResult:resultMap.entrySet()){\r                result.append(&quot;[&quot;+workResult.getValue()+&quot;]&quot;);\r            }\r            System.out.println(&quot; the result = &quot;+ result);\r            System.out.println(&quot;do other business........&quot;);\r        }\r    }\r\r    public static void main(String[] args) {\r\r        for(int i=0;i&lt;=4;i++){\r            Thread thread = new Thread(new SubThread());\r            thread.start();\r        }\r    }\r}</pre>\r\r<p>注意：CyclicBarrier的扣减数要等于要同时达到屏障的线程数。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 12),
(1670, 'CountDownLatch与CyclicBarrier的区别', '1670', 1558171380, 1558171596, '<p>本文记录Java学习过程中遇到的CountDownLatch与CyclicBarrier的区别～</p>\r<!--more-->\r\r<p>两者的主要区别如下：</p>\r\r<ol>\r	<li>CountDownLatch的放行由第三者控制，CyclicBarrier的放行由一组线程本身控制；</li>\r	<li>CountDownLatch的放行条件&gt;=线程数，CyclicBarrier的放行条件==线程数；</li>\r	<li>CountDownBatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 10),
(1671, '线程的并发工具类——Semaphore', '1671', 1558173568, 1558173568, '<p>本文记录Java学习过程中遇到的线程的并发工具类&mdash;&mdash;Semaphore～</p>\r<!--more-->\r\r<p>Semaphore的作用：控制同时访问某个特定资源的线程数量，其使用继承AQS的内部类完成线程安全。</p>\r\r<p>构造函数：</p>\r\r<ul>\r	<li>Semaphore(int permits)：permits为可用的许可证的数量；</li>\r	<li>Semaphore(int permits, boolean fair)：拿连接的时候是否公平。</li>\r</ul>\r\r<p>常用函数：</p>\r\r<ul>\r	<li>void acquire()：获取许可证；</li>\r	<li>boolean tryAcquire()：尝试获取许可证；</li>\r	<li>void release()：归还许可证；</li>\r	<li>int availablePermits：返回此信号量中当前可用的许可证数；</li>\r	<li>boolean hasQueueThreads：是否有线程正在等待获取许可证；</li>\r	<li>int getQueueLength()：返回正在等待获取许可证的线程数；</li>\r	<li>void reducePermits(int reduction)：减少reduction个许可证；</li>\r	<li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合。</li>\r</ul>\r\r<p><strong>基于Semaphore实现数据库连接池</strong></p>\r\r<p>示例代码（数据库连接的简单实现）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.semaphorepool;\r\rimport java.sql.*;\rimport java.util.Map;\rimport java.util.Properties;\rimport java.util.concurrent.Executor;\r\r/**\r * 数据库连接的简单实现\r */\rpublic class ConnectImpl implements Connection {\r\r    // 拿一个数据库连接\r    public static final Connection fetchConnection(){\r\r        return new ConnectImpl();\r    }\r\r    @Override\r    public Statement createStatement() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public PreparedStatement prepareStatement(String sql) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public CallableStatement prepareCall(String sql) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public String nativeSQL(String sql) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public void setAutoCommit(boolean autoCommit) throws SQLException {\r\r    }\r\r    @Override\r    public boolean getAutoCommit() throws SQLException {\r        return false;\r    }\r\r    @Override\r    public void commit() throws SQLException {\r\r    }\r\r    @Override\r    public void rollback() throws SQLException {\r\r    }\r\r    @Override\r    public void close() throws SQLException {\r\r    }\r\r    @Override\r    public boolean isClosed() throws SQLException {\r        return false;\r    }\r\r    @Override\r    public DatabaseMetaData getMetaData() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public void setReadOnly(boolean readOnly) throws SQLException {\r\r    }\r\r    @Override\r    public boolean isReadOnly() throws SQLException {\r        return false;\r    }\r\r    @Override\r    public void setCatalog(String catalog) throws SQLException {\r\r    }\r\r    @Override\r    public String getCatalog() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public void setTransactionIsolation(int level) throws SQLException {\r\r    }\r\r    @Override\r    public int getTransactionIsolation() throws SQLException {\r        return 0;\r    }\r\r    @Override\r    public SQLWarning getWarnings() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public void clearWarnings() throws SQLException {\r\r    }\r\r    @Override\r    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public Map&lt;String, Class&lt;?&gt;&gt; getTypeMap() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public void setTypeMap(Map&lt;String, Class&lt;?&gt;&gt; map) throws SQLException {\r\r    }\r\r    @Override\r    public void setHoldability(int holdability) throws SQLException {\r\r    }\r\r    @Override\r    public int getHoldability() throws SQLException {\r        return 0;\r    }\r\r    @Override\r    public Savepoint setSavepoint() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public Savepoint setSavepoint(String name) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public void rollback(Savepoint savepoint) throws SQLException {\r\r    }\r\r    @Override\r    public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\r    }\r\r    @Override\r    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public Clob createClob() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public Blob createBlob() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public NClob createNClob() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public SQLXML createSQLXML() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public boolean isValid(int timeout) throws SQLException {\r        return false;\r    }\r\r    @Override\r    public void setClientInfo(String name, String value) throws SQLClientInfoException {\r\r    }\r\r    @Override\r    public void setClientInfo(Properties properties) throws SQLClientInfoException {\r\r    }\r\r    @Override\r    public String getClientInfo(String name) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public Properties getClientInfo() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public void setSchema(String schema) throws SQLException {\r\r    }\r\r    @Override\r    public String getSchema() throws SQLException {\r        return null;\r    }\r\r    @Override\r    public void abort(Executor executor) throws SQLException {\r\r    }\r\r    @Override\r    public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {\r\r    }\r\r    @Override\r    public int getNetworkTimeout() throws SQLException {\r        return 0;\r    }\r\r    @Override\r    public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException {\r        return null;\r    }\r\r    @Override\r    public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException {\r        return false;\r    }\r}</pre>\r\r<p>示例代码（数据库连接池的实现-基于Semaphore）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.semaphorepool;\r\rimport java.sql.Connection;\rimport java.util.LinkedList;\rimport java.util.concurrent.Semaphore;\r\r/**\r * 数据库连接池的实现-基于Semaphore\r */\rpublic class DBPool {\r\r    // 数据库连接池的大小\r    private final static int POOL_SIZE = 10;\r\r    // useful表示可用的数据库连接\r    private final Semaphore useful;\r\r    // useless表示已用的数据库连接\r    private final Semaphore useless;\r\r    // 存放数据库连接的容器\r    private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();\r\r    // 初始化连接池\r    static {\r        for (int i = 0; i &lt; POOL_SIZE; i++) {\r            pool.addLast(ConnectImpl.fetchConnection());\r        }\r    }\r\r    public DBPool() {\r\r        this. useful = new Semaphore(POOL_SIZE);\r        this.useless = new Semaphore(0);\r    }\r\r    // 从池子拿连接\r    public Connection takeConnect() throws InterruptedException {\r\r        useful.acquire();\r        Connection conn;\r        synchronized (pool) {\r            conn = pool.removeFirst();\r        }\r        useless.release();\r        return conn;\r    }\r\r    // 归还连接\r    public void returnConnect(Connection connection) throws InterruptedException {\r\r        if(connection!=null) {\r            System.out.println(&quot;当前有&quot; + useful.getQueueLength() + &quot;个线程等待数据库连接！！&quot; + &quot;可用连接数:&quot; + useful.availablePermits());\r            useless.acquire();\r            synchronized (pool) {\r                pool.addLast(connection);\r            }\r            useful.release();\r        }\r    }\r}</pre>\r\r<p>示例代码（主程序）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.semaphorepool;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\rimport java.sql.Connection;\rimport java.util.Random;\r\rpublic class App {\r\r    private static DBPool pool = new DBPool();\r\r    // 业务线程\r    private static class BusiThread extends Thread{\r\r        @Override\r        public void run() {\r\r            // 让每个线程持有连接的时间不一样\r            Random r = new Random();\r            try {\r                long start = System.currentTimeMillis();\r                Connection connect = pool.takeConnect();\r                long end = System.currentTimeMillis();\r                System.out.println(&quot;Thread_&quot; + Thread.currentThread().getId() + &quot;_获取数据库连接共耗时【&quot; + (end-start) + &quot;】ms.&quot;);\r                // 模拟业务操作，线程持有连接查询数据\r                SleepTools.ms(100 + r.nextInt(100));\r                System.out.println(&quot;查询数据完成，归还连接！&quot;);\r                pool.returnConnect(connect);\r            } catch (InterruptedException e) {\r                e.printStackTrace();\r            }\r        }\r    }\r\r    public static void main(String[] args) {\r\r        // 用50个线程去拿连接\r        for (int i = 0; i &lt; 50; i++) {\r            Thread thread = new BusiThread();\r            thread.start();\r        }\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1672, '线程的并发工具类——Exchanger', '1672', 1558177116, 1558177116, '<p>本文记录Java学习过程中遇到的线程的并发工具类&mdash;&mdash;Exchanger～</p>\r<!--more-->\r\r<p>Exchanger的作用：用于两个线程间的数据交换，使用CAS来实现线程安全，exchange后要将返回的值覆盖旧的值，不然不会改变值。</p>\r\r<p>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。第一个线程先执行exchange()方法，第二个线程也执行exchange()方法，当两个线程同时到达同步点，这两个线程就可以交换数据。</p>\r\r<p>构造函数：</p>\r\r<ul>\r	<li>Exchanger&lt;V&gt; Exchanger()：V是要交换的数据的类型；</li>\r</ul>\r\r<p>常用函数：</p>\r\r<ul>\r	<li>V exchange(V x)：交互数据；</li>\r	<li>V exchange(V x, long timeout, TimeUnit unit)：有超市的时间的交互数据，避免一直等待。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.exchange;\r\rimport java.util.HashSet;\rimport java.util.Set;\rimport java.util.concurrent.Exchanger;\r\rpublic class UseExchange {\r\r    private static final Exchanger&lt;Set&lt;String&gt;&gt; exchange = new Exchanger&lt;Set&lt;String&gt;&gt;();\r\r    public static void main(String[] args) {\r\r        // 第一个线程\r        new Thread(new Runnable() {\r            @Override\r            public void run() {\r                Set&lt;String&gt; setA = new HashSet&lt;String&gt;();//存放数据的容器\r                try {\r                    /**\r                     * 添加数据\r                     * set.add(.....)\r                     */\r                    setA = exchange.exchange(setA);//交换set\r                    // 处理交换后的数据\r                } catch (InterruptedException e) {\r                    e.printStackTrace();\r                }\r            }\r        }).start();\r\r        // 第二个线程\r        new Thread(new Runnable() {\r            @Override\r            public void run() {\r                Set&lt;String&gt; setB = new HashSet&lt;String&gt;();//存放数据的容器\r                try {\r                    /**\r                     * 添加数据\r                     * set.add(.....)\r                     */\r                    setB = exchange.exchange(setB);//交换set\r                    // 处理交换后的数据\r                } catch (InterruptedException e) {\r                    e.printStackTrace();\r                }\r            }\r        }).start();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1673, 'Callable、Future 和FutureTask .png', 'Callable-Future-和FutureTask-png', 1558188310, 1558188310, 'a:5:{s:4:"name";s:36:"Callable、Future 和FutureTask .png";s:4:"path";s:35:"/usr/uploads/2019/05/3135053804.png";s:4:"size";i:378067;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1674, 0),
(1674, 'Callable、Future和FutureTask', '1674', 1558188300, 1558188428, '<p>本文记录Java并发编程学习过程中遇到的Callable、Future和FutureTask～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/3135053804.png" style="width: 800px;" /></p>\r\r<p>Callable与Runnable的区别：Callable是有返回值的，而且是可以抛出异常的。</p>\r\r<p>Callable的返回值的获取，需要Future这个接口，也就是get()方法。</p>\r\r<p>FutureTask是RunnableFuture的实现，既可以作为Runnable的实现去运行，又可以作为Future的实现去获取Callable的返回值，经常就是将Callable包装成一个Runnable去运行，</p>\r\r<p>FutureTask的构造函数：</p>\r\r<ul>\r	<li>FutureTask(Callable&lt;V&gt; callable)：传入一个Callable实现来创建一个FutureTask。</li>\r</ul>\r\r<p>FutureTask的常用函数：</p>\r\r<ul>\r	<li>V get()：获取返回值；</li>\r	<li>V get(long timeout, TimeUnit unit)：有超市时间的获取返回值；</li>\r	<li>boolean isDone()：正常结束、异常结束或者自己取消，返回true；</li>\r	<li>boolean isCancelled()：任务完成前被取消，返回true；</li>\r	<li>boolean cancel(boolean mayInterruptIfRunning)：任务还没开始，返回false；任务已经启动，cancel（true），中断正在运行的任务，中断成功，返回true，但cancel（false）不会去中断已经运行的任务；任务已经结束，返回false。</li>\r</ul>\r\r<p>常用场景：</p>\r\r<p>包含图片和文字的文档的处理：图片（云上），可以用future去取图片，主线程继续解析文字。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch02.future;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\rimport java.util.Random;\rimport java.util.concurrent.Callable;\rimport java.util.concurrent.ExecutionException;\rimport java.util.concurrent.FutureTask;\r\r/**\r * Future等的使用\r */\rpublic class UseFuture {\r\r    // 实现Callable接口，允许有返回值\r    private static class UseCallable implements Callable&lt;Integer&gt; {\r\r        private int sum;\r\r        @Override\r        public Integer call() throws Exception {\r\r            System.out.println(&quot;Callable子线程开始计算&quot;);\r            Thread.sleep(2000);\r            for(int i=0;i&lt;5000;i++) {\r                sum = sum+i;\r            }\r            System.out.println(&quot;Callable子线程计算完成，结果=&quot;+sum);\r            return sum;\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException, ExecutionException {\r\r        UseCallable useCallable = new UseCallable();\r        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(useCallable);\r        new Thread(futureTask).start();\r        Random r = new Random();\r        SleepTools.second(1);\r        // 随机决定是获得结果还是终止任务\r        if(r.nextBoolean()) {\r            System.out.println(&quot;Get UseCallable result = &quot;+futureTask.get());\r        }else {\r            System.out.println(&quot;中断计算&quot;);\r            futureTask.cancel(true);\r        }\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 13);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1675, '原子操作CAS', '1675', 1558200142, 1558200142, '<p>本文记录Java学习过程中遇到的原子操作CAS～</p>\r<!--more-->\r\r<p>原子（Atom）本意是&ldquo;不能被进一步分割的最小粒子&rdquo;，而原子操作（atomic operation）意为&rdquo;不可被中断的一个或一系列操作&rdquo; 。</p>\r\r<p>锁存在的问题：</p>\r\r<ul>\r	<li>被阻塞的线程优先级很高；</li>\r	<li>拿到锁的线程一直不释放，就整体卡住了；</li>\r	<li>竞争消耗大量CPU，同时带来死锁或者其他安全问题。</li>\r</ul>\r\r<p>Java如何实现原子操作？&nbsp;</p>\r\r<p>使用循环CAS实现原子操作：JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的，自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p>\r\r<p>CAS(Compare And Swap)，指令级别保证这是一个原子操作，包含三个运算符：一个内存地址V，一个期望的值A，一个新值B，基本思路：如果地址V上的值和期望的值A相等，就给地址V赋给新值B；如果地址V上的值和期望的值A不相等，不做任何操作。</p>\r\r<p>CAS的问题</p>\r\r<ul>\r	<li>ABA问题：将值从A改成了B，然后马上将B又改为了A，这个可以通过引入版本号解决（A1-&gt;B2-&gt;A3）；</li>\r	<li>开销问题：自旋是一个死循环，CAS操作长期不成功就会消耗大量的系统资源；</li>\r	<li>只能保证一个共享变量的原子操作：因为操作的是一个内存地址，当有多个地址的时候就不行了。</li>\r</ul>\r\r<p>Jdk中常用原子操作类</p>\r\r<ul>\r	<li>更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong；</li>\r	<li>更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li>\r	<li>更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference</li>\r	<li>原子更新字段类： AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater</li>\r</ul>\r\r<p>AtomicMarkableReference与AtomicStampedReference的区别：</p>\r\r<ul>\r	<li>AtomicMarkableReference：是boolean，记录有没有改动；</li>\r	<li>AtomicStampedReference：是int，记录改动过几次。</li>\r</ul>\r\r<p>示例代码（AtomicInteger）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch03.cas;\r\rimport java.util.concurrent.atomic.AtomicInteger;\r\r/**\r * 演示基本类型的原子操作类AtomicInteger的使用\r */\rpublic class UseAtomicInteger {\r\r    static AtomicInteger ai = new AtomicInteger(10);\r\r    public static void main(String[] args) {\r\r        // out10---&gt;10---&gt;11\r        System.out.println(ai.getAndIncrement());\r        // 11\r        System.out.println(ai.get());\r        // 11---&gt;12---&gt;out12\r        System.out.println(ai.incrementAndGet());\r        // 12\r        System.out.println(ai.get());\r    }\r}</pre>\r\r<p>示例代码（AtomicReference）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch03.cas;\r\rimport java.util.concurrent.atomic.AtomicReference;\r\r/**\r * 演示引用类型的原子操作类AtomicReference\r */\rpublic class UseAtomicReference {\r\r    // 定义一个实体类\r    static class Student {\r\r        private String name;\r        private int age;\r\r        public Student(String name, int age) {\r            this.name = name;\r            this.age = age;\r        }\r\r        public String getName() {\r            return name;\r        }\r\r        public int getAge() {\r            return age;\r        }\r    }\r\r    static AtomicReference&lt;Student&gt; studentRef = new AtomicReference&lt;Student&gt;();\r\r    public static void main(String[] args) {\r\r        // 要修改的实体的实例\r        Student oliver = new Student(&quot;oliver&quot;, 18);\r\r        studentRef.set(oliver);\r\r        // 要变化的新实例\r        Student cathy = new Student(&quot;cathy&quot;, 17);\r        studentRef.compareAndSet(oliver, cathy);\r\r        System.out.println(oliver.getName());\r        System.out.println(oliver.getAge());\r\r        System.out.println(studentRef.get().getName());\r        System.out.println(studentRef.get().getAge());\r    }\r}</pre>\r\r<p>示例代码（AtomicStampedReference）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch03.cas;\r\rimport java.util.concurrent.atomic.AtomicStampedReference;\r\r/**\r * 演示带版本戳的原子操作类\r */\rpublic class UseAtomicStampedReference {\r\r    static AtomicStampedReference&lt;String&gt; asr = new AtomicStampedReference&lt;&gt;(&quot;Oliver&quot;,0);\r\r    public static void main(String[] args) throws InterruptedException {\r\r        // 初始的版本号\r        final int oldStamp = asr.getStamp();\r        final String oldReferenc = asr.getReference();\r        System.out.println(oldReferenc+&quot;===========&quot;+oldStamp);\r\r        // 使用正确的版本戳\r        Thread rightStampThread = new Thread(new Runnable() {\r\r            @Override\r            public void run() {\r                System.out.println(Thread.currentThread().getName() + &quot;当前变量值：&quot; + oldReferenc + &quot;当前版本戳：&quot; + oldStamp + &quot;-&quot; + asr.compareAndSet(oldReferenc, oldReferenc + &quot;Java&quot;, oldStamp, oldStamp+1));\r            }\r\r        });\r\r        // 使用错误的版本戳\r        Thread errorStampThread = new Thread(new Runnable() {\r\r            @Override\r            public void run() {\r\r                String reference = asr.getReference();\r                System.out.println(Thread.currentThread().getName() + &quot;当前变量值：&quot; + reference + &quot;当前版本戳：&quot; + asr.getStamp() + &quot;-&quot; + asr.compareAndSet(reference, reference + &quot;C&quot;, oldStamp, oldStamp+1));\r            }\r\r        });\r\r        rightStampThread.start();\r        rightStampThread.join();\r        errorStampThread.start();\r        errorStampThread.join();\r        System.out.println(asr.getReference()+&quot;===========&quot;+asr.getStamp());\r    }\r}</pre>\r\r<p>示例代码（AtomicIntegerArray）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch03.cas;\r\rimport java.util.concurrent.atomic.AtomicIntegerArray;\r\r/**\r * AtomicIntegerArray演示\r */\rpublic class UseAtomicIntegerArray {\r\r    static int[] value = new int[] {1, 2};\r\r    static AtomicIntegerArray aia = new AtomicIntegerArray(value);\r\r    public static void main(String[] args) {\r\r        aia.getAndSet(0, 3);\r        System.out.println(aia.get(0));\r        System.out.println(value[0]);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1676, '显式锁Lock', '1676', 1558238941, 1558238941, '<p>本文记录Java学习过程中遇到的显式锁Lock～</p>\r<!--more-->\r\r<p>Lock接口的作用：管理锁，与内置锁synchronized关键字类似。</p>\r\r<p>Lock接口常用方法：</p>\r\r<ul>\r	<li>boolean tryLock()：尝试获取锁；</li>\r	<li>boolean tryLock(long time, TimeUnit unit)：带超市时间的尝试获取锁；</li>\r	<li>void lock()：获取锁；</li>\r	<li>void unlock()：释放锁；</li>\r	<li>Condition newCondition()：创建释放锁的条件对象。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.reentrantlock;\r\rimport java.util.concurrent.locks.Lock;\rimport java.util.concurrent.locks.ReentrantLock;\r\r/**\r * 演示Lock\r */\rpublic class UseReentrantLock {\r\r    private Lock lock  = new ReentrantLock();\r\r    private int count;\r\r    public void increament() {\r\r        lock.lock();\r        try {\r            count++;\r        }finally {\r            lock.unlock();\r        }\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 8),
(1677, '显式锁Lock和内置锁synchronized的区别', '1677', 1558239209, 1558239209, '<p>本文记录Java学习过程中遇到的显式锁Lock和内置锁synchronized的区别～</p>\r<!--more-->\r\r<p>两者的主要区别如下：</p>\r\r<p style="margin-left: 40px;">1.内置锁synchronized代码简洁，使用简便；</p>\r\r<p style="margin-left: 40px;">2.显式锁Lock有如下特点：</p>\r\r<ul style="margin-left: 40px;">\r	<li>获取锁可以被中断；</li>\r	<li>可以超时获取锁；</li>\r	<li>可以尝试获取锁。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 7),
(1678, '可重入锁ReentrantLock', '1678', 1558239540, 1558240279, '<p>本文记录Java学习过程中遇到的可重入锁ReentrantLock～</p>\r<!--more-->\r\r<p>可重入锁：可以锁多次，但锁多少次就需要再释放多少次。</p>\r\r<p>构造函数：</p>\r\r<ul>\r	<li>ReentrantLock()：默认创建的是一个非公平锁；</li>\r	<li>ReentrantLock(boolean fair)：指定是否创建一个公平锁。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.reentrantlock;\r\rimport java.util.concurrent.locks.Lock;\rimport java.util.concurrent.locks.ReentrantLock;\r\r/**\r * 演示Lock-ReentrantLock\r */\rpublic class UseReentrantLock {\r\r    private Lock lock  = new ReentrantLock();\r\r    private int count;\r\r    public void increament() {\r\r        lock.lock();\r        try {\r            if (count &lt; 100) {\r                count++;\r                increament();\r            } else {\r                count++;\r            }\r        }finally {\r            lock.unlock();\r        }\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1679, '公平锁与非公平锁', '1679', 1558240101, 1558240101, '<p>本文记录Java学习过程中遇到的公平锁与非公平锁～</p>\r<!--more-->\r\r<p>如果在时间上，先对锁进行获取的请求，一定先被满足，这个锁就是公平的；如果不能保证这个先后顺序，这个锁就是非公平的。</p>\r\r<p>非公平的效率一般更高，例如：线程A先获取到了锁，线程B一直没有获取到锁，操作系统将线程B挂起了。此时，新来了线程C也请求这个锁，公平锁的话，线程C应该等线程B恢复拿到锁，但现场B恢复需要很长的一段时间，这个时候就会有时间被浪费，降低效率；非公平锁会先把锁给新来的线程C，就不会有时间的浪费了，从而提供效率。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 7),
(1680, '读写锁ReadWriteLock', '1680', 1558245638, 1558245638, '<p>本文记录Java学习过程中遇到的读写锁ReadWriteLock</p>\r<!--more-->\r\r<p>读写锁与前面的锁不同，它不是一个排它锁，同一时刻允许多个读线程同时访问，但是写线程访问的时候，所有的读和写都被阻塞，最适宜与读多写少的情况。</p>\r\r<p>ReentrantReadWriteLock实现了ReadWriteLock接口，但没实现Lock接口，内部的两个读写锁实现了Lock接口。</p>\r\r<p><strong>通过读写锁控制对商品信息的修改</strong></p>\r\r<p>示例代码（商品信息实体类）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.reentrantreadwritelock;\r\rpublic class GoodsInfo {\r\r    private final String name;\r\r    // 总销售额\r    private double totalMoney;\r\r    // 库存数\r    private int storeNumber;\r\r    public GoodsInfo(String name, int totalMoney, int storeNumber) {\r\r        this.name = name;\r        this.totalMoney = totalMoney;\r        this.storeNumber = storeNumber;\r    }\r\r    public double getTotalMoney() {\r\r        return totalMoney;\r    }\r\r    public int getStoreNumber() {\r\r        return storeNumber;\r    }\r\r    public void changeNumber(int sellNumber){\r\r        this.totalMoney += sellNumber*25;\r        this.storeNumber -= sellNumber;\r    }\r}</pre>\r\r<p>示例代码（商品服务接口）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.reentrantreadwritelock;\r\rpublic interface GoodsService {\r\r    // 获得商品的信息\r    GoodsInfo getNum();\r\r    // 设置商品的数量\r    void setNum(int number);\r}</pre>\r\r<p>示例代码（使用synchronized实现锁）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.reentrantreadwritelock;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\r/**\r * 使用synchronized实现锁\r */\rpublic class UseSynchronized implements GoodsService {\r\r    private GoodsInfo goodsInfo;\r\r    public UseSynchronized(GoodsInfo goodsInfo) {\r\r        this.goodsInfo = goodsInfo;\r    }\r\r    @Override\r    public synchronized GoodsInfo getNum() {\r\r        SleepTools.ms(5);\r        return this.goodsInfo;\r    }\r\r    @Override\r    public synchronized void setNum(int number) {\r\r        SleepTools.ms(5);\r        goodsInfo.changeNumber(number);\r    }\r}</pre>\r\r<p>示例代码（使用ReentrantReadWriteLock实现锁）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.reentrantreadwritelock;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\rimport java.util.concurrent.locks.Lock;\rimport java.util.concurrent.locks.ReadWriteLock;\rimport java.util.concurrent.locks.ReentrantReadWriteLock;\r\r/**\r * 使用ReentrantReadWriteLock实现锁\r */\rpublic class UseReentrantReadWriteLock implements GoodsService {\r\r    private GoodsInfo goodsInfo;\r    private final ReadWriteLock lock = new ReentrantReadWriteLock();\r\r    // 读锁\r    private final Lock getLock = lock.readLock();\r\r    // 写锁\r    private final Lock setLock = lock.writeLock();\r\r    public UseReentrantReadWriteLock(GoodsInfo goodsInfo) {\r        this.goodsInfo = goodsInfo;\r    }\r\r    @Override\r    public GoodsInfo getNum() {\r\r        getLock.lock();\r        try {\r            SleepTools.ms(5);\r            return this.goodsInfo;\r        }finally {\r            getLock.unlock();\r        }\r    }\r\r    @Override\r    public void setNum(int number) {\r\r        setLock.lock();\r        try {\r            SleepTools.ms(5);\r            goodsInfo.changeNumber(number);\r        }finally {\r            setLock.unlock();\r        }\r    }\r}</pre>\r\r<p>示例代码（对商品进行业务的应用）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.reentrantreadwritelock;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\rimport java.util.Random;\r\r/**\r * 对商品进行业务的应用\r */\rpublic class App {\r\r    // 读写线程的比例\r    static final int readWriteRatio = 10;\r\r    // 最少线程数\r    static final int minthreadCount = 3;\r\r    // 读操作\r    private static class GetThread implements Runnable{\r\r        private GoodsService goodsService;\r\r        public GetThread(GoodsService goodsService) {\r\r            this.goodsService = goodsService;\r        }\r\r        @Override\r        public void run() {\r\r            long start = System.currentTimeMillis();\r            for(int i=0;i&lt;100;i++){//操作100次\r                goodsService.getNum();\r            }\r            long end = System.currentTimeMillis();\r            System.out.println(Thread.currentThread().getName() + &quot;读取商品数据耗时：&quot; + (end-start) + &quot;ms&quot;);\r        }\r    }\r\r    // 写操做\r    private static class SetThread implements Runnable{\r\r        private GoodsService goodsService;\r\r        public SetThread(GoodsService goodsService) {\r\r            this.goodsService = goodsService;\r        }\r\r        @Override\r        public void run() {\r\r            long start = System.currentTimeMillis();\r            Random r = new Random();\r            // 写操作10次\r            for(int i=0;i&lt;10;i++){\r                SleepTools.ms(50);\r                goodsService.setNum(r.nextInt(10));\r            }\r            long end = System.currentTimeMillis();\r            System.out.println(Thread.currentThread().getName() + &quot;写商品数据耗时：&quot; + (end-start) + &quot;ms&quot;);\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        GoodsInfo goodsInfo = new GoodsInfo(&quot;Cup&quot;,100000,10000);\r        GoodsService goodsService = null;\r        // goodsService = new UseSynchronized(goodsInfo);\r        goodsService = new UseReentrantReadWriteLock(goodsInfo);\r        for(int i = 0;i&lt;minthreadCount;i++){\r            Thread setT = new Thread(new SetThread(goodsService));\r            for(int j=0;j&lt;readWriteRatio;j++) {\r                Thread getT = new Thread(new GetThread(goodsService));\r                getT.start();\r            }\r            SleepTools.ms(100);\r            setT.start();\r        }\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 12),
(1681, '锁中的等待与通知——Condition接口', '1681', 1558246823, 1558246823, '<p>本文记录Java学习过程中遇到的锁中的等待与通知&mdash;&mdash;Condition接口～</p>\r<!--more-->\r\r<p>常用函数：</p>\r\r<ul>\r	<li>void await()：等待，可以被中断；</li>\r	<li>void awaitUninterruptibly()：不能被中断的等待；</li>\r	<li>boolean await(long time, TimeUnit unit)：带超市时间的等待；</li>\r	<li>void signal()：通知一个；</li>\r	<li>void signalAll()：通知所有。</li>\r</ul>\r\r<p><strong>用Condition实现快递的公里和目的地变化的业务</strong></p>\r\r<p>示例代码（快递类）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.condition;\r\rimport java.util.concurrent.locks.Condition;\rimport java.util.concurrent.locks.Lock;\rimport java.util.concurrent.locks.ReentrantLock;\r\r/**\r * 快递类\r */\rpublic class Express {\r\r    public final static String CITY = &quot;ShangHai&quot;;\r\r    // 快递运输里程数\r    private int km;\r\r    // 快递到达地点\r    private String site;\r\r    private Lock lock = new ReentrantLock();\r    private Condition keCond = lock.newCondition();\r    private Condition siteCond = lock.newCondition();\r\r    public Express() {\r\r    }\r\r    public Express(int km, String site) {\r\r        this.km = km;\r        this.site = site;\r    }\r\r    // 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理\r    public void changeKm(){\r\r        lock.lock();\r        try {\r            this.km = 101;\r            keCond.signalAll();\r        }finally {\r            lock.unlock();\r        }\r    }\r\r    // 变化地点，然后通知处于wait状态并需要处理地点的线程进行业务处理*/\r    public  void changeSite(){\r        lock.lock();\r        try {\r            this.site = &quot;BeiJing&quot;;\r            siteCond.signal();\r        }finally {\r            lock.unlock();\r        }\r    }\r\r    // 当快递的里程数大于100时更新数据库\r    public void waitKm(){\r        lock.lock();\r        try {\r            while(this.km&lt;=100) {\r                try {\r                    keCond.await();\r                    System.out.println(&quot;check km thread[&quot; + Thread.currentThread().getId() + &quot;] is be notifed.&quot;);\r                } catch (InterruptedException e) {\r                    e.printStackTrace();\r                }\r            }\r        }finally {\r            lock.unlock();\r        }\r        System.out.println(&quot;the Km is &quot;+this.km+&quot;,I will change db&quot;);\r    }\r\r    // 当快递到达目的地时通知用户\r    public void waitSite(){\r        lock.lock();\r        try {\r            while(CITY.equals(this.site)) {\r                try {\r                    siteCond.await();\r                    System.out.println(&quot;check site thread[&quot; + Thread.currentThread().getId() + &quot;] is be notifed.&quot;);\r                } catch (InterruptedException e) {\r                    e.printStackTrace();\r                }\r            }\r        }finally {\r            lock.unlock();\r        }\r        System.out.println(&quot;the site is &quot;+this.site+&quot;,I will call user&quot;);\r    }\r}</pre>\r\r<p>示例代码（主应用）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.condition;\r\r/**\r * 主应用\r */\rpublic class App {\r\r    private static Express express = new Express(0,Express.CITY);\r\r    // 检查里程数变化的线程,不满足条件，线程一直等待\r    private static class CheckKm extends Thread{\r\r        @Override\r        public void run() {\r            express.waitKm();\r        }\r    }\r\r    // 检查地点变化的线程,不满足条件，线程一直等待\r    private static class CheckSite extends Thread{\r\r        @Override\r        public void run() {\r            express.waitSite();\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        for(int i=0;i&lt;3;i++){\r            new CheckSite().start();\r        }\r        for(int i=0;i&lt;3;i++){\r            new CheckKm().start();\r        }\r        Thread.sleep(1000);\r\r        // 快递里程变化\r        express.changeKm();\r        express.changeSite();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1682, 'LockSupport工具类', '1682', 1558259400, 1558260679, '<p>本文记录Java学习过程中遇到的LockSupport工具类～</p>\r<!--more-->\r\r<p>LockSupport的作用：用于阻塞/唤醒一个线程，是构建同步组件的基础工具。</p>\r\r<p>常用的静态函数：</p>\r\r<ul>\r	<li>static void park(Object blocker)：阻塞一个线程；</li>\r	<li>static void parkNanos(long nanos)：带超时的阻塞一个线程；</li>\r	<li>static void unpark(Thread thread)：唤醒一个线程。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 11),
(1684, 'JDK锁的基础——AQS简介', '1684', 1558278360, 1558281347, '<p>本文记录Java学习过程中遇到的JDK锁的基础&mdash;&mdash;AQS简介～</p>\r<!--more-->\r\r<p>AQS全称是AbstractQueuedSynchronizer，是JDK中用来实现锁的基础框架，比如ReentrantLock、ReadWriteLock以及Condition的实现和AQS密切相关。</p>\r\r<p>一般通过使用继承的方式来使用AQS，采用了模版方法设计模式，要使用它，必须实现其中抽象的模版方法。</p>\r\r<p>常用的方法：</p>\r\r<p>独占式获取</p>\r\r<ul>\r	<li>void acquire(int arg)</li>\r	<li>void acquireInterruptibly(int arg)</li>\r	<li>boolean tryAcquireNanos(int arg, long nanosTimeout)</li>\r</ul>\r\r<p>独占式释放锁</p>\r\r<ul>\r	<li>boolean release(int arg)</li>\r</ul>\r\r<p>共享式获取</p>\r\r<ul>\r	<li>void acquireShared(int arg)</li>\r	<li>void acquireSharedInterruptibly(int arg)</li>\r	<li>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</li>\r</ul>\r\r<p>共享式释放锁</p>\r\r<ul>\r	<li>boolean releaseShared(int arg)</li>\r</ul>\r\r<p>常用的需要实现的模板流程方法：</p>\r\r<p>同步器是否处于独占模式</p>\r\r<ul>\r	<li>boolean isHeldExclusively()</li>\r</ul>\r\r<p>独占式获取</p>\r\r<ul>\r	<li>boolean tryAcquire(int arg)</li>\r</ul>\r\r<p>独占式释放</p>\r\r<ul>\r	<li>boolean tryRelease(int arg)</li>\r</ul>\r\r<p>共享式获取</p>\r\r<ul>\r	<li>int tryAcquireShared(int arg)</li>\r</ul>\r\r<p>共享式释放</p>\r\r<ul>\r	<li>boolean tryReleaseShared(int arg)</li>\r</ul>\r\r<p>同步状态state相关方法：</p>\r\r<ul>\r	<li>int getState()：获取当前的同步状态；</li>\r	<li>void setState(int newState)：设置当前同步状态；</li>\r	<li>boolean compareAndSetState(int expect, int update)：使用CAS设置状态，保证状态设置的原子性。</li>\r</ul>\r\r<p>基于AQS实现一个类似ReentrantLock的锁</p>\r\r<p>示例代码（SelfLock）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.aqs;\r\rimport java.util.concurrent.TimeUnit;\rimport java.util.concurrent.locks.AbstractQueuedSynchronizer;\rimport java.util.concurrent.locks.Condition;\rimport java.util.concurrent.locks.Lock;\r\r/**\r * 使用AQS实现一个独占锁\r */\rpublic class SelfLock implements Lock {\r\r    /**\r     * state 表示获取到锁\r     * state=1 有线程拿到了锁\r     * state=0 当前没有线程拿到\r     */\r    private static class Sync extends AbstractQueuedSynchronizer {\r\r        // 是否占用\r        protected boolean isHeldExclusively() {\r\r            return getState()==1;\r        }\r\r        protected boolean tryAcquire(int arg) {\r\r            if(compareAndSetState(0,1)) {\r                setExclusiveOwnerThread(Thread.currentThread());\r                return true;\r            } else {\r                return false;\r            }\r        }\r\r        protected boolean tryRelease(int arg) {\r\r            if(getState()==0) {\r                throw new UnsupportedOperationException();\r            }\r\r            // 释放的时候没有竞争，所以可以不用CAS\r            setExclusiveOwnerThread(null);\r            setState(0);\r            return true;\r        }\r\r        Condition newCondition() {\r\r            return new ConditionObject();\r        }\r    }\r\r    private final Sync sync = new Sync();\r\r    @Override\r    public void lock() {\r\r        sync.acquire(1);\r    }\r\r    @Override\r    public void lockInterruptibly() throws InterruptedException {\r\r        sync.acquireInterruptibly(1);\r    }\r\r    @Override\r    public boolean tryLock() {\r\r        return sync.tryAcquire(1);\r    }\r\r    @Override\r    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {\r\r        return sync.tryAcquireNanos(1, unit.toNanos(time));\r    }\r\r    @Override\r    public void unlock() {\r\r        sync.release(1);\r    }\r\r    @Override\r    public Condition newCondition() {\r\r        return sync.newCondition();\r    }\r}</pre>\r\r<p>示例代码（UseSelfLock）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch04.aqs;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\rimport java.util.concurrent.locks.Lock;\r\r/**\r * 测试SelfLock\r */\rpublic class UseSelfLock {\r\r    public void process() {\r\r        // final Lock lock = new ReentrantLock();\r        final Lock lock = new SelfLock();\r\r        class Worker extends Thread {\r            public void run() {\r                while (true) {\r                    lock.lock();\r                    try {\r                        SleepTools.second(1);\r                        System.out.println(Thread.currentThread().getName());\r                        SleepTools.second(1);\r                    } finally {\r                        lock.unlock();\r                    }\r                    SleepTools.second(2);\r                }\r            }\r        }\r        // 启动10个子线程\r        for (int i = 0; i &lt; 10; i++) {\r            Worker w = new Worker();\r            w.setDaemon(true);\r            w.start();\r        }\r        // 主线程每隔1秒换行\r        for (int i = 0; i &lt; 10; i++) {\r            SleepTools.second(1);\r            System.out.println();\r        }\r    }\r\r    public static void main(String[] args) {\r\r        UseSelfLock useSelfLock = new UseSelfLock();\r        useSelfLock.process();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1686, 'AQS中的数据结构-节点和同步队列.png', 'AQS中的数据结构-节点和同步队列-png', 1558283345, 1558283345, 'a:5:{s:4:"name";s:47:"AQS中的数据结构-节点和同步队列.png";s:4:"path";s:35:"/usr/uploads/2019/05/2264309367.png";s:4:"size";i:159163;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1687, 0),
(1687, 'AQS中的数据结构-节点和同步队列', '1687', 1558283340, 1558283780, '<p>本文记录Java学习过程中遇到的AQS中的数据结构-节点和同步队列～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2264309367.png" style="width: 800px; height: 204px;" /></p>\r\r<p>竞争失败的线程会打包成节点放到同步队列，节点的状态有：</p>\r\r<ul>\r	<li>CANCELLED：线程等待超时或者被中断了，需要从队列中移走；</li>\r	<li>SIGNAL：后续的节点等待状态，当前节点，通知后面的节点去运行；</li>\r	<li>CONDITION :当前节点处于等待队列；</li>\r	<li>PROPAGATE：共享，表示状态要往后面的节点传播；</li>\r	<li>0：表示初始状态。</li>\r</ul>\r\r<p>prev表示同步队列中的前一个节点。</p>\r\r<p>next是同步队列中的后一个节点。</p>\r\r<p>thread存放的获取锁失败的线程信息。</p>\r\r<p>nextWait是等待队列中下一个等待节点。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 15),
(1688, '节点加入到同步队列.png', '节点加入到同步队列-png', 1558284040, 1558284040, 'a:5:{s:4:"name";s:31:"节点加入到同步队列.png";s:4:"path";s:34:"/usr/uploads/2019/05/396087051.png";s:4:"size";i:153387;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1689, 0),
(1689, 'AQS节点在同步队列中的增加和移出', '1689', 1558284060, 1558284216, '<p>本文记录Java学习过程中遇到的AQS节点在同步队列中的增加和移出～</p>\r<!--more-->\r\r<p><strong>节点加入到同步队列</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/396087051.png" style="width: 800px; height: 227px;" /></p>\r\r<p><strong>首节点的变化</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2418789202.png" style="width: 800px; height: 183px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 10),
(1692, '独占式同步状态获取与释放.png', '独占式同步状态获取与释放-png', 1558284300, 1558284300, 'a:5:{s:4:"name";s:40:"独占式同步状态获取与释放.png";s:4:"path";s:35:"/usr/uploads/2019/05/2906941323.png";s:4:"size";i:259080;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1693, 0),
(1691, '首节点的变化.png', '首节点的变化-png', 1558284203, 1558284203, 'a:5:{s:4:"name";s:22:"首节点的变化.png";s:4:"path";s:35:"/usr/uploads/2019/05/2418789202.png";s:4:"size";i:131806;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1689, 0),
(1693, 'AQS独占式同步状态获取与释放', '1693', 1558284300, 1558285534, '<p>本文记录Java学习过程中遇到的AQS独占式同步状态获取与释放～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2906941323.png" style="width: 800px; height: 884px;" /></p>\r\r<p><br />\r源码分析（获取锁）：</p>\r\r<pre class="brush:java;">\rpublic final void acquire(int arg) {\r    if (!tryAcquire(arg) &amp;&amp;\r        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\r        selfInterrupt();\r}\r\rprivate Node addWaiter(Node mode) {\r    Node node = new Node(Thread.currentThread(), mode);\r    // Try the fast path of enq; backup to full enq on failure\r    Node pred = tail;\r    if (pred != null) {\r        node.prev = pred;\r        if (compareAndSetTail(pred, node)) {\r            pred.next = node;\r            return node;\r        }\r    }\r    enq(node);\r    return node;\r}\r\rprivate Node enq(final Node node) {\r    for (;;) {\r        Node t = tail;\r        if (t == null) { // Must initialize\r            if (compareAndSetHead(new Node()))\r                tail = head;\r        } else {\r            node.prev = t;\r            if (compareAndSetTail(t, node)) {\r                t.next = node;\r                return t;\r            }\r        }\r    }\r}\r\rfinal boolean acquireQueued(final Node node, int arg) {\r    boolean failed = true;\r    try {\r        boolean interrupted = false;\r        for (;;) {\r            final Node p = node.predecessor();\r            if (p == head &amp;&amp; tryAcquire(arg)) {\r                setHead(node);\r                p.next = null; // help GC\r                failed = false;\r                return interrupted;\r            }\r            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\r                parkAndCheckInterrupt())\r                interrupted = true;\r         }\r    } finally {\r        if (failed)\r            cancelAcquire(node);\r    }\r}\r\rfinal Node predecessor() throws NullPointerException {\r    Node p = prev;\r    if (p == null)\r        throw new NullPointerException();\r    else\r        return p;\r}\r\rprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\r    int ws = pred.waitStatus;\r    if (ws == Node.SIGNAL)\r        /*\r         * This node has already set status asking a release\r         * to signal it, so it can safely park.\r         */\r        return true;\r    if (ws &gt; 0) {\r        /*\r         * Predecessor was cancelled. Skip over predecessors and\r         * indicate retry.\r         */\r        do {\r            node.prev = pred = pred.prev;\r        } while (pred.waitStatus &gt; 0);\r        pred.next = node;\r    } else {\r        /*\r         * waitStatus must be 0 or PROPAGATE.  Indicate that we\r         * need a signal, but don&#39;t park yet.  Caller will need to\r         * retry to make sure it cannot acquire before parking.\r         */\r        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\r    }\r    return false;\r}\r\rprivate final boolean parkAndCheckInterrupt() {\r    LockSupport.park(this);\r    return Thread.interrupted();\r}</pre>\r\r<p>源码分析（释放锁）：</p>\r\r<pre class="brush:java;">\rpublic final boolean release(int arg) {\r    if (tryRelease(arg)) {\r        Node h = head;\r        if (h != null &amp;&amp; h.waitStatus != 0)\r            unparkSuccessor(h);\r        return true;\r    }\r    return false;\r}\r\rprivate void unparkSuccessor(Node node) {\r    /*\r     * If status is negative (i.e., possibly needing signal) try\r     * to clear in anticipation of signalling.  It is OK if this\r     * fails or if status is changed by waiting thread.\r     */\r    int ws = node.waitStatus;\r    if (ws &lt; 0)\r        compareAndSetWaitStatus(node, ws, 0);\r    /*\r     * Thread to unpark is held in successor, which is normally\r     * just the next node.  But if cancelled or apparently null,\r     * traverse backwards from tail to find the actual\r     * non-cancelled successor.\r     */\r    Node s = node.next;\r    if (s == null || s.waitStatus &gt; 0) {\r        s = null;\r        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)\r            if (t.waitStatus &lt;= 0)\r                s = t;\r    }\r    if (s != null)\r        LockSupport.unpark(s.thread);\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 15),
(1694, 'AQS共享式同步状态获取与释放', '1694', 1558286040, 1558286100, '<p>本文记录Java学习过程中遇到的AQS共享式同步状态获取与释放～</p>\r<!--more-->\r\r<p>源码分析（获取锁）：</p>\r\r<pre class="brush:java;">\rpublic final void acquireShared(int arg) {\r    if (tryAcquireShared(arg) &lt; 0)\r        doAcquireShared(arg);\r}\r\rprivate void doAcquireShared(int arg) {\r    final Node node = addWaiter(Node.SHARED);\r    boolean failed = true;\r    try {\r        boolean interrupted = false;\r        for (;;) {\r            final Node p = node.predecessor();\r            if (p == head) {\r                int r = tryAcquireShared(arg);\r                if (r &gt;= 0) {\r                    setHeadAndPropagate(node, r);\r                    p.next = null; // help GC\r                    if (interrupted)\r                        selfInterrupt();\r                    failed = false;\r                    return;\r                }\r            }\r            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\r                parkAndCheckInterrupt())\r                interrupted = true;\r        }\r    } finally {\r        if (failed)\r            cancelAcquire(node);\r    }\r}</pre>\r\r<p>源码分析（释放锁）：</p>\r\r<pre class="brush:java;">\rpublic final boolean releaseShared(int arg) {\r    if (tryReleaseShared(arg)) {\r        doReleaseShared();\r        return true;\r    }\r    return false;\r}\r\rprivate void doReleaseShared() {\r    /*\r     * Ensure that a release propagates, even if there are other\r     * in-progress acquires/releases.  This proceeds in the usual\r     * way of trying to unparkSuccessor of head if it needs\r     * signal. But if it does not, status is set to PROPAGATE to\r     * ensure that upon release, propagation continues.\r     * Additionally, we must loop in case a new node is added\r     * while we are doing this. Also, unlike other uses of\r     * unparkSuccessor, we need to know if CAS to reset status\r     * fails, if so rechecking.\r     */\r    for (;;) {\r        Node h = head;\r        if (h != null &amp;&amp; h != tail) {\r            int ws = h.waitStatus;\r            if (ws == Node.SIGNAL) {\r                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\r                    continue;            // loop to recheck cases\r                unparkSuccessor(h);\r            }\r            else if (ws == 0 &amp;&amp;\r                    !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\r                continue;                // loop on failed CAS\r        }\r        if (h == head)                   // loop if head changed\r            break;\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 9),
(1695, '等待队列.png', '等待队列-png', 1558286458, 1558286458, 'a:5:{s:4:"name";s:16:"等待队列.png";s:4:"path";s:35:"/usr/uploads/2019/05/1221360438.png";s:4:"size";i:110482;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1699, 0),
(1696, '同步队列与等待队列.png', '同步队列与等待队列-png', 1558286516, 1558286516, 'a:5:{s:4:"name";s:31:"同步队列与等待队列.png";s:4:"path";s:35:"/usr/uploads/2019/05/3026472196.png";s:4:"size";i:231798;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1699, 0),
(1697, 'await.png', 'await-png', 1558286632, 1558286632, 'a:5:{s:4:"name";s:9:"await.png";s:4:"path";s:35:"/usr/uploads/2019/05/2346816732.png";s:4:"size";i:209807;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1699, 0),
(1698, 'signal.png', 'signal-png', 1558286661, 1558286661, 'a:5:{s:4:"name";s:10:"signal.png";s:4:"path";s:35:"/usr/uploads/2019/05/1641178012.png";s:4:"size";i:205731;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1699, 0),
(1699, 'AQS中Condition的等待队列', '1699', 1558286640, 1558286801, '<p>本文记录Java学习过程中遇到的AQS中Condition的等待队列～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1221360438.png" style="width: 800px; height: 134px;" /></p>\r\r<p>同步队列与等待队列</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/3026472196.png" style="width: 800px; height: 355px;" /></p>\r\r<p>await</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2346816732.png" style="width: 800px; height: 209px;" />signal</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1641178012.png" style="width: 800px; height: 220px;" />​注意：AQS中一般尽量调用signal，而少用signalAll，因为等待的条件是明确知道的，唤醒一个即可；而notifyAll等待的条件不确定，需要都唤醒。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 11),
(1700, 'Hash简介', '1700', 1558487601, 1558487601, '<p>本文记录Java学习过程中遇到的Hash简介～</p>\r<!--more-->\r\r<p>散列，哈希：把任意长度的输入通过一种算法（散列），变换成为固定长度的输出，这个输出值就是散列值。</p>\r\r<p>它属于压缩映射，容易产生哈希冲突。</p>\r\r<p>Hash算法有直接取余法等。</p>\r\r<p>产生哈希冲突时解决办法：</p>\r\r<ol>\r	<li>开放寻址；</li>\r	<li>再散列；</li>\r	<li>链地址法（相同hash值的元素用链表串起来）。</li>\r</ol>\r\r<p>ConcurrentHashMap在发生哈希冲突时采用了链地址法。</p>\r\r<p>md4,md5,sha-hash算法也属于hash算法，又称摘要算法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 6),
(1701, 'ConcurrentHashMap简介', '1701', 1558488027, 1558488027, '<p>本文记录Java学习过程中遇到的ConcurrentHashMap简介～</p>\r<!--more-->\r\r<p>Hashmap多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>\r\r<p>HashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。例如：线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>\r\r<p>ConcurrentHashMap解决了这些问题，它还提供了一个putIfAbsent() 方法（没有这个值则放入map，有这个值则返回key本来对应的值）。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch05.concurrenthashmap;\r\rimport java.util.concurrent.ConcurrentHashMap;\r\rpublic class TryPutIfAbsent {\r\r    public static void main(String[] args) {\r\r        ConcurrentHashMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;String, String&gt;();\r        map.put(&quot;001&quot;, &quot;001_value&quot;);\r        map.put(&quot;002&quot;, &quot;002_value&quot;);\r        map.put(&quot;003&quot;, &quot;003_value&quot;);\r\r        System.out.println(&quot;002=&quot; + map.get(&quot;002&quot;));\r        String result = map.putIfAbsent(&quot;002&quot;, &quot;002_value_2nd&quot;);\r        System.out.println(&quot;result=&quot; + result);\r        System.out.println(&quot;002=&quot; + map.get(&quot;002&quot;));\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 8),
(1702, '位运算.png', '位运算-png', 1558619289, 1558619289, 'a:5:{s:4:"name";s:13:"位运算.png";s:4:"path";s:35:"/usr/uploads/2019/05/2556017637.png";s:4:"size";i:25428;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1703, 0),
(1703, '位运算', '1703', 1558619280, 1558620758, '<p>本文记录Java学习过程中遇到的位运算～</p>\r<!--more-->\r\r<p>Integer类型的位</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2556017637.png" style="width: 800px; height: 133px;" />​2的0次方=1，2的1次方=2&hellip;&hellip;，以上表格代表数字（2的5次方+2的3次方）=40。</p>\r\r<p>由上面的表格可以看出，数字类型在数字渐渐变大时，是由低位慢慢向高位扩展的。</p>\r\r<p>Java实际保存int型时是有符号位的，正数的第31位=0，负数的第31位=1。</p>\r\r<p>常用的位运算：</p>\r\r<ul>\r	<li>位与&nbsp; &amp;&nbsp; (1&amp;1=1 <span style="white-space:pre"> </span>1&amp;0=0<span style="white-space:pre"> </span> 0&amp;0=0)</li>\r	<li>位或&nbsp; |&nbsp; &nbsp;(1|1=1<span style="white-space:pre"> </span> 1|0=1 <span style="white-space:pre"> </span>0|0=0)</li>\r	<li>位非&nbsp; ~&nbsp; （ ~1=0 <span style="white-space:pre"> </span> ~0=1）</li>\r	<li>位异或&nbsp; ^&nbsp; &nbsp;(1^1=0<span style="white-space:pre"> </span> 1^0=1<span style="white-space:pre"> </span> 0^0=0)&nbsp;</li>\r	<li>有符号左移 &lt;&lt; (8 &lt;&lt; 2 = 32)</li>\r	<li>有符号右移 &gt;&gt; (8 &gt;&gt; 2 = 2)</li>\r	<li>无符号右移 &gt;&gt;&gt; (8 &gt;&gt;&gt; 2 = 2)</li>\r</ul>\r\r<p>注意：有个常用的提高效率的转换公式：取模的操作a%(Math.pow(2,n))等价于a&amp;(Math.pow(2,n)-1)。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r/**\r * 尝试位运算\r */\rpublic class IntToBinary {\r\r    public static void main(String[] args) {\r\r        // 将整数转为二进制字符串\r        System.out.println(&quot;the 4 is &quot; + Integer.toBinaryString(4));\r\r        // 位与 &amp; (1&amp;1=1 1&amp;0=0 0&amp;0=0)\r        System.out.println(&quot;the 4&amp;6 is &quot; + Integer.toBinaryString(4&amp;6));\r\r        // 位或 | (1|1=1 1|0=1 0|0=0)\r        System.out.println(&quot;the 4|6 is &quot; + Integer.toBinaryString(4|6));\r\r        // 位非 ~（~1=0  ~0=1）\r        System.out.println(&quot;the ~4 is &quot; + Integer.toBinaryString(~4));\r\r        // 位异或 ^ (1^1=0 1^0=1 0^0=0)\r        System.out.println(&quot;the 4^6 is &quot; + Integer.toBinaryString(4^6));\r\r        // 有符号左移 &lt;&lt;\r        System.out.println(&quot;the 8&lt;&lt;2 is &quot; + (8 &lt;&lt; 2));\r\r        // 有符号的右移 &gt;&gt;\r        System.out.println(&quot;the 8&gt;&gt;2 is &quot; + (8 &gt;&gt; 2));\r\r        // 无符号右移 &gt;&gt;&gt;\r        System.out.println(&quot;the 8&gt;&gt;&gt;2 is &quot; + (8 &gt;&gt;&gt; 2));\r\r        // 取模的操作 %  a%(2^n)等价于a&amp;(2^n-1)\r        System.out.println(&quot;the 345%16 is &quot; + (345 % 16) + &quot; or &quot; + (345 &amp; (16 - 1)));\r    }\r}</pre>\r\r<p>位运算常用的场景：</p>\r\r<ul>\r	<li>权限控制；</li>\r	<li>实体的属性非常多等。</li>\r</ul>\r\r<p>示例代码（通过为操作进行权限控制）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch05.bitwise;\r\r/**\r * 通过位操作管理权限\r */\rpublic class Permission {\r\r    // 是否允许查询，二进制第1位，0表示否，1表示是\r    public static final int ALLOW_SELECT = 1 &lt;&lt; 0; // 0001  = 1\r\r    // 是否允许新增，二进制第2位，0表示否，1表示是\r    public static final int ALLOW_INSERT = 1 &lt;&lt; 1; // 0010  = 2\r\r    // 是否允许修改，二进制第3位，0表示否，1表示是\r    public static final int ALLOW_UPDATE = 1 &lt;&lt; 2; // 0100  = 4\r\r    // 是否允许删除，二进制第4位，0表示否，1表示是\r    public static final int ALLOW_DELETE = 1 &lt;&lt; 3; // 1000  = 8\r\r    // 存储权限状态\r    private int flag;\r\r    // 设置用户的权限\r    public void setPer(int per) {\r        flag = per;\r    }\r\r    // 增加用户的权限（1个或者多个）\r    public void enable(int per) {\r        flag = flag|per;\r    }\r\r    // 删除用户的权限（1个或者多个）\r    public void disable(int per) {\r        flag = flag&amp;~per;\r    }\r\r    // 判断用户拥有的权限\r    public boolean isAllow(int per) {\r        return ((flag&amp;per)== per);\r    }\r\r    // 判断用户没有的权限\r    public boolean isNotAllow(int per) {\r        return ((flag&amp;per)==0);\r    }\r\r    public static void main(String[] args) {\r\r        int flag = 15;\r        Permission permission = new Permission();\r        permission.setPer(flag);\r        permission.disable(ALLOW_DELETE|ALLOW_INSERT);\r        System.out.println(&quot;select = &quot;+permission.isAllow(ALLOW_SELECT));\r        System.out.println(&quot;update = &quot;+permission.isAllow(ALLOW_UPDATE));\r        System.out.println(&quot;insert = &quot;+permission.isAllow(ALLOW_INSERT));\r        System.out.println(&quot;delete = &quot;+permission.isAllow(ALLOW_DELETE));\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 10);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1704, 'ConcurrentHashMap——JDK1.7及以前的实现', '1704', 1558650000, 1558767473, '<p>本文记录Java学习过程中遇到的ConcurrentHashMap&mdash;&mdash;JDK1.7及以前的实现～</p>\r<!--more-->\r\r<p>数据结构</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1237893370.png" style="width: 600px; height: 434px;" /></p>\r\r<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment实际继承自可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，每个Segment里包含一个HashEntry数组，我们称之为table，每个HashEntry是一个链表结构的元素。</p>\r\r<p>ConcurrentHashMap如何在保证高并发下线程安全的同时实现了性能提升？</p>\r\r<p>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的Hashtable，只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>\r\r<p><strong>构造函数</strong></p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {\r\r    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)\r        throw new IllegalArgumentException();\r\r    if (concurrencyLevel &gt; MAX_SEGMENTS)\r        concurrencyLevel = MAX_SEGMENTS;\r\r    // Find power-of-two sizes best matching arguments\r    int sshift = 0;\r    int ssize = 1;\r    // 保证Segment数组的大小，一定为2的幂，例如：用户设置并发度为17，则实际Segment数组大小则为32\r    while (ssize &lt; concurrencyLevel) {\r        ++sshift;\r        ssize &lt;&lt;= 1;\r    }\r\r    // 用于定位元素所在segment。\r    // segmentShift表示偏移位数，通过前面的int类型的位的描述我们可以得知，int类型的数字在变大的过程中，低位总是比高位先填满的，为保证元素在segment级别分布的尽量均匀，计算元素所在segment时，总是取hash值的高位进行计算。\r    // segmentMask作用就是为了利用位运算中取模的操作：a%(Math.pow(2,n))等价于a&amp;(Math.pow(2,n)-1)\r    this.segmentShift = 32 - sshift;\r    this.segmentMask = ssize - 1;\r    if (initialCapacity &gt; MAXIMUM_CAPACITY)\r        initialCapacity = MAXIMUM_CAPACITY;\r    int c = initialCapacity / ssize;\r    if (c * ssize &lt; initialCapacity)\r        ++c;\r\r    // 保证每个Segment中tabel数组的大小，一定为2的幂，初始化的三个参数取默认值时，table数组大小为2\r    int cap = MIN_SEGMENT_TABLE_CAPACITY;\r    while (cap &lt; c)\r        cap &lt;&lt;= 1;\r\r    // 初始化Segment数组，并实际只填充Segment数组的第0个元素。\r    // create segments and segments[0]\r    Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);\r    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];\r    // ordered write of segments[0]\r    UNSAFE.putOrderedObject(ss, SBASE, s0);\r    this.segments = ss;\r}</pre>\r\r<p>如何快速定位元素放在哪个位置？</p>\r\r<ol>\r	<li>对于某个元素而言，一定是放在某个segment元素的某个table元素中的，所以在定位上，要先定位segment，再定位table元素；</li>\r	<li>定位segment：取得key的hashcode值进行一次再散列（通过Wang/Jenkins算法），拿到再散列值后，以再散列值的高位进行取模得到当前元素在哪个segment上；</li>\r	<li>定位table：同样是取得key的再散列值（通过Wang/Jenkins算法）以后，用再散列值的全部和table的长度进行取模，得到当前元素在table的哪个元素上。</li>\r</ol>\r\r<p><strong>get()方法</strong></p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic V get(Object key) {\r\r	// manually integrate access methods to reduce overhead\r    Segment&lt;K,V&gt; s;\r    HashEntry&lt;K,V&gt;[] tab;\r    int h = hash(key);\r    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\r    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;\r        (tab = s.table) != null) {\r        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) {\r            K k;\r            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))\r                return e.value;\r            }\r        }\r    return null;\r}</pre>\r\r<p>定位segment和定位table后，依次扫描这个table元素下的的链表，要么找到元素，要么返回null。</p>\r\r<p>在高并发下的情况下如何保证取得的元素是最新的？</p>\r\r<p>用于存储键值对数据的HashEntry，在设计上它的成员变量value等都是volatile类型的，这样就保证别的线程对value值的修改，get方法可以马上看到。</p>\r\r<p><strong>put()方法</strong></p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic V put(K key, V value) {\r\r    Segment&lt;K,V&gt; s;\r    if (value == null)\r        throw new NullPointerException();\r    int hash = hash(key);\r    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;\r    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == null)\r        s = ensureSegment(j);\r    return s.put(key, hash, value, false);\r}\r\rfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\r\r	// 对Segment 加锁\r    HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);\r    V oldValue;\r    try {\r        HashEntry&lt;K,V&gt;[] tab = table;\r        int index = (tab.length - 1) &amp; hash;\r        HashEntry&lt;K,V&gt; first = entryAt(tab, index);\r        // 定位所在的table元素，并扫描table下的链表\r        for (HashEntry&lt;K,V&gt; e = first;;) {\r            if (e != null) {\r                K k;\r                // 找到时\r                if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) {\r                    oldValue = e.value;\r                    // put会覆盖原来的值，putIfAbsent不会覆盖\r                    if (!onlyIfAbsent) {\r                        e.value = value;\r                        ++modCount;\r                    }\r                    break;\r                }\r                e = e.next;\r            } else {\r            	// 没有找到时\r                if (node != null)\r                	// 链表为空，直接设置为第一个\r                    node.setNext(first);\r                else\r                	// 链表非空，加到最后\r                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);\r                int c = count + 1;\r                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)\r                	// 进行扩容\r                    rehash(node);\r                else\r                    setEntryAt(tab, index, node);\r                ++modCount;\r                count = c;\r                oldValue = null;\r                break;\r            }\r        }\r    } finally {\r        unlock();\r    }\r    return oldValue;\r}</pre>\r\r<p><strong>扩容操作</strong></p>\r\r<ul>\r	<li>Segment不扩容，扩容下面的table数组，每次都是将数组翻倍。</li>\r</ul>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rprivate void rehash(HashEntry&lt;K,V&gt; node) {\r    HashEntry&lt;K,V&gt;[] oldTable = table;\r    int oldCapacity = oldTable.length;\r    // 原容量左移1位，即容量翻倍\r    int newCapacity = oldCapacity &lt;&lt; 1;\r    threshold = (int)(newCapacity * loadFactor);\r    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];\r    int sizeMask = newCapacity - 1;\r    for (int i = 0; i &lt; oldCapacity ; i++) {\r        HashEntry&lt;K,V&gt; e = oldTable[i];\r        if (e != null) {\r            HashEntry&lt;K,V&gt; next = e.next;\r            int idx = e.hash &amp; sizeMask;\r            //  Single node on list\r            if (next == null)\r                newTable[idx] = e;\r            else { \r            	// Reuse consecutive sequence at same slot\r                HashEntry&lt;K,V&gt; lastRun = e;\r                int lastIdx = idx;\r                for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) {\r                    int k = last.hash &amp; sizeMask;\r                    if (k != lastIdx) {\r                        lastIdx = k;\r                        lastRun = last;\r                    }\r                }\r                newTable[lastIdx] = lastRun;\r                // Clone remaining nodes\r                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {\r                    V v = p.value;\r                    int h = p.hash;\r                    int k = h &amp; sizeMask;\r                    HashEntry&lt;K,V&gt; n = newTable[k];\r                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);\r                }\r            }\r        }\r    }\r    int nodeIndex = node.hash &amp; sizeMask; // add the new node\r    node.setNext(newTable[nodeIndex]);\r    newTable[nodeIndex] = node;\r    table = newTable;\r}</pre>\r\r<p><strong>扩容带来的好处</strong></p>\r\r<p>假设原来table长度为4，那么元素在table中的分布是：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/949276354.png" style="width: 800px; height: 100px;" /></p>\r\r<p>扩容后table长度变为8，那么元素在table中的分布变成：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/771873182.png" style="width: 800px; height: 101px;" /></p>\r\r<p>可以看到，hash值为34和56的下标保持不变，而15,23,77的下标都是在原来下标的基础上+4即可，可以快速定位和减少重排次数。</p>\r\r<p><strong>size()方法</strong></p>\r\r<p>size()的时候进行两次不加锁的统计，两次一致直接返回结果，不一致则重新加锁再次统计。</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic int size() {\r\r    // Try a few times to get accurate count. On failure due to\r    // continuous async changes in table, resort to locking.\r    final Segment&lt;K,V&gt;[] segments = this.segments;\r    int size;\r    // true if size overflows 32 bits\r    boolean overflow;\r    // sum of modCounts\r    long sum;\r    // previous sum\r    long last = 0L;\r    // first iteration isn&#39;t retry\r    int retries = -1;\r    try {\r        for (;;) {\r            if (retries++ == RETRIES_BEFORE_LOCK) {\r                for (int j = 0; j &lt; segments.length; ++j)\r                	// force creation\r                    ensureSegment(j).lock(); \r            }\r            sum = 0L;\r            size = 0;\r            overflow = false;\r            for (int j = 0; j &lt; segments.length; ++j) {\r                Segment&lt;K,V&gt; seg = segmentAt(segments, j);\r                if (seg != null) {\r                    sum += seg.modCount;\r                    int c = seg.count;\r                    if (c &lt; 0 || (size += c) &lt; 0)\r                        overflow = true;\r                }\r            }\r            if (sum == last)\r                break;\r            last = sum;\r        }\r    } finally {\r        if (retries &gt; RETRIES_BEFORE_LOCK) {\r            for (int j = 0; j &lt; segments.length; ++j)\r                segmentAt(segments, j).unlock();\r        }\r    }\r    return overflow ? Integer.MAX_VALUE : size;\r}</pre>\r\r<p><strong>弱一致性</strong></p>\r\r<p>get()方法和containsKey()方法都是通过对链表遍历判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get()和containsKey()返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 20),
(1705, '1.7.png', '1-7-png', 1558650566, 1558650566, 'a:5:{s:4:"name";s:7:"1.7.png";s:4:"path";s:35:"/usr/uploads/2019/05/1237893370.png";s:4:"size";i:92393;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1704, 0),
(1706, '扩容01.png', '扩容01-png', 1558653693, 1558653693, 'a:5:{s:4:"name";s:12:"扩容01.png";s:4:"path";s:34:"/usr/uploads/2019/05/949276354.png";s:4:"size";i:26784;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1704, 0),
(1707, '扩容02.png', '扩容02-png', 1558653714, 1558653714, 'a:5:{s:4:"name";s:12:"扩容02.png";s:4:"path";s:34:"/usr/uploads/2019/05/771873182.png";s:4:"size";i:21298;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1704, 0),
(1708, 'ConcurrentHashMap——JDK1.8的实现', '1708', 1558654140, 1558778232, '<p>本文记录Java学习过程中遇到的ConcurrentHashMap&mdash;&mdash;JDK1.8的实现～</p>\r<!--more-->\r\r<p>相比1.7的重大变化：</p>\r\r<ol>\r	<li>取消了segment数组，直接用table保存数据，锁的粒度更小，降低并发冲突的概率；</li>\r	<li>存储数据时采用了链表+红黑树的形式，纯链表的形式时间复杂度为O(n)，红黑树则为O(logn)，性能提升很大。当key值的hash值相等的元素形成的链表中元素个数超过8个的时候，链表转红黑树；当key值的hash值相等的元素形成的链表中元素个数少于6个的时候，红黑树转链表。</li>\r</ol>\r\r<p><strong>数据结构</strong></p>\r\r<p>Node类存放实际的key和value值。</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\r\r    final int hash;\r    final K key;\r    volatile V val;\r    volatile Node&lt;K,V&gt; next;\r\r    Node(int hash, K key, V val, Node&lt;K,V&gt; next) {\r        this.hash = hash;\r        this.key = key;\r        this.val = val;\r        this.next = next;\r    }\r\r    public final K getKey()       { return key; }\r    public final V getValue()     { return val; }\r    public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }\r    public final String toString(){ return key + &quot;=&quot; + val; }\r    public final V setValue(V value) {\r        throw new UnsupportedOperationException();\r    }\r\r    public final boolean equals(Object o) {\r        Object k, v, u; Map.Entry&lt;?,?&gt; e;\r        return ((o instanceof Map.Entry) &amp;&amp; (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp; (v = e.getValue()) != null &amp;&amp; (k == key || k.equals(key)) &amp;&amp; (v == (u = val) || v.equals(u)));\r    }\r\r    /**\r     * Virtualized support for map.get(); overridden in subclasses.\r     */\r    Node&lt;K,V&gt; find(int h, Object k) {\r        Node&lt;K,V&gt; e = this;\r        if (k != null) {\r            do {\r                K ek;\r                if (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))\r                    return e;\r            } while ((e = e.next) != null);\r        }\r        return null;\r    }\r}</pre>\r\r<p>TreeBin表示红黑树的根</p>\r\r<p>TreeNode表示红黑树的节点</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rstatic final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; {\r\r    // red-black tree links\r    TreeNode&lt;K,V&gt; parent;\r    TreeNode&lt;K,V&gt; left;\r    TreeNode&lt;K,V&gt; right;\r    // needed to unlink next upon deletion\r    TreeNode&lt;K,V&gt; prev;\r    boolean red;\r\r    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next, TreeNode&lt;K,V&gt; parent) {\r        super(hash, key, val, next);\r        this.parent = parent;\r    }\r\r    Node&lt;K,V&gt; find(int h, Object k) {\r        return findTreeNode(h, k, null);\r    }\r\r    /**\r     * Returns the TreeNode (or null if not found) for the given key\r     * starting at given root.\r     */\r    final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) {\r        if (k != null) {\r            TreeNode&lt;K,V&gt; p = this;\r            do  {\r                int ph, dir; K pk; TreeNode&lt;K,V&gt; q;\r                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;\r                if ((ph = p.hash) &gt; h)\r                    p = pl;\r                else if (ph &lt; h)\r                    p = pr;\r                else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))\r                    return p;\r                else if (pl == null)\r                    p = pr;\r                else if (pr == null)\r                    p = pl;\r                else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0)\r                    p = (dir &lt; 0) ? pl : pr;\r                else if ((q = pr.findTreeNode(h, k, kc)) != null)\r                    return q;\r                else\r                    p = pl;\r            } while (p != null);\r        }\r        return null;\r    }\r}</pre>\r\r<p><strong>关键变量</strong></p>\r\r<p>sizeCtl</p>\r\r<ol>\r	<li>负数：表示进行初始化或者扩容。例如：-1表示正在初始化；-N，表示有N-1个线程正在进行扩容；</li>\r	<li>零：表示还没有初始化；</li>\r	<li>正数：N表示初始化或者是下一次进行扩容的阈值。</li>\r</ol>\r\r<p><strong>构造函数</strong></p>\r\r<p>只是给成员变量赋值，put时进行实际数组的填充。</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic ConcurrentHashMap() {\r\r}</pre>\r\r<p><strong>get()方法</strong></p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rstatic final int spread(int h) {\r    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;\r}\r\rpublic V get(Object key) {\r\r    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;\r    int h = spread(key.hashCode());\r    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) {\r        // 判断当前元素是不是\r        if ((eh = e.hash) == h) {\r            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))\r                return e.val;\r        } else if (eh &lt; 0)\r            // 在红黑树中寻找\r            return (p = e.find(h, key)) != null ? p.val : null;\r        // 在链表中寻找\r        while ((e = e.next) != null) {\r            if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))\r                return e.val;\r        }\r    }\r    return null;\r}</pre>\r\r<p><strong>put()方法</strong></p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic V put(K key, V value) {\r    return putVal(key, value, false);\r}\r\rfinal V putVal(K key, V value, boolean onlyIfAbsent) {\r    if (key == null || value == null) throw new NullPointerException();\r    int hash = spread(key.hashCode());\r    int binCount = 0;\r    for (Node&lt;K,V&gt;[] tab = table;;) {\r        Node&lt;K,V&gt; f; int n, i, fh;\r        if (tab == null || (n = tab.length) == 0)\r            // 初始化\r            tab = initTable();\r        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {\r            // node上这个元素为null，则直接放入\r            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))\r                // no lock when adding to empty bin\r                break;\r        } else if ((fh = f.hash) == MOVED)\r            // 正在扩容，帮助扩容\r            tab = helpTransfer(tab, f);\r        else {\r            V oldVal = null;\r            synchronized (f) {\r                if (tabAt(tab, i) == f) {\r                    if (fh &gt;= 0) {\r                        binCount = 1;\r                        for (Node&lt;K,V&gt; e = f;; ++binCount) {\r                            K ek;\r                            // 放到链表的最后面\r                            if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) {\r                                oldVal = e.val;\r                                if (!onlyIfAbsent)\r                                    e.val = value;\r                                break;\r                            }\r                            Node&lt;K,V&gt; pred = e;\r                            if ((e = e.next) == null) {\r                                pred.next = new Node&lt;K,V&gt;(hash, key,\r                                                          value, null);\r                                break;\r                            }\r                        }\r                    }\r                    else if (f instanceof TreeBin) {\r                        Node&lt;K,V&gt; p;\r                        binCount = 2;\r                        // 放入红黑树\r                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) {\r                            oldVal = p.val;\r                            if (!onlyIfAbsent)\r                                p.val = value;\r                        }\r                    }\r                }\r            }\r            if (binCount != 0) {\r                // 当链表元素个数超过8，将链表转为红黑树\r                if (binCount &gt;= TREEIFY_THRESHOLD)\r                    treeifyBin(tab, i);\r                if (oldVal != null)\r                    return oldVal;\r                break;\r            }\r        }\r    }\r    addCount(1L, binCount);\r    return null;\r}\r\rprivate final Node&lt;K,V&gt;[] initTable() {\r    Node&lt;K,V&gt;[] tab; int sc;\r    while ((tab = table) == null || tab.length == 0) {\r        if ((sc = sizeCtl) &lt; 0)\r            // 数组正在初始化，放弃执行权\r            // lost initialization race; just spin\r            Thread.yield();\r        // CAS设置sizeCtl的值为-1\r        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\r            try {\r                if ((tab = table) == null || tab.length == 0) {\r                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;\r                    @SuppressWarnings(&quot;unchecked&quot;)\r                    // 进行初始化\r                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];\r                    table = tab = nt;\r                    sc = n - (n &gt;&gt;&gt; 2);\r                }\r            } finally {\r                // 设置下一次需要扩容的阈值\r                sizeCtl = sc;\r            }\r            break;\r        }\r    }\r    return tab;\r}\r\rprivate final void addCount(long x, int check) {\r    CounterCell[] as; long b, s;\r    if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {\r        CounterCell a; long v; int m;\r        boolean uncontended = true;\r        if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {\r            fullAddCount(x, uncontended);\r            return;\r        }\r        if (check &lt;= 1)\r            return;\r        s = sumCount();\r    }\r    if (check &gt;= 0) {\r        Node&lt;K,V&gt;[] tab, nt; int n, sc;\r        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) {\r            int rs = resizeStamp(n);\r            if (sc &lt; 0) {\r                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0)\r                    break;\r                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\r                    transfer(tab, nt);\r            }\r            else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))\r                transfer(tab, null);\r            s = sumCount();\r        }\r    }\r}</pre>\r\r<p><strong>扩容操作</strong></p>\r\r<p>transfer()方法进行实际的扩容操作，table大小也是翻倍的形式，有一个并发扩容的机制。</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rprivate final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {\r    int n = tab.length, stride;\r    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)\r        stride = MIN_TRANSFER_STRIDE; // subdivide range\r    if (nextTab == null) {            // initiating\r        try {\r            @SuppressWarnings(&quot;unchecked&quot;)\r            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];\r            nextTab = nt;\r        } catch (Throwable ex) {\r            // 避免OOM\r            // try to cope with OOME\r            sizeCtl = Integer.MAX_VALUE;\r            return;\r        }\r        nextTable = nextTab;\r        transferIndex = n;\r    }\r    int nextn = nextTab.length;\r    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);\r    boolean advance = true;\r    // to ensure sweep before committing nextTab\r    boolean finishing = false;\r    for (int i = 0, bound = 0;;) {\r        Node&lt;K,V&gt; f; int fh;\r        while (advance) {\r            int nextIndex, nextBound;\r            if (--i &gt;= bound || finishing)\r                advance = false;\r            else if ((nextIndex = transferIndex) &lt;= 0) {\r                i = -1;\r                advance = false;\r            }\r            else if (U.compareAndSwapInt\r                     (this, TRANSFERINDEX, nextIndex,\r                      nextBound = (nextIndex &gt; stride ?\r                                   nextIndex - stride : 0))) {\r                bound = nextBound;\r                i = nextIndex - 1;\r                advance = false;\r            }\r        }\r        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {\r            int sc;\r            if (finishing) {\r                nextTable = null;\r                table = nextTab;\r                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);\r                return;\r            }\r            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\r                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)\r                    return;\r                finishing = advance = true;\r                i = n; // recheck before commit\r            }\r        }\r        else if ((f = tabAt(tab, i)) == null)\r            advance = casTabAt(tab, i, null, fwd);\r        else if ((fh = f.hash) == MOVED)\r            advance = true; // already processed\r        else {\r            synchronized (f) {\r                if (tabAt(tab, i) == f) {\r                    Node&lt;K,V&gt; ln, hn;\r                    if (fh &gt;= 0) {\r                        int runBit = fh &amp; n;\r                        Node&lt;K,V&gt; lastRun = f;\r                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {\r                            int b = p.hash &amp; n;\r                            if (b != runBit) {\r                                runBit = b;\r                                lastRun = p;\r                            }\r                        }\r                        if (runBit == 0) {\r                            ln = lastRun;\r                            hn = null;\r                        }\r                        else {\r                            hn = lastRun;\r                            ln = null;\r                        }\r                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {\r                            int ph = p.hash; K pk = p.key; V pv = p.val;\r                            if ((ph &amp; n) == 0)\r                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);\r                            else\r                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);\r                        }\r                        setTabAt(nextTab, i, ln);\r                        setTabAt(nextTab, i + n, hn);\r                        setTabAt(tab, i, fwd);\r                        advance = true;\r                    }\r                    else if (f instanceof TreeBin) {\r                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;\r                        TreeNode&lt;K,V&gt; lo = null, loTail = null;\r                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;\r                        int lc = 0, hc = 0;\r                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {\r                            int h = e.hash;\r                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;\r                                (h, e.key, e.val, null, null);\r                            if ((h &amp; n) == 0) {\r                                if ((p.prev = loTail) == null)\r                                    lo = p;\r                                else\r                                    loTail.next = p;\r                                loTail = p;\r                                ++lc;\r                            }\r                            else {\r                                if ((p.prev = hiTail) == null)\r                                    hi = p;\r                                else\r                                    hiTail.next = p;\r                                hiTail = p;\r                                ++hc;\r                            }\r                        }\r                        // 转成链表\r                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :\r                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;\r                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\r                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;\r                        setTabAt(nextTab, i, ln);\r                        setTabAt(nextTab, i + n, hn);\r                        setTabAt(tab, i, fwd);\r                        advance = true;\r                    }\r                }\r            }\r        }\r    }\r}\r\r// 帮助扩容\rfinal Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {\r    Node&lt;K,V&gt;[] nextTab; int sc;\r    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {\r        int rs = resizeStamp(tab.length);\r        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) {\r            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)\r                break;\r            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {\r                transfer(tab, nextTab);\r                break;\r            }\r        }\r        return nextTab;\r    }\r    return table;\r}</pre>\r\r<p><strong>size()方法</strong></p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic int size() {\r    long n = sumCount();\r    return ((n &lt; 0L) ? 0 :\r            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :\r            (int)n);\r}\r\rfinal long sumCount() {\r    CounterCell[] as = counterCells; CounterCell a;\r    long sum = baseCount;\r    if (as != null) {\r        for (int i = 0; i &lt; as.length; ++i) {\r            if ((a = as[i]) != null)\r                sum += a.value;\r        }\r    }\r    return sum;\r}</pre>\r\r<p>注意：1.8的get和size方法也是弱一致的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 14),
(1709, '跳表.png', '跳表-png', 1558830248, 1558830248, 'a:5:{s:4:"name";s:10:"跳表.png";s:4:"path";s:35:"/usr/uploads/2019/05/2072811490.png";s:4:"size";i:189354;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1710, 0),
(1710, '跳表SkipList', '1710', 1558830277, 1558830277, '<p>本文记录Java学习过程中遇到的跳表SkipList～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/2072811490.png" style="width: 800px; height: 297px;" /></p>\r\r<p>链表的查找比较慢，跳表就是为了解决这一问题，基本思想是以空间换时间，与数据库中的索引类似，它可以加很多层索引。索引中元素的确定是通过随机数来确定的，所以又被称为概率数据结构。</p>\r\r<p>通过添加索引，跳表的查找效率已经接近红黑树了。</p>\r\r<p>ConcurrentHashMap不使用跳表的原因：跳表的空间利用率大约40%，而ConcurrentHashMap的空间利用率只有20%，再使用跳表的话空间利用率就更低了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1711, 'ConcurrentSkipListMap和ConcurrentSkipListSet', '1711', 1558830405, 1558830405, '<p>本文记录Java学习过程中遇到的ConcurrentSkipListMap和ConcurrentSkipListSet～</p>\r<!--more-->\r\r<p>TreeMap和TreeSet是两个有序的容器，ConcurrentSkipListMap和ConcurrentSkipListSet是这两种容器的并发版本。</p>\r\r<p>示例代码：</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1712, 'ConcurrentLinkedQueue', '1712', 1558830864, 1558830864, '<p>本文记录Java学习过程中遇到的ConcurrentLinkedQueue~</p>\r<!--more-->\r\r<p>ConcurrentLinkedQueue是一个无界非阻塞队列，底层是个链表，遵循先进先出原则，可以看作是LinkedList的并发版本。</p>\r\r<p>常用方法：</p>\r\r<ul>\r	<li>add()：将数据插入到尾部（异常）；</li>\r	<li>offer()：将数据插入到尾部（返回值）；</li>\r	<li>peek()：拿头部的数据但不移除；</li>\r	<li>poll()：拿头部的数据并移除。</li>\r</ul>\r\r<p>示例代码：</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1713, 'CopyOnWriteArrayList和CopyOnWriteArraySet', '1713', 1558831267, 1558831267, '<p>本文记录Java学习过程中遇到的CopyOnWriteArrayList和CopyOnWriteArraySet～</p>\r<!--more-->\r\r<p>CopyOnWriteArrayList和CopyOnWriteArraySet是两个写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以写时复制容器也是一种读写分离的思想，读和写不同的容器。如果读的时候有多个线程正在向容器添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的，只能保证最终一致性，而不能保证实时一致性。</p>\r\r<p>常用场景：</p>\r\r<ul>\r	<li>白名单/黑名单；</li>\r	<li>商品类目的访问和更新场景。</li>\r</ul>\r\r<p>注意：写时复制容器存在内存占用问题，当写操作过多的时候，可能会导致OOM。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1714, '生产者和消费者模式', '1714', 1558831541, 1558831541, '<p>本文记录Java学习过程中遇到的生产者和消费者模式～</p>\r<!--more-->\r\r<p>生产者就是生产数据的线程，消费者就是消费数据的线程。</p>\r\r<p>在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。</p>\r\r<p>生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1715, '常用方法.png', '常用方法-png', 1558832040, 1558832040, 'a:5:{s:4:"name";s:16:"常用方法.png";s:4:"path";s:34:"/usr/uploads/2019/05/268648153.png";s:4:"size";i:56424;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1716, 0),
(1716, '阻塞队列BlockingQueue', '1716', 1558832040, 1558832185, '<p>本文记录Java学习过程中遇到的阻塞队列BlockingQueue～</p>\r<!--more-->\r\r<p><strong>概念</strong></p>\r\r<ul>\r	<li>当队列满的时候，插入元素的线程被阻塞，直达队列不满；</li>\r	<li>队列为空的时候，获取元素的线程被阻塞，直到队列不空。</li>\r</ul>\r\r<p><strong>常用方法</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/268648153.png" style="width: 800px; height: 184px;" /></p>\r\r<ul>\r	<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（&quot;Queuefull&quot;）异常。当队列空时，从队列里获取/检查元素会抛出NoSuchElementException异常；</li>\r	<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null；</li>\r	<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空；</li>\r	<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>\r</ul>\r\r<p><strong>实现原理</strong></p>\r\r<ul>\r	<li>比如，ArrayBlockingQueue就是基于Lock和Condition实现的。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 7),
(1717, '常用阻塞队列', '1717', 1558874599, 1558874599, '<p>本文记录Java学习过程中遇到的常用阻塞队列～</p>\r<!--more-->\r\r<p><strong>ArrayBlockingQueue</strong></p>\r\r<p>一个由数组结构组成的有界阻塞队列，按照先进先出原则，要求设定初始大小。</p>\r\r<p><strong>LinkedBlockingQueue</strong></p>\r\r<p>一个由链表结构组成的有界阻塞队列，按照先进先出原则，可以不设定初始大小，默认值为Integer.MAX_VALUE。</p>\r\r<p>ArrayBlockingQueue和LinkedBlockingQueue不同：</p>\r\r<ul>\r	<li>锁上面：ArrayBlockingQueue只有一个锁，LinkedBlockingQueue用了两个锁；</li>\r	<li>实现上：ArrayBlockingQueue直接插入元素，LinkedBlockingQueue需要转换。</li>\r</ul>\r\r<p><strong>PriorityBlockingQueue</strong></p>\r\r<p>一个支持优先级排序的无界阻塞队列。默认情况下，按照自然顺序；要想自定义排序规则，要么实现compareTo()方法，要么指定构造参数Comparator。</p>\r\r<p><strong>DelayQueue</strong></p>\r\r<p>一个使用优先级队列实现的无界阻塞队列。支持延时获取的元素的阻塞队列，元素必须要实现Delayed接口。适用场景：实现自己的缓存系统，订单到期，限时支付等等。</p>\r\r<p><strong>SynchronousQueue</strong></p>\r\r<p>一个不存储元素的阻塞队列，每一个put操作都要等待一个take操作，吞吐量较高，但生产者和消费者能力不匹配的时候就显得耦合度较高。</p>\r\r<p><strong>LinkedTransferQueue</strong></p>\r\r<p>一个由链表结构组成的无界阻塞队列。transfer()必须要消费者消费了以后方法才会返回；tryTransfer()无论消费者是否接收，方法都立即返回。</p>\r\r<p><strong>LinkedBlockingDeque</strong></p>\r\r<p>一个由链表结构组成的双向阻塞队列。从队列的头和尾都可以插入和移除元素，并发的情况下可以减少一半的竞争，可以用于实现工作密取，方法名带了first从头部操作，方法名带了last从尾部操作，另外：add=addLast;remove=removeFirst;take=takeFirst。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1718, '线程池简介', '1718', 1558882975, 1558882975, '<p>本文记录Java学习过程中遇到的线程池简介～</p>\r<!--more-->\r\r<p>线程池的好处：</p>\r\r<ul>\r	<li>降低资源的消耗，降低线程创建和销毁的资源消耗，与数据库连接池相似；</li>\r	<li>提高响应速度，例如：线程的创建时间为T1，执行时间T2，销毁时间T3，使用线程池可以免去T1和T3的时间；</li>\r	<li>提高线程的可管理性。</li>\r</ul>\r\r<p>线程池的基本功能：</p>\r\r<ul>\r	<li>线程必须在池子已经创建好，并且可以保持住，要有容器保存多个线程；</li>\r	<li>线程要能够接受外部的任务并运行；</li>\r	<li>可以保存提交了但来不及运行的任务（阻塞队列）。</li>\r</ul>\r\r<p>示例代码（自定义线程池）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch06.threadpool;\r\rimport java.util.concurrent.ArrayBlockingQueue;\rimport java.util.concurrent.BlockingQueue;\r\rpublic class MyThreadPool {\r\r    // 线程池中默认线程的个数为5\r    private static int WORK_NUM = 5;\r\r    // 队列默认任务个数为100\r    private static int TASK_COUNT = 100;\r\r    // 工作线程组\r    private WorkThread[] workThreads;\r\r    // 任务队列，作为一个缓冲\r    private final BlockingQueue&lt;Runnable&gt; taskQueue;\r\r    // 用户在构造这个池，希望的启动的线程数\r    private final int worker_num;\r\r    // 创建具有默认线程个数的线程池\r    public MyThreadPool() {\r\r        this(WORK_NUM,TASK_COUNT);\r    }\r\r    // 创建线程池,worker_num为线程池中工作线程的个数\r    public MyThreadPool(int worker_num,int taskCount) {\r\r        if (worker_num&lt;=0) {\r            worker_num = WORK_NUM;\r        }\r\r        if(taskCount&lt;=0) {\r            taskCount = TASK_COUNT;\r        }\r\r        this.worker_num = worker_num;\r\r        taskQueue = new ArrayBlockingQueue&lt;&gt;(taskCount);\r        workThreads = new WorkThread[worker_num];\r        for(int i=0; i &lt; worker_num; i++) {\r            workThreads[i] = new WorkThread();\r            workThreads[i].start();\r        }\r    }\r\r    // 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定\r    public void execute(Runnable task) {\r        try {\r            taskQueue.put(task);\r        } catch (InterruptedException e) {\r            e.printStackTrace();\r        }\r    }\r\r\r    // 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁\r    public void destroy() {\r\r        // 工作线程停止工作，且置为null\r        System.out.println(&quot;ready close pool.....&quot;);\r        for(int i = 0; i &lt; worker_num; i++) {\r            workThreads[i].stopWorker();\r            // 垃圾回收\r            workThreads[i] = null;\r        }\r        // 清空任务队列\r        taskQueue.clear();\r    }\r\r    // 覆盖toString方法，返回线程池信息：工作线程个数和已完成任务个数\r    @Override\r    public String toString() {\r\r        return &quot;WorkThread number:&quot; + worker_num + &quot;  wait task number:&quot; + taskQueue.size();\r    }\r\r    /**\r     * 内部类，工作线程\r     */\r    private class WorkThread extends Thread {\r\r        @Override\r        public void run(){\r            Runnable r = null;\r            try {\r                while (!isInterrupted()) {\r                    r = taskQueue.take();\r                    if(r!=null) {\r                        System.out.println(getId()+&quot; ready exec :&quot;+r);\r                        r.run();\r                    }\r                    // 垃圾回收\r                    r = null;\r                }\r            } catch (Exception e) {\r                e.printStackTrace();\r            }\r        }\r\r        public void stopWorker() {\r            interrupt();\r        }\r    }\r}</pre>\r\r<p>示例代码（测试自定义线程池）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch06.threadpool;\r\rimport java.util.Random;\r\rpublic class App {\r\r    // 任务类\r    static class MyTask implements Runnable {\r\r        private String name;\r        private Random r = new Random();\r\r        public MyTask(String name) {\r            this.name = name;\r        }\r\r        public String getName() {\r            return name;\r        }\r\r        @Override\r        public void run() {\r            // 执行任务\r            try {\r                Thread.sleep(r.nextInt(1000)+2000);\r            } catch (InterruptedException e) {\r                System.out.println(Thread.currentThread().getId() + &quot; sleep InterruptedException:&quot; + Thread.currentThread().isInterrupted());\r            }\r            System.out.println(&quot;任务 &quot; + name + &quot; 完成&quot;);\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException {\r\r        // 创建3个线程的线程池\r        MyThreadPool t = new MyThreadPool(3,0);\r        t.execute(new MyTask(&quot;testA&quot;));\r        t.execute(new MyTask(&quot;testB&quot;));\r        t.execute(new MyTask(&quot;testC&quot;));\r        t.execute(new MyTask(&quot;testD&quot;));\r        t.execute(new MyTask(&quot;testE&quot;));\r        System.out.println(t);\r        Thread.sleep(10000);\r        // 所有线程都执行完成才destory\r        t.destroy();\r        System.out.println(t);\r    }\r}</pre>\r\r<p>自定义的线程池存在的问题：</p>\r\r<ul>\r	<li>线程池中线程的数量是固定的，不能动态调整；</li>\r	<li>当大量的任务涌入的时候，应用会卡住。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1719, 'JDK线程池ThreadPoolExecutor', '1719', 1558883940, 1558885793, '<p>本文记录Java学习过程中遇到的JDK线程池ThreadPoolExecutor～</p>\r<!--more-->\r\r<p>ThreadPoolExecutor是JDK所有线程池实现的父类。</p>\r\r<p><strong>构造函数</strong></p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\r    if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0)\r        throw new IllegalArgumentException();\r    if (workQueue == null || threadFactory == null || handler == null)\r        throw new NullPointerException();\r    this.acc = System.getSecurityManager() == null ? null : AccessController.getContext();\r    this.corePoolSize = corePoolSize;\r    this.maximumPoolSize = maximumPoolSize;\r    this.workQueue = workQueue;\r    this.keepAliveTime = unit.toNanos(keepAliveTime);\r    this.threadFactory = threadFactory;\r    this.handler = handler;\r}</pre>\r\r<p>参数的含义：</p>\r\r<ul>\r	<li>corePoolSize：线程池中核心线程数，线程池中的线程数量小于corePoolSize的时候，提交任务的时候就会创建新线程来执行；当等于corePoolSize的时候，提交任务就会保存到阻塞队列workQueue。调用prestartAllCoreThreads()方法就会一次性的创建corePoolSize&nbsp; 个数的线程并添加到线程池中；</li>\r	<li>maximumPoolSize：线程池中允许的最大线程数。当阻塞队列workQueue满了，线程池中的线程数小于maximumPoolSize时候，提交任务就会再次创建新的线程来执行；</li>\r	<li>keepAliveTime：线程空闲下来后，存活的时间，这个参数只在线程池中的线程数大于corePoolSize时生效；</li>\r	<li>unit：存活时间的单位值；</li>\r	<li>workQueue：保存任务的阻塞队列；</li>\r	<li>threadFactory：创建线程的工厂，主要是给新建的线程赋予名字；</li>\r	<li>RejectedExecutionHandler handler ：饱和策略。</li>\r</ul>\r\r<p>四种饱和策略：</p>\r\r<ul>\r	<li>AbortPolicy：直接抛出异常，默认值；</li>\r	<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\r	<li>DiscardOldestPolicy：丢弃阻塞队列里最老的最靠前的任务；</li>\r	<li>DiscardPolicy：当前任务直接丢弃。</li>\r</ul>\r\r<p>当然，也可以实现RejectedExecutionHandler接口来实现自己的饱和策略。</p>\r\r<p><strong>提交任务</strong></p>\r\r<ul>\r	<li>无返回值：execute(Runnable command)，在ThreadPoolExecutor中实现；</li>\r	<li>有返回值：Future&lt;T&gt; submit(Callable&lt;T&gt; task)，在AbstractExecutorService中实现。</li>\r</ul>\r\r<p><strong>工作机制</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1461352810.png" style="width: 800px; height: 730px;" />源码分析：</p>\r\r<pre class="brush:java;">\rpublic void execute(Runnable command) {\r\r    if (command == null)\r        throw new NullPointerException();\r    int c = ctl.get();\r    // 小于corePoolSize，创建线程执行\r    if (workerCountOf(c) &lt; corePoolSize) {\r        if (addWorker(command, true))\r            return;\r        c = ctl.get();\r    }\r    // 尝试放入阻塞队列\r    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {\r        int recheck = ctl.get();\r        if (! isRunning(recheck) &amp;&amp; remove(command))\r            reject(command);\r        else if (workerCountOf(recheck) == 0)\r            addWorker(null, false);\r    } \r    // 小于maximumPoolSize时再创建线程\r    else if (!addWorker(command, false))\r    	// 拒绝\r        reject(command);\r}</pre>\r\r<p><strong>关闭线程池</strong></p>\r\r<ul>\r	<li>shutdown()：设置线程池的状态，只会中断所有没有执行任务的线程；</li>\r	<li>shutdownNow()：设置线程池的状态，会尝试停止正在运行或者暂停运行的线程。</li>\r</ul>\r\r<p>如何合理地配置线程池？</p>\r\r<p>根据任务的性质来可以分为三类：</p>\r\r<ul>\r	<li>计算（CPU）密集型：例如，加密，大数分解，正则等等；</li>\r	<li>IO密集型：例如，读取文件，数据库连接，网络通讯等等；</li>\r	<li>混合型：两者都有。</li>\r</ul>\r\r<p>可以根据任务的类型来配置：</p>\r\r<ul>\r	<li>计算密集型：线程数适当小一点，推荐的最大数值为机器的CPU核心数+1，+1是为了防止页缺失的时候线程被挂起；</li>\r	<li>IO密集型：线程数适当大一点，推荐的数值是机器的CPU核心数*2；</li>\r	<li>混合型：尽量拆分，但当IO密集型远远多于计算密集型的时候，拆分意义不大；当IO密集型约等于计算密集型的时候，建议进行拆分，可以极大的提高吞吐量。</li>\r</ul>\r\r<p>注意：机器的CPU核心数=Runtime.getRuntime().availableProcessors()。</p>\r\r<p>队列的选择上，应该尽量使用有界，无界队列可能会导致内存溢出（OOM）。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 7),
(1720, '工作机制.png', '工作机制-png', 1558885729, 1558885729, 'a:5:{s:4:"name";s:16:"工作机制.png";s:4:"path";s:35:"/usr/uploads/2019/05/1461352810.png";s:4:"size";i:209917;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1719, 0),
(1721, 'JDK常用线程池', '1721', 1558918041, 1558918041, '<p>本文记录Java学习过程中遇到的JDK常用线程池～</p>\r<!--more-->\r\r<p>JDK预定义的线程池是工厂Executors提供的。</p>\r\r<p><strong>FixedThreadPool</strong></p>\r\r<p>创建固定线程数量的，适用于负载较重的服务器，使用了无界队列。</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\r    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);\r}</pre>\r\r<p><strong>SingleThreadExecutor</strong></p>\r\r<p>创建单个线程，需要顺序保证执行任务，不会有多个线程活动，使用了无界队列</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\r    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));\r}</pre>\r\r<p><strong>CachedThreadPool</strong></p>\r\r<p>会根据需要来创建新线程的，执行很多短期异步任务的程序，使用了无元素阻塞队列SynchronousQueue。</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\r    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);\r}</pre>\r\r<p><strong>WorkStealingPool</strong></p>\r\r<p>基于ForkJoinPool实现</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic static ExecutorService newWorkStealingPool(int parallelism) {\r    return new ForkJoinPool(parallelism, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);\r}</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch06.threadpool;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\rimport java.util.Random;\rimport java.util.concurrent.ArrayBlockingQueue;\rimport java.util.concurrent.Callable;\rimport java.util.concurrent.ExecutionException;\rimport java.util.concurrent.ExecutorService;\rimport java.util.concurrent.Future;\rimport java.util.concurrent.ThreadPoolExecutor;\rimport java.util.concurrent.TimeUnit;\r\rpublic class UseThreadPool {\r\r    // 无返回值的任务\r    static class RunWorker implements Runnable\r    {\r        private String taskName;\r        private Random r = new Random();\r\r        public RunWorker(String taskName){\r            this.taskName = taskName;\r        }\r\r        public String getName() {\r            return taskName;\r        }\r\r        @Override\r        public void run(){\r            System.out.println(Thread.currentThread().getName() + &quot; process the task : &quot; + taskName);\r            SleepTools.ms(r.nextInt(100)*5);\r        }\r    }\r\r    static class CallWorker implements Callable&lt;String&gt; {\r\r        private String taskName;\r        private Random r = new Random();\r\r        public CallWorker(String taskName){\r            this.taskName = taskName;\r        }\r\r        public String getName() {\r            return taskName;\r        }\r\r        @Override\r        public String call() throws Exception {\r            System.out.println(Thread.currentThread().getName() + &quot; process the task : &quot; + taskName);\r            return Thread.currentThread().getName()+&quot;:&quot;+r.nextInt(100)*5;\r        }\r    }\r\r    public static void main(String[] args) throws InterruptedException, ExecutionException {\r\r        ExecutorService pool;\r\r        pool = new ThreadPoolExecutor(2,4,3,TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10), new ThreadPoolExecutor.DiscardOldestPolicy());\r\r        // pool = Executors.newCachedThreadPool();\r\r        for(int i=0;i&lt;6;i++) {\r            RunWorker runWorker = new RunWorker(&quot;runWorker_&quot; + i);\r            pool.execute(runWorker);\r        }\r\r        for(int i=0;i&lt;6;i++) {\r            CallWorker callWorker = new CallWorker(&quot;callWorker_&quot; + i);\r            Future&lt;String&gt; future = pool.submit(callWorker);\r            System.out.println(future.get());\r        }\r\r        pool.shutdown();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1722, '区别.png', '区别-png', 1558919669, 1558919669, 'a:5:{s:4:"name";s:10:"区别.png";s:4:"path";s:35:"/usr/uploads/2019/05/1232129560.png";s:4:"size";i:16830;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1723, 0),
(1723, 'ScheduledThreadPoolExecutor', '1723', 1558919726, 1558919726, '<p>本文记录Java学习过程中遇到的ScheduledThreadPoolExecutor～</p>\r<!--more-->\r\r<p>需要定期执行周期任务（Timer问题太多，不建议使用）。</p>\r\r<p>两种创建方式：</p>\r\r<ul>\r	<li>newSingleThreadScheduledExecutor：只包含一个线程，适用于只需要单个线程执行周期任务，保证顺序的执行各个任务的场景；</li>\r	<li>newScheduledThreadPool：可以包含多个线程的，线程执行周期任务，适度控制后台线程数量的时候。</li>\r</ul>\r\r<p>常用方法：</p>\r\r<ul>\r	<li>schedule：只执行一次，任务还可以延时执行；</li>\r	<li>scheduleAtFixedRate：提交固定时间间隔的任务；</li>\r	<li>scheduleWithFixedDelay：提交固定延时间隔执行的任务。</li>\r</ul>\r\r<p>两者的区别：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/1232129560.png" style="width: 614px; height: 220px;" />​</p>\r\r<p>scheduleAtFixedRate任务超时：</p>\r\r<p>规定60s执行一次，有任务执行了80S，下个任务马上开始执行</p>\r\r<p>例如：第一个任务执行时长80s，第二个任务执行时长20s，第三个任务执行时长50s。</p>\r\r<p>具体执行过程如下：</p>\r\r<ul>\r	<li>第一个任务第0秒开始，第80S结束；</li>\r	<li>第二个任务第80s开始，在第100秒结束；</li>\r	<li>第三个任务第120s秒开始，170秒结束；</li>\r	<li>第四个任务从180s开始。</li>\r</ul>\r\r<p>示例代码（Worker）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch06.schedule;\r\rimport java.text.SimpleDateFormat;\rimport java.util.Date;\r\r/**\r * 定时任务类\r */\rpublic class ScheduleWorker implements Runnable {\r\r    // 普通任务类型\r    public final static int Normal = 0;\r\r    // 会抛出异常的任务类型\r    public final static int HasException = -1;\r\r    // 抛出异常但会捕捉的任务类型\r    public final static int ProcessException = 1;\r\r    private int taskType;\r\r    public static SimpleDateFormat formater = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\r\r    public ScheduleWorker(int taskType) {\r        this.taskType = taskType;\r    }\r\r    @Override\r    public void run() {\r\r        if(taskType==HasException) {\r            System.out.println(formater.format(new Date())+&quot; Exception made...&quot;);\r            throw new RuntimeException(&quot;HasException Happen&quot;);\r        }else if(taskType==ProcessException) {\r            try {\r                System.out.println(formater.format(new Date()) + &quot; Exception made,but catch&quot;);\r                throw new RuntimeException(&quot;HasException Happen&quot;);\r            }catch(Exception e) {\r                System.out.println(&quot;Exception be catched&quot;);\r            }\r        }else {\r            System.out.println(&quot;Normal: &quot; + formater.format(new Date()));\r        }\r    }\r}</pre>\r\r<p>示例代码（测试）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch06.schedule;\r\rimport java.util.concurrent.ScheduledThreadPoolExecutor;\rimport java.util.concurrent.TimeUnit;\r\r/**\r * 演示ScheduledThreadPoolExecutor的用法\r */\rpublic class App {\r\r    public static void main(String[] args) {\r\r        ScheduledThreadPoolExecutor schedule = new ScheduledThreadPoolExecutor(1);\r\r        schedule.scheduleAtFixedRate(new ScheduleWorker(ScheduleWorker.HasException), 1000, 3000, TimeUnit.MILLISECONDS);\r        schedule.scheduleAtFixedRate(new ScheduleWorker(ScheduleWorker.Normal), 1000, 3000, TimeUnit.MILLISECONDS);\r    }\r}</pre>\r\r<p>注意：建议在提交给ScheduledThreadPoolExecutor的任务要住catch异常，否则会卡住。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1724, 'Executor框架.png', 'Executor框架-png', 1558919874, 1558919874, 'a:5:{s:4:"name";s:18:"Executor框架.png";s:4:"path";s:35:"/usr/uploads/2019/05/4119863811.png";s:4:"size";i:362546;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1726, 0),
(1725, 'Executor框架基本使用流程.png', 'Executor框架基本使用流程-png', 1558919875, 1558919875, 'a:5:{s:4:"name";s:36:"Executor框架基本使用流程.png";s:4:"path";s:34:"/usr/uploads/2019/05/441895910.png";s:4:"size";i:195088;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1726, 1),
(1726, 'Executor框架', '1726', 1558919902, 1558919902, '<p>本文记录Java学习过程中遇到的Executor框架～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/4119863811.png" style="width: 800px; height: 579px;" /></p>\r\r<p>Executor框架基本使用流程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/05/441895910.png" style="width: 800px; height: 597px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1727, 'CompletionService', '1727', 1559443085, 1559443085, '<p>本文记录Java学习过程中遇到的CompletionService～</p>\r<!--more-->\r\r<p>CompletionService用来从线程池中拿线程的执行结果，它可以保证先执行完的任务的结果先拿到。</p>\r\r<p>示例代码（任务类）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch06.completionservice;\r\rimport java.util.Random;\rimport java.util.concurrent.Callable;\r\rpublic class WorkTask implements Callable&lt;Integer&gt; {\r\r    private String name;\r\r    public WorkTask(String name) {\r\r        this.name = name;\r    }\r\r    @Override\r    public Integer call() {\r\r        int sleepTime = new Random().nextInt(1000);\r\r        try {\r            Thread.sleep(sleepTime);\r        } catch (InterruptedException e) {\r            e.printStackTrace();\r        }\r\r        // 返回给调用者的值\r        return sleepTime;\r    }\r}</pre>\r\r<p>示例代码（手工实现拿返回结果）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch06.completionservice;\r\rimport java.util.concurrent.BlockingQueue;\rimport java.util.concurrent.ExecutorService;\rimport java.util.concurrent.Executors;\rimport java.util.concurrent.Future;\rimport java.util.concurrent.LinkedBlockingQueue;\rimport java.util.concurrent.atomic.AtomicInteger;\r\rpublic class MyCompletion {\r\r    private static final int POOL_SIZE = Runtime.getRuntime().availableProcessors();\r    private static final int TOTAL_TASK = Runtime.getRuntime().availableProcessors() * 10;\r\r    public static void main(String[] args) throws Exception {\r\r        // 开始时间\r        long start = System.currentTimeMillis();\r\r        // 统计所有任务休眠的总时长\r        AtomicInteger count = new AtomicInteger(0);\r\r        // 创建线程池\r        ExecutorService pool = Executors.newFixedThreadPool(POOL_SIZE);\r\r        // 容器存放提交给线程池的任务 list,map,\r        BlockingQueue&lt;Future&lt;Integer&gt;&gt; queue = new LinkedBlockingQueue&lt;Future&lt;Integer&gt;&gt;();\r\r        // 向里面扔任务\r        for (int i = 0; i &lt; TOTAL_TASK; i++) {\r            Future&lt;Integer&gt; future = pool.submit(new WorkTask(&quot;ExecTask&quot; + i));\r            // i=0 先进队列，i=1的任务跟着进\r            queue.add(future);\r        }\r\r        // 检查线程池任务执行结果\r        for (int i = 0; i &lt; TOTAL_TASK; i++) {\r            // i=0先取到，i=1的后取到\r            int sleptTime = queue.take().get();\r            System.out.println(&quot; slept &quot;+sleptTime+&quot; ms ...&quot;);\r            count.addAndGet(sleptTime);\r        }\r\r        // 关闭线程池\r        pool.shutdown();\r        Long end = System.currentTimeMillis();\r        System.out.println(&quot;those tasks sleep time &quot; + count.get() + &quot;ms,and spend time &quot; + (end-start) + &quot; ms&quot;);\r    }\r}</pre>\r\r<p>示例代码（使用CompletionService）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch06.completionservice;\r\rimport java.util.concurrent.CompletionService;\rimport java.util.concurrent.ExecutorCompletionService;\rimport java.util.concurrent.ExecutorService;\rimport java.util.concurrent.Executors;\rimport java.util.concurrent.atomic.AtomicInteger;\r\rpublic class UseCompletionService {\r\r    private static final int POOL_SIZE = Runtime.getRuntime().availableProcessors();\r    private static final int TOTAL_TASK = Runtime.getRuntime().availableProcessors() * 10;\r\r    public static void main(String[] args) throws Exception {\r\r        // 开始时间\r        long start = System.currentTimeMillis();\r\r        // 统计所有任务休眠的总时长\r        AtomicInteger count = new AtomicInteger(0);\r\r        // 创建线程池\r        ExecutorService pool = Executors.newFixedThreadPool(POOL_SIZE);\r        CompletionService&lt;Integer&gt; completionService = new ExecutorCompletionService&lt;&gt;(pool);\r\r        // 向里面扔任务\r        for (int i = 0; i &lt; TOTAL_TASK; i++) {\r            completionService.submit(new WorkTask(&quot;ExecTask&quot; + i));\r        }\r\r        // 检查线程池任务执行结果\r        for (int i = 0; i &lt; TOTAL_TASK; i++) {\r            int sleptTime = completionService.take().get();\r            System.out.println(&quot; slept &quot;+sleptTime+&quot; ms ...&quot;);\r            count.addAndGet(sleptTime);\r        }\r\r        // 关闭线程池\r        pool.shutdown();\r\r        long end = System.currentTimeMillis();\r        System.out.println(&quot;those tasks sleep time &quot; + count.get() + &quot;ms,and spend time &quot; + (end-start) + &quot; ms&quot;);\r    }\r}</pre>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rprivate final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;\r\r// 继承FutureTask\rprivate class QueueingFuture extends FutureTask&lt;Void&gt; {\r    QueueingFuture(RunnableFuture&lt;V&gt; task) {\r        super(task, null);\r        this.task = task;\r    }\r    // 覆盖done方法，将完成的任务加到completionQueue\r    protected void done() { completionQueue.add(task); }\r    private final Future&lt;V&gt; task;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1728, '线程安全', '1728', 1559444640, 1559464212, '<p>本文记录Java学习过程中遇到的线程安全～</p>\r<!--more-->\r\r<p>线程安全定义：如果多线程下使用这个类，不过多线程如何使用和调度这个类，这个类总是表示出正确的行为，这个类就是线程安全的。</p>\r\r<p>类的线程安全表现为：</p>\r\r<ul>\r	<li>操作的原子性；</li>\r	<li>内存的可见性。</li>\r</ul>\r\r<p>不做正确的同步，在多个线程之间共享状态的时候，就会出现线程不安全。</p>\r\r<p>线程安全的实现方式</p>\r\r<p>栈封闭：所有的变量都是在方法内部声明的，这些变量都处于栈封闭状态。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic void method() {\r	List&lt;String&gt; stringList = new ArrayList&lt;&gt;();\r	for(String string : stringList) {\r		System.out.println(string);\r	}\r}</pre>\r\r<p>无状态：没有任何成员变量的类，就叫无状态的类。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class StatelessClass {\r	public int service(int a,int b) {\r		return a*b;\r	}\r}</pre>\r\r<p>让类不可变：让状态不可变，两种方式：1、加final关键字，对于一个类，所有的成员变量应该是私有的，同样的只要有可能，所有的成员变量应该加上final关键字，但是加上final，要注意如果成员变量又是一个对象时，这个对象所对应的类也要是不可变，才能保证整个类是不可变的；2、根本就不提供任何可供修改成员变量的地方，同时成员变量也不作为方法的返回值。</p>\r\r<p>示例代码（不可变的类）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.safeclass;\r\r/**\r * 不可变的类\r */\rpublic class ImmutableFinal {\r\r    private final int a;\r    private final int b;\r\r    public ImmutableFinal(int a, int b) {\r\r        super();\r        this.a = a;\r        this.b = b;\r    }\r\r    public int getA() {\r\r        return a;\r    }\r\r    public int getB() {\r\r        return b;\r    }\r}</pre>\r\r<p>示例代码（带引用变量的不可变的类）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.safeclass;\r\r/**\r * 带引用变量的不可变的类\r */\rpublic class ImmutableFinalRef {\r\r    public static class User {\r        private final int age;\r\r        public User(int age) {\r            super();\r            this.age = age;\r        }\r\r        public int getAge() {\r            return age;\r        }\r    }\r\r    private final int a;\r    private final int b;\r    private final User user;\r\r    public ImmutableFinalRef(int a, int b) {\r\r        super();\r        this.a = a;\r        this.b = b;\r        this.user = new User(18);\r    }\r\r    public int getA() {\r\r        return a;\r    }\r\r    public int getB() {\r\r        return b;\r    }\r\r    public User getUser() {\r\r        return user;\r    }\r}</pre>\r\r<p>示例代码（不提供对变量的访问方法）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.safeclass;\r\rimport java.util.ArrayList;\rimport java.util.List;\r\r/**\r * 不提供对变量的访问方法\r */\rpublic class ImmutetableToo {\r\r    private List&lt;Integer&gt; list =  new ArrayList&lt;&gt;(3);\r\r    public ImmutetableToo() {\r\r        list.add(1);\r        list.add(2);\r        list.add(3);\r    }\r\r    public boolean isContains(int i) {\r\r        return list.contains(i);\r    }\r}</pre>\r\r<p>volatile关键字：保证类的可见性，最适合一个线程写，多个线程读的情景。</p>\r\r<p>示例代码（ConcurrentHashMap中的Node中的value属性）：</p>\r\r<pre class="brush:java;">\rstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\r    final int hash;\r    final K key;\r    volatile V val;\r    volatile Node&lt;K,V&gt; next;\r\r    Node(int hash, K key, V val, Node&lt;K,V&gt; next) {\r        this.hash = hash;\r        this.key = key;\r        this.val = val;\r        this.next = next;\r    }\r\r    public final K getKey()       { return key; }\r    public final V getValue()     { return val; }\r    public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }\r    public final String toString(){ return key + &quot;=&quot; + val; }\r    public final V setValue(V value) {\r        throw new UnsupportedOperationException();\r    }\r\r    public final boolean equals(Object o) {\r        Object k, v, u; Map.Entry&lt;?,?&gt; e;\r        return ((o instanceof Map.Entry) &amp;&amp;\r                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp;\r                (v = e.getValue()) != null &amp;&amp;\r                (k == key || k.equals(key)) &amp;&amp;\r                (v == (u = val) || v.equals(u)));\r    }\r\r    /**\r     * Virtualized support for map.get(); overridden in subclasses.\r     */\r    Node&lt;K,V&gt; find(int h, Object k) {\r        Node&lt;K,V&gt; e = this;\r        if (k != null) {\r            do {\r                K ek;\r                if (e.hash == h &amp;&amp;\r                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))\r                    return e;\r            } while ((e = e.next) != null);\r        }\r        return null;\r    }\r}</pre>\r\r<p>加锁和CAS：对不安全的变量加锁，或者使用原子操作。</p>\r\r<p>安全的发布：类中持有的成员变量，特别是对象的引用，如果这个成员对象不是线程安全的，通过get等方法发布出去，会造成这个成员对象本身持有的数据在多线程下不正确的修改，从而造成整个类线程不安全的问题。这时候，要么用线程的容器替换；要么发布出去的时候，提供副本，深度拷贝。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.safeclass;\r\rimport java.util.ArrayList;\rimport java.util.List;\r\r/**\r * 不安全的发布\r */\rpublic class UnsafePublish {\r\r    // 要么用线程的容器替换；要么发布出去的时候，提供副本，深度拷贝\r    private List&lt;Integer&gt; list =  new ArrayList&lt;&gt;(3);\r\r    public UnsafePublish() {\r        list.add(1);\r        list.add(2);\r        list.add(3);\r    }\r\r    // 将list不安全的发布出去\r    public List&lt;Integer&gt; getList() {\r        return list;\r    }\r\r    // 是安全的,加了锁\r    public synchronized int getList(int index) {\r        return list.get(index);\r    }\r\r    // 是安全的,加了锁\r    public synchronized void set(int index, int val) {\r        list.set(index,val);\r    }\r}</pre>\r\r<p>TheadLocal：将数据和线程绑定。</p>\r\r<p>注意：Servlet不是线程安全的类，没有感觉到不安全的原因：1、在需求上，很少有共享的需求；2、接收到了请求，返回应答的时候，都是由一个线程来负责的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 8),
(1729, '死锁', '1729', 1559468160, 1559471153, '<p>本文记录Java学习过程中遇到的死锁～</p>\r<!--more-->\r\r<p>死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>\r\r<p>注意：资源一定是多于1个，同时小于等于竞争的线程数；如果资源只有一个，只会产生激烈的竞争，而不会死锁。</p>\r\r<p>死锁的根本成因：获取锁的顺序不一致。</p>\r\r<p>示例代码（正常死锁）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.deadlock;\r\rimport ren.oliver.concurrent.tools.SleepTools;\r\r/**\r * 常见的死锁和解决\r */\rpublic class NormalDeadLock {\r\r    // 第一个锁\r    private static Object valueFirst = new Object();\r\r    // 第二个锁\r    private static Object valueSecond = new Object();\r\r    // 先拿第一个锁，再拿第二个锁\r    private static void fisrtToSecond() throws InterruptedException {\r        String threadName = Thread.currentThread().getName();\r        synchronized (valueFirst) {\r            System.out.println(threadName + &quot; get first&quot;);\r            SleepTools.ms(100);\r            synchronized (valueSecond) {\r                System.out.println(threadName + &quot; get second&quot;);\r            }\r        }\r    }\r\r    // 先拿第二个锁，再拿第一个锁\r    private static void SecondToFisrt() throws InterruptedException {\r        String threadName = Thread.currentThread().getName();\r        synchronized (valueSecond) {\r            System.out.println(threadName + &quot; get second&quot;);\r            SleepTools.ms(100);\r            synchronized (valueFirst) {\r                System.out.println(threadName + &quot; get first&quot;);\r            }\r        }\r    }\r\r    // 执行先拿第二个锁，再拿第一个锁\r    private static class TestThread extends Thread{\r\r        private String name;\r\r        public TestThread(String name) {\r            this.name = name;\r        }\r\r        public void run(){\r            Thread.currentThread().setName(name);\r            try {\r                SecondToFisrt();\r            } catch (InterruptedException e) {\r                e.printStackTrace();\r            }\r        }\r    }\r\r    public static void main(String[] args) {\r        Thread.currentThread().setName(&quot;TestDeadLock&quot;);\r        TestThread testThread = new TestThread(&quot;SubTestThread&quot;);\r        testThread.start();\r        try {\r            // 先拿第一个锁，再拿第二个锁\r            fisrtToSecond();\r        } catch (InterruptedException e) {\r            e.printStackTrace();\r        }\r    }\r}</pre>\r\r<p>如何检测死锁：</p>\r\r<ol>\r	<li>通过jps查询应用的pid；</li>\r	<li>通过jstack pid查看应用的锁的持有情况。</li>\r</ol>\r\r<p>死锁的解决方案：保证获取锁的循序一致。</p>\r\r<p>动态死锁案例&mdash;&mdash;用户转账</p>\r\r<p>示例代码（账户实体类）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.deadlock.transfer.domain;\r\rimport java.util.concurrent.locks.Lock;\rimport java.util.concurrent.locks.ReentrantLock;\r\rpublic class UserAccount {\r\r    // private int id;\r\r    // 账户名称\r    private final String name;\r\r    // 账户余额\r    private int money;\r\r    // 显示锁\r    private final Lock lock = new ReentrantLock();\r\r    public Lock getLock() {\r        return lock;\r    }\r\r    public UserAccount(String name, int amount) {\r        this.name = name;\r        this.money = amount;\r    }\r\r    public String getName() {\r        return name;\r    }\r\r    public int getAmount() {\r        return money;\r    }\r\r    @Override\r    public String toString() {\r        return &quot;UserAccount{name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, money=&quot; + money + &#39;}&#39;;\r    }\r\r    // 转入资金\r    public void addMoney(int amount){\r        money = money + amount;\r    }\r\r    // 转出资金\r    public void flyMoney(int amount){\r        money = money - amount;\r    }\r}</pre>\r\r<p>示例代码（转账服务接口）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.deadlock.transfer.service;\r\rimport ren.oliver.concurrent.ch07.deadlock.transfer.domain.UserAccount;\r\rpublic interface TransferService {\r\r    /**\r     * @param from 转出账户\r     * @param to 转入账户\r     * @param amount 转账金额\r     * @throws InterruptedException\r     */\r    void transfer(UserAccount from, UserAccount to, int amount) throws InterruptedException;\r}</pre>\r\r<p>示例代码（转账服务简单实现-会发生死锁）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.deadlock.transfer.service.impl;\r\rimport ren.oliver.concurrent.ch07.deadlock.transfer.domain.UserAccount;\rimport ren.oliver.concurrent.ch07.deadlock.transfer.service.TransferService;\r\rpublic class TrasnferAccount implements TransferService {\r\r    @Override\r    public void transfer(UserAccount from, UserAccount to, int amount) throws InterruptedException {\r        // 先锁转出\r        synchronized (from){\r            System.out.println(Thread.currentThread().getName() + &quot; get&quot;+from.getName());\r            Thread.sleep(100);\r            // 再锁转入\r            synchronized (to){\r                System.out.println(Thread.currentThread().getName() + &quot; get&quot;+to.getName());\r                from.flyMoney(amount);\r                to.addMoney(amount);\r            }\r        }\r    }\r}</pre>\r\r<p>示例代码（通过hash值确定锁的先后顺序）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.deadlock.transfer.service.impl;\r\rimport ren.oliver.concurrent.ch07.deadlock.transfer.domain.UserAccount;\rimport ren.oliver.concurrent.ch07.deadlock.transfer.service.TransferService;\r\r/**\r * 通过hash值确定拿锁的先后顺序\r */\rpublic class SafeOperate implements TransferService {\r\r    // 加时赛锁\r    private static Object tieLock = new Object();\r\r    @Override\r    public void transfer(UserAccount from, UserAccount to, int amount) throws InterruptedException {\r\r        int fromHash = System.identityHashCode(from);\r        int toHash = System.identityHashCode(to);\r\r        // 先锁hash小的那个\r        if(fromHash &lt; toHash) {\r            synchronized (from){\r                System.out.println(Thread.currentThread().getName() + &quot; get&quot; + from.getName());\r                Thread.sleep(100);\r                synchronized (to){\r                    System.out.println(Thread.currentThread().getName() + &quot; get&quot; + to.getName());\r                    from.flyMoney(amount);\r                    to.addMoney(amount);\r                }\r            }\r        }else if(toHash&lt;fromHash) {\r            synchronized (to){\r                System.out.println(Thread.currentThread().getName() + &quot; get&quot; + to.getName());\r                Thread.sleep(100);\r                synchronized (from){\r                    System.out.println(Thread.currentThread().getName() + &quot; get&quot; + from.getName());\r                    from.flyMoney(amount);\r                    to.addMoney(amount);\r                }\r            }\r        }else {\r            // 解决hash冲突的方法\r            synchronized (tieLock) {\r                synchronized (from) {\r                    synchronized (to) {\r                        from.flyMoney(amount);\r                        to.addMoney(amount);\r                    }\r                }\r            }\r        }\r    }\r}</pre>\r\r<p>示例代码（使用显式锁，同时避免活锁）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.deadlock.transfer.service.impl;\r\rimport ren.oliver.concurrent.ch07.deadlock.transfer.domain.UserAccount;\rimport ren.oliver.concurrent.ch07.deadlock.transfer.service.TransferService;\rimport ren.oliver.concurrent.tools.SleepTools;\r\rimport java.util.Random;\r\r/**\r * 使用显式锁\r */\rpublic class SafeOperateToo implements TransferService {\r\r    @Override\r    public void transfer(UserAccount from, UserAccount to, int amount) throws InterruptedException {\r\r        Random r = new Random();\r        while(true) {\r            if(from.getLock().tryLock()) {\r                try {\r                    System.out.println(Thread.currentThread().getName() + &quot; get &quot; + from.getName());\r                    if(to.getLock().tryLock()) {\r                        try {\r                            System.out.println(Thread.currentThread().getName() + &quot; get &quot; + to.getName());\r                            // 两把锁都拿到了\r                            from.flyMoney(amount);\r                            to.addMoney(amount);\r                            break;\r                        }finally {\r                            to.getLock().unlock();\r                        }\r                    }\r                }finally {\r                    from.getLock().unlock();\r                }\r            }\r            // 避免活锁\r            SleepTools.ms(r.nextInt(10));\r        }\r    }\r}</pre>\r\r<p>示例代码（主测试程序）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.deadlock.transfer.app;\r\rimport ren.oliver.concurrent.ch07.deadlock.transfer.domain.UserAccount;\rimport ren.oliver.concurrent.ch07.deadlock.transfer.service.TransferService;\rimport ren.oliver.concurrent.ch07.deadlock.transfer.service.impl.SafeOperateToo;\r\r/**\r * 模拟支付公司转账的动作\r */\rpublic class App {\r\r    // 执行转账动作的线程\r    private static class TransferThread extends Thread{\r\r        // 线程名字\r        private String name;\r\r        private UserAccount from;\r        private UserAccount to;\r        private int amount;\r\r        // 实际的转账动作\r        private TransferService transfer;\r\r        public TransferThread(String name, UserAccount from, UserAccount to, int amount, TransferService transfer) {\r            this.name = name;\r            this.from = from;\r            this.to = to;\r            this.amount = amount;\r            this.transfer = transfer;\r        }\r\r        @Override\r        public void run(){\r            Thread.currentThread().setName(name);\r            try {\r                transfer.transfer(from,to,amount);\r            } catch (InterruptedException e) {\r                e.printStackTrace();\r            }\r        }\r    }\r\r    public static void main(String[] args) {\r\r        UserAccount zhangsan = new UserAccount(&quot;zhangsan&quot;,20000);\r        UserAccount lisi = new UserAccount(&quot;lisi&quot;,20000);\r        TransferService transfer;\r        // transfer = new TrasnferAccount();\r        // transfer = new SafeOperate();\r        transfer = new SafeOperateToo();\r        TransferThread zhangsanToLisi = new TransferThread(&quot;zhangsanToLisi&quot;, zhangsan, lisi,2000, transfer);\r        TransferThread lisiToZhangsan = new TransferThread(&quot;lisiToZhangsan&quot;, lisi, zhangsan,4000, transfer);\r        zhangsanToLisi.start();\r        lisiToZhangsan.start();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1730, '线程饥饿', '1730', 1559472240, 1559472507, '<p>本文记录Java学习过程中遇到的线程饥饿～</p>\r<!--more-->\r\r<p>线程饥饿，就是一个线程（低优先级）一直拿不到时间片，一直得不到执行。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1731, 'Amdahl定律.png', 'Amdahl定律-png', 1559475992, 1559475992, 'a:5:{s:4:"name";s:16:"Amdahl定律.png";s:4:"path";s:35:"/usr/uploads/2019/06/2181998898.png";s:4:"size";i:774;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1732, 1),
(1732, '并发编程的性能和思考', '1732', 1559476117, 1559476117, '<p>本文记录Java学习过程中遇到的并发编程的性能和思考～</p>\r<!--more-->\r\r<p>使用并发编程的目标是为了提高性能，但引入多线程后也引入了额外的开销。</p>\r\r<p>常见的衡量应用程序的性能的指标：</p>\r\r<ul>\r	<li>服务时间；</li>\r	<li>延迟时间；</li>\r	<li>吞吐量；</li>\r	<li>可伸缩性；</li>\r	<li>服务时间；</li>\r	<li>延迟时间（多快）；</li>\r	<li>吞吐量（处理能力的指标，完成工作的多少）。</li>\r</ul>\r\r<p>注意：多快和多少是完全独立的，甚至是相互矛盾的。</p>\r\r<p>对于服务端应用来说，多少（可伸缩性和吞吐量）一般比多快更重要。</p>\r\r<p>做应用的原则：</p>\r\r<ul>\r	<li>先保证程序正确，确实达不到性能要求的时候，再考虑提升速度（黄金原则）；</li>\r	<li>一定要以真实的测试数据为支撑来决定如何做性能改善。</li>\r</ul>\r\r<p>注意：一个应用程序中，穿行的部分是永远都有的。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/2181998898.png" style="width: 116px; height: 48px;" /></p>\r\r<p>Amdahl定律：如果F是必须串行化执行的比重，那么Amdahl定律告诉我们，在一个N 处理器的机器中，我们最多可以加速speedup。当N无限增大趋近无穷时，speedup的最大值无限趋近1/F，这意味着一个程序中如果50%的处理都需要串行进行的话，speedup只能提升2倍（不考虑事实上有多少线程可用）；如果程序的10%需要串行进行，speedup最多能够提高近10倍。Amdahl定律同样量化了串行化的效率开销。在拥有10个处理器的系统中，程序如果有10%是串行化的，那么最多可以加速5.3倍（53％的使用率），在拥有100个处理器的系统中，这个数字可以达到9.2（9％的使用率）。这使得无效的CPU利用永远不可能到达10倍。</p>\r\r<p>影响性能的因素：</p>\r\r<ul>\r	<li>上下文切换：一次上下文切换要耗费5000-10000个时钟周期，几微秒的样子；</li>\r	<li>内存同步：加锁，在同步的时候需要JVM在指令之前插入些特殊的指令（内存屏障），也会耗费时间；</li>\r	<li>线程阻塞：挂起的时候，会产生两次额外的上下文切换以及缓存操作等的时间。</li>\r</ul>\r\r<p><strong>如何减少锁的竞争</strong></p>\r\r<ul>\r	<li>缩小锁的范围：对锁的持有，快进快出，尽量缩短持有锁的时间；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.performance;\r\rimport java.util.HashMap;\rimport java.util.Map;\rimport java.util.regex.Pattern;\r\r/**\r * 缩小锁的范围\r */\rpublic class ReduceLock {\r\r    private Map&lt;String,String&gt; matchMap = new HashMap&lt;&gt;();\r\r    // 锁整个方法，锁的范围过大\r    public synchronized boolean isMatch(String name,String regexp) {\r\r        String key = &quot;user.&quot;+name;\r        String job = matchMap.get(key);\r        if(job == null) {\r            return false;\r        }else {\r            // 很耗费时间\r            return Pattern.matches(regexp, job);\r        }\r    }\r\r    public  boolean isMatchReduce(String name,String regexp) {\r\r        String key = &quot;user.&quot;+name;\r        String job ;\r\r        // 将锁的范围减小\r        synchronized(this) {\r            job = matchMap.get(key);\r        }\r\r        if(job == null) {\r            return false;\r        }else {\r            // 很耗费时间\r            return Pattern.matches(regexp, job);\r        }\r    }\r}</pre>\r\r<p>注意：要避免多余的缩减锁的范围，太小的锁不如直接合并，减少JVM插入额外指令的时间（JVM内部有锁粗化来减少锁的个数）。</p>\r\r<p>示例代码（错误）：</p>\r\r<pre class="brush:java;">\rsynchronized(this) {\r    job = matchMap.get(key);\r}\rjob += &quot;s&quot;;\rsynchronized(this) {\r    job = matchMap.get(key);\r}</pre>\r\r<p>示例代码（正确）：</p>\r\r<pre class="brush:java;">\rsynchronized(this) {\r    job = matchMap.get(key);\r    job += &quot;s&quot;;\r    job = matchMap.get(key);\r}</pre>\r\r<ul>\r	<li>减少锁的粒度：使用锁的时候，锁所保护的对象是多个，但这多个对象其实是独立变化的，这时候不如用多个锁来一一保护这些对象；</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.performance;\r\rimport java.util.HashSet;\rimport java.util.Set;\r\r/**\r * 减少锁的粒度\r */\rpublic class FinenessLock {\r\r    public final Set&lt;String&gt; users = new HashSet&lt;String&gt;();\r    public final Set&lt;String&gt; queries = new HashSet&lt;String&gt;();\r\r    public synchronized void addUser(String u) {\r        users.add(u);\r    }\r\r    public void addUserLess(String u) {\r        synchronized (users) {\r            users.add(u);\r        }\r    }\r\r    public synchronized void addQuery(String q) {\r            queries.add(q);\r    }\r\r    public void addQueryLess(String q) {\r        synchronized (users) {\r            queries.add(q);\r        }\r    }\r}</pre>\r\r<ul>\r	<li>锁分段：ConcurrentHashMap就是用的分段锁；</li>\r	<li>替换独占锁：1、使用读写锁；2、使用自旋CAS；3、使用系统的并发容器。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1733, '线程安全的单例模式', '1733', 1559478393, 1559478393, '<p>本文记录Java学习过程中遇到的线程安全的单例模式～</p>\r<!--more-->\r\r<p>双重检查锁定</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.doublecheckedlock;\r\r/**\r * 基于双重检查的单例模式\r */\rpublic class SingleDcl {\r\r    private static SingleDcl singleDcl;\r\r    private SingleDcl(){\r    }\r\r    public static SingleDcl getInstance(){\r        if(singleDcl==null) {\r            // 类锁\r            synchronized (SingleDcl.class) {\r                if(singleDcl==null) {\r                    singleDcl = new SingleDcl();\r                }\r            }\r        }\r        return singleDcl;\r    }\r}</pre>\r\r<p>这样看似是没有问题，但如果这个单例对象内容较大，就可能初始化太慢导致初始化不完就返回了，从而导致使用的时候的空指针；这个问题可以通过volatile关键字来解决。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.doublecheckedlock;\r\r/**\r * 基于双重检查的单例模式\r */\rpublic class SingleDcl {\r\r    private volatile static SingleDcl singleDcl;\r\r    private SingleDcl(){\r    }\r\r    public static SingleDcl getInstance(){\r        if(singleDcl==null) {\r            // 类锁\r            synchronized (SingleDcl.class) {\r                if(singleDcl==null) {\r                    singleDcl = new SingleDcl();\r                }\r            }\r        }\r        return singleDcl;\r    }\r}</pre>\r\r<p><strong>饿汉式</strong></p>\r\r<p>JVM对类的加载，由虚拟机保证。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.single;\r\r/**\r * 饿汉式单例模式\r */\rpublic class SingleEHan {\r\r    public static SingleEHan singleEHan = new SingleEHan();\r    \r    private SingleEHan(){}\r}</pre>\r\r<p><strong>懒汉式</strong></p>\r\r<p>示例代码（单例较复杂，类初始化模式/延迟占位模式）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.single;\r\r/**\r * 类初始化模式\r */\rpublic class SingleInit {\r\r    private SingleInit(){\r\r    }\r\r    // 定义一个私有类，来持有当前类的实例，内部类只有在用的时候才会被初始化\r    private static class InstanceHolder{\r        public static SingleInit instance = new SingleInit();\r    }\r\r    public static SingleInit getInstance(){\r        return InstanceHolder.instance;\r    }\r}</pre>\r\r<p>示例代码（内部的值占用的内存太大）：</p>\r\r<pre class="brush:java;">\rpackage ren.oliver.concurrent.ch07.single;\r\rpublic class InstanceLazy {\r\r    private Integer value;\r    \r    //可能很大，如巨型数组1000000\r    private Integer val ;\r\r    public InstanceLazy(Integer value) {\r        super();\r        this.value = value;\r    }\r\r    public Integer getValue() {\r        return value;\r    }\r\r    private static class ValHolder {\r        public static Integer vHolder = new Integer(1000000);\r    }\r\r    public Integer getVal() {\r        return ValHolder.vHolder;\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1734, '线程之间的通信和同步', '1734', 1561344938, 1561344938, '<p>本文记录Java学习过程中遇到的线程之间的通信和同步～</p>\r<!--more-->\r\r<p><strong>线程之间的通信</strong></p>\r\r<p>线程的通信是指线程之间以何种机制来交换信息。</p>\r\r<p>在编程中，线程之间的通信机制有两种，共享内存和消息传递：</p>\r\r<ul>\r	<li>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信；</li>\r	<li>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在Java中典型的消息传递方式就是wait()和notify()。</li>\r</ul>\r\r<p><strong>线程之间的同步</strong></p>\r\r<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。</p>\r\r<ul>\r	<li>在共享内存并发模型里，同步是显式进行的，程序员必须显式地指定某个方法或某段代码需要在线程之间互斥执行；</li>\r	<li>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</li>\r</ul>\r\r<p>注意：Java的并发采用的是共享内存模型。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1735, '物理内存性能测试.png', '物理内存性能测试-png', 1561349033, 1561349033, 'a:5:{s:4:"name";s:28:"物理内存性能测试.png";s:4:"path";s:35:"/usr/uploads/2019/06/4265822925.png";s:4:"size";i:529221;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1739, 0),
(1736, '处理器、高速缓存、主内存间的交互关系.png', '处理器-高速缓存-主内存间的交互关系-png', 1561349066, 1561349066, 'a:5:{s:4:"name";s:58:"处理器、高速缓存、主内存间的交互关系.png";s:4:"path";s:35:"/usr/uploads/2019/06/3544273441.png";s:4:"size";i:240531;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1739, 0),
(1737, '现代计算机物理上的内存模型带来的问题01.png', '现代计算机物理上的内存模型带来的问题01-png', 1561349101, 1561349101, 'a:5:{s:4:"name";s:60:"现代计算机物理上的内存模型带来的问题01.png";s:4:"path";s:35:"/usr/uploads/2019/06/1723853702.png";s:4:"size";i:75716;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1739, 0),
(1738, '现代计算机物理上的内存模型带来的问题02.png', '现代计算机物理上的内存模型带来的问题02-png', 1561349101, 1561349101, 'a:5:{s:4:"name";s:60:"现代计算机物理上的内存模型带来的问题02.png";s:4:"path";s:34:"/usr/uploads/2019/06/606834542.png";s:4:"size";i:162687;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1739, 0),
(1739, '现代计算机物理内存模型', '1739', 1561349125, 1561349125, '<p>本文记录Java学习过程中遇到的现代计算机物理内存模型～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/4265822925.png" style="width: 800px; height: 796px;" />​</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/3544273441.png" style="width: 800px; height: 485px;" /></p>\r\r<p>JMM遇到的问题与现代计算机中遇到的问题是类似的。</p>\r\r<p>物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p>\r\r<p>其中一个重要的复杂性来源是绝大多数的运算任务都不可能只靠处理器&ldquo;计算&rdquo;就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。早期计算机中CPU和内存的速度是差不多的，但在现代计算机中，CPU的指令速度远超内存的存取速度，由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>\r\r<p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，举例说明变量在多个CPU之间的共享。如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p>\r\r<p>现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/1723853702.png" style="width: 800px; height: 258px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/606834542.png" style="width: 800px; height: 596px;" />​</p>\r\r<p>处理器A和处理器B按程序的顺序并行执行内存访问，最终可能得到x=y=0的结果。</p>\r\r<p>处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1、B1），然后从内存中读取另一个共享变量（A2、B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3、B3）。当以这种时序执行时，程序就可以得到x=y=0的结果。</p>\r\r<p>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1&rarr;A2，但内存操作实际发生的顺序却是A2&rarr;A1。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1740, 'JMM01.png', 'JMM01-png', 1561360321, 1561360321, 'a:5:{s:4:"name";s:9:"JMM01.png";s:4:"path";s:35:"/usr/uploads/2019/06/3790879323.png";s:4:"size";i:215016;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1742, 0),
(1741, 'JMM02.png', 'JMM02-png', 1561360321, 1561360321, 'a:5:{s:4:"name";s:9:"JMM02.png";s:4:"path";s:34:"/usr/uploads/2019/06/163354330.png";s:4:"size";i:55406;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1742, 0),
(1742, 'Java内存模型（JMM）', '1742', 1561360361, 1561360361, '<p>本文记录Java学习过程中遇到的Java内存模型（JMM）～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/3790879323.png" style="width: 800px; height: 347px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/163354330.png" style="width: 758px; height: 575px;" /></p>\r\r<p>Java内存模型，即Java Memory Model，简称JMM。</p>\r\r<p>JMM定义了Java虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。</p>\r\r<p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1743, '线程栈区和堆区.png', '线程栈区和堆区-png', 1561371164, 1561371164, 'a:5:{s:4:"name";s:25:"线程栈区和堆区.png";s:4:"path";s:35:"/usr/uploads/2019/06/4078150973.png";s:4:"size";i:41796;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1746, 0),
(1744, '线程栈区.png', '线程栈区-png', 1561371183, 1561371183, 'a:5:{s:4:"name";s:16:"线程栈区.png";s:4:"path";s:35:"/usr/uploads/2019/06/4285123891.png";s:4:"size";i:108695;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1746, 0),
(1745, '堆区.png', '堆区-png', 1561371202, 1561371202, 'a:5:{s:4:"name";s:10:"堆区.png";s:4:"path";s:34:"/usr/uploads/2019/06/393632330.png";s:4:"size";i:126328;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1746, 0),
(1746, 'JVM对Java内存模型的实现', '1746', 1561371213, 1561371213, '<p>本文记录Java学习过程中遇到的JVM对Java内存模型的实现～</p>\r<!--more-->\r\r<p>在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/4078150973.png" style="width: 800px; height: 619px;" /></p>\r\r<p>JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/4285123891.png" style="width: 758px; height: 679px;" /></p>\r\r<p>所有原始类型(boolean,byte,short,char,int,long,float,double)的局部变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的局部变量，一个线程可以传递一个副本给另一个线程，但它们之间是无法共享的。</p>\r\r<p>线程栈还包含了当前方法的所有局部变量信息。一个线程只能读取自己的线程栈，也就是说，线程中的本地变量对其它线程是不可见的。即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈中创建局部变量，因此，每个线程中的局部变量都会有自己的版本。</p>\r\r<p>堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的局部变量，它都会被存储在堆区。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/393632330.png" style="width: 745px; height: 604px;" />​</p>\r\r<p>一个局部变量如果是原始类型，那么它会被完全存储到栈区。 一个局部变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</p>\r\r<p>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于局部变量，每个线程都会拷贝一份到自己的线程栈中。</p>\r\r<p>对于一个对象的成员方法，这些方法中包含局部变量，仍需要存储在栈区，即使它们所属的对象在堆区。对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。static类型的变量以及类本身相关信息都会随着类本身存储在堆区。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1747, '可见性问题.png', '可见性问题-png', 1561381666, 1561381666, 'a:5:{s:4:"name";s:19:"可见性问题.png";s:4:"path";s:34:"/usr/uploads/2019/06/809275481.png";s:4:"size";i:88516;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1749, 0),
(1748, '竞争问题.png', '竞争问题-png', 1561381685, 1561381685, 'a:5:{s:4:"name";s:16:"竞争问题.png";s:4:"path";s:35:"/usr/uploads/2019/06/2063882951.png";s:4:"size";i:82165;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1749, 0),
(1749, 'Java内存模型带来的问题', '1749', 1561381680, 1561381753, '<p>本文记录Java学习过程中遇到的Java内存模型带来的问题～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/809275481.png" style="width: 800px; height: 603px;" /></p>\r\r<p>可见性问题：左边CPU中运行的线程从主存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2。但这个变更对运行在右边CPU中的线程不可见，因为这个更改还没有flush到主存中：要解决共享对象可见性这个问题，我们可以使用Java的volatile关键字或者是加锁。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/2063882951.png" style="width: 800px; height: 553px;" /></p>\r\r<p>竞争问题：线程A和线程B共享一个对象obj。假设线程A从主存读取obj.count变量到自己的CPU缓存，同时线程B也读取了obj.count变量到它的CPU缓存，并且这两个线程都对obj.count做了加1操作。此时，obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。如果这两个加1操作是串行执行的，那么obj.count变量便会在原始值上加2，最终主存中的obj.count的值会是3。然而，下图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的obj.count只会增加1次变成2，尽管一共有两次加1操作。 要解决这个问题我们可以使用Java的synchronized关键字。</p>\r\r<p>重排序问题：除了共享内存和工作内存带来的问题，还存在重排序的问题：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1750, '重排序类型.png', '重排序类型-png', 1561382238, 1561382238, 'a:5:{s:4:"name";s:19:"重排序类型.png";s:4:"path";s:35:"/usr/uploads/2019/06/3095860465.png";s:4:"size";i:169843;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1752, 0),
(1751, '数据依赖性类型.png', '数据依赖性类型-png', 1561382274, 1561382274, 'a:5:{s:4:"name";s:25:"数据依赖性类型.png";s:4:"path";s:34:"/usr/uploads/2019/06/259139154.png";s:4:"size";i:73266;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1752, 0),
(1752, 'Java内存模型中的重排序', '1752', 1561382339, 1561382339, '<p>本文记录Java学习过程中遇到的Java内存模型中的重排序～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/3095860465.png" style="width: 800px; height: 119px;" /></p>\r\r<p>重排序类型</p>\r\r<ul>\r	<li>编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；</li>\r	<li>指令级并行的重排序：现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；</li>\r	<li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>\r</ul>\r\r<p>重排序与依赖性</p>\r\r<ul>\r	<li>数据依赖性</li>\r</ul>\r\r<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>\r\r<p>数据依赖分为下列3种类型：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/259139154.png" style="width: 800px; height: 344px;" />​<br />\r&nbsp;<br />\r上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p>\r\r<ul>\r	<li>控制依赖性</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic void use() {\r	if (flag) {\r		int i = a * a;\r	}\r}</pre>\r\r<p>flag变量是个标记，用来标识变量a是否已被写入，在use方法中比变量i依赖if(flag)的判断，这里就叫控制依赖，如果发生了重排序，结果就不对了。</p>\r\r<p><strong>as-if-serial</strong></p>\r\r<p>不管如何重排序，都必须保证代码在单线程下的运行正确，连单线程下都无法正确，更不用讨论多线程并发的情况，所以就提出了一个as-if-serial的概念，as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。（强调一下，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。）但是，如果操作之间不存在数据依赖关系，这些操作依然可能被编译器和处理器重排序。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rint a = 1;//1\rint b = 2;//2\rint c = a + b;//3</pre>\r\r<p>1和3之间存在数据依赖关系，同时2和3之间也存在数据依赖关系。因此在最终执行的指令序列中，3不能被重排序到1和2的前面（3排到1和2的前面，程序的结果将会被改变）。但1和2之间没有数据依赖关系，编译器和处理器可以重排序1和2之间的执行顺序。</p>\r\r<p>总之，as-if-serial语义使单线程下无需担心重排序的干扰，也无需担心内存可见性问题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1753, '并发下重排序带来的问题01.png', '并发下重排序带来的问题01-png', 1561418710, 1561418710, 'a:5:{s:4:"name";s:39:"并发下重排序带来的问题01.png";s:4:"path";s:35:"/usr/uploads/2019/06/1134416866.png";s:4:"size";i:83966;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1756, 0),
(1754, '并发下重排序带来的问题02.png', '并发下重排序带来的问题02-png', 1561418730, 1561418730, 'a:5:{s:4:"name";s:39:"并发下重排序带来的问题02.png";s:4:"path";s:35:"/usr/uploads/2019/06/2993215094.png";s:4:"size";i:48709;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1756, 0),
(1755, '并发下重排序带来的问题03.png', '并发下重排序带来的问题03-png', 1561418730, 1561418730, 'a:5:{s:4:"name";s:39:"并发下重排序带来的问题03.png";s:4:"path";s:35:"/usr/uploads/2019/06/3578307738.png";s:4:"size";i:69317;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1756, 0),
(1756, '并发下重排序带来的问题', '1756', 1561418760, 1561418788, '<p>本文记录Java学习过程中遇到的并发下重排序带来的问题～</p>\r\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/1134416866.png" style="width: 593px; height: 735px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/2993215094.png" style="width: 800px; height: 486px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/3578307738.png" style="width: 800px; height: 392px;" /></p>\r\r<p>这里假设有两个线程A和B，A首先执行init()方法，随后B线程接着执行use()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？答案是：不一定能看到。</p>\r\r<p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p>\r\r<p>让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还没有被线程A写入，这时就会发生错误！</p>\r\r<p>当操作3和操作4重排序时会产生什么效果？在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当操作3的条件判断为真时，就把该计算结果写入变量i中。猜测执行实质上对操作3和4做了重排序，问题在于这时候，a的值还没被线程A赋值。在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1757, '内存屏障.png', '内存屏障-png', 1561419492, 1561419492, 'a:5:{s:4:"name";s:16:"内存屏障.png";s:4:"path";s:35:"/usr/uploads/2019/06/2661367031.png";s:4:"size";i:175197;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1759, 0),
(1758, '临界区.png', '临界区-png', 1561419517, 1561419517, 'a:5:{s:4:"name";s:13:"临界区.png";s:4:"path";s:33:"/usr/uploads/2019/06/73611030.png";s:4:"size";i:127642;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1759, 0),
(1759, '并发下重排序问题的解决', '1759', 1561419533, 1561419533, '<p>本文记录Java学习过程中遇到的并发下重排序问题的解决～</p>\r<!--more-->\r\r<p>内存屏障</p>\r\r<p>Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序，从而让程序按我们预想的流程去执行。</p>\r\r<p>保证特定操作的执行顺序;<br />\r影响某些数据（或者是某条指令的执行结果）的内存可见性。</p>\r\r<p>编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。</p>\r\r<p>Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。</p>\r\r<p>JMM把内存屏障指令分为4类，StoreLoad Barriers是一个&ldquo;全能型&rdquo;的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/2661367031.png" style="width: 800px; height: 329px;" /></p>\r\r<p>临界区</p>\r\r<p>临界区内的代码可以重排序（但JMM不允许临界区内的代码&ldquo;逸出&rdquo;到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法&ldquo;观察&rdquo;到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/73611030.png" style="width: 800px; height: 761px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1760, 'Happens-Before.png', 'Happens-Before-png', 1561422279, 1561422279, 'a:5:{s:4:"name";s:18:"Happens-Before.png";s:4:"path";s:35:"/usr/uploads/2019/06/2695677410.png";s:4:"size";i:344730;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1761, 0),
(1761, 'Happens-Before', '1761', 1561422311, 1561422311, '<p>本文记录Java学习过程中遇到的Happens-Before～</p>\r<!--more-->\r\r<p><strong>定义</strong></p>\r\r<p>用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系 。</p>\r\r<p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p>\r\r<p><strong>加深理解</strong></p>\r\r<ul>\r	<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前（对程序员来说）；</li>\r	<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序是允许的（对编译器和处理器来说）。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/2695677410.png" style="width: 800px; height: 697px;" />​</p>\r\r<p>Happens-Before规则：</p>\r\r<ol>\r	<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作；</li>\r	<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁；</li>\r	<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读；</li>\r	<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C；</li>\r	<li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作；</li>\r	<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回；</li>\r	<li>线程中断规则:对线程interrupt方法的调用happens-before于被中断线程的代码检测到中断事件的发生。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1762, '《Java并发编程的艺术》PDF完整版下载', '1762', 1561436578, 1561436578, '<p>本文分享一本Java高级程序员必备书籍&mdash;&mdash;《Java并发编程的艺术》～</p>\r<!--more-->\r\r<p>并发编程领域的扛鼎之作，作者是阿里和1号店的资深Java技术专家，对并发编程有非常深入的研究，《Java并发编程的艺术》是他们多年一线开发经验的结晶。本书的部分内容在出版早期发表在Java并发编程网和InfoQ等技术社区，得到了非常高的评价。它选取了Java并发编程中核心的技术进行讲解，从JDK源码、JVM、CPU等多角度全面剖析和讲解了Java并发编程的框架、工具、原理和方法，对Java并发编程进行了为深入和透彻的阐述。</p>\r\r<p>《Java并发编程的艺术》内容涵盖Java并发编程机制的底层实现原理、Java内存模型、Java并发编程基础、Java中的锁、并发容器和框架、原子类、并发工具类、线程池、Executor框架等主题，每个主题都做了深入的讲解，同时通过实例介绍了如何应用这些技术。</p>\r\r<p>目录</p>\r\r<p>前 言<br />\r第1章 并发编程的挑战 1<br />\r1.1 上下文切换 1<br />\r1.1.1 多线程一定快吗 1<br />\r1.1.2 测试上下文切换次数和时长 3<br />\r1.1.3 如何减少上下文切换 3<br />\r1.1.4 减少上下文切换实战 4<br />\r1.2 死锁 5<br />\r1.3 资源限制的挑战 6<br />\r1.4 本章小结 7<br />\r第2章 Java并发机制的底层实现原理 8<br />\r2.1 volatile的应用 8<br />\r2.2 synchronized的实现原理与应用 11<br />\r2.2.1 Java对象头 12<br />\r2.2.2 锁的升级与对比 13<br />\r2.3 原子操作的实现原理 16<br />\r2.4 本章小结 20<br />\r第3章 Java内存模型 21<br />\r3.1 Java内存模型的基础 21<br />\r3.1.1 并发编程模型的两个关键问题 21<br />\r3.1.2 Java内存模型的抽象结构 22<br />\r3.1.3 从源代码到指令序列的重排序 23<br />\r3.1.4 并发编程模型的分类 24<br />\r3.1.5 happens-before简介 26<br />\r3.2 重排序 27<br />\r3.2.1 数据依赖性 28<br />\r3.2.2 as-if-serial语义 28<br />\r3.2.3 程序顺序规则 29<br />\r3.2.4 重排序对多线程的影响 29<br />\r3.3 顺序一致性 31<br />\r3.3.1 数据竞争与顺序一致性 31<br />\r3.3.2 顺序一致性内存模型 32<br />\r3.3.3 同步程序的顺序一致性效果 34<br />\r3.3.4 未同步程序的执行特性 35<br />\r3.4 volatile的内存语义 38<br />\r3.4.1 volatile的特性 38<br />\r3.4.2 volatile写-读建立的happens-before关系 39<br />\r3.4.3 volatile写-读的内存语义 40<br />\r3.4.4 volatile内存语义的实现 42<br />\r3.4.5 JSR-133为什么要增强volatile的内存语义 46<br />\r3.5 锁的内存语义 47<br />\r3.5.1 锁的释放-获取建立的<br />\rhappens-before关系 47<br />\r3.5.2 锁的释放和获取的内存语义 48<br />\r3.5.3 锁内存语义的实现 50<br />\r3.5.4 concurrent包的实现 54<br />\r3.6 final域的内存语义 55<br />\r3.6.1 final域的重排序规则 55<br />\r3.6.2 写final域的重排序规则 56<br />\r3.6.3 读final域的重排序规则 57<br />\r3.6.4 final域为引用类型 58<br />\r3.6.5 为什么final引用不能从构造函数内&ldquo;溢出&rdquo; 59<br />\r3.6.6 final语义在处理器中的实现 61<br />\r3.6.7 JSR-133为什么要增强f?inal的语义 62<br />\r3.7 happens-before 62<br />\r3.7.1 JMM的设计 62<br />\r3.7.2 happens-before的定义 64<br />\r3.7.3 happens-before规则 65<br />\r3.8 双重检查锁定与延迟初始化 67<br />\r3.8.1 双重检查锁定的由来 67<br />\r3.8.2 问题的根源 69<br />\r3.8.3 基于volatile的解决方案 71<br />\r3.8.4 基于类初始化的解决方案 72<br />\r3.9 Java内存模型综述 78<br />\r3.9.1 处理器的内存模型 78<br />\r3.9.2 各种内存模型之间的关系 80<br />\r3.9.3 JMM的内存可见性保证 80<br />\r3.9.4 JSR-133对旧内存模型的修补 81<br />\r3.10 本章小结 82<br />\r第4章 Java并发编程基础 83<br />\r4.1 线程简介 83<br />\r4.1.1 什么是线程 83<br />\r4.1.2 为什么要使用多线程 84<br />\r4.1.3 线程优先级 85<br />\r4.1.4 线程的状态 87<br />\r4.1.5 Daemon线程 90<br />\r4.2 启动和终止线程 91<br />\r4.2.1 构造线程 91<br />\r4.2.2 启动线程 92<br />\r4.2.3 理解中断 92<br />\r4.2.4 过期的suspend()、resume()和stop() 93<br />\r4.2.5 安全地终止线程 95<br />\r4.3 线程间通信 96<br />\r4.3.1 volatile和synchronized关键字 96<br />\r4.3.2 等待/通知机制 98<br />\r4.3.3 等待/通知的经典范式 101<br />\r4.3.4 管道输入/输出流 102<br />\r4.3.5 Thread.join()的使用 103<br />\r4.3.6 ThreadLocal的使用 105<br />\r4.4 线程应用实例 106<br />\r4.4.1 等待超时模式 106<br />\r4.4.2 一个简单的数据库连接池示例 106<br />\r4.4.3 线程池技术及其示例 110<br />\r4.4.4 一个基于线程池技术的简单Web服务器 114<br />\r4.5 本章小结 118<br />\r第5章 Java中的锁 119<br />\r5.1 Lock接口 119<br />\r5.2 队列同步器 121<br />\r5.2.1 队列同步器的接口与示例 121<br />\r5.2.2 队列同步器的实现分析 124<br />\r5.3 重入锁 136<br />\r5.4 读写锁 140<br />\r5.4.1 读写锁的接口与示例 141<br />\r5.4.2 读写锁的实现分析 142<br />\r5.5 LockSupport工具 146<br />\r5.6 Condition接口 147<br />\r5.6.1 Condition接口与示例 148<br />\r5.6.2 Condition的实现分析 150<br />\r5.7 本章小结 154<br />\r第6章 Java并发容器和框架 155<br />\r6.1 ConcurrentHashMap的实现原理与使用 155<br />\r6.1.1 为什么要使用ConcurrentHashMap 155<br />\r6.1.2 ConcurrentHashMap的结构 156<br />\r6.1.3 ConcurrentHashMap的初始化 157<br />\r6.1.4 定位Segment 159<br />\r6.1.5 ConcurrentHashMap的操作 160<br />\r6.2 ConcurrentLinkedQueue 161<br />\r6.2.1 ConcurrentLinkedQueue的结构 162<br />\r6.2.2 入队列 162<br />\r6.2.3 出队列 165<br />\r6.3 Java中的阻塞队列 167<br />\r6.3.1 什么是阻塞队列 167<br />\r6.3.2 Java里的阻塞队列 168<br />\r6.3.3 阻塞队列的实现原理 172<br />\r6.4 Fork/Join框架 175<br />\r6.4.1 什么是Fork/Join框架 175<br />\r6.4.2 工作窃取算法 176<br />\r6.4.3 Fork/Join框架的设计 177<br />\r6.4.4 使用Fork/Join框架 177<br />\r6.4.5 Fork/Join框架的异常处理 179<br />\r6.4.6 Fork/Join框架的实现原理 179<br />\r6.5 本章小结 181<br />\r第7章 Java中的13个原子操作类 182<br />\r7.1 原子更新基本类型类 182<br />\r7.2 原子更新数组 184<br />\r7.3 原子更新引用类型 185<br />\r7.4 原子更新字段类 187<br />\r7.5 本章小结 188<br />\r第8章 Java中的并发工具类 189<br />\r8.1 等待多线程完成的CountDownLatch 189<br />\r8.2 同步屏障CyclicBarrier 191<br />\r8.2.1 CyclicBarrier简介 191<br />\r8.2.2 CyclicBarrier的应用场景 193<br />\r8.2.3 CyclicBarrier和CountDownLatch的区别 195<br />\r8.3 控制并发线程数的Semaphore 196<br />\r8.4 线程间交换数据的Exchanger 198<br />\r8.5 本章小结 199<br />\r第9章 Java中的线程池 200<br />\r9.1 线程池的实现原理 200<br />\r9.2 线程池的使用 203<br />\r9.2.1 线程池的创建 203<br />\r9.2.2 向线程池提交任务 205<br />\r9.2.3 关闭线程池 205<br />\r9.2.4 合理地配置线程池 206<br />\r9.2.5 线程池的监控 206<br />\r9.3 本章小结 207<br />\r第10章 Executor框架 208<br />\r10.1 Executor框架简介 208<br />\r10.1.1 Executor框架的两级调度模型 208<br />\r10.1.2 Executor框架的结构与成员 208<br />\r10.2 ThreadPoolExecutor详解 213<br />\r10.2.1 FixedThreadPool详解 213<br />\r10.2.2 SingleThreadExecutor详解 214<br />\r10.2.3 CachedThreadPool详解 215<br />\r10.3 ScheduledThreadPoolExecutor详解 217<br />\r10.3.1 ScheduledThreadPoolExecutor的运行机制 217<br />\r10.3.2 ScheduledThreadPoolExecutor的实现 218<br />\r10.4 FutureTask详解 221<br />\r10.4.1 FutureTask简介 222<br />\r10.4.2 FutureTask的使用 222<br />\r10.4.3 FutureTask的实现 224<br />\r10.5 本章小结 227<br />\r第11章 Java并发编程实践 228<br />\r11.1 生产者和消费者模式 228<br />\r11.1.1 生产者消费者模式实战 229<br />\r11.1.2 多生产者和多消费者场景 231<br />\r11.1.3 线程池与生产消费者模式 234<br />\r11.2 线上问题定位 234<br />\r11.3 性能测试 236<br />\r11.4 异步任务池 238<br />\r11.5 本章小结 240</p>\r\r<p>下载地址：<a href="https://pan.baidu.com/s/1X3XwG3wJH9_GDAu7isTtlA" target="_blank">vjrc</a></p>\r\r<hr style="margin: 1.5em auto; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-color: rgb(233, 233, 233); color: rgb(102, 102, 102); font-family: &quot;microsoft yahei&quot;, Georgia, &quot;Times New Roman&quot;, STHeiti, serif; font-size: 14px;" />\r<p style="color: rgb(102, 102, 102); font-family: &quot;microsoft yahei&quot;, Georgia, &quot;Times New Roman&quot;, STHeiti, serif; font-size: 14px;">由于版权问题，文件已经被加密，解压密码请自己猜~</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1763, 'volatile写的内存语义.png', 'volatile写的内存语义-png', 1561457343, 1561457343, 'a:5:{s:4:"name";s:30:"volatile写的内存语义.png";s:4:"path";s:35:"/usr/uploads/2019/06/2441399785.png";s:4:"size";i:63716;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1768, 0),
(1764, 'volatile读的内存语义.png', 'volatile读的内存语义-png', 1561457364, 1561457364, 'a:5:{s:4:"name";s:30:"volatile读的内存语义.png";s:4:"path";s:35:"/usr/uploads/2019/06/1337089419.png";s:4:"size";i:88286;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1768, 0),
(1765, 'volatile重排序规则表.png', 'volatile重排序规则表-png', 1561457385, 1561457385, 'a:5:{s:4:"name";s:30:"volatile重排序规则表.png";s:4:"path";s:35:"/usr/uploads/2019/06/2272310480.png";s:4:"size";i:61196;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1768, 0),
(1766, 'JMM对volatile的内存屏障插入策略——写.png', 'JMM对volatile的内存屏障插入策略-写-png', 1561457433, 1561457433, 'a:5:{s:4:"name";s:54:"JMM对volatile的内存屏障插入策略——写.png";s:4:"path";s:35:"/usr/uploads/2019/06/1293849162.png";s:4:"size";i:119783;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1768, 0),
(1767, 'JMM对volatile的内存屏障插入策略——读.png', 'JMM对volatile的内存屏障插入策略-读-png', 1561457453, 1561457453, 'a:5:{s:4:"name";s:54:"JMM对volatile的内存屏障插入策略——读.png";s:4:"path";s:35:"/usr/uploads/2019/06/1976091264.png";s:4:"size";i:121537;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1768, 0),
(1768, 'volatile的内存语义', '1768', 1561457464, 1561457464, '<p>本文记录Java学习过程中遇到的volatile的内存语义～</p>\r<!--more-->\r\r<p>可以把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。</p>\r\r<p>示例代码（使用volatile）：</p>\r\r<pre class="brush:java;">\rpublic class Vola {\r\r    // 使用volatile声明64位的long型变量\r    volatile long i = 0L;\r\r    // 单个volatile变量的读\r    public long getI() {\r        return i;\r    }\r\r    // 单个volatile变量的写\r    public void setI(long i) {\r        this.i = i;\r    }\r    \r    // 复合（多个）volatile变量的读/写\r    public void inc() {\r    	i++;\r    }\r}</pre>\r\r<p>示例代码（不使用volatile）：</p>\r\r<pre class="brush:java;">\rpublic class VolaLikeSyn {\r\r    // 普通的long型变量\r    long i = 0L;\r\r    // 对单个的普通变量的写用同一个锁同步\r    public synchronized long getI() {\r        return this.i;  \r    }\r\r    // 对单个的普通变量的读用同一个锁同步\r    public synchronized void setI(long i) {\r        // 单个volatile变量的写\r        this.i = i;\r    }\r    \r    // 普通方法调用\r    public void inc() {\r        // 调用已同步的读方法    \r    	long temp = getI();\r        // 普通写操作\r    	temp = temp + 1L;\r        // 调用已同步的写方法\r    	setI(temp);\r    }\r}</pre>\r\r<p>volatile变量自身具有下列特性：</p>\r\r<ul>\r	<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入；</li>\r	<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile变量++这种复合操作不具有原子性。</li>\r</ul>\r\r<p>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/2441399785.png" style="width: 800px; height: 555px;" /></p>\r\r<p>volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/1337089419.png" style="width: 800px; height: 528px;" /></p>\r\r<p>volatile重排序规则表</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/2272310480.png" style="width: 800px; height: 229px;" /></p>\r\r<p>JMM对volatile的内存屏障插入策略</p>\r\r<p>在每个volatile写操作的前面插入一个StoreStore屏障，在每个volatile写操作的后面插入一个StoreLoad屏障。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/1293849162.png" style="width: 800px; height: 545px;" /></p>\r\r<p>在每个volatile读操作的后面插入一个LoadLoad屏障，在每个volatile读操作的后面插入一个LoadStore屏障。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/1976091264.png" style="width: 800px; height: 519px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1769, '锁的内存语义-获取.png', '锁的内存语义-获取-png', 1561465711, 1561465711, 'a:5:{s:4:"name";s:29:"锁的内存语义-获取.png";s:4:"path";s:35:"/usr/uploads/2019/06/2913722842.png";s:4:"size";i:88471;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1771, 0),
(1770, '锁的内存语义-释放.png', '锁的内存语义-释放-png', 1561465711, 1561465711, 'a:5:{s:4:"name";s:29:"锁的内存语义-释放.png";s:4:"path";s:35:"/usr/uploads/2019/06/3678390057.png";s:4:"size";i:41748;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1771, 0),
(1771, '锁的内存语义', '1771', 1561465740, 1561465759, '<p>本文记录Java学习过程中遇到的锁的内存语义～</p>\r<!--more-->\r\r<p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/3678390057.png" style="width: 652px; height: 543px;" /></p>\r\r<p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/2913722842.png" style="width: 758px; height: 625px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1772, 'final的内存语义', '1772', 1561466467, 1561466467, '<p>本文记录Java学习过程中遇到的final的内存语义～</p>\r<!--more-->\r\r<p>编译器和处理器要遵守三个重排序规则：</p>\r\r<ul>\r	<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序；</li>\r	<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>\r	<li>当final域为引用类型时，增加了如下规则：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>\r</ul>\r\r<p>final语义在处理器中的实现：</p>\r\r<ul>\r	<li>会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏；</li>\r	<li>读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1773, 'volatile的实现原理', '1773', 1561467371, 1561467371, '<p>本文记录Java学习过程中遇到的volatile的实现原理～</p>\r<!--more-->\r\r<p>有volatile变量修饰的共享变量进行写操作的时候会使用CPU提供的Lock前缀指令：</p>\r\r<ul>\r	<li>将当前处理器缓存行的数据写回到系统内存；</li>\r	<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1774, '锁的存放位置01.png', '锁的存放位置01-png', 1561467831, 1561467831, 'a:5:{s:4:"name";s:24:"锁的存放位置01.png";s:4:"path";s:35:"/usr/uploads/2019/06/4131216710.png";s:4:"size";i:58332;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1777, 0),
(1775, '锁的存放位置02.png', '锁的存放位置02-png', 1561467832, 1561467832, 'a:5:{s:4:"name";s:24:"锁的存放位置02.png";s:4:"path";s:35:"/usr/uploads/2019/06/4239363444.png";s:4:"size";i:45649;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1777, 0),
(1776, '锁的存放位置03.png', '锁的存放位置03-png', 1561467832, 1561467832, 'a:5:{s:4:"name";s:24:"锁的存放位置03.png";s:4:"path";s:35:"/usr/uploads/2019/06/3444896097.png";s:4:"size";i:73835;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1777, 0),
(1777, 'synchronized的实现原理', '1777', 1561467878, 1561467878, '<p>本文记录Java学习过程中遇到的synchronized的实现原理～</p>\r<!--more-->\r\r<p>使用monitorenter和monitorexit指令实现的：</p>\r\r<ul>\r	<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处；</li>\r	<li>每个monitorenter必须有对应的monitorexit与之配对；</li>\r	<li>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。</li>\r</ul>\r\r<p>锁的存放位置</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/4131216710.png" style="width: 800px; height: 125px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/4239363444.png" style="width: 800px; height: 134px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/3444896097.png" style="width: 800px; height: 173px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1778, '各种常见锁.png', '各种常见锁-png', 1561468985, 1561468985, 'a:5:{s:4:"name";s:19:"各种常见锁.png";s:4:"path";s:34:"/usr/uploads/2019/06/771018372.png";s:4:"size";i:195060;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1779, 0),
(1779, '各种常见锁', '1779', 1561469000, 1561469000, '<p>本文记录Java学习过程中遇到的各种常见锁～</p>\r<!--more-->\r\r<p>锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/771018372.png" style="width: 800px; height: 158px;" />​</p>\r\r<ul>\r	<li>偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。无竞争时不需要进行CAS操作来加锁和解锁；</li>\r	<li>轻量级锁：无竞争时通过CAS操作来加锁和解锁；</li>\r	<li>重量级锁。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1780, 'Spring的目标', '1780', 1561533574, 1561533574, '<p>本文记录Java学习过程中遇到的Spring的目标～</p>\r<!--more-->\r\r<p>Spring的目标主要有两个：</p>\r\r<ol>\r	<li>让现有的技术更容易使用；</li>\r	<li>促进良好的编程习惯。</li>\r</ol>\r\r<p>Spring是一个全面的解决方案，它坚持一个原则：不从新造轮子。已经有较好解决方案的领域，Spring绝不重复性实现，比如：对象持久化和OR映射，Spring只对现有的JDBC，Hibernate等技术提供支持，使之更容易使用，而不做重复的实现。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1781, 'Spring的体系结构', '1781', 1561533840, 1561533874, '<p>本文记录Java学习过程中遇到的Spring的体系结构～</p>\r<!--more-->\r\r<p>Spring框架有很多特性，这些特性由7个定义良好的模块构成：</p>\r\r<ol>\r	<li>Spring Core：即Spring核心，它是框架最基础的部分，提供IOC和依赖注入特性；</li>\r	<li>Spring Context：即Spring上下文容器，它是BeanFactory功能加强的一个子接口；</li>\r	<li>Spring Web：它提供Web应用开发的支持；</li>\r	<li>Spring MVC：它针对Web应用中MVC思想的实现；</li>\r	<li>Spring DAO：提供对JDBC抽象层，简化了JDBC编码，同时编码更具有健壮性；</li>\r	<li>Spring ORM：它支持用于流行的ORM框架的整合，比如：Spring+Hibernate、Spring+iBatis、Spring+JDO的整合等；</li>\r	<li>Spring AOP：即面向切面编程，它提供了与AOP联盟兼容的编程实现。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1782, 'Spring常用组件.png', 'Spring常用组件-png', 1561534527, 1561534527, 'a:5:{s:4:"name";s:22:"Spring常用组件.png";s:4:"path";s:34:"/usr/uploads/2019/06/892046670.png";s:4:"size";i:166116;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1783, 0),
(1783, 'Spring的常用组件', '1783', 1561534560, 1561534576, '<p>本文记录Java学习过程中遇到的Spring的常用组件～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/06/892046670.png" style="width: 800px; height: 681px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1784, 'Spring的@Configuration注解', '1784', 1562230662, 1562230662, '<p>本文记录Java学习过程中遇到的Spring的@Configuration注解～</p>\r<!--more-->\r\r<p>@Configuration注解表示这个类是一个配置类，它与XML配置文件等同。</p>\r\r<p>示例代码（XML配置文件）：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r       xsi:schemaLocation=&quot;\r       http://www.springframework.org/schema/beans\r       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\r    &lt;bean id=&quot;person&quot; class=&quot;ren.oliver.spring.cap01.domain.Person&quot;&gt;\r        &lt;property name=&quot;name&quot; value=&quot;oliver&quot; /&gt;\r        &lt;property name=&quot;age&quot; value=&quot;18&quot; /&gt;\r    &lt;/bean&gt;\r&lt;/beans&gt;</pre>\r\r<p>示例代码（@Configuration注解）：</p>\r\r<pre class="brush:java;">\r@Configuration\rpublic class MainConfig {\r    @Bean\r    public Person person(){\r        return new Person(&quot;oliver&quot;,18);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1785, 'Spring的@ComponentScan注解', '1785', 1562231112, 1562231112, '<p>本文记录Java学习过程中遇到的Spring的@ComponentScan注解～</p>\r<!--more-->\r\r<p>@ComponentScan注解表示要扫描的组件，它可以指定扫描范围、指定扫描过滤器和自定义过滤规则。</p>\r\r<p>示例代码（指定扫描范围）：</p>\r\r<pre class="brush:java;">\r@Configuration\r@ComponentScan(&quot;ren.oliver.spring.cap02&quot;)\rpublic class MainConfig02 {\r    @Bean\r    public Person person(){\r        return new Person(&quot;oliver&quot;,18);\r    }\r}</pre>\r\r<p>示例代码（指定扫描规则-包含）：</p>\r\r<pre class="brush:java;">\r@Configuration\r@ComponentScan(value = &quot;ren.oliver.spring.cap02&quot;, useDefaultFilters = false, includeFilters = {\r        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})\r})\rpublic class MainConfig03 {\r    @Bean\r    public Person person(){\r        return new Person(&quot;oliver&quot;,18);\r    }\r}</pre>\r\r<p>示例代码（指定扫描规则-排除）：</p>\r\r<pre class="brush:java;">\r@Configuration\r@ComponentScan(value = &quot;ren.oliver.spring.cap02&quot;, useDefaultFilters = true, excludeFilters = {\r        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})\r})\rpublic class MainConfig04 {\r    @Bean\r    public Person person(){\r        return new Person(&quot;oliver&quot;,18);\r    }\r}</pre>\r\r<p>注意：排除的时候，要制定useDefaultFilters为true，也可以不写（默认是true）。</p>\r\r<p>示例代码（自定义过滤规则&mdash;&mdash;自定义过滤规则）：</p>\r\r<pre class="brush:java;">\rpublic class MyTypeFilter implements TypeFilter {\r\r    // MetadataReader 读取到当前正在扫描类的信息\r    // MetadataReaderFactory 可以获取到其他任何类信息\r    @Override\r    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\r        //获取当前类注解的信息\r        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();\r\r        //获取当前正在扫描的类信息\r        ClassMetadata classMetadata = metadataReader.getClassMetadata();\r\r        //获取当前类资源(类的路径)\r        Resource resource = metadataReader.getResource();\r\r        String className = classMetadata.getClassName();\r        System.out.println(className);\r\r        return false;\r    }\r}</pre>\r\r<p>示例代码（自定义过滤规则&mdash;&mdash;配置自定义过滤规则）：</p>\r\r<pre class="brush:java;">\r@Configuration\r@ComponentScan(value = &quot;ren.oliver.spring.cap02&quot;, useDefaultFilters = false, includeFilters = {\r        @ComponentScan.Filter(type = FilterType.CUSTOM, classes = {MyTypeFilter.class})\r})\rpublic class MainConfig05 {\r    @Bean\r    public Person person(){\r        return new Person(&quot;oliver&quot;,18);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1786, 'Spring的@Scope注解', '1786', 1562321945, 1562321945, '<p>本文记录Java学习过程中遇到的Spring的@Scope注解～</p>\r<!--more-->\r\r<p>@Scope注解表示对应的bean是单例还是多例，它有两个取值：single（单例，默认值）和prototype（多例）。</p>\r\r<p>示例代码（单例）：</p>\r\r<pre class="brush:java;">\r@Configuration\rpublic class MainConfig01 {\r    // 给容器中注册一个bean, 类型为返回值的类型, 默认是单实例\r    @Bean\r    public Person person(){\r        return new Person(&quot;oliver&quot;,18);\r    }\r}\r\r@Configuration\rpublic class MainConfig03 {\r    /*\r     * singleton: 单实例(默认):IOC容器启动的时候会调用方法创建对象并放到IOC容器中,以后每次获取的就是直接从容器中拿(大Map.get)的同一个bean\r     * request: 主要针对web应用, 递交一次请求创建一个实例\r     * session: 同一个session创建一个实例\r     */\r    @Bean\r    @Scope(&quot;singleton&quot;)\r    public Person person(){\r        return new Person(&quot;oliver&quot;,18);\r    }\r}</pre>\r\r<p>示例代码（多例）：</p>\r\r<pre class="brush:java;">\r@Configuration\rpublic class MainConfig02 {\r    // prototype: 多实例: IOC容器启动的时候,IOC容器启动并不会去调用方法创建对象, 而是每次获取的时候才会调用方法创建对象\r    @Bean\r    @Scope(&quot;prototype&quot;)\r    public Person person(){\r        return new Person(&quot;oliver&quot;,18);\r    }\r}</pre>\r\r<p>示例代码（验证是单例还是多例）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app;\r        // app = new AnnotationConfigApplicationContext(MainConfig01.class);\r        // app = new AnnotationConfigApplicationContext(MainConfig02.class);\r        app = new AnnotationConfigApplicationContext(MainConfig03.class);\r        // 从容器中分别取两次person实例, 看是否为同一个bean\r        Object bean1 = app.getBean(&quot;person&quot;);\r        Object bean2 = app.getBean(&quot;person&quot;);\r        System.out.println(bean1 == bean2);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1787, 'Spring的@Lazy注解', '1787', 1562325241, 1562325241, '<p>本文记录Java学习过程中遇到的Spring的@Lazy注解～</p>\r<!--more-->\r\r<p>@Lazy注解表示对应的bean是否懒加载，它只对单实例有效，多实例本身就是懒加载的。</p>\r\r<p>示例代码（懒加载）：</p>\r\r<pre class="brush:java;">\r@Configuration\rpublic class MainConfig {\r    // 给容器中注册一个bean, 类型为返回值的类型, 默认是单实例\r    @Bean\r    @Lazy\r    public Person person(){\r        System.out.println(&quot;Person对象被创建&quot;);\r        return new Person(&quot;oliver&quot;,18);\r    }\r}</pre>\r\r<p>示例代码（验证懒加载）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(MainConfig.class);\r        System.out.println(&quot;IOC容器创建完成&quot;);\r        // 执行获取的时候才创建并初始化bean\r        app.getBean(&quot;person&quot;);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1788, 'Spring的@Conditional注解', '1788', 1562547273, 1562547273, '<p>本文记录Java学习过程中遇到的Spring的@Conditional注解～</p>\r<!--more-->\r\r<p>@Conditional注解可以根据某些条件来判断bean是否注册，这些条件主要包括：</p>\r\r<ul>\r	<li>ConditionContext: 判断条件可以使用的上下文(环境)；</li>\r	<li>AnnotatedTypeMetadata: Bean的注解的信息。</li>\r</ul>\r\r<p>示例代码（判断条件-Windows）：</p>\r\r<pre class="brush:java;">\rpublic class WindowsCondition implements Condition {\r    // ConditionContext: 判断条件可以使用的上下文(环境)\r    // AnnotatedTypeMetadata: 注解的信息\r    @Override\r    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\r        // 获取到IOC容器正在使用的BeanFactory\r        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\r        // 获取当前环境变量\r        Environment environment = context.getEnvironment();\r        String os_name = environment.getProperty(&quot;os.name&quot;);\r        if(os_name.contains(&quot;Windows&quot;)){\r            return true;\r        } else {\r            return false;\r        }\r    }\r}</pre>\r\r<p>示例代码（判断条件-Linux）：</p>\r\r<pre class="brush:java;">\rpublic class LinuxCondition implements Condition {\r    // ConditionContext: 判断条件可以使用的上下文(环境)\r    // AnnotatedTypeMetadata: 注解的信息\r    @Override\r    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\r        // 获取到IOC容器正在使用的beanFactory\r        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\r        // 获取当前环境变量\r        Environment environment = context.getEnvironment();\r        String os_name = environment.getProperty(&quot;os.name&quot;);\r        if(os_name.contains(&quot;linux&quot;)){\r            return true;\r        } else {\r            return false;\r        }\r    }\r}</pre>\r\r<p>示例代码（判断条件-Mac）：</p>\r\r<pre class="brush:java;">\rpublic class MacCondition implements Condition {\r    // ConditionContext: 判断条件可以使用的上下文(环境)\r    // AnnotatedTypeMetadata: 注解的信息\r    @Override\r    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\r        // 获取到IOC容器正在使用的beanFactory\r        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\r        // 获取当前环境变量\r        Environment environment = context.getEnvironment();\r        String os_name = environment.getProperty(&quot;os.name&quot;);\r        if(os_name.contains(&quot;Mac&quot;)){\r            return true;\r        } else {\r            return false;\r        }\r    }\r}</pre>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Configuration\rpublic class MainConfig {\r    @Bean\r    public Person person(){\r        System.out.println(&quot;Person对象被创建&quot;);\r        return new Person(&quot;person&quot;,18);\r    }\r    @Bean\r    @Conditional(WindowsCondition.class)\r    public Person windows(){\r        System.out.println(&quot;Windows对象被创建&quot;);\r        return new Person(&quot;windows&quot;,19);\r    }\r    @Bean\r    @Conditional(LinuxCondition.class)\r    public Person linux(){\r        System.out.println(&quot;Linux对象被创建&quot;);\r        return new Person(&quot;linux&quot;,20);\r    }\r    @Bean\r    @Conditional(MacCondition.class)\r    public Person mac(){\r        System.out.println(&quot;Mac对象被创建&quot;);\r        return new Person(&quot;mac&quot;,21);\r    }\r}</pre>\r\r<p>示例代码（应用测试类）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(MainConfig.class);\r        System.out.println(&quot;IOC容器创建完成&quot;);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1789, 'Spring的@Import注解', '1789', 1562900760, 1562900811, '<p>本文记录Java学习过程中遇到的Spring的@Import注解～</p>\r<!--more-->\r\r<p>@Import注解主要用于将组建添加到IOC容器中，主要有三种使用方式：</p>\r\r<p>1. 手动添加组件到IOC容器</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Import(Dog.class)\r@Configuration\rpublic class MainConfig02 {\r    @Bean\r    public Person person(){\r        return new Person(&quot;person&quot;,18);\r    }\r}</pre>\r\r<p>2.使用ImportSelector自定义返回组件</p>\r\r<p>示例代码（ImportSelector）：</p>\r\r<pre class="brush:java;">\rpublic class MyImportSelector implements ImportSelector {\r    @Override\r    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\r        // 返回全类名的bean\r        return new String[]{&quot;ren.oliver.spring.cap06.domain.Fish&quot;,&quot;ren.oliver.spring.cap06.domain.Tiger&quot;};\r    }\r}</pre>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Import({Dog.class, Cat.class, MyImportSelector.class})\r@Configuration\rpublic class MainConfig04 {\r    @Bean\r    public Person person(){\r        return new Person(&quot;person&quot;,18);\r    }\r}</pre>\r\r<p>3.使用ImportBeanDefinitionRegistrar返回自定义组件</p>\r\r<p>示例代码（ImportBeanDefinitionRegistrar）：</p>\r\r<pre class="brush:java;">\rpublic class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\r    @Override\r    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\r        boolean bean1 = registry.containsBeanDefinition(&quot;ren.oliver.spring.cap06.domain.Dog&quot;);\r        boolean bean2 = registry.containsBeanDefinition(&quot;ren.oliver.spring.cap06.domain.Cat&quot;);\r        // 如果Dog和Cat同时存在于我们IOC容器中,那么创建Pig类, 加入到容器\r        if(bean1 &amp;&amp; bean2){\r            // 对于要注册的bean, 给bean进行封装\r            RootBeanDefinition beanDefinition = new RootBeanDefinition(Pig.class);\r            registry.registerBeanDefinition(&quot;pig&quot;, beanDefinition);\r        }\r    }\r}</pre>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Import({Dog.class, Cat.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class})\r@Configuration\rpublic class MainConfig05 {\r    @Bean\r    public Person person(){\r        return new Person(&quot;person&quot;,18);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1790, 'FactoryBean与BeanFactory的区别', '1790', 1562903449, 1562903449, '<p>本文记录Java学习过程中遇到的FactoryBean与BeanFactory的区别～</p>\r<!--more-->\r\r<p>两者的区别如下：</p>\r\r<ul>\r	<li>FactoryBean用于将Java实例Bean注入到IOC容器中；</li>\r	<li>BeanFactory用于从容器中获取实例化后的Bean。</li>\r</ul>\r\r<p>示例代码（FactoryBean）：</p>\r\r<pre class="brush:java;">\rpublic class MyFactoryBean implements FactoryBean {\r    @Override\r    public Object getObject() throws Exception {\r        return new Monkey();\r    }\r\r    @Override\r    public Class&lt;?&gt; getObjectType() {\r        return Monkey.class;\r    }\r\r    @Override\r    public boolean isSingleton() {\r        return true;\r    }\r}</pre>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Import({Dog.class, Cat.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class})\r@Configuration\rpublic class MainConfig06 {\r    @Bean\r    public Person person(){\r        return new Person(&quot;person&quot;,18);\r    }\r\r    @Bean\r    public MyFactoryBean myFactoryBean() {\r        return new MyFactoryBean();\r    }\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(MainConfig01.class);\r        // app = new AnnotationConfigApplicationContext(MainConfig01.class);\r        // app = new AnnotationConfigApplicationContext(MainConfig02.class);\r        // app = new AnnotationConfigApplicationContext(MainConfig03.class);\r        // app = new AnnotationConfigApplicationContext(MainConfig04.class);\r        // app = new AnnotationConfigApplicationContext(MainConfig05.class);\r        app = new AnnotationConfigApplicationContext(MainConfig06.class);\r        System.out.println(&quot;IOC容器创建完成&quot;);\r        String[] beanDefinitionNames = app.getBeanDefinitionNames();\r		for(String name:beanDefinitionNames){\r			System.out.println(name);\r		}\r        Object bean1 = app.getBean(&quot;myFactoryBean&quot;);\r        Object bean2 = app.getBean(&quot;myFactoryBean&quot;);\r        System.out.println(bean1.getClass());\r        System.out.println(bean1 == bean2);\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1791, 'Spring的Bean生命周期', '1791', 1563180672, 1563180672, '<p>本文记录Java学习过程中遇到的Spring的Bean生命周期～</p>\r<!--more-->\r\r<p>Bean的生命周期指Bean创建、初始化合销毁的过程，可以自定义Bean初始化和销毁方法，容器会在Bean进行到相应生命周期的时候，调用自定义的初始化和销毁方法。</p>\r\r<p>自定义初始化和销毁方法有三种：</p>\r\r<p>1.指定初始化init-method方法和销毁destory-method方法</p>\r\r<p>示例代码（实体类）：</p>\r\r<pre class="brush:java;">\rpublic class Jeep {\r    public Jeep() {\r        System.out.println(&quot;Jeep()&quot;);\r    }\r    public void initMethod() {\r        System.out.println(&quot;init()&quot;);\r    }\r    public void destroyMethod() {\r        System.out.println(&quot;destory()&quot;);\r    }\r}</pre>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Configuration\rpublic class MainConfig01 {\r    @Bean(initMethod = &quot;initMethod&quot;, destroyMethod = &quot;destroyMethod&quot;)\r    public Jeep singleJeep() {\r        return new Jeep();\r    }\r\r    @Scope(&quot;prototype&quot;)\r    @Bean(initMethod = &quot;initMethod&quot;, destroyMethod = &quot;destroyMethod&quot;)\r    public Jeep multiJeep() {\r        return new Jeep();\r    }\r}</pre>\r\r<p>2.实现InitializingBean接口的afterPropertiesSet()方法，当beanFactory创建好对象，且把bean所有属性设置好之后，会调这个方法，相当于初始化方法；实现DisposableBean的destory()方法，当bean销毁时会把单实例bean进行销毁。</p>\r\r<p>示例代码（实体类）：</p>\r\r<pre class="brush:java;">\rpublic class Train implements InitializingBean, DisposableBean {\r    @Override\r    public void afterPropertiesSet() throws Exception {\r        System.out.println(&quot;afterPropertiesSet()&quot;);\r    }\r    @Override\r    public void destroy() throws Exception {\r        System.out.println(&quot;destroy()&quot;);\r    }\r}</pre>\r\r<p>3.可以使用JSR250规则定义的(java规范)两个注解来实现：@PostConstruct：在Bean创建完成，且属于赋值完成后进行初始化，属于JDK规范的注解；@PreDestroy：在bean将被移除之前进行通知，在容器销毁之前进行清理工作。</p>\r\r<p>示例代码（实体类）：</p>\r\r<pre class="brush:java;">\rpublic class Car {\r    public Car() {\r        System.out.println(&quot;Car()&quot;);\r    }\r    @PostConstruct\r    public void postConstruct() {\r        System.out.println(&quot;postConstruct()&quot;);\r    }\r    @PreDestroy\r    public void preDestroy() {\r        System.out.println(&quot;preDestroy()&quot;);\r    }\r}</pre>\r\r<p>提示：JSR是由JDK提供的一组规范。</p>\r\r<p>注意：对于单实例的Bean，可以正常调用初始化和销毁方法；对于多实例的Bean，容器只负责初始化，但不会管理bean，即容器关闭时不会调用销毁方法。另外，三者的顺序是3&mdash;&mdash;2&mdash;&mdash;1。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1792, 'Spring的BeanPostProcessor', '1792', 1563716460, 1570184100, '<p>本文记录Java学习过程中遇到的Spring的BeanPostProcessor～</p>\r<!--more-->\r\r<p>BeanPostProcessor是bean的后置处理器，在bean初始化前后进行一些处理工作，可以使用BeanPostProcessors控制Bean的生命周期，只需要实现BeanPostProcessors的两个接口即可：</p>\r\r<ul>\r	<li>postProcessBeforeInitialization()；</li>\r	<li>postProcessAfterInitialization()。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Component\rpublic class MyBeanPostProcessor implements BeanPostProcessor {\r    // 返回一个的对象(传过来的对象)\r    // 在初始化方法调用之前进行后置处理工作\r    // 什么时候调用它: init-method=init之前调用\r    @Override\r    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r        System.out.println(&quot;postProcessBeforeInitialization &quot; + bean.getClass());\r        System.out.println(&quot;beanName: &quot; + beanName);\r        System.out.println(&quot;bean: &quot; + bean);\r        return bean;\r    }\r    // 返回一个的对象(传过来的对象)\r    // 在初始化方法调用之后进行后置处理工作\r    // 什么时候调用它: init-method=init之后调用\r    @Override\r    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\r        System.out.println(&quot;postProcessAfterInitialization &quot; + bean.getClass());\r        System.out.println(&quot;beanName: &quot; + beanName);\r        System.out.println(&quot;bean: &quot; + bean);\r        return bean;\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1793, 'ApplicationContextAware与ApplicationContextAwareProcessor', '1793', 1563755700, 1563844648, '<p>本文记录Java学习过程中遇到的Spring的ApplicationContextAware与ApplicationContextAwareProcessor～</p>\r<!--more-->\r\r<p>实现ApplicationContextAware接口后，可以获取到Spring的ApplicationContext。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class Plane implements ApplicationContextAware {\r\r    ApplicationContext applicationContext;\r\r    @Override\r    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\r        this.applicationContext = applicationContext;\r    }\r}</pre>\r\r<p>Spring中是通过ApplicationContextAwareProcessor处理器来实现的，它也是BeanPostProcessor的一个实现类。</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\rpublic Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {\r	AccessControlContext acc = null;\r\r	if (System.getSecurityManager() != null &amp;&amp;\r			(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||\r					bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||\r					bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {\r		acc = this.applicationContext.getBeanFactory().getAccessControlContext();\r	}\r\r	if (acc != null) {\r		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\r			invokeAwareInterfaces(bean);\r			return null;\r		}, acc);\r	}\r	else {\r		invokeAwareInterfaces(bean);\r	}\r\r	return bean;\r}\r\rprivate void invokeAwareInterfaces(Object bean) {\r	if (bean instanceof Aware) {\r		if (bean instanceof EnvironmentAware) {\r			((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\r		}\r		if (bean instanceof EmbeddedValueResolverAware) {\r			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);\r		}\r		if (bean instanceof ResourceLoaderAware) {\r			((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);\r		}\r		if (bean instanceof ApplicationEventPublisherAware) {\r			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);\r		}\r		if (bean instanceof MessageSourceAware) {\r			((MessageSourceAware) bean).setMessageSource(this.applicationContext);\r		}\r		if (bean instanceof ApplicationContextAware) {\r			((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\r		}\r	}\r}</pre>\r\r<ol>\r	<li>在创建Plane对象，还没初始化之前，先判断是不是实现了ApplicationContextAware接口，如果是的话就调用invokeAwareInterfaces方法, 并给里面注入值；</li>\r	<li>进入invokeAwareInterfaces()方法，判断是哪个aware，如果是ApplicationContextAware，就将当前的bean转成ApplicationContextAware类型，调用setApplicationContext()，把IOC容器注入到Plane里去。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1794, 'Spring的@Value注解', '1794', 1563757080, 1563757160, '<p>本文记录Java学习过程中遇到的Spring的@Value注解～</p>\r<!--more-->\r\r<p>@Value注解主要用于对Bean中的变量赋值，它支持三种类型：</p>\r\r<ul>\r	<li>基本字符；</li>\r	<li>Spring的EL表达式；</li>\r	<li>运行环境变量。</li>\r</ul>\r\r<p>示例代码（Bean类）：</p>\r\r<pre class="brush:java;">\rpublic class Bird {\r\r    // 基本字符\r    @Value(&quot;Oliver&quot;)\r    private String name;\r\r    // Spring的EL表达式\r    @Value(&quot;#{20-2}&quot;)\r    private Integer age;\r\r    // 读取环境变量\r    @Value(&quot;${bird.color}&quot;)\r    private String color;\r\r    public Bird() {\r    }\r\r    public Bird(String name, Integer age, String color) {\r        this.name = name;\r        this.age = age;\r        this.color = color;\r    }\r\r    public String getName() {\r        return name;\r    }\r    public void setName(String name) {\r        this.name = name;\r    }\r    public Integer getAge() {\r        return age;\r    }\r\r    public void setAge(Integer age) {\r        this.age = age;\r    }\r\r    public String getColor() {\r        return color;\r    }\r\r    public void setColor(String color) {\r        this.color = color;\r    }\r\r    @Override\r    public String toString() {\r        return &quot;Bird [name=&quot; + name + &quot;, age=&quot; + age + &quot;, color=&quot; + color + &quot;]&quot;;\r    }\r}</pre>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Configuration\r@PropertySource(&quot;classpath:/config.properties&quot;)\rpublic class MainConfig01 {\r    @Bean\r    public Bird bird() {\r        return new Bird();\r    }\r}</pre>\r\r<p>示例代码（配置文件）：</p>\r\r<pre class="brush:bash;">\rbird.color=red</pre>\r\r<p>示例代码（测试代码）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app;\r        app = new AnnotationConfigApplicationContext(MainConfig01.class);\r        System.out.println(&quot;IOC容器创建完成&quot;);\r        //从容器中获取所有bean\r        String[] names = app.getBeanDefinitionNames();\r        for(String name:names){\r            System.out.println(name);\r        }\r        Bird bird = app.getBean(Bird.class);\r        System.out.println(bird);\r        app.close();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1795, 'Spring的BeanValidationPostProcessor', '1795', 1563845027, 1563845027, '<p>本文记录Java学习过程中遇到的Spring的BeanValidationPostProcessor～</p>\r<!--more-->\r\r<p>作用时间是，当对象创建完，给bean赋值后，对赋值的有效性进行校验，在WEB用得特别多，把页面提交的值进行校验。</p>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\r@Override\rpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r	if (!this.afterInitialization) {\r		doValidate(bean);\r	}\r	return bean;\r}\r\r@Override\rpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\r	if (this.afterInitialization) {\r		doValidate(bean);\r	}\r	return bean;\r}</pre>\r\r<p>注意：它依赖javax.validation包，需要导入。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1796, 'Spring的InitDestroyAnnotationBeanPostProcessor', '1796', 1563845456, 1563845456, '<p>本文记录Java学习过程中遇到的Spring的InitDestroyAnnotationBeanPostProcessor～</p>\r<!--more-->\r\r<p>此处理器用来处理@PostConstruct, @PreDestroy注解。</p>\r\r<p>示例代码（实体类）：</p>\r\r<pre class="brush:java;">\rpublic class Car {\r    public Car() {\r        System.out.println(&quot;Car()&quot;);\r    }\r    @PostConstruct\r    public void postConstruct() {\r        System.out.println(&quot;postConstruct()&quot;);\r    }\r    @PreDestroy\r    public void preDestroy() {\r        System.out.println(&quot;preDestroy()&quot;);\r    }\r}</pre>\r\r<p>源码分析：</p>\r\r<pre class="brush:java;">\r@Override\rpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r	LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\r	try {\r		metadata.invokeInitMethods(bean, beanName);\r	}\r	catch (InvocationTargetException ex) {\r		throw new BeanCreationException(beanName, &quot;Invocation of init method failed&quot;, ex.getTargetException());\r	}\r	catch (Throwable ex) {\r		throw new BeanCreationException(beanName, &quot;Failed to invoke init method&quot;, ex);\r	}\r	return bean;\r}\r\rpublic void invokeInitMethods(Object target, String beanName) throws Throwable {\r	Collection&lt;LifecycleElement&gt; checkedInitMethods = this.checkedInitMethods;\r	Collection&lt;LifecycleElement&gt; initMethodsToIterate =\r			(checkedInitMethods != null ? checkedInitMethods : this.initMethods);\r	if (!initMethodsToIterate.isEmpty()) {\r		boolean debug = logger.isDebugEnabled();\r		for (LifecycleElement element : initMethodsToIterate) {\r			if (debug) {\r				logger.debug(&quot;Invoking init method on bean &#39;&quot; + beanName + &quot;&#39;: &quot; + element.getMethod());\r			}\r			// 通过反射调用对应的初始化方法\r			element.invoke(target);\r		}\r	}\r}\r\r@Override\rpublic void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\r	LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\r	try {\r		metadata.invokeDestroyMethods(bean, beanName);\r	}\r	catch (InvocationTargetException ex) {\r		String msg = &quot;Invocation of destroy method failed on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;;\r		if (logger.isDebugEnabled()) {\r			logger.warn(msg, ex.getTargetException());\r		}\r		else {\r			logger.warn(msg + &quot;: &quot; + ex.getTargetException());\r		}\r	}\r	catch (Throwable ex) {\r		logger.error(&quot;Failed to invoke destroy method on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;, ex);\r	}\r}\r\rpublic void invokeDestroyMethods(Object target, String beanName) throws Throwable {\r	Collection&lt;LifecycleElement&gt; checkedDestroyMethods = this.checkedDestroyMethods;\r	Collection&lt;LifecycleElement&gt; destroyMethodsToUse =\r			(checkedDestroyMethods != null ? checkedDestroyMethods : this.destroyMethods);\r	if (!destroyMethodsToUse.isEmpty()) {\r		boolean debug = logger.isDebugEnabled();\r		for (LifecycleElement element : destroyMethodsToUse) {\r			if (debug) {\r				logger.debug(&quot;Invoking destroy method on bean &#39;&quot; + beanName + &quot;&#39;: &quot; + element.getMethod());\r			}\r			// 通过反射调用对应的预销毁方法\r			element.invoke(target);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1797, 'Spring的@Autowired、@Qualifier与@Primary注解', '1797', 1563928828, 1563928828, '<p>本文记录Java学习过程中遇到的Spring的@Autowired、@Qualifier与@Primary注解～</p>\r<!--more-->\r\r<p>自动装配：Spring利用依赖注入(DI)完成对IOC容器中的各个组件的依赖关系赋值。</p>\r\r<p>@Autowired注解用于自动装配，默认优先按类型去容器中找对应的组件，相当于app.getBean(Bean.class)去容器获取id为指定id的bean并注入到相应的bean中。</p>\r\r<p>示例代码（TestRepository）：</p>\r\r<pre class="brush:java;">\r@Repository\rpublic class TestRepository {\r\r    private int flag = 1;\r\r    public int getFlag() {\r        return flag;\r    }\r\r    public void setFlag(int flag) {\r        this.flag = flag;\r    }\r\r    @Override\r    public String toString() {\r        return &quot;TestDao [flag=&quot; + flag + &quot;]&quot;;\r    }\r}</pre>\r\r<p>示例代码（TestService）：</p>\r\r<pre class="brush:java;">\r@Service\rpublic class TestService {\r\r    @Autowired\r    TestRepository testRepository;\r\r    public TestRepository getTestRepository() {\r        return testRepository;\r    }\r\r    public void setTestRepository(TestRepository testRepository) {\r        this.testRepository = testRepository;\r    }\r}</pre>\r\r<p>示例代码（测试程序）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app;\r        app = new AnnotationConfigApplicationContext(MainConfig01.class);\r        System.out.println(&quot;IOC容器创建完成&quot;);\r        \r        System.out.println(app.getBean(TestRepository.class));\r\r        TestService testService = app.getBean(TestService.class);\r        System.out.println(testService.getTestRepository());\r\r        app.close();\r    }\r}</pre>\r\r<p>注意：@Autowired支持将required设置为false，这样就在容器中没有对应类型的容器的时候也不会报错了。</p>\r\r<p>@Qualifier注解用于指定将哪一个id进行注入。</p>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Configuration\r@ComponentScan(&quot;ren.oliver.spring.cap09&quot;)\rpublic class MainConfig01 {\r    @Bean\r    public TestRepository testRepositoryBean() {\r        TestRepository testRepository = new TestRepository();\r        testRepository.setFlag(2);\r        return testRepository;\r    }\r}</pre>\r\r<p>示例代码（TestService）：</p>\r\r<pre class="brush:java;">\r@Service\rpublic class TestService {\r    \r    @Autowired\r    @Qualifier(&quot;testRepositoryBean&quot;)\r    TestRepository testRepository;\r\r    public TestRepository getTestRepository() {\r        return testRepository;\r    }\r\r    public void setTestRepository(TestRepository testRepository) {\r        this.testRepository = testRepository;\r    }\r}</pre>\r\r<p>@Primary注解用于指定注入的时候，优先将对应的bean注入。</p>\r\r<p>示例代码（TestService）：</p>\r\r<pre class="brush:java;">\r@Service\rpublic class TestService {\r    \r    @Autowired\r    TestRepository testRepository;\r\r    public TestRepository getTestRepository() {\r        return testRepository;\r    }\r\r    public void setTestRepository(TestRepository testRepository) {\r        this.testRepository = testRepository;\r    }\r}</pre>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Configuration\r@ComponentScan(&quot;ren.oliver.spring.cap09&quot;)\rpublic class MainConfig01 {\r\r    @Bean\r    @Primary\r    public TestRepository testRepositoryBean() {\r        TestRepository testRepository = new TestRepository();\r        testRepository.setFlag(2);\r        return testRepository;\r    }\r}</pre>\r\r<p>注意：@Qualifier注解不受@Primary注解的影响，或者说优先级比@Primary注解高。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1798, '@Resource注解与@Inject注解', '1798', 1563929248, 1563929248, '<p>本文记录Java学习过程中遇到的@Resource注解与@Inject注解～</p>\r<!--more-->\r\r<p>@Resource和@Autowired的对比如下:</p>\r\r<ul>\r	<li>@Resource和@Autowired一样可以装配bean；</li>\r	<li>@Resource的缺点: 不能支持@Primary功能；不能支持@Autowired(required=false)的功能。</li>\r</ul>\r\r<p>示例代码（TestService）：</p>\r\r<pre class="brush:java;">\r@Service\rpublic class TestService {\r\r    @Resource(name = &quot;testRepositoryBean&quot;)\r    TestRepository testRepository;\r\r    public TestRepository getTestRepository() {\r        return testRepository;\r    }\r\r    public void setTestRepository(TestRepository testRepository) {\r        this.testRepository = testRepository;\r    }\r}</pre>\r\r<p>@Inject与@Autowired的对比如下:</p>\r\r<ul>\r	<li>@Inject和Autowired一样可以装配bean，并支持@Primary功能，可用于非spring框架；</li>\r	<li>@Inject缺点: 不能支持@Autowired(required=false)的功能；使用需要引入第三方包javax.inject。</li>\r</ul>\r\r<p>示例代码（TestService）：</p>\r\r<pre class="brush:java;">\r@Service\rpublic class TestService {\r\r    @Inject\r    TestRepository testRepository;\r\r    public TestRepository getTestRepository() {\r        return testRepository;\r    }\r\r    public void setTestRepository(TestRepository testRepository) {\r        this.testRepository = testRepository;\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1799, '@Autowired的其它加载方式', '1799', 1564013961, 1564013961, '<p>本文记录Java学习过程中遇到的@Autowired的其它加载方式～</p>\r<!--more-->\r\r<p>@Autowired的其它加载方式有：</p>\r\r<ul>\r	<li>方法加载；</li>\r	<li>方法内部的使用参数加载；</li>\r	<li>构造方法加载。</li>\r</ul>\r\r<p>示例代码（引用类）：</p>\r\r<pre class="brush:java;">\r@Component\rpublic class Sun {\r    \r    @Autowired\r    Moon moon;\r\r    @Autowired\r    public Sun(Moon moon) {\r        this.moon = moon;\r    }\r\r    public Moon getMoon() {\r        return moon;\r    }\r\r    @Autowired\r    public void setMoon(Moon moon) {\r        this.moon = moon;\r    }\r}</pre>\r\r<p>示例代码（被引用类）：</p>\r\r<pre class="brush:java;">\r@Component\rpublic class Moon {\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1800, 'Aware注入Spring组件自动装配原理', '1800', 1564014465, 1564014465, '<p>本文记录Java学习过程中遇到的Aware注入Spring组件自动装配原理～</p>\r<!--more-->\r\r<p>自定义组件想要使用Spring容器底层的组件（ApplicationContext, BeanFactory等等）可以通过实现xxxAware接口, 在创建对象的时候, 会调用接口规定的方法注入到相关组件。</p>\r\r<p>常见的Aware接口有：</p>\r\r<ul>\r	<li>ApplicationContextAware接口: 获取IOC容器；</li>\r	<li>BeanNameAware接口: 获取BeanName信息；</li>\r	<li>EmbeddedValueResolverAware接口: 解析器(表达式及相关脚本解析)。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Component\rpublic class Light implements ApplicationContextAware, BeanNameAware, EmbeddedValueResolverAware {\r\r    ApplicationContext applicationContext;\r\r    @Override\r    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\r        this.applicationContext = applicationContext;\r    }\r\r    @Override\r    public void setBeanName(String name) {\r        System.out.println(name);\r    }\r\r    @Override\r    public void setEmbeddedValueResolver(StringValueResolver resolver) {\r        System.out.println(resolver.resolveStringValue(&quot;${os.name}, #{3*8}&quot;));\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 6),
(1801, 'AOP简介与常用通知类型', '1801', 1565514480, 1570184063, '<p>本文记录Java学习过程中遇到的AOP简介与常用通知类型～</p>\r<!--more-->\r\r<p>AOP: 面向切面编程，底层就是动态代理，指程序在运行期间动态的将某段代码切入到指定方法位置进行运行的编程方式。</p>\r\r<p>AOP常用通知类型：</p>\r\r<ul>\r	<li>前置通知（@Before）：在目标方法运行之前运行；</li>\r	<li>后置通知（@After）：在目标方法运行结束之后运行，无论正常或异常结束；</li>\r	<li>返回通知（@AfterReturning）：在目标方法正常返回之后运行；</li>\r	<li>异常通知（@AfterThrowing）：在目标方法出现异常后运行；</li>\r	<li>环绕通知（@Around）：最底层通知，手动指定执行目标方法。</li>\r</ul>\r\r<p>示例代码（业务类）：</p>\r\r<pre class="brush:java;">\rpublic class Calculator {\r    // 业务逻辑方法\r    public int div(int i, int j){\r        return i/j;\r    }\r}</pre>\r\r<p>示例代码（切面类）：</p>\r\r<pre class="brush:java;">\r@Aspect\rpublic class LogAspects {\r\r    @Pointcut(&quot;execution(public int ren.oliver.spring.cap10.domain.Calculator.*(..))&quot;)\r    public void pointCut(){}\r\r    @Before(&quot;pointCut()&quot;)\r    public void logStart(JoinPoint joinPoint){\r        System.out.println(&quot;logStart()&quot;);\r        System.out.println(&quot;方法名称是：&quot; + joinPoint.getSignature().getName());\r        System.out.println(&quot;参数列表是：&quot; + Arrays.asList(joinPoint.getArgs()));\r    }\r\r    @After(&quot;pointCut()&quot;)\r    public void logEnd(JoinPoint joinPoint){\r        System.out.println(&quot;logEnd()&quot;);\r        System.out.println(&quot;方法名称是：&quot; + joinPoint.getSignature().getName());\r        System.out.println(&quot;参数列表是：&quot; + Arrays.asList(joinPoint.getArgs()));\r    }\r\r    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)\r    public void logReturn(Object result){\r        System.out.println(&quot;logReturn()&quot;);\r        System.out.println(&quot;返回结果是：&quot; + result);\r    }\r\r    @AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;exception&quot;)\r    public void logException(Exception exception){\r        System.out.println(&quot;logException()&quot;);\r        System.out.println(&quot;异常信息是：&quot; + exception.getMessage());\r    }\r\r    @Around(&quot;pointCut()&quot;)\r    public Object Around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{\r        System.out.println(&quot;@Arount:执行目标方法之前&quot;);\r        // 相当于调用对应的业务方法\r        Object obj = null;\r        try {\r            obj = proceedingJoinPoint.proceed();\r        } catch (Exception e) {\r            e.printStackTrace();\r        }\r        System.out.println(&quot;@Arount:执行目标方法之后&quot;);\r        if (obj == null) {\r            obj = -1;\r        }\r        return obj;\r    }\r}</pre>\r\r<p>示例代码（配置类）：</p>\r\r<pre class="brush:java;">\r@Configuration\r@EnableAspectJAutoProxy\rpublic class MainConfig {\r    @Bean\r    public Calculator calculator() {\r        return new Calculator();\r    }\r\r    @Bean\r    public LogAspects logAspects() {\r        return new LogAspects();\r    }\r}</pre>\r\r<p>示例代码（测试类）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app;\r        app = new AnnotationConfigApplicationContext(MainConfig.class);\r        System.out.println(&quot;IOC容器创建完成&quot;);\r        Calculator calculator = app.getBean(Calculator.class);\r        System.out.println(&quot;正常测试开始&quot;);\r        calculator.div(1, 1);\r        System.out.println(&quot;正常测试结束&quot;);\r        System.out.println(&quot;异常测试开始&quot;);\r        calculator.div(1, 0);\r        System.out.println(&quot;异常测试结束&quot;);\r        app.close();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1802, 'AOP源码分析（一）——开启AOP注解', '1802', 1565747144, 1565747144, '<p>本文记录Java学习过程中遇到的AOP源码分析（一）&mdash;&mdash;开启AOP注解～</p>\r<!--more-->\r\r<p>AOP使用前需要先打开开关，即@EnableAspectJAutoProxy注解。</p>\r\r<p>源码分析（@EnableAspectJAutoProxy）：</p>\r\r<pre class="brush:java;">\r@Target(ElementType.TYPE)\r@Retention(RetentionPolicy.RUNTIME)\r@Documented\r// 引入AspectJAutoProxyRegistrar组件\r@Import(AspectJAutoProxyRegistrar.class)\rpublic @interface EnableAspectJAutoProxy {\r	/**\r	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed\r	 * to standard Java interface-based proxies. The default is {@code false}.\r	 */\r	// 代理的方式：JDK动态代理（实现接口）或者CGLIB代理（继承实现）\r	boolean proxyTargetClass() default false;\r\r	/**\r	 * Indicate that the proxy should be exposed by the AOP framework as a {@code ThreadLocal}\r	 * for retrieval via the {@link org.springframework.aop.framework.AopContext} class.\r	 * Off by default, i.e. no guarantees that {@code AopContext} access will work.\r	 * @since 4.3.1\r	 */\r	// 是否要暴露代理对象，即AopContext能否被访问\r	boolean exposeProxy() default false;\r}</pre>\r\r<p>源码分析（AspectJAutoProxyRegistrar）：</p>\r\r<pre class="brush:java;">\rclass AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {\r	/**\r	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value\r	 * of the @{@link EnableAspectJAutoProxy#proxyTargetClass()} attribute on the importing\r	 * {@code @Configuration} class.\r	 */\r	@Override\r	public void registerBeanDefinitions(\r			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\r		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);\r		AnnotationAttributes enableAspectJAutoProxy =\r				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);\r		if (enableAspectJAutoProxy != null) {\r			if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) {\r				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\r			}\r			if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) {\r				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);\r			}\r		}\r	}\r}</pre>\r\r<p>源码分析（AopConfigUtils相关部分）：</p>\r\r<pre class="brush:java;">\r@Nullable\rpublic static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) {\r	return registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, null);\r}\r\r@Nullable\rpublic static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry,\r		@Nullable Object source) {\r	return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);\r}\r\rpublic static final String AUTO_PROXY_CREATOR_BEAN_NAME = 	&quot;org.springframework.aop.config.internalAutoProxyCreator&quot;;\r\r@Nullable\rprivate static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry,\r		@Nullable Object source) {\r\r	Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);\r\r	if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\r		BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\r		if (!cls.getName().equals(apcDefinition.getBeanClassName())) {\r			int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());\r			int requiredPriority = findPriorityForClass(cls);\r			if (currentPriority &lt; requiredPriority) {\r				apcDefinition.setBeanClassName(cls.getName());\r			}\r		}\r		return null;\r	}\r\r	// 进行Bean的定义，并不是把Bean创建好\r	RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);\r	beanDefinition.setSource(source);\r	// 添加Order的顺序为最高\r	beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);\r	beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\r	registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);\r	return beanDefinition;\r}</pre>\r\r<p>总结，开关就是将AOP的核心类的Bean定义注入到了IOC，但并没有创建Bean。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1803, 'AnnotationAwareAspectJAutoProxyCreator.png', 'AnnotationAwareAspectJAutoProxyCreator-png', 1565829765, 1565829765, 'a:5:{s:4:"name";s:42:"AnnotationAwareAspectJAutoProxyCreator.png";s:4:"path";s:35:"/usr/uploads/2019/08/1922088874.png";s:4:"size";i:131829;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1804, 0),
(1804, 'AOP源码分析（二）——核心类AnnotationAwareAspectJAutoProxyCreator', '1804', 1565829780, 1565829780, '<p>本文记录Java学习过程中遇到的AOP源码分析（二）&mdash;&mdash;核心类AnnotationAwareAspectJAutoProxyCreator～</p>\r<!--more-->\r\r<p>AnnotationAwareAspectJAutoProxyCreator的继承实现关系如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/08/1922088874.png" style="width: 800px; height: 380px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1805, 'AOP源码分析（三）——AnnotationAwareAspectJAutoProxyCreator实例化', '1805', 1566111636, 1566111636, '<p>本文记录Java学习过程中遇到的AOP源码分析（三）&mdash;&mdash;AnnotationAwareAspectJAutoProxyCreator实例化～</p>\r<!--more-->\r\r<p>AOP核心其实就是创建AnnotationAwareAspectJAutoProxyCreator类（后置处理器），该类最终实现的接口为BeanPostProcessor类；其它bean组件的创建的时候都会会被AnnotationAwareAspectJAutoProxyCreator的后置处理器拦截，拦截到创建过程。</p>\r\r<p>源码分析（AnnotationConfigApplicationContext类的构造函数）：</p>\r\r<pre class="brush:java;">\r/**\r * Create a new AnnotationConfigApplicationContext, deriving bean definitions\r * from the given annotated classes and automatically refreshing the context.\r * @param annotatedClasses one or more annotated classes,\r * e.g. {@link Configuration @Configuration} classes\r */\rpublic AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {\r	this();\r	register(annotatedClasses);\r	// 刷新或者创建Spring容器\r	refresh();\r}</pre>\r\r<p>源码分析（AbstractApplicationContext的refresh()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic void refresh() throws BeansException, IllegalStateException {\r	synchronized (this.startupShutdownMonitor) {\r		// Prepare this context for refreshing.\r		prepareRefresh();\r\r		// Tell the subclass to refresh the internal bean factory.\r		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\r\r		// Prepare the bean factory for use in this context.\r		prepareBeanFactory(beanFactory);\r\r		try {\r			// Allows post-processing of the bean factory in context subclasses.\r			postProcessBeanFactory(beanFactory);\r\r			// 会进行AnnotationAwareAspectJAutoProxyCreator的定义，即AOP源码分析（一）中的定义\r			// Invoke factory processors registered as beans in the context.\r			invokeBeanFactoryPostProcessors(beanFactory);\r\r			// 注册AnnotationAwareAspectJAutoProxyCreator的后置处理器来方便拦截Bean的创建\r			// Register bean processors that intercept bean creation.\r			registerBeanPostProcessors(beanFactory);\r\r			// Initialize message source for this context.\r			initMessageSource();\r\r			// Initialize event multicaster for this context.\r			initApplicationEventMulticaster();\r\r			// Initialize other special beans in specific context subclasses.\r			onRefresh();\r\r			// Check for listener beans and register them.\r			registerListeners();\r\r			// Instantiate all remaining (non-lazy-init) singletons.\r			finishBeanFactoryInitialization(beanFactory);\r\r			// Last step: publish corresponding event.\r			finishRefresh();\r		}\r\r		catch (BeansException ex) {\r			if (logger.isWarnEnabled()) {\r				logger.warn(&quot;Exception encountered during context initialization - &quot; +\r						&quot;cancelling refresh attempt: &quot; + ex);\r			}\r\r			// Destroy already created singletons to avoid dangling resources.\r			destroyBeans();\r\r			// Reset &#39;active&#39; flag.\r			cancelRefresh(ex);\r\r			// Propagate exception to caller.\r			throw ex;\r		}\r\r		finally {\r			// Reset common introspection caches in Spring&#39;s core, since we\r			// might not ever need metadata for singleton beans anymore...\r			resetCommonCaches();\r		}\r	}\r}</pre>\r\r<p>源码分析（AbstractApplicationContext的registerBeanPostProcessors()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Instantiate and invoke all registered BeanPostProcessor beans,\r * respecting explicit order if given.\r * &lt;p&gt;Must be called before any instantiation of application beans.\r */\rprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\r	PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\r}</pre>\r\r<p>源码分析（PostProcessorRegistrationDelegate的registerBeanPostProcessors()方法）：</p>\r\r<pre class="brush:java;">\rpublic static void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\r	// 获取IOC容器已经定义了需要创建对象的所有BeanPostProcessor（定义是在上一步invokeBeanFactoryPostProcessors(beanFactory)中定义的），接下来要讲所有定义过的BeanPostProcessor实例化\r	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\r\r	// Register BeanPostProcessorChecker that logs an info message when\r	// a bean is created during BeanPostProcessor instantiation, i.e. when\r	// a bean is not eligible for getting processed by all BeanPostProcessors.\r	int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\r	beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\r\r	// 将要创建的BeanPostProcessor分组，分三大组（priorityOrderedPostProcessors、orderedPostProcessorNames和nonOrderedPostProcessorNames），AnnotationAwareAspectJAutoProxyCreator属于orderedPostProcessorNames，并且优先级最高\r	// Separate between BeanPostProcessors that implement PriorityOrdered,\r	// Ordered, and the rest.\r	List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();\r	List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();\r	List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();\r	List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();\r	for (String ppName : postProcessorNames) {\r		if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\r			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\r			priorityOrderedPostProcessors.add(pp);\r			if (pp instanceof MergedBeanDefinitionPostProcessor) {\r				internalPostProcessors.add(pp);\r			}\r		}\r		else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\r			orderedPostProcessorNames.add(ppName);\r		}\r		else {\r			nonOrderedPostProcessorNames.add(ppName);\r		}\r	}\r\r	// 首先，注册实现了PriorityOrdered接口的BeanPostProcessor\r	// First, register the BeanPostProcessors that implement PriorityOrdered.\r	// 先排序下\r	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\r	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\r\r	// 然后，注册实现了Ordered接口的BeanPostProcessor，AnnotationAwareAspectJAutoProxyCreator是实现了Ordered接口的\r	// Next, register the BeanPostProcessors that implement Ordered.\r	List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();\r	for (String ppName : orderedPostProcessorNames) {\r		// 在这一步创建对应的BeanPostProcessor\r		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\r		orderedPostProcessors.add(pp);\r		if (pp instanceof MergedBeanDefinitionPostProcessor) {\r			internalPostProcessors.add(pp);\r		}\r	}\r	sortPostProcessors(orderedPostProcessors, beanFactory);\r	// 将创建的PostProcessor注册到beanFactory，AOP核心对象创建完成\r	registerBeanPostProcessors(beanFactory, orderedPostProcessors);\r\r	// 再然后，注册没实现优先级接口的剩下的所有BeanPostProcessor\r	// Now, register all regular BeanPostProcessors.\r	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();\r	for (String ppName : nonOrderedPostProcessorNames) {\r		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\r		nonOrderedPostProcessors.add(pp);\r		if (pp instanceof MergedBeanDefinitionPostProcessor) {\r			internalPostProcessors.add(pp);\r		}\r	}\r	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\r\r	// 最后，重新再注册一遍内部的PostProcessor\r	// Finally, re-register all internal BeanPostProcessors.\r	sortPostProcessors(internalPostProcessors, beanFactory);\r	registerBeanPostProcessors(beanFactory, internalPostProcessors);\r\r	// Re-register post-processor for detecting inner beans as ApplicationListeners,\r	// moving it to the end of the processor chain (for picking up proxies etc).\r	beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\r}</pre>\r\r<p>源码分析（AbstractBeanFactory的getBean()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Return an instance, which may be shared or independent, of the specified bean.\r * @param name the name of the bean to retrieve\r * @param requiredType the required type of the bean to retrieve\r * @param args arguments to use when creating a bean instance using explicit arguments\r * (only applied when creating a new instance as opposed to retrieving an existing one)\r * @return an instance of the bean\r * @throws BeansException if the bean could not be created\r */\rpublic &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object... args) throws BeansException {\r	return doGetBean(name, requiredType, args, false);\r}\r\r/**\r * Return an instance, which may be shared or independent, of the specified bean.\r * @param name the name of the bean to retrieve\r * @param requiredType the required type of the bean to retrieve\r * @param args arguments to use when creating a bean instance using explicit arguments\r * (only applied when creating a new instance as opposed to retrieving an existing one)\r * @param typeCheckOnly whether the instance is obtained for a type check,\r * not for actual use\r * @return an instance of the bean\r * @throws BeansException if the bean could not be created\r */\r@SuppressWarnings(&quot;unchecked&quot;)\rprotected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,\r		@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\r\r	final String beanName = transformedBeanName(name);\r	Object bean;\r\r	// Eagerly check singleton cache for manually registered singletons.\r	Object sharedInstance = getSingleton(beanName);\r	if (sharedInstance != null &amp;&amp; args == null) {\r		if (logger.isDebugEnabled()) {\r			if (isSingletonCurrentlyInCreation(beanName)) {\r				logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +\r						&quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);\r			}\r			else {\r				logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);\r			}\r		}\r		bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\r	}\r\r	else {\r		// Fail if we&#39;re already creating this bean instance:\r		// We&#39;re assumably within a circular reference.\r		if (isPrototypeCurrentlyInCreation(beanName)) {\r			throw new BeanCurrentlyInCreationException(beanName);\r		}\r\r		// Check if bean definition exists in this factory.\r		BeanFactory parentBeanFactory = getParentBeanFactory();\r		if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\r			// Not found -&gt; check parent.\r			String nameToLookup = originalBeanName(name);\r			if (parentBeanFactory instanceof AbstractBeanFactory) {\r				return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\r						nameToLookup, requiredType, args, typeCheckOnly);\r			}\r			else if (args != null) {\r				// Delegation to parent with explicit args.\r				return (T) parentBeanFactory.getBean(nameToLookup, args);\r			}\r			else {\r				// No args -&gt; delegate to standard getBean method.\r				return parentBeanFactory.getBean(nameToLookup, requiredType);\r			}\r		}\r\r		if (!typeCheckOnly) {\r			markBeanAsCreated(beanName);\r		}\r\r		try {\r			final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\r			checkMergedBeanDefinition(mbd, beanName, args);\r\r			// Guarantee initialization of beans that the current bean depends on.\r			String[] dependsOn = mbd.getDependsOn();\r			if (dependsOn != null) {\r				for (String dep : dependsOn) {\r					if (isDependent(beanName, dep)) {\r						throw new BeanCreationException(mbd.getResourceDescription(), beanName,\r								&quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\r					}\r					registerDependentBean(dep, beanName);\r					try {\r						getBean(dep);\r					}\r					catch (NoSuchBeanDefinitionException ex) {\r						throw new BeanCreationException(mbd.getResourceDescription(), beanName,\r								&quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);\r					}\r				}\r			}\r\r			// Create bean instance.\r			if (mbd.isSingleton()) {\r				// 调用了父类DefaultSingletonBeanRegistry的getSingleton()方法\r				sharedInstance = getSingleton(beanName, () -&gt; {\r					try {\r						// 第一次加载是没有sharedInstance这个bean的，会直接进行创建\r						return createBean(beanName, mbd, args);\r					}\r					catch (BeansException ex) {\r						// Explicitly remove instance from singleton cache: It might have been put there\r						// eagerly by the creation process, to allow for circular reference resolution.\r						// Also remove any beans that received a temporary reference to the bean.\r						destroySingleton(beanName);\r						throw ex;\r					}\r				});\r				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\r			}\r\r			else if (mbd.isPrototype()) {\r				// It&#39;s a prototype -&gt; create a new instance.\r				Object prototypeInstance = null;\r				try {\r					beforePrototypeCreation(beanName);\r					prototypeInstance = createBean(beanName, mbd, args);\r				}\r				finally {\r					afterPrototypeCreation(beanName);\r				}\r				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\r			}\r\r			else {\r				String scopeName = mbd.getScope();\r				final Scope scope = this.scopes.get(scopeName);\r				if (scope == null) {\r					throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);\r				}\r				try {\r					Object scopedInstance = scope.get(beanName, () -&gt; {\r						beforePrototypeCreation(beanName);\r						try {\r							return createBean(beanName, mbd, args);\r						}\r						finally {\r							afterPrototypeCreation(beanName);\r						}\r					});\r					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\r				}\r				catch (IllegalStateException ex) {\r					throw new BeanCreationException(beanName,\r							&quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +\r							&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,\r							ex);\r				}\r			}\r		}\r		catch (BeansException ex) {\r			cleanupAfterBeanCreationFailure(beanName);\r			throw ex;\r		}\r	}\r\r	// Check if required type matches the type of the actual bean instance.\r	if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {\r		try {\r			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\r			if (convertedBean == null) {\r				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\r			}\r			return convertedBean;\r		}\r		catch (TypeMismatchException ex) {\r			if (logger.isDebugEnabled()) {\r				logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +\r						ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);\r			}\r			throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\r		}\r	}\r	return (T) bean;\r}</pre>\r\r<p>源码分析（DefaultSingletonBeanRegistry的getSingleton()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Return the (raw) singleton object registered under the given name,\r * creating and registering a new one if none registered yet.\r * @param beanName the name of the bean\r * @param singletonFactory the ObjectFactory to lazily create the singleton\r * with, if necessary\r * @return the registered singleton object\r */\rpublic Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {\r	Assert.notNull(beanName, &quot;Bean name must not be null&quot;);\r	synchronized (this.singletonObjects) {\r		Object singletonObject = this.singletonObjects.get(beanName);\r		if (singletonObject == null) {\r			if (this.singletonsCurrentlyInDestruction) {\r				throw new BeanCreationNotAllowedException(beanName,\r						&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +\r						&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);\r			}\r			if (logger.isDebugEnabled()) {\r				logger.debug(&quot;Creating shared instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);\r			}\r			beforeSingletonCreation(beanName);\r			boolean newSingleton = false;\r			boolean recordSuppressedExceptions = (this.suppressedExceptions == null);\r			if (recordSuppressedExceptions) {\r				this.suppressedExceptions = new LinkedHashSet&lt;&gt;();\r			}\r			try {\r				// 获取Bean，第一次肯定拿不到\r				singletonObject = singletonFactory.getObject();\r				newSingleton = true;\r			}\r			catch (IllegalStateException ex) {\r				// Has the singleton object implicitly appeared in the meantime -&gt;\r				// if yes, proceed with it since the exception indicates that state.\r				singletonObject = this.singletonObjects.get(beanName);\r				if (singletonObject == null) {\r					throw ex;\r				}\r			}\r			catch (BeanCreationException ex) {\r				if (recordSuppressedExceptions) {\r					for (Exception suppressedException : this.suppressedExceptions) {\r						ex.addRelatedCause(suppressedException);\r					}\r				}\r				throw ex;\r			}\r			finally {\r				if (recordSuppressedExceptions) {\r					this.suppressedExceptions = null;\r				}\r				afterSingletonCreation(beanName);\r			}\r			if (newSingleton) {\r				// 将初始化创建好的Bean放到singletonObjects的Map中，完成Bean初始化及创建\r				addSingleton(beanName, singletonObject);\r			}\r		}\r		return singletonObject;\r	}\r}</pre>\r\r<p>源码分析（AbstractAutowireCapableBeanFactory的createBean()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Central method of this class: creates a bean instance,\r * populates the bean instance, applies post-processors, etc.\r * @see #doCreateBean\r */\r@Override\rprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\r		throws BeanCreationException {\r\r	if (logger.isDebugEnabled()) {\r		logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\r	}\r	RootBeanDefinition mbdToUse = mbd;\r\r	// Make sure bean class is actually resolved at this point, and\r	// clone the bean definition in case of a dynamically resolved Class\r	// which cannot be stored in the shared merged bean definition.\r	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);\r	if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {\r		mbdToUse = new RootBeanDefinition(mbd);\r		mbdToUse.setBeanClass(resolvedClass);\r	}\r\r	// Prepare method overrides.\r	try {\r		mbdToUse.prepareMethodOverrides();\r	}\r	catch (BeanDefinitionValidationException ex) {\r		throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\r				beanName, &quot;Validation of method overrides failed&quot;, ex);\r	}\r\r	try {\r		// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\r		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\r		if (bean != null) {\r			return bean;\r		}\r	}\r	catch (Throwable ex) {\r		throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\r				&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);\r	}\r\r	try {\r		// 真正的创建Bean实例\r		Object beanInstance = doCreateBean(beanName, mbdToUse, args);\r		if (logger.isDebugEnabled()) {\r			logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\r		}\r		return beanInstance;\r	}\r	catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\r		// A previously detected exception with proper bean creation context already,\r		// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\r		throw ex;\r	}\r	catch (Throwable ex) {\r		throw new BeanCreationException(\r				mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);\r	}\r}</pre>\r\r<p>源码分析（AbstractAutowireCapableBeanFactory的doCreateBean()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Actually create the specified bean. Pre-creation processing has already happened\r * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\r * &lt;p&gt;Differentiates between default bean instantiation, use of a\r * factory method, and autowiring a constructor.\r * @param beanName the name of the bean\r * @param mbd the merged bean definition for the bean\r * @param args explicit arguments to use for constructor or factory method invocation\r * @return a new instance of the bean\r * @throws BeanCreationException if the bean could not be created\r * @see #instantiateBean\r * @see #instantiateUsingFactoryMethod\r * @see #autowireConstructor\r */\rprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\r		throws BeanCreationException {\r\r	// Instantiate the bean.\r	BeanWrapper instanceWrapper = null;\r	if (mbd.isSingleton()) {\r		instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\r	}\r	if (instanceWrapper == null) {\r		// 真正创建Bean实例\r		instanceWrapper = createBeanInstance(beanName, mbd, args);\r	}\r	final Object bean = instanceWrapper.getWrappedInstance();\r	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();\r	if (beanType != NullBean.class) {\r		mbd.resolvedTargetType = beanType;\r	}\r\r	// Allow post-processors to modify the merged bean definition.\r	synchronized (mbd.postProcessingLock) {\r		if (!mbd.postProcessed) {\r			try {\r				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\r			}\r			catch (Throwable ex) {\r				throw new BeanCreationException(mbd.getResourceDescription(), beanName,\r						&quot;Post-processing of merged bean definition failed&quot;, ex);\r			}\r			mbd.postProcessed = true;\r		}\r	}\r\r	// Eagerly cache singletons to be able to resolve circular references\r	// even when triggered by lifecycle interfaces like BeanFactoryAware.\r	boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\r			isSingletonCurrentlyInCreation(beanName));\r	if (earlySingletonExposure) {\r		if (logger.isDebugEnabled()) {\r			logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +\r					&quot;&#39; to allow for resolving potential circular references&quot;);\r		}\r		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\r	}\r\r	// Initialize the bean instance.\r	Object exposedObject = bean;\r	try {\r		// 给Bean的各种属性赋值\r		populateBean(beanName, mbd, instanceWrapper);\r		// 初始化Bean\r		exposedObject = initializeBean(beanName, exposedObject, mbd);\r	}\r	catch (Throwable ex) {\r		if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {\r			throw (BeanCreationException) ex;\r		}\r		else {\r			throw new BeanCreationException(\r					mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);\r		}\r	}\r\r	if (earlySingletonExposure) {\r		Object earlySingletonReference = getSingleton(beanName, false);\r		if (earlySingletonReference != null) {\r			if (exposedObject == bean) {\r				exposedObject = earlySingletonReference;\r			}\r			else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {\r				String[] dependentBeans = getDependentBeans(beanName);\r				Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);\r				for (String dependentBean : dependentBeans) {\r					if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\r						actualDependentBeans.add(dependentBean);\r					}\r				}\r				if (!actualDependentBeans.isEmpty()) {\r					throw new BeanCurrentlyInCreationException(beanName,\r							&quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +\r							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\r							&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +\r							&quot;wrapped. This means that said other beans do not use the final version of the &quot; +\r							&quot;bean. This is often the result of over-eager type matching - consider using &quot; +\r							&quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);\r				}\r			}\r		}\r	}\r\r	// Register bean as disposable.\r	try {\r		registerDisposableBeanIfNecessary(beanName, bean, mbd);\r	}\r	catch (BeanDefinitionValidationException ex) {\r		throw new BeanCreationException(\r				mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);\r	}\r\r	return exposedObject;\r}</pre>\r\r<p>源码分析（AbstractAutowireCapableBeanFactory的initializeBean()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Initialize the given bean instance, applying factory callbacks\r * as well as init methods and bean post processors.\r * &lt;p&gt;Called from {@link #createBean} for traditionally defined beans,\r * and from {@link #initializeBean} for existing bean instances.\r * @param beanName the bean name in the factory (for debugging purposes)\r * @param bean the new bean instance we may need to initialize\r * @param mbd the bean definition that the bean was created with\r * (can also be {@code null}, if given an existing bean instance)\r * @return the initialized bean instance (potentially wrapped)\r * @see BeanNameAware\r * @see BeanClassLoaderAware\r * @see BeanFactoryAware\r * @see #applyBeanPostProcessorsBeforeInitialization\r * @see #invokeInitMethods\r * @see #applyBeanPostProcessorsAfterInitialization\r */\rprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\r	if (System.getSecurityManager() != null) {\r		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\r			invokeAwareMethods(beanName, bean);\r			return null;\r		}, getAccessControlContext());\r	}\r	else {\r		// 调用实现Aware相关接口需要调用的方法\r		invokeAwareMethods(beanName, bean);\r	}\r\r	Object wrappedBean = bean;\r	if (mbd == null || !mbd.isSynthetic()) {\r		// 返回一个被包装的bean，也就是后置Before处理器调用\r		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\r	}\r\r	try {\r		// 执行初始化自定义方法\r		invokeInitMethods(beanName, wrappedBean, mbd);\r	}\r	catch (Throwable ex) {\r		throw new BeanCreationException(\r				(mbd != null ? mbd.getResourceDescription() : null),\r				beanName, &quot;Invocation of init method failed&quot;, ex);\r	}\r	if (mbd == null || !mbd.isSynthetic()) {\r		// 返回一个被包装的bean，也就是后置After处理器调用\r		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\r	}\r\r	return wrappedBean;\r}</pre>\r\r<p>源码分析（AbstractAutowireCapableBeanFactory的invokeAwareMethods()方法）：</p>\r\r<pre class="brush:java;">\rprivate void invokeAwareMethods(final String beanName, final Object bean) {\r	// 判断Bean对象是否实现了Aware接口，再看是哪个Aware来调用其回调函数\r	if (bean instanceof Aware) {\r		if (bean instanceof BeanNameAware) {\r			((BeanNameAware) bean).setBeanName(beanName);\r		}\r		if (bean instanceof BeanClassLoaderAware) {\r			ClassLoader bcl = getBeanClassLoader();\r			if (bcl != null) {\r				((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\r			}\r		}\r		if (bean instanceof BeanFactoryAware) {\r			// 放入BeanFactory对象\r			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\r		}\r	}\r}</pre>\r\r<p>源码分析（AbstractAdvisorAutoProxyCreator的setBeanFactory()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic void setBeanFactory(BeanFactory beanFactory) {\r	// 调用父类的setBeanFactory()方法\r	super.setBeanFactory(beanFactory);\r	if (!(beanFactory instanceof ConfigurableListableBeanFactory)) {\r		throw new IllegalArgumentException(\r				&quot;AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: &quot; + beanFactory);\r	}\r	// 初始化BeanFactory\r	initBeanFactory((ConfigurableListableBeanFactory) beanFactory);\r}</pre>\r\r<p>源码分析（AnnotationAwareAspectJAutoProxyCreator的initBeanFactory()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rprotected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) {\r	super.initBeanFactory(beanFactory);\r	if (this.aspectJAdvisorFactory == null) {\r		// 创建了ReflectiveAspectJAdvisorFactory反射机制，相当于把aspectJAdvisorFactor对象通知工厂\r		this.aspectJAdvisorFactory = new ReflectiveAspectJAdvisorFactory(beanFactory);\r	}\r	// 通知适配器，相当于aspectJAdvisorFacotr通知到构建器的适配器，把aspectJAdvisorFactory重新包装了一下\r	this.aspectJAdvisorsBuilder =\r			new BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, this.aspectJAdvisorFactory);\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1806, 'AOP源码分析（四）——被代理对象的实例化过程', '1806', 1566139488, 1566139488, '<p>本文记录Java学习过程中遇到的AOP源码分析（四）&mdash;&mdash;被代理对象的实例化过程～</p>\r<!--more-->\r\r<p>AnnotationAwareAspectJAutoProxyCreator后置处理器创建成功后，以后创建其他组件的时候就可以拦截创建过程。</p>\r\r<p>源码分析（AnnotationConfigApplicationContext的构造方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Create a new AnnotationConfigApplicationContext, deriving bean definitions\r * from the given annotated classes and automatically refreshing the context.\r * @param annotatedClasses one or more annotated classes,\r * e.g. {@link Configuration @Configuration} classes\r */\rpublic AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {\r	this();\r	register(annotatedClasses);\r	refresh();\r}</pre>\r\r<p>源码分析（AbstractApplicationContext的refresh()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic void refresh() throws BeansException, IllegalStateException {\r	synchronized (this.startupShutdownMonitor) {\r		// Prepare this context for refreshing.\r		prepareRefresh();\r\r		// Tell the subclass to refresh the internal bean factory.\r		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\r\r		// Prepare the bean factory for use in this context.\r		prepareBeanFactory(beanFactory);\r\r		try {\r			// Allows post-processing of the bean factory in context subclasses.\r			postProcessBeanFactory(beanFactory);\r\r			// Invoke factory processors registered as beans in the context.\r			invokeBeanFactoryPostProcessors(beanFactory);\r\r			// Register bean processors that intercept bean creation.\r			registerBeanPostProcessors(beanFactory);\r\r			// Initialize message source for this context.\r			initMessageSource();\r\r			// Initialize event multicaster for this context.\r			initApplicationEventMulticaster();\r\r			// Initialize other special beans in specific context subclasses.\r			onRefresh();\r\r			// Check for listener beans and register them.\r			registerListeners();\r\r			// 创建普通的单实例Bean\r			// Instantiate all remaining (non-lazy-init) singletons.\r			finishBeanFactoryInitialization(beanFactory);\r\r			// Last step: publish corresponding event.\r			finishRefresh();\r		}\r\r		catch (BeansException ex) {\r			if (logger.isWarnEnabled()) {\r				logger.warn(&quot;Exception encountered during context initialization - &quot; +\r						&quot;cancelling refresh attempt: &quot; + ex);\r			}\r\r			// Destroy already created singletons to avoid dangling resources.\r			destroyBeans();\r\r			// Reset &#39;active&#39; flag.\r			cancelRefresh(ex);\r\r			// Propagate exception to caller.\r			throw ex;\r		}\r\r		finally {\r			// Reset common introspection caches in Spring&#39;s core, since we\r			// might not ever need metadata for singleton beans anymore...\r			resetCommonCaches();\r		}\r	}\r}</pre>\r\r<p>源码分析（AbstractApplicationContext的finishBeanFactoryInitialization()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Finish the initialization of this context&#39;s bean factory,\r * initializing all remaining singleton beans.\r */\rprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\r	// Initialize conversion service for this context.\r	if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;\r			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\r		beanFactory.setConversionService(\r				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\r	}\r\r	// Register a default embedded value resolver if no bean post-processor\r	// (such as a PropertyPlaceholderConfigurer bean) registered any before:\r	// at this point, primarily for resolution in annotation attribute values.\r	if (!beanFactory.hasEmbeddedValueResolver()) {\r		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));\r	}\r\r	// 与AspectJ weaver相关的，暂时先不关注\r	// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\r	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\r	for (String weaverAwareName : weaverAwareNames) {\r		getBean(weaverAwareName);\r	}\r\r	// Stop using the temporary ClassLoader for type matching.\r	beanFactory.setTempClassLoader(null);\r\r	// Allow for caching all bean definition metadata, not expecting further changes.\r	beanFactory.freezeConfiguration();\r\r	// 真正的创建单实例的Bean，初始化剩下的单实例Bean，完成剩余Bean的创建\r	// Instantiate all remaining (non-lazy-init) singletons.\r	beanFactory.preInstantiateSingletons();\r}</pre>\r\r<p>源码分析（DefaultListableBeanFactory的preInstantiateSingletons()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic void preInstantiateSingletons() throws BeansException {\r	if (this.logger.isDebugEnabled()) {\r		this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);\r	}\r\r	// 获取容器中所有的Bean名称，依次进行初始化和创建对象\r	// Iterate over a copy to allow for init methods which in turn register new bean definitions.\r	// While this may not be part of the regular factory bootstrap, it does otherwise work fine.\r	List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);\r\r	// Trigger initialization of all non-lazy singleton beans...\r	for (String beanName : beanNames) {\r		// 拿到Bean的定义信息\r		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\r		// Bean不是抽象，是单例，不是懒加载\r		if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {\r			// 工厂模式，是否实现FactoryBean接口，是的话就调用FactoryBean的getObject来获取Bean\r			if (isFactoryBean(beanName)) {\r				Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);\r				if (bean instanceof FactoryBean) {\r					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;\r					boolean isEagerInit;\r					if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {\r						isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)\r										((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,\r								getAccessControlContext());\r					}\r					else {\r						isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;\r								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());\r					}\r					if (isEagerInit) {\r						getBean(beanName);\r					}\r				}\r			}\r			else {\r				// 生成单实例Bean的主要方法\r				getBean(beanName);\r			}\r		}\r	}\r\r	// 所有Bean都创建完后，触发初始化后置处理器的回调方法\r	// Trigger post-initialization callback for all applicable beans...\r	for (String beanName : beanNames) {\r		Object singletonInstance = getSingleton(beanName);\r		// 检查所有的Bean是否是SmartInitializingSingleton接口，如果是就执行afterSingletonsInstantiated()\r		if (singletonInstance instanceof SmartInitializingSingleton) {\r			final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\r			if (System.getSecurityManager() != null) {\r				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {\r					smartSingleton.afterSingletonsInstantiated();\r					return null;\r				}, getAccessControlContext());\r			}\r			else {\r				smartSingleton.afterSingletonsInstantiated();\r			}\r		}\r	}\r}</pre>\r\r<p>源码分析（AbstractBeanFactory的getBean()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic Object getBean(String name) throws BeansException {\r	return doGetBean(name, null, null, false);\r}</pre>\r\r<p>源码分析（AbstractBeanFactory的doGetBean()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Return an instance, which may be shared or independent, of the specified bean.\r * @param name the name of the bean to retrieve\r * @param requiredType the required type of the bean to retrieve\r * @param args arguments to use when creating a bean instance using explicit arguments\r * (only applied when creating a new instance as opposed to retrieving an existing one)\r * @param typeCheckOnly whether the instance is obtained for a type check,\r * not for actual use\r * @return an instance of the bean\r * @throws BeansException if the bean could not be created\r */\r@SuppressWarnings(&quot;unchecked&quot;)\rprotected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,\r		@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\r\r	final String beanName = transformedBeanName(name);\r	Object bean;\r\r	// 第一次获取先检查单实例的缓存中是否存在此Bean\r	// Eagerly check singleton cache for manually registered singletons.\r	Object sharedInstance = getSingleton(beanName);\r	if (sharedInstance != null &amp;&amp; args == null) {\r		if (logger.isDebugEnabled()) {\r			if (isSingletonCurrentlyInCreation(beanName)) {\r				logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +\r						&quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);\r			}\r			else {\r				logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);\r			}\r		}\r		// 如果缓存中有，就直接拿\r		bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\r	} else {\r		// Fail if we&#39;re already creating this bean instance:\r		// We&#39;re assumably within a circular reference.\r		if (isPrototypeCurrentlyInCreation(beanName)) {\r			throw new BeanCurrentlyInCreationException(beanName);\r		}\r\r		// Check if bean definition exists in this factory.\r		BeanFactory parentBeanFactory = getParentBeanFactory();\r		// Spring是否存在父子容器，没有父子工厂关系，直接跳过\r		if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\r			// Not found -&gt; check parent.\r			String nameToLookup = originalBeanName(name);\r			if (parentBeanFactory instanceof AbstractBeanFactory) {\r				return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\r						nameToLookup, requiredType, args, typeCheckOnly);\r			}\r			else if (args != null) {\r				// Delegation to parent with explicit args.\r				return (T) parentBeanFactory.getBean(nameToLookup, args);\r			}\r			else {\r				// No args -&gt; delegate to standard getBean method.\r				return parentBeanFactory.getBean(nameToLookup, requiredType);\r			}\r		}\r\r		if (!typeCheckOnly) {\r			// 标记当前Bean已经被创建，防止在多线程情况下，两个线程同时来创建一个Bean\r			markBeanAsCreated(beanName);\r		}\r\r		try {\r			// 获取Bean定义信息\r			final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\r			checkMergedBeanDefinition(mbd, beanName, args);\r\r			// 获取当前Bean依赖的其它Bean，如果有依赖的Bean就先把依赖的Bean创建出来\r			// Guarantee initialization of beans that the current bean depends on.\r			String[] dependsOn = mbd.getDependsOn();\r			if (dependsOn != null) {\r				for (String dep : dependsOn) {\r					if (isDependent(beanName, dep)) {\r						throw new BeanCreationException(mbd.getResourceDescription(), beanName,\r								&quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);\r					}\r					registerDependentBean(dep, beanName);\r					try {\r						getBean(dep);\r					}\r					catch (NoSuchBeanDefinitionException ex) {\r						throw new BeanCreationException(mbd.getResourceDescription(), beanName,\r								&quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);\r					}\r				}\r			}\r\r			// 如果Bean是单实例的，进行创建\r			// Create bean instance.\r			if (mbd.isSingleton()) {\r				sharedInstance = getSingleton(beanName, () -&gt; {\r					try {\r						// 真正的创建Bean\r						return createBean(beanName, mbd, args);\r					}\r					catch (BeansException ex) {\r						// Explicitly remove instance from singleton cache: It might have been put there\r						// eagerly by the creation process, to allow for circular reference resolution.\r						// Also remove any beans that received a temporary reference to the bean.\r						destroySingleton(beanName);\r						throw ex;\r					}\r				});\r				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\r			}\r\r			else if (mbd.isPrototype()) {\r				// It&#39;s a prototype -&gt; create a new instance.\r				Object prototypeInstance = null;\r				try {\r					beforePrototypeCreation(beanName);\r					prototypeInstance = createBean(beanName, mbd, args);\r				}\r				finally {\r					afterPrototypeCreation(beanName);\r				}\r				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\r			}\r\r			else {\r				String scopeName = mbd.getScope();\r				final Scope scope = this.scopes.get(scopeName);\r				if (scope == null) {\r					throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);\r				}\r				try {\r					Object scopedInstance = scope.get(beanName, () -&gt; {\r						beforePrototypeCreation(beanName);\r						try {\r							return createBean(beanName, mbd, args);\r						}\r						finally {\r							afterPrototypeCreation(beanName);\r						}\r					});\r					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\r				}\r				catch (IllegalStateException ex) {\r					throw new BeanCreationException(beanName,\r							&quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +\r							&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,\r							ex);\r				}\r			}\r		}\r		catch (BeansException ex) {\r			cleanupAfterBeanCreationFailure(beanName);\r			throw ex;\r		}\r	}\r\r	// Check if required type matches the type of the actual bean instance.\r	if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {\r		try {\r			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\r			if (convertedBean == null) {\r				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\r			}\r			return convertedBean;\r		}\r		catch (TypeMismatchException ex) {\r			if (logger.isDebugEnabled()) {\r				logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +\r						ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);\r			}\r			throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\r		}\r	}\r	return (T) bean;\r}</pre>\r\r<p>源码分析（AbstractAutowireCapableBeanFactory的createBean()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Central method of this class: creates a bean instance,\r * populates the bean instance, applies post-processors, etc.\r * @see #doCreateBean\r */\r@Override\rprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\r		throws BeanCreationException {\r\r	if (logger.isDebugEnabled()) {\r		logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\r	}\r	// 要创建Bean的信息：比如，Bean的类型以及是否单实例等\r	RootBeanDefinition mbdToUse = mbd;\r\r	// Make sure bean class is actually resolved at this point, and\r	// clone the bean definition in case of a dynamically resolved Class\r	// which cannot be stored in the shared merged bean definition.\r	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);\r	if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {\r		mbdToUse = new RootBeanDefinition(mbd);\r		mbdToUse.setBeanClass(resolvedClass);\r	}\r\r	// Prepare method overrides.\r	try {\r		mbdToUse.prepareMethodOverrides();\r	}\r	catch (BeanDefinitionValidationException ex) {\r		throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\r				beanName, &quot;Validation of method overrides failed&quot;, ex);\r	}\r\r	try {\r		// 希望后置处理器能再次返回一个代理对象，能返回就直接用（普通的Bean是null）\r		// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\r		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\r		if (bean != null) {\r			return bean;\r		}\r	}\r	catch (Throwable ex) {\r		throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\r				&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);\r	}\r\r	try {\r		Object beanInstance = doCreateBean(beanName, mbdToUse, args);\r		if (logger.isDebugEnabled()) {\r			logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\r		}\r		return beanInstance;\r	}\r	catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\r		// A previously detected exception with proper bean creation context already,\r		// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\r		throw ex;\r	}\r	catch (Throwable ex) {\r		throw new BeanCreationException(\r				mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);\r	}\r}</pre>\r\r<p>源码分析（AbstractAutowireCapableBeanFactory的resolveBeforeInstantiation()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Apply before-instantiation post-processors, resolving whether there is a\r * before-instantiation shortcut for the specified bean.\r * @param beanName the name of the bean\r * @param mbd the bean definition for the bean\r * @return the shortcut-determined bean instance, or {@code null} if none\r */\r@Nullable\rprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\r	Object bean = null;\r	// 提前拿到mbd的Bean定义信息，看是否被提前解析过了\r	if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\r		// Make sure bean class is actually resolved at this point.\r		if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\r			Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);\r			if (targetType != null) {\r				// 拿到所有的后置前处理器并遍历执行\r				bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\r				if (bean != null) {\r					// 拿到所有的后置后处理器并遍历执行\r					bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\r				}\r			}\r		}\r		mbd.beforeInstantiationResolved = (bean != null);\r	}\r	return bean;\r}</pre>\r\r<p>源码分析（AbstractAutowireCapableBeanFactory的applyBeanPostProcessorsBeforeInstantiation()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Apply InstantiationAwareBeanPostProcessors to the specified bean definition\r * (by class and name), invoking their {@code postProcessBeforeInstantiation} methods.\r * &lt;p&gt;Any returned object will be used as the bean instead of actually instantiating\r * the target bean. A {@code null} return value from the post-processor will\r * result in the target bean being instantiated.\r * @param beanClass the class of the bean to be instantiated\r * @param beanName the name of the bean\r * @return the bean object to use instead of a default instance of the target bean, or {@code null}\r * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\r */\r@Nullable\rprotected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {\r	for (BeanPostProcessor bp : getBeanPostProcessors()) {\r		// 如果是InstantiationAwareBeanPostProcessor类型就执行（AnnotationAwareBeanPostProcessor就是）\r		if (bp instanceof InstantiationAwareBeanPostProcessor) {\r			InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\r			Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);\r			if (result != null) {\r				return result;\r			}\r		}\r	}\r	return null;\r}</pre>\r\r<p>源码分析（AbstractAutoProxyCreator的postProcessBeforeInstantiation）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {\r	// 先拿到要AOP增强的Bean的名字\r	Object cacheKey = getCacheKey(beanClass, beanName);\r\r	if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {\r		// 已经增强的Bean是否包含当前的Bean，包含则直接返回null\r		if (this.advisedBeans.containsKey(cacheKey)) {\r			return null;\r		}\r		// isInfrastructureClass()：判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean或者是否是切面(@Aspect) \r		// shouldSkip()：是否跳过(不处理此Bean)\r		if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {\r			// 已经增强的Bean\r			this.advisedBeans.put(cacheKey, Boolean.FALSE);\r			return null;\r		}\r	}\r\r	// Create proxy here if we have a custom TargetSource.\r	// Suppresses unnecessary default instantiation of the target bean:\r	// The TargetSource will handle target instances in a custom fashion.\r	TargetSource targetSource = getCustomTargetSource(beanClass, beanName);\r	if (targetSource != null) {\r		if (StringUtils.hasLength(beanName)) {\r			this.targetSourcedBeans.add(beanName);\r		}\r		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);\r		Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);\r		this.proxyTypes.put(cacheKey, proxy.getClass());\r		return proxy;\r	}\r\r	return null;\r}</pre>\r\r<p>源码分析（AbstractAutoProxyCreator的isInfrastructureClass()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rprotected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {\r	// Previously we setProxyTargetClass(true) in the constructor, but that has too\r	// broad an impact. Instead we now override isInfrastructureClass to avoid proxying\r	// aspects. I&#39;m not entirely happy with that as there is no good reason not\r	// to advise aspects, except that it causes advice invocation to go through a\r	// proxy, and if the aspect implements e.g the Ordered interface it will be\r	// proxied by that interface and fail at runtime as the advice method is not\r	// defined on the interface. We could potentially relax the restriction about\r	// not advising aspects in the future.\r	// 不是切面aspect，返回false\r	return (super.isInfrastructureClass(beanClass) || (this.aspectJAdvisorFactory != null &amp;&amp; this.aspectJAdvisorFactory.isAspect(beanClass)));\r}</pre>\r\r<p>源码分析（AbstractAutoProxyCreator的shouldSkip()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rprotected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) {\r	// TODO: Consider optimization by caching the list of the aspect names\r	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();\r	for (Advisor advisor : candidateAdvisors) {\r		// 判断增强是否为AspectJPointcutAdvisor，明显不是，返回false\r		if (advisor instanceof AspectJPointcutAdvisor &amp;&amp; ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {\r			return true;\r		}\r	}\r	// 直接调用父类，返回false\r	return super.shouldSkip(beanClass, beanName);\r}</pre>\r\r<p>源码分析（AbstractAutoProxyCreator的postProcessAfterInitialization(）方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Create a proxy with the configured interceptors if the bean is\r * identified as one to proxy by the subclass.\r * @see #getAdvicesAndAdvisorsForBean\r */\r@Override\rpublic Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException {\r	if (bean != null) {\r		// 拿到Bean的名字\r		Object cacheKey = getCacheKey(bean.getClass(), beanName);\r		// 看之前有没有代理过\r		if (!this.earlyProxyReferences.contains(cacheKey)) {\r			// 如果需要的情况下进行包装\r			return wrapIfNecessary(bean, beanName, cacheKey);\r		}\r	}\r	return bean;\r}</pre>\r\r<p>源码分析（AbstractAutoProxyCreator的wrapIfNecessary()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.\r * @param bean the raw bean instance\r * @param beanName the name of the bean\r * @param cacheKey the cache key for metadata access\r * @return a proxy wrapping the bean, or the raw bean instance as-is\r */\rprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\r	if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) {\r		return bean;\r	}\r	// 看增强过的Bean有没有对应的Bean，返回false\r	if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\r		return bean;\r	}\r	// 看是不是基础类型，是不是切面\r	if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\r		this.advisedBeans.put(cacheKey, Boolean.FALSE);\r		return bean;\r	}\r\r	// 创建一个代理对象，获取当前Bean的增强器\r	// Create proxy if we have advice.\r	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\r	// 如果这个Bean有增强器，就不为空\r	if (specificInterceptors != DO_NOT_PROXY) {\r		// 把当前已经增强过的Bean保存到advisedBeans中\r		this.advisedBeans.put(cacheKey, Boolean.TRUE);\r		// 如果当前Bean需要增强，创建当前Bean的代理对象\r		Object proxy = createProxy(\r				bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\r		this.proxyTypes.put(cacheKey, proxy.getClass());\r		return proxy;\r	}\r\r	this.advisedBeans.put(cacheKey, Boolean.FALSE);\r	return bean;\r}</pre>\r\r<p>源码分析（AbstractAdvisorAutoProxyCreator的getAdvicesAndAdvisorsForBean()方法）：</p>\r\r<pre class="brush:java;">\r@Override\r@Nullable\rprotected Object[] getAdvicesAndAdvisorsForBean(\r		Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {\r	// 查找所有可用的增强器\r	List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);\r	if (advisors.isEmpty()) {\r		return DO_NOT_PROXY;\r	}\r	return advisors.toArray();\r}</pre>\r\r<p>源码分析（AbstractAdvisorAutoProxyCreator的findEligibleAdvisors()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Find all eligible Advisors for auto-proxying this class.\r * @param beanClass the clazz to find advisors for\r * @param beanName the name of the currently proxied bean\r * @return the empty List, not {@code null},\r * if there are no pointcuts or interceptors\r * @see #findCandidateAdvisors\r * @see #sortAdvisors\r * @see #extendAdvisors\r */\rprotected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {\r	// 找到候选的增强器\r	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();\r	// 找到候选的所有的增强器（找哪些通知方法是需要切入当前Bean方法的）\r	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\r	extendAdvisors(eligibleAdvisors);\r	if (!eligibleAdvisors.isEmpty()) {\r		eligibleAdvisors = sortAdvisors(eligibleAdvisors);\r	}\r	return eligibleAdvisors;\r}</pre>\r\r<p>源码分析（AbstractAdvisorAutoProxyCreator的findAdvisorsThatCanApply()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Search the given candidate Advisors to find all Advisors that\r * can apply to the specified bean.\r * @param candidateAdvisors the candidate Advisors\r * @param beanClass the target&#39;s bean class\r * @param beanName the target&#39;s bean name\r * @return the List of applicable Advisors\r * @see ProxyCreationContext#getCurrentProxiedBeanName()\r */\rprotected List&lt;Advisor&gt; findAdvisorsThatCanApply(\r		List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) {\r\r	// 设置当前的BeanName\r	ProxyCreationContext.setCurrentProxiedBeanName(beanName);\r	try {\r		// 重点关注下此方法\r		return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);\r	}\r	finally {\r		ProxyCreationContext.setCurrentProxiedBeanName(null);\r	}\r}</pre>\r\r<p>源码分析（AopUtils的findAdvisorsThatCanApply()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Determine the sublist of the {@code candidateAdvisors} list\r * that is applicable to the given class.\r * @param candidateAdvisors the Advisors to evaluate\r * @param clazz the target class\r * @return sublist of Advisors that can apply to an object of the given class\r * (may be the incoming List as-is)\r */\rpublic static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {\r	if (candidateAdvisors.isEmpty()) {\r		return candidateAdvisors;\r	}\r	// 先找到能用的增强器放到LinkedList里\r	List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;&gt;();\r	// 遍历所有增强器\r	for (Advisor candidate : candidateAdvisors) {\r		// 判断增强器是否为IntroductionAdvisor类型，明显不是\r		if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {\r			eligibleAdvisors.add(candidate);\r		}\r	}\r	boolean hasIntroductions = !eligibleAdvisors.isEmpty();\r	for (Advisor candidate : candidateAdvisors) {\r		// 判断增强器是否为IntroductionAdvisor类型，明显不是\r		if (candidate instanceof IntroductionAdvisor) {\r			// already processed\r			continue;\r		}\r		// 判断是否能用\r		if (canApply(candidate, clazz, hasIntroductions)) {\r			// 能用就加入eligibleAdvisors\r			eligibleAdvisors.add(candidate);\r		}\r	}\r	return eligibleAdvisors;\r}\r\r/**\r * Can the given advisor apply at all on the given class?\r * &lt;p&gt;This is an important test as it can be used to optimize out a advisor for a class.\r * This version also takes into account introductions (for IntroductionAwareMethodMatchers).\r * @param advisor the advisor to check\r * @param targetClass class we&#39;re testing\r * @param hasIntroductions whether or not the advisor chain for this bean includes\r * any introductions\r * @return whether the pointcut can apply on any method\r */\rpublic static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) {\r	if (advisor instanceof IntroductionAdvisor) {\r		return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\r	}\r	else if (advisor instanceof PointcutAdvisor) {\r		PointcutAdvisor pca = (PointcutAdvisor) advisor;\r		// 切入点表达式算一下每一个方法是否能匹配并返回\r		return canApply(pca.getPointcut(), targetClass, hasIntroductions);\r	}\r	else {\r		// It doesn&#39;t have a pointcut so we assume it applies.\r		return true;\r	}\r}</pre>\r\r<p>源码分析（AbstractAutoProxyCreator的createProxy()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Create an AOP proxy for the given bean.\r * @param beanClass the class of the bean\r * @param beanName the name of the bean\r * @param specificInterceptors the set of interceptors that is\r * specific to this bean (may be empty, but not null)\r * @param targetSource the TargetSource for the proxy,\r * already pre-configured to access the bean\r * @return the AOP proxy for the bean\r * @see #buildAdvisors\r */\rprotected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,\r		@Nullable Object[] specificInterceptors, TargetSource targetSource) {\r\r	if (this.beanFactory instanceof ConfigurableListableBeanFactory) {\r		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);\r	}\r\r	ProxyFactory proxyFactory = new ProxyFactory();\r	proxyFactory.copyFrom(this);\r\r	if (!proxyFactory.isProxyTargetClass()) {\r		if (shouldProxyTargetClass(beanClass, beanName)) {\r			proxyFactory.setProxyTargetClass(true);\r		}\r		else {\r			evaluateProxyInterfaces(beanClass, proxyFactory);\r		}\r	}\r\r	// 先拿增强器\r	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\r	// 把增强器（通知方法）保存到proxyFactory中\r	proxyFactory.addAdvisors(advisors);\r	proxyFactory.setTargetSource(targetSource);\r	customizeProxyFactory(proxyFactory);\r\r	proxyFactory.setFrozen(this.freezeProxy);\r	if (advisorsPreFiltered()) {\r		proxyFactory.setPreFiltered(true);\r	}\r\r	// 用proxyFactory.getProxy代理工厂创建代理对象\r	return proxyFactory.getProxy(getProxyClassLoader());\r}</pre>\r\r<p>源码分析（ProxyFactory的getProxy()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Create a new proxy according to the settings in this factory.\r * &lt;p&gt;Can be called repeatedly. Effect will vary if we&#39;ve added\r * or removed interfaces. Can add and remove interceptors.\r * &lt;p&gt;Uses the given class loader (if necessary for proxy creation).\r * @param classLoader the class loader to create the proxy with\r * (or {@code null} for the low-level proxy facility&#39;s default)\r * @return the proxy object\r */\rpublic Object getProxy(@Nullable ClassLoader classLoader) {\r	return createAopProxy().getProxy(classLoader);\r}</pre>\r\r<p>源码分析（ProxyCreatorSupport的createAopProxy()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Subclasses should call this to get a new AOP proxy. They should &lt;b&gt;not&lt;/b&gt;\r * create an AOP proxy with {@code this} as an argument.\r */\rprotected final synchronized AopProxy createAopProxy() {\r	if (!this.active) {\r		activate();\r	}\r	return getAopProxyFactory().createAopProxy(this);\r}</pre>\r\r<p>源码分析（DefaultAopProxyFactory的createAopProxy()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\r	if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {\r		Class&lt;?&gt; targetClass = config.getTargetClass();\r		if (targetClass == null) {\r			throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +\r					&quot;Either an interface or a target is required for proxy creation.&quot;);\r		}\r		if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\r			// JDK动态代理\r			return new JdkDynamicAopProxy(config);\r		}\r		// CGLIB动态代理\r		return new ObjenesisCglibAopProxy(config);\r	} else {\r		// JDK动态代理\r		return new JdkDynamicAopProxy(config);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1807, 'AOP源码分析（五）——被代理对象的方法调用过程', '1807', 1566195475, 1566195475, '<p>本文记录Java学习过程中遇到的AOP源码分析（五）&mdash;&mdash;被代理对象的方法调用过程～</p>\r<!--more-->\r\r<p>从IOC容器中拿到的对象就是代理对象，下面研究一下代理对象的代理方法的执行流程，看它是怎么执行的。</p>\r\r<p>示例代码（测试应用类）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app;\r        app = new AnnotationConfigApplicationContext(MainConfig.class);\r        System.out.println(&quot;IOC容器创建完成&quot;);\r        Calculator calculator = app.getBean(Calculator.class);\r        System.out.println(&quot;正常测试开始&quot;);\r        calculator.div(1, 1);\r        System.out.println(&quot;正常测试结束&quot;);\r        System.out.println(&quot;异常测试开始&quot;);\r        calculator.div(1, 0);\r        System.out.println(&quot;异常测试结束&quot;);\r        app.close();\r    }\r}</pre>\r\r<p>源码分析（CglibAopProxy的intercept()方法）：</p>\r\r<pre class="brush:java;">\r@Override\r@Nullable\rpublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\r	Object oldProxy = null;\r	boolean setProxyContext = false;\r	Object target = null;\r	TargetSource targetSource = this.advised.getTargetSource();\r	try {\r		if (this.advised.exposeProxy) {\r			// Make invocation available if necessary.\r			oldProxy = AopContext.setCurrentProxy(proxy);\r			setProxyContext = true;\r		}\r		// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...\r		target = targetSource.getTarget();\r		Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);\r		// 根据ProxyFactory对象获取将要执行的目标方法拦截器链\r		List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\r		Object retVal;\r\r		// 如果chain链为空\r		// Check whether we only have one InvokerInterceptor: that is,\r		// no real advice, but just reflective invocation of the target.\r		if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {\r			// 如果没有拦截器链，注解的意思是直接执行目标方法\r			// We can skip creating a MethodInvocation: just invoke the target directly.\r			// Note that the final invoker must be an InvokerInterceptor, so we know\r			// it does nothing but a reflective operation on the target, and no hot\r			// swapping or fancy proxying.\r			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\r			retVal = methodProxy.invoke(target, argsToUse);\r		} else {\r			// 拦截器链chain不为空\r			// 使用proceed()来执行拦截器链，整个执行的过程就是来触发调用拦截器链的过程\r			// We need to create a method invocation...\r			retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();\r			// 拦截器链等信息传入创建一个CglibMethodInvocation对象，把proxy, target, method, args, targetClass, chain, methodProxy参数都传进去\r			688行调用 Object retVal = mi.proceed();\r			//使用proceed()来执行拦截器链,整个执行的过程就是来触发调用拦截器链的过程\r		}\r		retVal = processReturnType(proxy, target, method, retVal);\r		return retVal;\r	}\r	finally {\r		if (target != null &amp;&amp; !targetSource.isStatic()) {\r			targetSource.releaseTarget(target);\r		}\r		if (setProxyContext) {\r			// Restore old proxy.\r			AopContext.setCurrentProxy(oldProxy);\r		}\r	}\r}</pre>\r\r<p>源码分析（AdvisedSupport的getInterceptorsAndDynamicInterceptionAdvice()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Determine a list of {@link org.aopalliance.intercept.MethodInterceptor} objects\r * for the given method, based on this configuration.\r * @param method the proxied method\r * @param targetClass the target class\r * @return List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)\r */\rpublic List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class&lt;?&gt; targetClass) {\r	// 把当前方法的拦截器链缓存起来，方便下次调用\r	MethodCacheKey cacheKey = new MethodCacheKey(method);\r	List&lt;Object&gt; cached = this.methodCache.get(cacheKey);\r	if (cached == null) {\r		// 从拦截器工厂获取目标方法的拦截器键\r		cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(				this, method, targetClass);\r		this.methodCache.put(cacheKey, cached);\r	}\r	return cached;\r}</pre>\r\r<p>源码分析（DefaultAdvisorChainFactory的getInterceptorsAndDynamicInterceptionAdvice()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(\r		Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) {\r\r	// config是proxyFactory\r	// config.getAdvisors()有5个拦截器，包括一个默认的ExposeInvocationInterceptor和4个增强器\r	// This is somewhat tricky... We have to process introductions first,\r	// but we need to preserve order in the ultimate list.\r	List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(config.getAdvisors().length);\r	Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());\r	boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);\r	AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();\r\r	// 遍历所有的增强器，转为Interceptor\r	for (Advisor advisor : config.getAdvisors()) {\r		// 判断是否为PointcutAdvisor类型\r		if (advisor instanceof PointcutAdvisor) {\r			// Add it conditionally.\r			PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;\r			if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\r				// 获取所有的interceptors，跟进查看\r				MethodInterceptor[] interceptors = registry.getInterceptors(advisor);\r				MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\r				if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) {\r					if (mm.isRuntime()) {\r						// Creating a new object instance in the getInterceptors() method\r						// isn&#39;t a problem as we normally cache created chains.\r						for (MethodInterceptor interceptor : interceptors) {\r							interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));\r						}\r					}\r					else {\r						// 将增强器转为List&lt;MethodInterceptor&gt;，如果不是进行强转supportsAdvice\r						interceptorList.addAll(Arrays.asList(interceptors));\r					}\r				}\r			}\r		}\r		else if (advisor instanceof IntroductionAdvisor) {\r			IntroductionAdvisor ia = (IntroductionAdvisor) advisor;\r			if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {\r				Interceptor[] interceptors = registry.getInterceptors(advisor);\r				// 将增强器转为List&lt;MethodInterceptor&gt;，如果不是进行强转supportsAdvice\r				interceptorList.addAll(Arrays.asList(interceptors));\r			}\r		}\r		else {\r			Interceptor[] interceptors = registry.getInterceptors(advisor);\r			// 将增强器转为List&lt;MethodInterceptor&gt;，如果不是进行强转supportsAdvice\r			interceptorList.addAll(Arrays.asList(interceptors));\r		}\r	}\r\r	return interceptorList;\r}</pre>\r\r<p>源码分析（DefaultAdvisorAdapterRegistry的getInterceptors()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {\r	// 方法拦截器集合\r	List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;&gt;(3);\r	Advice advice = advisor.getAdvice();\r	// 如果advice是MethodInterceptor类型，就直接加入interceptors集合\r	if (advice instanceof MethodInterceptor) {\r		interceptors.add((MethodInterceptor) advice);\r	}\r	// 有些advice不是实现MethodInterceptor接口,需要使用adapter进行包装转换,实际上就是加一个AfterReturningAdviceInterceptor后置通知进行\r	for (AdvisorAdapter adapter : this.adapters) {\r		if (adapter.supportsAdvice(advice)) {\r			interceptors.add(adapter.getInterceptor(advisor));\r		}\r	}\r	if (interceptors.isEmpty()) {\r		throw new UnknownAdviceTypeException(advisor.getAdvice());\r	}\r	// 把每个adivce转换成MethodIntereptor数组并返回，得到拦截器链（其实就是指每个通知方法又被包装为方法拦截\r器，以后的方法的执行都是利用MethodIntercpter机制执行）\r	return interceptors.toArray(new MethodInterceptor[0]);\r}</pre>\r\r<p>源码分析（ReflectiveMethodInvocation的proceed()方法）：</p>\r\r<pre class="brush:java;">\r@Override\r@Nullable\rpublic Object proceed() throws Throwable {\r	// currentInterceptorIndex索引默认为-1，记录当前拦截器索引\r	// We start with an index of -1 and increment early.\r	if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\r		// 如果代码执行到这，表示前置通知已处理完，并执行完@Before注解的打印内容，开始准备调用目标方法\r		return invokeJoinpoint();\r	}\r\r	// 每次+1，取一个拦截器\r	Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\r	if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\r		// Evaluate dynamic method matcher here: static part will already have\r		// been evaluated and found to match.\r		InterceptorAndDynamicMethodMatcher dm =\r				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\r		if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\r			return dm.interceptor.invoke(this);\r		}\r		else {\r			// Dynamic matching failed.\r			// Skip this interceptor and invoke the next in the chain.\r			return proceed();\r		}\r	}\r	else {\r		// It&#39;s an interceptor, so we just invoke it: The pointcut will have\r		// been evaluated statically before this object was constructed.\r		// 会调用此方法，this=CglibAopProxy，跟进去看\r		return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\r	}\r}</pre>\r\r<p>源码分析（ExposeInvocationInterceptor的invoke()方法）：</p>\r\r<pre class="brush:java;">\r// 它是ThreadLocal同一线共享数据，要把MethodInvocation共享，然后我们的MethodInvocation就是我们上面的 mi=CglibAopProxy进行共享\rprivate static final ThreadLocal&lt;MethodInvocation&gt; invocation = new NamedThreadLocal&lt;&gt;(&quot;Current AOP method invocation&quot;);\r\r@Override\rpublic Object invoke(MethodInvocation mi) throws Throwable {\r	// 跟进去\r	MethodInvocation oldInvocation = invocation.get();\r	// 第一次mi还没共享，所以先设置进去\r	invocation.set(mi);\r	try {\r		// 重新进行CglibProxy.proceed()，执行第二个拦截器 (interceptIndex已自增了，所以为第二个拦截器)\r		return mi.proceed();\r	}\r	finally {\r		invocation.set(oldInvocation);\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1808, 'Spring声明式事务源码分析（一）——开启事务', '1808', 1566918060, 1566919995, '<p>本文记录Java学习过程中遇到的Spring声明式事务源码分析（一）&mdash;&mdash;开启事务～</p>\r<!--more-->\r\r<p>Spring声明式事务使用前需要先打开开关，即@EnableTransactionManagement注解。</p>\r\r<p>源码分析（@EnableTransactionManagement注解）：</p>\r\r<pre class="brush:java;">\r@Target(ElementType.TYPE)\r@Retention(RetentionPolicy.RUNTIME)\r@Documented\r@Import(TransactionManagementConfigurationSelector.class)\rpublic @interface EnableTransactionManagement {\r\r	/**\r	 * Indicate whether subclass-based (CGLIB) proxies are to be created ({@code true}) as\r	 * opposed to standard Java interface-based proxies ({@code false}). The default is\r	 * {@code false}. &lt;strong&gt;Applicable only if {@link #mode()} is set to\r	 * {@link AdviceMode#PROXY}&lt;/strong&gt;.\r	 * &lt;p&gt;Note that setting this attribute to {@code true} will affect &lt;em&gt;all&lt;/em&gt;\r	 * Spring-managed beans requiring proxying, not just those marked with\r	 * {@code @Transactional}. For example, other beans marked with Spring&#39;s\r	 * {@code @Async} annotation will be upgraded to subclass proxying at the same\r	 * time. This approach has no negative impact in practice unless one is explicitly\r	 * expecting one type of proxy vs another, e.g. in tests.\r	 */\r	boolean proxyTargetClass() default false;\r\r	/**\r	 * Indicate how transactional advice should be applied.\r	 * &lt;p&gt;&lt;b&gt;The default is {@link AdviceMode#PROXY}.&lt;/b&gt;\r	 * Please note that proxy mode allows for interception of calls through the proxy\r	 * only. Local calls within the same class cannot get intercepted that way; an\r	 * {@link Transactional} annotation on such a method within a local call will be\r	 * ignored since Spring&#39;s interceptor does not even kick in for such a runtime\r	 * scenario. For a more advanced mode of interception, consider switching this to\r	 * {@link AdviceMode#ASPECTJ}.\r	 */\r	AdviceMode mode() default AdviceMode.PROXY;\r\r	/**\r	 * Indicate the ordering of the execution of the transaction advisor\r	 * when multiple advices are applied at a specific joinpoint.\r	 * &lt;p&gt;The default is {@link Ordered#LOWEST_PRECEDENCE}.\r	 */\r	int order() default Ordered.LOWEST_PRECEDENCE;\r}</pre>\r\r<p>源码分析（TransactionManagementConfigurationSelector）：</p>\r\r<pre class="brush:java;">\rpublic class TransactionManagementConfigurationSelector extends AdviceModeImportSelector&lt;EnableTransactionManagement&gt; {\r\r	/**\r	 * {@inheritDoc}\r	 * @return {@link ProxyTransactionManagementConfiguration} or\r	 * {@code AspectJTransactionManagementConfiguration} for {@code PROXY} and\r	 * {@code ASPECTJ} values of {@link EnableTransactionManagement#mode()}, respectively\r	 */\r	@Override\r	protected String[] selectImports(AdviceMode adviceMode) {\r		switch (adviceMode) {\r			case PROXY:\r				return new String[] {AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()};\r			case ASPECTJ:\r				return new String[] {TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME};\r			default:\r				return null;\r		}\r	}\r}</pre>\r\r<p>源码分析（AutoProxyRegistrar）：</p>\r\r<pre class="brush:java;">\rpublic class AutoProxyRegistrar implements ImportBeanDefinitionRegistrar {\r\r	private final Log logger = LogFactory.getLog(getClass());\r\r	/**\r	 * Register, escalate, and configure the standard auto proxy creator (APC) against the\r	 * given registry. Works by finding the nearest annotation declared on the importing\r	 * {@code @Configuration} class that has both {@code mode} and {@code proxyTargetClass}\r	 * attributes. If {@code mode} is set to {@code PROXY}, the APC is registered; if\r	 * {@code proxyTargetClass} is set to {@code true}, then the APC is forced to use\r	 * subclass (CGLIB) proxying.\r	 * &lt;p&gt;Several {@code @Enable*} annotations expose both {@code mode} and\r	 * {@code proxyTargetClass} attributes. It is important to note that most of these\r	 * capabilities end up sharing a {@linkplain AopConfigUtils#AUTO_PROXY_CREATOR_BEAN_NAME\r	 * single APC}. For this reason, this implementation doesn&#39;t &quot;care&quot; exactly which\r	 * annotation it finds -- as long as it exposes the right {@code mode} and\r	 * {@code proxyTargetClass} attributes, the APC can be registered and configured all\r	 * the same.\r	 */\r	@Override\r	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\r		boolean candidateFound = false;\r		Set&lt;String&gt; annoTypes = importingClassMetadata.getAnnotationTypes();\r		for (String annoType : annoTypes) {\r			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType);\r			if (candidate == null) {\r				continue;\r			}\r			Object mode = candidate.get(&quot;mode&quot;);\r			Object proxyTargetClass = candidate.get(&quot;proxyTargetClass&quot;);\r			if (mode != null &amp;&amp; proxyTargetClass != null &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;\r					Boolean.class == proxyTargetClass.getClass()) {\r				candidateFound = true;\r				if (mode == AdviceMode.PROXY) {\r					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);\r					if ((Boolean) proxyTargetClass) {\r						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\r						return;\r					}\r				}\r			}\r		}\r		if (!candidateFound) {\r			String name = getClass().getSimpleName();\r			logger.warn(String.format(&quot;%s was imported but no annotations were found &quot; +\r					&quot;having both &#39;mode&#39; and &#39;proxyTargetClass&#39; attributes of type &quot; +\r					&quot;AdviceMode and boolean respectively. This means that auto proxy &quot; +\r					&quot;creator registration and configuration may not have occurred as &quot; +\r					&quot;intended, and components may not be proxied as expected. Check to &quot; +\r					&quot;ensure that %s has been @Import&#39;ed on the same class where these &quot; +\r					&quot;annotations are declared; otherwise remove the import of %s &quot; +\r					&quot;altogether.&quot;, name, name, name));\r		}\r	}\r}</pre>\r\r<p>源码分析（AopConfigUtils.registerAutoProxyCreatorIfNecessary()方法）：</p>\r\r<pre class="brush:java;">\r@Nullable\rpublic static BeanDefinition registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) {\r	return registerAutoProxyCreatorIfNecessary(registry, null);\r}\r\r@Nullable\rpublic static BeanDefinition registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry,\r		@Nullable Object source) {\r	return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);\r}\r\r/**\r * The bean name of the internally managed auto-proxy creator.\r */\rpublic static final String AUTO_PROXY_CREATOR_BEAN_NAME = &quot;org.springframework.aop.config.internalAutoProxyCreator&quot;;\r\r// 注册Bean的优先级\r/**\r * Setup the escalation list.\r */\rstatic {\r	APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);\r	APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);\r	APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);\r}\r\r@Nullable\rprivate static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry,\r		@Nullable Object source) {\r\r	Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);\r\r	if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\r		BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\r		if (!cls.getName().equals(apcDefinition.getBeanClassName())) {\r			int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());\r			int requiredPriority = findPriorityForClass(cls);\r			if (currentPriority &lt; requiredPriority) {\r				apcDefinition.setBeanClassName(cls.getName());\r			}\r		}\r		return null;\r	}\r\r	RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);\r	beanDefinition.setSource(source);\r	beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);\r	beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\r	registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);\r	return beanDefinition;\r}</pre>\r\r<p>总结，开关就是将Spring声明式事务的核心类的Bean定义注入到了IOC，但并没有创建Bean。</p>\r\r<p>源码分析（ProxyTransactionManagementConfiguration）：</p>\r\r<pre class="brush:java;">\r@Configuration\rpublic class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration {\r\r        // 属性源增强\r	@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)\r	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\r	public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() {\r		BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();\r		advisor.setTransactionAttributeSource(transactionAttributeSource());\r		advisor.setAdvice(transactionInterceptor());\r		if (this.enableTx != null) {\r			advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(&quot;order&quot;));\r		}\r		return advisor;\r	}\r\r	@Bean\r	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\r	public TransactionAttributeSource transactionAttributeSource() {\r		return new AnnotationTransactionAttributeSource();\r	}\r\r        // 保存了事务信息和事务管理器\r	@Bean\r	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\r	public TransactionInterceptor transactionInterceptor() {\r		TransactionInterceptor interceptor = new TransactionInterceptor();\r		interceptor.setTransactionAttributeSource(transactionAttributeSource());\r		if (this.txManager != null) {\r			interceptor.setTransactionManager(this.txManager);\r		}\r		return interceptor;\r	}\r}</pre>\r\r<p>源码分析（AnnotationTransactionAttributeSource）：</p>\r\r<pre class="brush:java;">\r/**\r * Create a custom AnnotationTransactionAttributeSource, supporting\r * public methods that carry the {@code Transactional} annotation\r * or the EJB3 {@link javax.ejb.TransactionAttribute} annotation.\r * @param publicMethodsOnly whether to support public methods that carry\r * the {@code Transactional} annotation only (typically for use\r * with proxy-based AOP), or protected/private methods as well\r * (typically used with AspectJ class weaving)\r */\rpublic AnnotationTransactionAttributeSource(boolean publicMethodsOnly) {\r	this.publicMethodsOnly = publicMethodsOnly;\r	this.annotationParsers = new LinkedHashSet&lt;&gt;(2);\r	this.annotationParsers.add(new SpringTransactionAnnotationParser());\r	if (jta12Present) {\r		this.annotationParsers.add(new JtaTransactionAnnotationParser());\r	}\r	if (ejb3Present) {\r		this.annotationParsers.add(new Ejb3TransactionAnnotationParser());\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1809, 'InfrastructureAdvisorAutoProxyCreator.png', 'InfrastructureAdvisorAutoProxyCreator-png', 1566920932, 1566920932, 'a:5:{s:4:"name";s:41:"InfrastructureAdvisorAutoProxyCreator.png";s:4:"path";s:35:"/usr/uploads/2019/08/1221801317.png";s:4:"size";i:86447;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1810, 0),
(1810, 'Spring声明式事务源码分析（二）——核心类InfrastructureAdvisorAutoProxyCreator', '1810', 1566920964, 1566920964, '<p>本文记录Java学习过程中遇到的Spring声明式事务源码分析（二）&mdash;&mdash;核心类InfrastructureAdvisorAutoProxyCreator～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/08/1221801317.png" style="width: 800px; height: 314px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1811, 'Spring声明式事务源码分析（三）——核心类TransactionInterceptor', '1811', 1566921780, 1566922371, '<p>本文记录Java学习过程中遇到的Spring声明式事务源码分析（三）&mdash;&mdash;核心类TransactionInterceptor～</p>\r<!--more-->\r\r<p>源码分析（TransactionInterceptor的invoke()方法）：</p>\r\r<pre class="brush:java;">\r@Override\r@Nullable\rpublic Object invoke(final MethodInvocation invocation) throws Throwable {\r	// Work out the target class: may be {@code null}.\r	// The TransactionAttributeSource should be passed the target class\r	// as well as the method, which may be from an interface.\r	Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);\r\r	// Adapt to TransactionAspectSupport&#39;s invokeWithinTransaction...\r	return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);\r}</pre>\r\r<p>源码分析（TransactionAspectSupport的invokeWithinTransaction()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * General delegate for around-advice-based subclasses, delegating to several other template\r * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}\r * as well as regular {@link PlatformTransactionManager} implementations.\r * @param method the Method being invoked\r * @param targetClass the target class that we&#39;re invoking the method on\r * @param invocation the callback to use for proceeding with the target invocation\r * @return the return value of the method, if any\r * @throws Throwable propagated from the target invocation\r */\r@Nullable\rprotected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,\r		final InvocationCallback invocation) throws Throwable {\r\r	// If the transaction attribute is null, the method is non-transactional.\r	TransactionAttributeSource tas = getTransactionAttributeSource();\r	final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);\r	final PlatformTransactionManager tm = determineTransactionManager(txAttr);\r	final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);\r\r	if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {\r		// 开启事务\r		// Standard transaction demarcation with getTransaction and commit/rollback calls.\r		TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\r		Object retVal = null;\r		try {\r			// 调用对应的方法\r			// This is an around advice: Invoke the next interceptor in the chain.\r			// This will normally result in a target object being invoked.\r			retVal = invocation.proceedWithInvocation();\r		}\r		catch (Throwable ex) {\r			// 回滚事务\r			// target invocation exception\r			completeTransactionAfterThrowing(txInfo, ex);\r			throw ex;\r		}\r		finally {\r			// 清理事务信息\r			cleanupTransactionInfo(txInfo);\r		}\r		// 提交事务\r		commitTransactionAfterReturning(txInfo);\r		return retVal;\r	}\r\r	else {\r		final ThrowableHolder throwableHolder = new ThrowableHolder();\r\r		// It&#39;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.\r		try {\r			Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&gt; {\r				// 开启事务\r				TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);\r				try {\r					// 执行目标方法\r					return invocation.proceedWithInvocation();\r				}\r				catch (Throwable ex) {\r					// 异常回滚\r					if (txAttr.rollbackOn(ex)) {\r						// A RuntimeException: will lead to a rollback.\r						if (ex instanceof RuntimeException) {\r							throw (RuntimeException) ex;\r						}\r						else {\r							throw new ThrowableHolderException(ex);\r						}\r					}\r					else {\r						// A normal return value: will lead to a commit.\r						throwableHolder.throwable = ex;\r						return null;\r					}\r				}\r				finally {\r					// 清理事务信息\r					cleanupTransactionInfo(txInfo);\r				}\r			});\r\r			// Check result state: It might indicate a Throwable to rethrow.\r			if (throwableHolder.throwable != null) {\r				throw throwableHolder.throwable;\r			}\r			return result;\r		}\r		catch (ThrowableHolderException ex) {\r			throw ex.getCause();\r		}\r		catch (TransactionSystemException ex2) {\r			if (throwableHolder.throwable != null) {\r				logger.error(&quot;Application exception overridden by commit exception&quot;, throwableHolder.throwable);\r				ex2.initApplicationException(throwableHolder.throwable);\r			}\r			throw ex2;\r		}\r		catch (Throwable ex2) {\r			if (throwableHolder.throwable != null) {\r				logger.error(&quot;Application exception overridden by commit exception&quot;, throwableHolder.throwable);\r			}\r			throw ex2;\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1812, 'Spring声明式事务源码分析（四）——被代理对象的方法调用过程', '1812', 1566923470, 1566923470, '<p>本文记录Java学习过程中遇到的Spring声明式事务源码分析（四）&mdash;&mdash;被代理对象的方法调用过程～</p>\r<!--more-->\r\r<p>源码分析（测试类）：</p>\r\r<pre class="brush:java;">\rpublic class App {\r    public static void main(String[] args) {\r        AnnotationConfigApplicationContext app;\r        app = new AnnotationConfigApplicationContext(MainConfig.class);\r        OrderService orderService = app.getBean(OrderService.class);\r        System.out.println(&quot;正常测试开始&quot;);\r        orderService.addOrderNormal();\r        System.out.println(&quot;正常测试结束&quot;);\r        System.out.println(&quot;异常测试开始&quot;);\r        try {\r            orderService.addOrderError();\r        } catch (Exception e) {\r            e.printStackTrace();\r        }\r        System.out.println(&quot;异常测试结束&quot;);\r        app.close();\r    }\r}</pre>\r\r<p>源码分析（CglibAopProxy的intercept()方法）：</p>\r\r<pre class="brush:java;">\r@Override\r@Nullable\rpublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\r	Object oldProxy = null;\r	boolean setProxyContext = false;\r	Object target = null;\r	TargetSource targetSource = this.advised.getTargetSource();\r	try {\r		if (this.advised.exposeProxy) {\r			// Make invocation available if necessary.\r			oldProxy = AopContext.setCurrentProxy(proxy);\r			setProxyContext = true;\r		}\r		// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...\r		target = targetSource.getTarget();\r		Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);\r		List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\r		Object retVal;\r		// Check whether we only have one InvokerInterceptor: that is,\r		// no real advice, but just reflective invocation of the target.\r		if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {\r			// We can skip creating a MethodInvocation: just invoke the target directly.\r			// Note that the final invoker must be an InvokerInterceptor, so we know\r			// it does nothing but a reflective operation on the target, and no hot\r			// swapping or fancy proxying.\r			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\r			retVal = methodProxy.invoke(target, argsToUse);\r		}\r		else {\r			// 创建Cglib调用类并调用\r			// We need to create a method invocation...\r			retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();\r		}\r		retVal = processReturnType(proxy, target, method, retVal);\r		return retVal;\r	}\r	finally {\r		if (target != null &amp;&amp; !targetSource.isStatic()) {\r			targetSource.releaseTarget(target);\r		}\r		if (setProxyContext) {\r			// Restore old proxy.\r			AopContext.setCurrentProxy(oldProxy);\r		}\r	}\r}</pre>\r\r<p>源码分析（ReflectiveMethodInvocation的proceed()方法）：</p>\r\r<pre class="brush:java;">\r@Override\r@Nullable\rpublic Object proceed() throws Throwable {\r	//	We start with an index of -1 and increment early.\r	if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\r		return invokeJoinpoint();\r	}\r\r	Object interceptorOrInterceptionAdvice =\r			this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\r	if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\r		// Evaluate dynamic method matcher here: static part will already have\r		// been evaluated and found to match.\r		InterceptorAndDynamicMethodMatcher dm =\r				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\r		if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\r			return dm.interceptor.invoke(this);\r		}\r		else {\r			// Dynamic matching failed.\r			// Skip this interceptor and invoke the next in the chain.\r			return proceed();\r		}\r	}\r	else {\r		// 调用拦截器的方法\r		// It&#39;s an interceptor, so we just invoke it: The pointcut will have\r		// been evaluated statically before this object was constructed.\r		return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\r	}\r}</pre>\r\r<p>源码分析（TransactionInterceptor的invoke()方法）：</p>\r\r<pre class="brush:java;">\r@Override\r@Nullable\rpublic Object invoke(final MethodInvocation invocation) throws Throwable {\r	// Work out the target class: may be {@code null}.\r	// The TransactionAttributeSource should be passed the target class\r	// as well as the method, which may be from an interface.\r	Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);\r\r	// Adapt to TransactionAspectSupport&#39;s invokeWithinTransaction...\r	return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);\r}</pre>\r\r<p>源码分析（TransactionAspectSupport的invokeWithinTransaction()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * General delegate for around-advice-based subclasses, delegating to several other template\r * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}\r * as well as regular {@link PlatformTransactionManager} implementations.\r * @param method the Method being invoked\r * @param targetClass the target class that we&#39;re invoking the method on\r * @param invocation the callback to use for proceeding with the target invocation\r * @return the return value of the method, if any\r * @throws Throwable propagated from the target invocation\r */\r@Nullable\rprotected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,\r		final InvocationCallback invocation) throws Throwable {\r\r	// If the transaction attribute is null, the method is non-transactional.\r	TransactionAttributeSource tas = getTransactionAttributeSource();\r	final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);\r	final PlatformTransactionManager tm = determineTransactionManager(txAttr);\r	final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);\r\r	if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {\r		// Standard transaction demarcation with getTransaction and commit/rollback calls.\r		TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\r		Object retVal = null;\r		try {\r			// This is an around advice: Invoke the next interceptor in the chain.\r			// This will normally result in a target object being invoked.\r			retVal = invocation.proceedWithInvocation();\r		}\r		catch (Throwable ex) {\r			// target invocation exception\r			completeTransactionAfterThrowing(txInfo, ex);\r			throw ex;\r		}\r		finally {\r			cleanupTransactionInfo(txInfo);\r		}\r		commitTransactionAfterReturning(txInfo);\r		return retVal;\r	}\r\r	else {\r		final ThrowableHolder throwableHolder = new ThrowableHolder();\r\r		// It&#39;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.\r		try {\r			Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&gt; {\r				TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);\r				try {\r					return invocation.proceedWithInvocation();\r				}\r				catch (Throwable ex) {\r					if (txAttr.rollbackOn(ex)) {\r						// A RuntimeException: will lead to a rollback.\r						if (ex instanceof RuntimeException) {\r							throw (RuntimeException) ex;\r						}\r						else {\r							throw new ThrowableHolderException(ex);\r						}\r					}\r					else {\r						// A normal return value: will lead to a commit.\r						throwableHolder.throwable = ex;\r						return null;\r					}\r				}\r				finally {\r					cleanupTransactionInfo(txInfo);\r				}\r			});\r\r			// Check result state: It might indicate a Throwable to rethrow.\r			if (throwableHolder.throwable != null) {\r				throw throwableHolder.throwable;\r			}\r			return result;\r		}\r		catch (ThrowableHolderException ex) {\r			throw ex.getCause();\r		}\r		catch (TransactionSystemException ex2) {\r			if (throwableHolder.throwable != null) {\r				logger.error(&quot;Application exception overridden by commit exception&quot;, throwableHolder.throwable);\r				ex2.initApplicationException(throwableHolder.throwable);\r			}\r			throw ex2;\r		}\r		catch (Throwable ex2) {\r			if (throwableHolder.throwable != null) {\r				logger.error(&quot;Application exception overridden by commit exception&quot;, throwableHolder.throwable);\r			}\r			throw ex2;\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1813, 'Spring扩展组件BeanDefinitionRegistryPostProcessor与BeanFactoryPostProcessor', '1813', 1567066758, 1567066758, '<p>本文记录Java学习过程中遇到的Spring扩展组件BeanDefinitionRegistryPostProcessor与BeanFactoryPostProcessor～</p>\r<!--more-->\r\r<ul>\r	<li>BeanDefinitionRegistryPostProcessor：Bean定义的后置处理器；</li>\r	<li>BeanFactoryPostProcessor：BeanFactory的后置处理器。</li>\r</ul>\r\r<p>示例代码（BeanDefinitionRegistryPostProcessor）：</p>\r\r<pre class="brush:java;">\r@Component\rpublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\r\r    @Override\r    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\r        // 获取此时bean定义的数量\r        System.out.println(&quot;MyBeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry()&quot;);\r        System.out.println(&quot;此时bean定义的数量：&quot; + registry.getBeanDefinitionCount());\r        // 添加一个新的bean定义\r        // RootBeanDefinition rbd = new RootBeanDefinition(Moon.class);\r        AbstractBeanDefinition rbd = BeanDefinitionBuilder.rootBeanDefinition(Person.class).getBeanDefinition();\r        registry.registerBeanDefinition(&quot;bean&quot;, rbd);\r    }\r\r    @Override\r    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\r        // 获取此时bean定义的数量\r        System.out.println(&quot;MyBeanDefinitionRegistryPostProcessor.postProcessBeanFactory()&quot;);\r        System.out.println(&quot;此时bean定义的数量：&quot; + beanFactory.getBeanDefinitionCount());\r    }\r\r}</pre>\r\r<p>示例代码（BeanFactoryPostProcessor）：</p>\r\r<pre class="brush:java;">\r@Component\rpublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\r\r    @Override\r    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\r        System.out.println(&quot;MyBeanFactoryPostProcessor.postProcessBeanFactory()&quot;);\r        // 所有bean的定义，已经加载到beanFactory, 但是bean实例并没有创建\r        int count = beanFactory.getBeanDefinitionCount();\r        String[] beanDefName = beanFactory.getBeanDefinitionNames();\r        System.out.println(&quot;此时bean定义的个数：&quot; + count);\r        System.out.println(Arrays.asList(beanDefName));\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1814, 'Spring的IOC源码分析（一）——总体流程', '1814', 1567067880, 1570184041, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（一）&mdash;&mdash;总体流程～</p>\r<!--more-->\r\r<p>源码分析（AnnotationConfigApplicationContext的构造方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Create a new AnnotationConfigApplicationContext, deriving bean definitions\r * from the given annotated classes and automatically refreshing the context.\r * @param annotatedClasses one or more annotated classes,\r * e.g. {@link Configuration @Configuration} classes\r */\rpublic AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {\r	this();\r	register(annotatedClasses);\r	// 刷新容器\r	refresh();\r}</pre>\r\r<p>源码分析（AbstractApplicationContext的refresh()方法）：</p>\r\r<pre class="brush:java;">\r@Override\rpublic void refresh() throws BeansException, IllegalStateException {\r        // 加了个线程安全的锁机制\r	synchronized (this.startupShutdownMonitor) {\r		// 刷新前的预处理\r		// Prepare this context for refreshing.\r		prepareRefresh();\r\r		// 获取BeanFactory实例\r		// Tell the subclass to refresh the internal bean factory.\r		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\r\r		// BeanFactory预准备工作\r		// Prepare the bean factory for use in this context.\r		prepareBeanFactory(beanFactory);\r\r		try {\r			// BeanFactory准备工作完成后进行的后置处理工作\r			// Allows post-processing of the bean factory in context subclasses.\r			postProcessBeanFactory(beanFactory);\r\r			// 执行BeanFactoryPostProcessor的方法\r			// Invoke factory processors registered as beans in the context.\r			invokeBeanFactoryPostProcessors(beanFactory);\r\r			// 注册BeanPostProcessor（Bean的后置处理器）\r			// Register bean processors that intercept bean creation.\r			registerBeanPostProcessors(beanFactory);\r\r			// 初始化MessageSource组件\r			// Initialize message source for this context.\r			initMessageSource();\r\r			// 初始化应用事件广播器\r			// Initialize event multicaster for this context.\r			initApplicationEventMulticaster();\r\r			// 刷新时的操作，这是是空实现，留给子容器扩展\r			// Initialize other special beans in specific context subclasses.\r			onRefresh();\r\r			// 注册监听器\r			// Check for listener beans and register them.\r			registerListeners();\r\r			// 初始化所有剩下的单实例Bean\r			// Instantiate all remaining (non-lazy-init) singletons.\r			finishBeanFactoryInitialization(beanFactory);\r\r			// 完成BeanFactory的初始化创建工作\r			// Last step: publish corresponding event.\r			finishRefresh();\r		}\r\r		catch (BeansException ex) {\r			if (logger.isWarnEnabled()) {\r				logger.warn(&quot;Exception encountered during context initialization - &quot; +\r						&quot;cancelling refresh attempt: &quot; + ex);\r			}\r\r			// Destroy already created singletons to avoid dangling resources.\r			destroyBeans();\r\r			// Reset &#39;active&#39; flag.\r			cancelRefresh(ex);\r\r			// Propagate exception to caller.\r			throw ex;\r		}\r\r		finally {\r			// Reset common introspection caches in Spring&#39;s core, since we\r			// might not ever need metadata for singleton beans anymore...\r			resetCommonCaches();\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1815, 'Spring的IOC源码分析（二）——刷新前的预处理', '1815', 1567068736, 1567068736, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（二）&mdash;&mdash;刷新前的预处理～</p>\r<!--more-->\r\r<p>源码分析（AbstractApplicationContext的prepareRefresh()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Prepare this context for refreshing, setting its startup date and\r * active flag as well as performing any initialization of property sources.\r */\rprotected void prepareRefresh() {\r	this.startupDate = System.currentTimeMillis();\r	// 记录当前容器的状态\r	this.closed.set(false);\r	this.active.set(true);\r\r	if (logger.isInfoEnabled()) {\r		logger.info(&quot;Refreshing &quot; + this);\r	}\r\r	// 初始化一些属性设计（空实现，留给子容器来扩展）\r	// Initialize any placeholder property sources in the context environment\r	initPropertySources();\r\r	// 校验属性的合法性\r	// Validate that all properties marked as required are resolvable\r	// see ConfigurablePropertyResolver#setRequiredProperties\r	getEnvironment().validateRequiredProperties();\r\r	// 保存容器中的一些早期事件\r	// Allow for the collection of early ApplicationEvents,\r	// to be published once the multicaster is available...\r	this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1816, 'Spring的IOC源码分析（三）——获取BeanFactory', '1816', 1567069172, 1567069172, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（三）&mdash;&mdash;获取BeanFactory～</p>\r<!--more-->\r\r<p>源码分析（AbstractApplicationContext的obtainFreshBeanFactory()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Tell the subclass to refresh the internal bean factory.\r * @return the fresh BeanFactory instance\r * @see #refreshBeanFactory()\r * @see #getBeanFactory()\r */\rprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\r	// 刷新BeanFactory\r	refreshBeanFactory();\r	// 获取BeanFactory\r	ConfigurableListableBeanFactory beanFactory = getBeanFactory();\r	if (logger.isDebugEnabled()) {\r		logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);\r	}\r	return beanFactory;\r}</pre>\r\r<p>源码分析（GenericApplicationContext的refreshBeanFactory()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Create a new GenericApplicationContext.\r * @see #registerBeanDefinition\r * @see #refresh\r */\rpublic GenericApplicationContext() {\r	// 构造函数中创建BeanFactory对象，对象的所有配置都为默认配置\r	this.beanFactory = new DefaultListableBeanFactory();\r}\r\r/**\r * Do nothing: We hold a single internal BeanFactory and rely on callers\r * to register beans through our public methods (or the BeanFactory&#39;s).\r * @see #registerBeanDefinition\r */\r@Override\rprotected final void refreshBeanFactory() throws IllegalStateException {\r	if (!this.refreshed.compareAndSet(false, true)) {\r		throw new IllegalStateException(\r				&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#39;refresh&#39; once&quot;);\r	}\r	// 设置BeanFactory的ID标示\r	this.beanFactory.setSerializationId(getId());\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1817, 'Spring的IOC源码分析（四）——BeanFactory预准备工作', '1817', 1567070548, 1567070548, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（四）&mdash;&mdash;BeanFactory预准备工作～</p>\r<!--more-->\r\r<p>源码分析（AbstractApplicationContext的prepareBeanFactory()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Configure the factory&#39;s standard context characteristics,\r * such as the context&#39;s ClassLoader and post-processors.\r * @param beanFactory the BeanFactory to configure\r */\rprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\r	// Tell the internal bean factory to use the context&#39;s class loader etc.\r\r	// 设置BeanFactory的类加载器\r	beanFactory.setBeanClassLoader(getClassLoader());\r	// 设置表达式解析器\r	beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\r	beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\r\r	// 添加部分BeanPostProcessor&mdash;&mdash;ApplicationContextAwareProcessor\r	// Configure the bean factory with context callbacks.\r	beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\r	// 设置要忽略的自动装配接口\r	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\r	beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\r	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\r	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\r	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\r	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\r\r	// 注册可以解析的自动装配组件&mdash;&mdash;BeanFactory，ResourceLoader，ApplicationEventPublisher，ApplicationContext\r	// BeanFactory interface not registered as resolvable type in a plain factory.\r	// MessageSource registered (and found for autowiring) as a bean.\r	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\r	beanFactory.registerResolvableDependency(ResourceLoader.class, this);\r	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\r	beanFactory.registerResolvableDependency(ApplicationContext.class, this);\r\r	// 添加BeanPostProcessor&mdash;&mdash;ApplicationListenerDetector\r	// Register early post-processor for detecting inner beans as ApplicationListeners.\r	beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\r\r	// Detect a LoadTimeWeaver and prepare for weaving, if found.\r	if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\r		beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\r		// Set a temporary ClassLoader for type matching.\r		beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\r	}\r\r	// Register default environment beans.\r	if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\r		// 注册环境environment&mdash;&mdash;ConfigurableEnvironment\r		beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\r	}\r	if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\r		// 注册系统属性systemProperties&mdash;&mdash;Map&lt;String, Object&gt;\r		beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\r	}\r	if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\r		// 注册系统环境信息systemEnvironment&mdash;&mdash;Map&lt;String, Object&gt;\r		beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1818, 'Spring的IOC源码分析（五）——执行BeanFactoryPostProcessor的方法', '1818', 1567070957, 1567070957, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（五）&mdash;&mdash;执行BeanFactoryPostProcessor的方法～</p>\r<!--more-->\r\r<p>源码分析（AbstractApplicationContext的invokeBeanFactoryPostProcessors()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Instantiate and invoke all registered BeanFactoryPostProcessor beans,\r * respecting explicit order if given.\r * &lt;p&gt;Must be called before singleton instantiation.\r */\rprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\r	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\r\r	// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\r	// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\r	if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\r		beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\r		beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\r	}\r}</pre>\r\r<p>源码分析（PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()方法）：</p>\r\r<pre class="brush:java;">\rpublic static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {\r\r	// Invoke BeanDefinitionRegistryPostProcessors first, if any.\r	Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();\r\r	// 先判断类型\r	if (beanFactory instanceof BeanDefinitionRegistry) {\r		BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\r		List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;&gt;();\r		List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new LinkedList&lt;&gt;();\r\r		for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\r			if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\r				BeanDefinitionRegistryPostProcessor registryProcessor =\r						(BeanDefinitionRegistryPostProcessor) postProcessor;\r				registryProcessor.postProcessBeanDefinitionRegistry(registry);\r				registryProcessors.add(registryProcessor);\r			}\r			else {\r				regularPostProcessors.add(postProcessor);\r			}\r		}\r\r		// Do not initialize FactoryBeans here: We need to leave all regular beans\r		// uninitialized to let the bean factory post-processors apply to them!\r		// Separate between BeanDefinitionRegistryPostProcessors that implement\r		// PriorityOrdered, Ordered, and the rest.\r		List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();\r\r		// 先调用实现了PriorityOrdered的\r		// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\r		String[] postProcessorNames =\r				beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\r		for (String ppName : postProcessorNames) {\r			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\r				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\r				processedBeans.add(ppName);\r			}\r		}\r		sortPostProcessors(currentRegistryProcessors, beanFactory);\r		registryProcessors.addAll(currentRegistryProcessors);\r		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\r		currentRegistryProcessors.clear();\r\r		// 在调用实现了Ordered\r		// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\r		postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\r		for (String ppName : postProcessorNames) {\r			if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {\r				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\r				processedBeans.add(ppName);\r			}\r		}\r		sortPostProcessors(currentRegistryProcessors, beanFactory);\r		registryProcessors.addAll(currentRegistryProcessors);\r		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\r		currentRegistryProcessors.clear();\r\r		// 最后调用所有剩余的\r		// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\r		boolean reiterate = true;\r		while (reiterate) {\r			reiterate = false;\r			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\r			for (String ppName : postProcessorNames) {\r				if (!processedBeans.contains(ppName)) {\r					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\r					processedBeans.add(ppName);\r					reiterate = true;\r				}\r			}\r			sortPostProcessors(currentRegistryProcessors, beanFactory);\r			registryProcessors.addAll(currentRegistryProcessors);\r			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\r			currentRegistryProcessors.clear();\r		}\r\r		// Now, invoke the postProcessBeanFactory callback of all processors handled so far.\r		invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\r		invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\r	}\r\r	else {\r		// Invoke factory processors registered with the context instance.\r		invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\r	}\r\r	// Do not initialize FactoryBeans here: We need to leave all regular beans\r	// uninitialized to let the bean factory post-processors apply to them!\r	String[] postProcessorNames =\r			beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\r\r	// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\r	// Ordered, and the rest.\r	List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();\r	List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();\r	List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();\r	for (String ppName : postProcessorNames) {\r		if (processedBeans.contains(ppName)) {\r			// skip - already processed in first phase above\r		}\r		else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\r			priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\r		}\r		else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\r			orderedPostProcessorNames.add(ppName);\r		}\r		else {\r			nonOrderedPostProcessorNames.add(ppName);\r		}\r	}\r\r	// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\r	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\r	invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\r\r	// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\r	List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();\r	for (String postProcessorName : orderedPostProcessorNames) {\r		orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\r	}\r	sortPostProcessors(orderedPostProcessors, beanFactory);\r	invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\r\r	// Finally, invoke all other BeanFactoryPostProcessors.\r	List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();\r	for (String postProcessorName : nonOrderedPostProcessorNames) {\r		nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\r	}\r	invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\r\r	// Clear cached merged bean definitions since the post-processors might have\r	// modified the original metadata, e.g. replacing placeholders in values...\r	beanFactory.clearMetadataCache();\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1819, 'Spring的IOC源码分析（六）——注册BeanPostProcessor后置处理器', '1819', 1567071995, 1567071995, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（六）&mdash;&mdash;注册BeanPostProcessor后置处理器～</p>\r<!--more-->\r\r<p>源码分析（AbstractApplicationContext的registerBeanPostProcessors()）：</p>\r\r<pre class="brush:java;">\r/**\r * Instantiate and invoke all registered BeanPostProcessor beans,\r * respecting explicit order if given.\r * &lt;p&gt;Must be called before any instantiation of application beans.\r */\rprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\r	PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\r}</pre>\r\r<p>源码分析（PostProcessorRegistrationDelegate.registerBeanPostProcessors()方法）：</p>\r\r<pre class="brush:java;">\rpublic static void registerBeanPostProcessors(\r		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\r\r	// 获取所有的后置处理器\r	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\r\r	// Register BeanPostProcessorChecker that logs an info message when\r	// a bean is created during BeanPostProcessor instantiation, i.e. when\r	// a bean is not eligible for getting processed by all BeanPostProcessors.\r	int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\r	beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\r\r	// Separate between BeanPostProcessors that implement PriorityOrdered,\r	// Ordered, and the rest.\r	List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();\r	List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();\r	List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();\r	List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();\r	for (String ppName : postProcessorNames) {\r		if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\r			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\r			priorityOrderedPostProcessors.add(pp);\r			if (pp instanceof MergedBeanDefinitionPostProcessor) {\r				internalPostProcessors.add(pp);\r			}\r		}\r		else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\r			orderedPostProcessorNames.add(ppName);\r		}\r		else {\r			nonOrderedPostProcessorNames.add(ppName);\r		}\r	}\r\r	// 先注册PriorityOrdered优先级接口的BeanPostProcessor\r	// First, register the BeanPostProcessors that implement PriorityOrdered.\r	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\r	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\r\r	// 再注册Ordered接口的BeanPostProcessor\r	// Next, register the BeanPostProcessors that implement Ordered.\r	List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();\r	for (String ppName : orderedPostProcessorNames) {\r		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\r		orderedPostProcessors.add(pp);\r		if (pp instanceof MergedBeanDefinitionPostProcessor) {\r			internalPostProcessors.add(pp);\r		}\r	}\r	sortPostProcessors(orderedPostProcessors, beanFactory);\r	registerBeanPostProcessors(beanFactory, orderedPostProcessors);\r\r	// 最后注册没有实现任何优先级接口的\r	// Now, register all regular BeanPostProcessors.\r	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();\r	for (String ppName : nonOrderedPostProcessorNames) {\r		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\r		nonOrderedPostProcessors.add(pp);\r		if (pp instanceof MergedBeanDefinitionPostProcessor) {\r			internalPostProcessors.add(pp);\r		}\r	}\r	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\r\r	// 最终注册MergedBeanDefinitionPostProcessor（MergedBeanDefinitionPostProcessor则是在合并处 理Bean定义的时候的回调，基本是框架内部使用的）\r	// Finally, re-register all internal BeanPostProcessors.\r	sortPostProcessors(internalPostProcessors, beanFactory);\r	registerBeanPostProcessors(beanFactory, internalPostProcessors);\r\r	// 注册一个ApplicationListenerDetector来在Bean创建完成后检查是否是ApplicationListener\r	// Re-register post-processor for detecting inner beans as ApplicationListeners,\r	// moving it to the end of the processor chain (for picking up proxies etc).\r	beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1820, 'Spring的IOC源码分析（七）——初始化MessageSource组件', '1820', 1567083961, 1567083961, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（七）&mdash;&mdash;初始化MessageSource组件～</p>\r<!--more-->\r\r<p>源码分析（AbstractApplicationContext的initMessageSource()）：</p>\r\r<pre class="brush:java;">\r/**\r * Initialize the MessageSource.\r * Use parent&#39;s if none defined in this context.\r */\rprotected void initMessageSource() {\r	// 获取BeanFactory\r	ConfigurableListableBeanFactory beanFactory = getBeanFactory();\r	// 判断工厂是否存在messageSource\r	if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\r		// 如果存在，就把它拿过来赋值为this.messageSource\r		this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\r		// Make MessageSource aware of parent MessageSource.\r		if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) {\r			HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\r			if (hms.getParentMessageSource() == null) {\r				// Only set parent context as parent MessageSource if no parent MessageSource\r				// registered already.\r				hms.setParentMessageSource(getInternalParentMessageSource());\r			}\r		}\r		if (logger.isDebugEnabled()) {\r			logger.debug(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);\r		}\r	} else {\r		// 如果不存在，就自己创建一个DelegatingMessageSource\r		// Use empty MessageSource to be able to accept getMessage calls.\r		DelegatingMessageSource dms = new DelegatingMessageSource();\r		dms.setParentMessageSource(getInternalParentMessageSource());\r		this.messageSource = dms;\r		beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\r		if (logger.isDebugEnabled()) {\r			logger.debug(&quot;Unable to locate MessageSource with name &#39;&quot; + MESSAGE_SOURCE_BEAN_NAME +\r					&quot;&#39;: using default [&quot; + this.messageSource + &quot;]&quot;);\r		}\r	}\r}\r\r@Override\r@Nullable\rpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\r	if (this.parentMessageSource != null) {\r		// 从properties中读取，取出国际化配置文件中的某个key的值，能按照区域信息locale获取\r		return this.parentMessageSource.getMessage(code, args, defaultMessage, locale);\r	}\r	else if (defaultMessage != null) {\r		return renderDefaultMessage(defaultMessage, args, locale);\r	}\r	else {\r		return null;\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1821, 'Spring的IOC源码分析（八）——初始化事件派发器', '1821', 1567084202, 1567084202, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（八）&mdash;&mdash;初始化事件派发器～</p>\r<!--more-->\r\r<p>源码分析（AbstractApplicationContext的initApplicationEventMulticaster()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Initialize the ApplicationEventMulticaster.\r * Uses SimpleApplicationEventMulticaster if none defined in the context.\r * @see org.springframework.context.event.SimpleApplicationEventMulticaster\r */\rprotected void initApplicationEventMulticaster() {\r	// 获取BeanFactory\r	ConfigurableListableBeanFactory beanFactory = getBeanFactory();\r	// 判断工厂是否存在applicationEventMulticaster的applicationEventMulticaster\r	if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\r		// 如果存在applicationEventMulticaster，把这个组件拿过来赋值为this.applicationEventMulticaster\r		this.applicationEventMulticaster =\r				beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\r		if (logger.isDebugEnabled()) {\r			logger.debug(&quot;Using ApplicationEventMulticaster [&quot; + this.applicationEventMulticaster + &quot;]&quot;);\r		}\r	} else {\r		// 如果不存在,自己创建一个DelegatingMessageSource\r		this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\r		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\r		if (logger.isDebugEnabled()) {\r			logger.debug(&quot;Unable to locate ApplicationEventMulticaster with name &#39;&quot; +\r					APPLICATION_EVENT_MULTICASTER_BEAN_NAME +\r					&quot;&#39;: using default [&quot; + this.applicationEventMulticaster + &quot;]&quot;);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1822, 'Spring的IOC源码分析（九）——注册监听器', '1822', 1567084454, 1567084454, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（九）&mdash;&mdash;注册监听器～</p>\r<!--more-->\r\r<p>源码分析（AbstractApplicationContext的registerListeners()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Add beans that implement ApplicationListener as listeners.\r * Doesn&#39;t affect other listeners, which can be added without being beans.\r */\rprotected void registerListeners() {\r	// 从事件派发器中拿到监听\r	// Register statically specified listeners first.\r	for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {\r		getApplicationEventMulticaster().addApplicationListener(listener);\r	}\r\r	// 直接从容器中拿到所有监听\r	// Do not initialize FactoryBeans here: We need to leave all regular beans\r	// uninitialized to let post-processors apply to them!\r	String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\r	for (String listenerBeanName : listenerBeanNames) {\r		// 将每个监听器添加到事件派发器中\r		getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\r	}\r\r	// Publish early application events now that we finally have a multicaster...\r	Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;\r	this.earlyApplicationEvents = null;\r	if (earlyEventsToProcess != null) {\r		for (ApplicationEvent earlyEvent : earlyEventsToProcess) {\r			// 派发之前步骤产生的事件\r			getApplicationEventMulticaster().multicastEvent(earlyEvent);\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1823, 'Spring的IOC源码分析（十）——创建所有单实例Bean并完成初始化', '1823', 1567084560, 1567084817, '<p>本文记录Java学习过程中遇到的Spring的IOC源码分析（十）&mdash;&mdash;创建所有单实例Bean并完成初始化～</p>\r<!--more-->\r\r<p>创建单实例的Bean已经在AOP部分看过很多遍了，不再重复，重点看完成初始化。</p>\r\r<p>源码分析（AbstractApplicationContext的finishRefresh()方法）：</p>\r\r<pre class="brush:java;">\r/**\r * Finish the refresh of this context, invoking the LifecycleProcessor&#39;s\r * onRefresh() method and publishing the\r * {@link org.springframework.context.event.ContextRefreshedEvent}.\r */\rprotected void finishRefresh() {\r	// 清除环境级别的缓存\r	// Clear context-level resource caches (such as ASM metadata from scanning).\r	clearResourceCaches();\r\r	// 初始化与生命周期有关的后置处理器\r	// Initialize lifecycle processor for this context.\r	initLifecycleProcessor();\r\r	// 拿到上面定义的生命周期处理器,回调onRefresh()\r	// Propagate refresh to lifecycle processor first.\r	getLifecycleProcessor().onRefresh();\r\r	// 发布容器刷新完成事件\r	// Publish the final event.\r	publishEvent(new ContextRefreshedEvent(this));\r\r	// 暴露一些Mbean之类\r	// Participate in LiveBeansView MBean, if active.\r	LiveBeansView.registerApplicationContext(this);\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1825, 'Servlet3.0——基本Servlet', '1825', 1568556226, 1568556226, '<p>本文记录Java学习过程中遇到的Servlet3.0&mdash;&mdash;基本Servlet～</p>\r<!--more-->\r\r<p>Servlet3.0抛弃了web.xml的配置，采用注解的形式。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@WebServlet(&quot;/myServlet&quot;)\rpublic class MyServlet extends HttpServlet {\r    @Override\r    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r        resp.getWriter().write(&quot;MyServlet.doGet()&quot;);\r    }\r}</pre>\r\r<p>直接访问webapp/myServlet就可以看到输出了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1826, 'Servlet3.0——共享库和运行时插件', '1826', 1568556540, 1568557017, '<p>本文记录Java学习过程中遇到的Servlet3.0&mdash;&mdash;共享库和运行时插件～</p>\r<!--more-->\r\r<p>Shared libraries and runtimes pluggability（共享库和运行时插件）的原理在框架整合里用得比较多，这里来分析一下他。</p>\r\r<p>ServletContainerInitializer初始化web容器：</p>\r\r<ul>\r	<li>在web容器启动时为提供给第三方组件机会做一些初始化的工作，例如注册servlet或者filters等，servlet规范(JSR356)中通过ServletContainerInitializer实现此功能；</li>\r	<li>每个框架要使用ServletContainerInitializer就必须在对应的jar包的META-INF/services目录创建一个名为javax.servlet.ServletContainerInitializer的文件，文件内容指定具体的ServletContainerInitializer实现类，当web容器启动时就会运行这个初始化器做一些组件内的初始化工作。</li>\r</ul>\r\r<p>示例代码（javax.servlet.ServletContainerInitializer）：</p>\r\r<pre class="brush:java;">\rren.oliver.spring.initializer.MyServletContainerInitializer</pre>\r\r<p>示例代码（MyServletContainerInitializer）：</p>\r\r<pre class="brush:java;">\r// 声明对哪些类感兴趣\r@HandlesTypes(InterfaceService.class)\rpublic class MyServletContainerInitializer implements ServletContainerInitializer {\r\r    // set是感兴趣的类的子类型的集合\r    @Override\r    public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException {\r\r        // 打印感兴趣的类型\r        System.out.println(&quot;感兴趣的类型有：&quot;);\r        for (Class&lt;?&gt; clazz : set) {\r            // 传进来后，可以根据自己需要利用反射来创建对象等操作\r            System.out.println(clazz);\r        }\r\r    }\r\r}</pre>\r\r<p>示例代码（InterfaceService）：</p>\r\r<pre class="brush:java;">\rpublic interface InterfaceService {\r	\r}</pre>\r\r<p>示例代码（OrderService）：</p>\r\r<pre class="brush:java;">\r// 接口的实现\rpublic class OrderService implements InterfaceService {\r	\r}</pre>\r\r<p>示例代码（SunInterfaceService）：</p>\r\r<pre class="brush:java;">\r// 接口的子接口\rpublic interface SunInterfaceService extends InterfaceService {\r\r}</pre>\r\r<p>示例代码（AbstractService）：</p>\r\r<pre class="brush:java;">\r// 接口的抽象类\rpublic abstract class AbstractService implements InterfaceService {\r    \r}</pre>\r\r<p>示例代码（ConcreteService）：</p>\r\r<pre class="brush:java;">\r// 接口的抽象类实现\rpublic class ConcreteService extends AbstractService {\r    \r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1827, 'Servlet3.0——三大组件', '1827', 1568594640, 1568615690, '<p>本文记录Java学习过程中遇到的Servlet3.0&mdash;&mdash;三大组件～</p>\r<!--more-->\r\r<p>使用ServletContext注册Web三大组件（其实就是Servlet,Filter,Listener三大组件）：对于我们自己写的Servlet，我们可以使用@WebServlet注解来加入JamesServlet组件，但若是我们要导入第三方阿里的连接池或filter，以前的web.xml方式就可通过配置加载就可以了，但现在我们使用ServletContext注入进来。</p>\r\r<p>示例代码（OrderServlet）：</p>\r\r<pre class="brush:java;">\rpublic class OrderServlet extends HttpServlet {\r\r    @Override\r    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r        resp.getWriter().write(&quot;OrderServlet.doGet()&quot;);\r    }\r\r}</pre>\r\r<p>示例代码（OrderFilter）：</p>\r\r<pre class="brush:java;">\rpublic class OrderFilter implements Filter {\r\r    @Override\r    public void init(FilterConfig filterConfig) throws ServletException {\r        System.out.println(&quot;OrderFilter.init()&quot;);\r    }\r\r    @Override\r    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\r        System.out.println(&quot;OrderFilter.doFilter()&quot;);\r        // 放行\r        chain.doFilter(request, response);\r    }\r\r    @Override\r    public void destroy() {\r        System.out.println(&quot;OrderFilter.destroy()&quot;);\r    }\r\r}</pre>\r\r<p>示例代码（OrderListener）：</p>\r\r<pre class="brush:java;">\r// 监听项目的启动或停止\rpublic class OrderListener implements ServletContextListener {\r\r    // 监听ServletContext初始化\r    @Override\r    public void contextInitialized(ServletContextEvent event) {\r        ServletContext servletContext = event.getServletContext();\r        System.out.println(&quot;OrderListener.contextInitialized()&quot;);\r    }\r\r    // 监听ServletContext销毁\r    @Override\r    public void contextDestroyed(ServletContextEvent event) {\r        System.out.println(&quot;OrderListener.contextDestroyed()&quot;);\r    }\r\r}</pre>\r\r<p>示例代码（MyServletContainerInitializer）：</p>\r\r<pre class="brush:java;">\r// 声明对哪些类感兴趣\r@HandlesTypes(InterfaceService.class)\rpublic class MyServletContainerInitializer implements ServletContainerInitializer {\r\r    // set是感兴趣的类的子类型的集合\r    @Override\r    public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException {\r\r        // 打印感兴趣的类型\r        System.out.println(&quot;感兴趣的类型有：&quot;);\r        for (Class&lt;?&gt; clazz : set) {\r            // 传进来后，可以根据自己需要利用反射来创建对象等操作\r            System.out.println(clazz);\r        }\r\r        // 注册OrderServlet\r        Registration.Dynamic servlet = servletContext.addServlet(&quot;orderServlet&quot;, OrderServlet.class);\r        ((ServletRegistration.Dynamic) servlet).addMapping(&quot;/order&quot;);\r\r        // 注册OrderListener\r        servletContext.addListener(OrderListener.class);\r\r        // 注册OrderFilter\r        FilterRegistration.Dynamic filter = servletContext.addFilter(&quot;orderFilter&quot;, OrderFilter.class);\r\r        // 添加OrderFilter的映射信息，指定拦截哪个路径\r        filter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), true, &quot;/order&quot;);\r    }\r\r}</pre>\r\r<p>注意：在运行的过程中，是不可以注册组件，和IOC道理一样，是出于安全考虑。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1828, 'SpringMVC源码分析', '1828', 1569079620, 1570184015, '<p>本文记录Java学习过程中遇到的SpringMVC源码分析～</p>\r<!--more-->\r\r<p>源码分析（javax.servlet.ServletContainerInitializer）：</p>\r\r<pre class="brush:java;">\rorg.springframework.web.SpringServletContainerInitializer</pre>\r\r<p>源码分析（SpringServletContainerInitializer）：</p>\r\r<pre class="brush:java;">\r// 感兴趣的类的接口WebApplicationInitializer\r@HandlesTypes(WebApplicationInitializer.class)\rpublic class SpringServletContainerInitializer implements ServletContainerInitializer {\r\r	/**\r	 * Delegate the {@code ServletContext} to any {@link WebApplicationInitializer}\r	 * implementations present on the application classpath.\r	 * &lt;p&gt;Because this class declares @{@code HandlesTypes(WebApplicationInitializer.class)},\r	 * Servlet 3.0+ containers will automatically scan the classpath for implementations\r	 * of Spring&#39;s {@code WebApplicationInitializer} interface and provide the set of all\r	 * such types to the {@code webAppInitializerClasses} parameter of this method.\r	 * &lt;p&gt;If no {@code WebApplicationInitializer} implementations are found on the classpath,\r	 * this method is effectively a no-op. An INFO-level log message will be issued notifying\r	 * the user that the {@code ServletContainerInitializer} has indeed been invoked but that\r	 * no {@code WebApplicationInitializer} implementations were found.\r	 * &lt;p&gt;Assuming that one or more {@code WebApplicationInitializer} types are detected,\r	 * they will be instantiated (and &lt;em&gt;sorted&lt;/em&gt; if the @{@link\r	 * org.springframework.core.annotation.Order @Order} annotation is present or\r	 * the {@link org.springframework.core.Ordered Ordered} interface has been\r	 * implemented). Then the {@link WebApplicationInitializer#onStartup(ServletContext)}\r	 * method will be invoked on each instance, delegating the {@code ServletContext} such\r	 * that each instance may register and configure servlets such as Spring&#39;s\r	 * {@code DispatcherServlet}, listeners such as Spring&#39;s {@code ContextLoaderListener},\r	 * or any other Servlet API componentry such as filters.\r	 * @param webAppInitializerClasses all implementations of\r	 * {@link WebApplicationInitializer} found on the application classpath\r	 * @param servletContext the servlet context to be initialized\r	 * @see WebApplicationInitializer#onStartup(ServletContext)\r	 * @see AnnotationAwareOrderComparator\r	 */\r	// 启动时调用此方法\r	// webAppInitializerClasses传入的感兴趣的类\r	@Override\r	public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)\r			throws ServletException {\r\r		List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();\r\r		if (webAppInitializerClasses != null) {\r			for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {\r				// Be defensive: Some servlet containers provide us with invalid classes,\r				// no matter what @HandlesTypes says...\r				if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;\r						WebApplicationInitializer.class.isAssignableFrom(waiClass)) {\r					try {\r						// 初始化每个WebApplicationInitializer\r						initializers.add((WebApplicationInitializer)\r								ReflectionUtils.accessibleConstructor(waiClass).newInstance());\r					}\r					catch (Throwable ex) {\r						throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);\r					}\r				}\r			}\r		}\r\r		if (initializers.isEmpty()) {\r			servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);\r			return;\r		}\r\r		servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);\r		AnnotationAwareOrderComparator.sort(initializers);\r		for (WebApplicationInitializer initializer : initializers) {\r			initializer.onStartup(servletContext);\r		}\r	}\r\r}</pre>\r\r<p>WebApplicationInitializer的四个子类：</p>\r\r<ul>\r	<li>AbstractAnnotationConfigDispatcherServletInitializer；</li>\r	<li>AbstractContextLoaderInitializer；</li>\r	<li>AbstractDispatcherServletInitializer；</li>\r	<li>AbstractReactiveWebInitializer。</li>\r</ul>\r\r<p>源码分析（AbstractDispatcherServletInitializer，DispatcherServlet初始化）：</p>\r\r<pre class="brush:java;">\r/**\r * Base class for {@link org.springframework.web.WebApplicationInitializer}\r * implementations that register a {@link DispatcherServlet} in the servlet context.\r *\r * &lt;p&gt;Most applications should consider extending the Spring Java config subclass\r * {@link AbstractAnnotationConfigDispatcherServletInitializer}.\r *\r * @author Arjen Poutsma\r * @author Chris Beams\r * @author Rossen Stoyanchev\r * @author Juergen Hoeller\r * @author Stephane Nicoll\r * @since 3.2\r */\rpublic abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer {\r\r	/**\r	 * The default servlet name. Can be customized by overriding {@link #getServletName}.\r	 */\r	public static final String DEFAULT_SERVLET_NAME = &quot;dispatcher&quot;;\r\r	// 启动的时候会调用\r	@Override\r	public void onStartup(ServletContext servletContext) throws ServletException {\r		// 先调用父类的同名方法\r		super.onStartup(servletContext);\r		// 注册DispatcherServlet\r		registerDispatcherServlet(servletContext);\r	}\r\r	/**\r	 * Register a {@link DispatcherServlet} against the given servlet context.\r	 * &lt;p&gt;This method will create a {@code DispatcherServlet} with the name returned by\r	 * {@link #getServletName()}, initializing it with the application context returned\r	 * from {@link #createServletApplicationContext()}, and mapping it to the patterns\r	 * returned from {@link #getServletMappings()}.\r	 * &lt;p&gt;Further customization can be achieved by overriding {@link\r	 * #customizeRegistration(ServletRegistration.Dynamic)} or\r	 * {@link #createDispatcherServlet(WebApplicationContext)}.\r	 * @param servletContext the context to register the servlet against\r	 */\r	protected void registerDispatcherServlet(ServletContext servletContext) {\r		String servletName = getServletName();\r		Assert.hasLength(servletName, &quot;getServletName() must not return null or empty&quot;);\r\r		// 创建WebContext对象\r		WebApplicationContext servletAppContext = createServletApplicationContext();\r		Assert.notNull(servletAppContext, &quot;createServletApplicationContext() must not return null&quot;);\r\r		// 创建DispatcherServlet\r		FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);\r		Assert.notNull(dispatcherServlet, &quot;createDispatcherServlet(WebApplicationContext) must not return null&quot;);\r		dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());\r\r		// 将DispatcherServlet加到ServletContext中\r		ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);\r		if (registration == null) {\r			throw new IllegalStateException(&quot;Failed to register servlet with name &#39;&quot; + servletName + &quot;&#39;. &quot; +\r					&quot;Check if there is another servlet registered under the same name.&quot;);\r		}\r\r		// 设置ServletContext的启动顺序\r		registration.setLoadOnStartup(1);\r		// 设置要拦截的路径\r		registration.addMapping(getServletMappings());\r		registration.setAsyncSupported(isAsyncSupported());\r\r		Filter[] filters = getServletFilters();\r		if (!ObjectUtils.isEmpty(filters)) {\r			for (Filter filter : filters) {\r				registerServletFilter(servletContext, filter);\r			}\r		}\r\r		customizeRegistration(registration);\r	}\r\r	/**\r	 * Return the name under which the {@link DispatcherServlet} will be registered.\r	 * Defaults to {@link #DEFAULT_SERVLET_NAME}.\r	 * @see #registerDispatcherServlet(ServletContext)\r	 */\r	protected String getServletName() {\r		return DEFAULT_SERVLET_NAME;\r	}\r\r	/**\r	 * Create a servlet application context to be provided to the {@code DispatcherServlet}.\r	 * &lt;p&gt;The returned context is delegated to Spring&#39;s\r	 * {@link DispatcherServlet#DispatcherServlet(WebApplicationContext)}. As such,\r	 * it typically contains controllers, view resolvers, locale resolvers, and other\r	 * web-related beans.\r	 * @see #registerDispatcherServlet(ServletContext)\r	 */\r	protected abstract WebApplicationContext createServletApplicationContext();\r\r	/**\r	 * Create a {@link DispatcherServlet} (or other kind of {@link FrameworkServlet}-derived\r	 * dispatcher) with the specified {@link WebApplicationContext}.\r	 * &lt;p&gt;Note: This allows for any {@link FrameworkServlet} subclass as of 4.2.3.\r	 * Previously, it insisted on returning a {@link DispatcherServlet} or subclass thereof.\r	 */\r	protected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext) {\r		return new DispatcherServlet(servletAppContext);\r	}\r\r	/**\r	 * Specify application context initializers to be applied to the servlet-specific\r	 * application context that the {@code DispatcherServlet} is being created with.\r	 * @since 4.2\r	 * @see #createServletApplicationContext()\r	 * @see DispatcherServlet#setContextInitializers\r	 * @see #getRootApplicationContextInitializers()\r	 */\r	@Nullable\r	protected ApplicationContextInitializer&lt;?&gt;[] getServletApplicationContextInitializers() {\r		return null;\r	}\r\r	/**\r	 * Specify the servlet mapping(s) for the {@code DispatcherServlet} &amp;mdash;\r	 * for example {@code &quot;/&quot;}, {@code &quot;/app&quot;}, etc.\r	 * @see #registerDispatcherServlet(ServletContext)\r	 */\r	protected abstract String[] getServletMappings();\r\r	/**\r	 * Specify filters to add and map to the {@code DispatcherServlet}.\r	 * @return an array of filters or {@code null}\r	 * @see #registerServletFilter(ServletContext, Filter)\r	 */\r	@Nullable\r	protected Filter[] getServletFilters() {\r		return null;\r	}\r\r	/**\r	 * Add the given filter to the ServletContext and map it to the\r	 * {@code DispatcherServlet} as follows:\r	 * &lt;ul&gt;\r	 * &lt;li&gt;a default filter name is chosen based on its concrete type\r	 * &lt;li&gt;the {@code asyncSupported} flag is set depending on the\r	 * return value of {@link #isAsyncSupported() asyncSupported}\r	 * &lt;li&gt;a filter mapping is created with dispatcher types {@code REQUEST},\r	 * {@code FORWARD}, {@code INCLUDE}, and conditionally {@code ASYNC} depending\r	 * on the return value of {@link #isAsyncSupported() asyncSupported}\r	 * &lt;/ul&gt;\r	 * &lt;p&gt;If the above defaults are not suitable or insufficient, override this\r	 * method and register filters directly with the {@code ServletContext}.\r	 * @param servletContext the servlet context to register filters with\r	 * @param filter the filter to be registered\r	 * @return the filter registration\r	 */\r	protected FilterRegistration.Dynamic registerServletFilter(ServletContext servletContext, Filter filter) {\r		String filterName = Conventions.getVariableName(filter);\r		Dynamic registration = servletContext.addFilter(filterName, filter);\r\r		if (registration == null) {\r			int counter = 0;\r			while (registration == null) {\r				if (counter == 100) {\r					throw new IllegalStateException(&quot;Failed to register filter with name &#39;&quot; + filterName + &quot;&#39;. &quot; +\r							&quot;Check if there is another filter registered under the same name.&quot;);\r				}\r				registration = servletContext.addFilter(filterName + &quot;#&quot; + counter, filter);\r				counter++;\r			}\r		}\r\r		registration.setAsyncSupported(isAsyncSupported());\r		registration.addMappingForServletNames(getDispatcherTypes(), false, getServletName());\r		return registration;\r	}\r\r	private EnumSet&lt;DispatcherType&gt; getDispatcherTypes() {\r		return (isAsyncSupported() ?\r				EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ASYNC) :\r				EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE));\r	}\r\r	/**\r	 * A single place to control the {@code asyncSupported} flag for the\r	 * {@code DispatcherServlet} and all filters added via {@link #getServletFilters()}.\r	 * &lt;p&gt;The default value is &quot;true&quot;.\r	 */\r	protected boolean isAsyncSupported() {\r		return true;\r	}\r\r	/**\r	 * Optionally perform further registration customization once\r	 * {@link #registerDispatcherServlet(ServletContext)} has completed.\r	 * @param registration the {@code DispatcherServlet} registration to be customized\r	 * @see #registerDispatcherServlet(ServletContext)\r	 */\r	protected void customizeRegistration(ServletRegistration.Dynamic registration) {\r	}\r\r}</pre>\r\r<p>源码分析（AbstractAnnotationConfigDispatcherServletInitializer）：</p>\r\r<pre class="brush:java;">\r/**\r * {@link org.springframework.web.WebApplicationInitializer WebApplicationInitializer}\r * to register a {@code DispatcherServlet} and use Java-based Spring configuration.\r *\r * &lt;p&gt;Implementations are required to implement:\r * &lt;ul&gt;\r * &lt;li&gt;{@link #getRootConfigClasses()} -- for &quot;root&quot; application context (non-web\r * infrastructure) configuration.\r * &lt;li&gt;{@link #getServletConfigClasses()} -- for {@code DispatcherServlet}\r * application context (Spring MVC infrastructure) configuration.\r * &lt;/ul&gt;\r *\r * &lt;p&gt;If an application context hierarchy is not required, applications may\r * return all configuration via {@link #getRootConfigClasses()} and return\r * {@code null} from {@link #getServletConfigClasses()}.\r *\r * @author Arjen Poutsma\r * @author Chris Beams\r * @since 3.2\r */\rpublic abstract class AbstractAnnotationConfigDispatcherServletInitializer\r		extends AbstractDispatcherServletInitializer {\r\r	/**\r	 * {@inheritDoc}\r	 * &lt;p&gt;This implementation creates an {@link AnnotationConfigWebApplicationContext},\r	 * providing it the annotated classes returned by {@link #getRootConfigClasses()}.\r	 * Returns {@code null} if {@link #getRootConfigClasses()} returns {@code null}.\r	 */\r	@Override\r	@Nullable\r	protected WebApplicationContext createRootApplicationContext() {\r		Class&lt;?&gt;[] configClasses = getRootConfigClasses();\r		// 以注解的方式启动Spring\r		if (!ObjectUtils.isEmpty(configClasses)) {\r			// 创建根容器\r			AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\r			// 将配置注册进去\r			context.register(configClasses);\r			return context;\r		}\r		else {\r			return null;\r		}\r	}\r\r	/**\r	 * {@inheritDoc}\r	 * &lt;p&gt;This implementation creates an {@link AnnotationConfigWebApplicationContext},\r	 * providing it the annotated classes returned by {@link #getServletConfigClasses()}.\r	 */\r	@Override\r	protected WebApplicationContext createServletApplicationContext() {\r		// 创建WebContext\r		AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\r		Class&lt;?&gt;[] configClasses = getServletConfigClasses();\r		if (!ObjectUtils.isEmpty(configClasses)) {\r			// 通过注解来完成Web的IOC容器，用来扫描@Controller\r			context.register(configClasses);\r		}\r		return context;\r	}\r\r	/**\r	 * Specify {@code @Configuration} and/or {@code @Component} classes for the\r	 * {@linkplain #createRootApplicationContext() root application context}.\r	 * @return the configuration for the root application context, or {@code null}\r	 * if creation and registration of a root context is not desired\r	 */\r	@Nullable\r	protected abstract Class&lt;?&gt;[] getRootConfigClasses();\r\r	/**\r	 * Specify {@code @Configuration} and/or {@code @Component} classes for the\r	 * {@linkplain #createServletApplicationContext() Servlet application context}.\r	 * @return the configuration for the Servlet application context, or\r	 * {@code null} if all configuration is specified through root config classes.\r	 */\r	@Nullable\r	protected abstract Class&lt;?&gt;[] getServletConfigClasses();\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1829, 'SpringMVC的根容器与Servlet子容器的区别.png', 'SpringMVC的根容器与Servlet子容器的区别-png', 1569079955, 1569079955, 'a:5:{s:4:"name";s:53:"SpringMVC的根容器与Servlet子容器的区别.png";s:4:"path";s:35:"/usr/uploads/2019/09/4158651128.png";s:4:"size";i:199189;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1830, 0),
(1830, 'SpringMVC的根容器与Servlet子容器的区别', '1830', 1569079980, 1570183987, '<p>本文记录Java学习过程中遇到的SpringMVC的根容器与Servlet子容器的区别～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/09/4158651128.png" style="width: 800px; height: 728px;" />​</p>\r\r<p>两者的区别总结为：</p>\r\r<ul>\r	<li>Servlet的容器用来处理@Controller，视图解析，和Web相关组件；</li>\r	<li>根容器主要针对服务层，和数据层及事务控制相关处理。</li>\r</ul>\r\r<p>官方文档：<a href="https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/web.html#mvc-servlet-context-hierarchy" target="_blank">docs</a></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1831, 'SpringMVC实战——注解版', '1831', 1569085680, 1570183976, '<p>本文记录Java学习过程中遇到的SpringMVC实战&mdash;&mdash;注解版～</p>\r<!--more-->\r\r<p>示例代码（MyInitializer）：</p>\r\r<pre class="brush:java;">\rpublic class MyInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\r\r    // 获取根容器的配置类（Spring的配置文件）\r    @Override\r    protected Class&lt;?&gt;[] getRootConfigClasses() {\r        return new Class[]{RootConfig.class};\r    }\r\r    // 获取Web容器的配置类（SpringMVC配置文件）\r    @Override\r    protected Class&lt;?&gt;[] getServletConfigClasses() {\r        return new Class[]{AppConfig.class};\r    }\r\r    // 获取DispatcherServlet的映射信息\r    // /：拦截所有请求（包括静态资源（xx.js,xx.png）），但是不包括*.jsp；\r    // /*：拦截所有请求（连*.jsp页面都拦截），jsp页面是Tomcat的jsp引擎解析的。\r    @Override\r    protected String[] getServletMappings() {\r        return new String[]{&quot;/&quot;};\r    }\r    \r}</pre>\r\r<p>示例代码（RootConfig）：</p>\r\r<pre class="brush:java;">\r// 根容器的配置\r// 排出Controller注解\r@ComponentScan(\r        value=&quot;ren.oliver.spring.mvc&quot;,\r        excludeFilters={\r                @ComponentScan.Filter(type=FilterType.ANNOTATION,classes={Controller.class})\r        }\r)\rpublic class RootConfig {\r\r}</pre>\r\r<p>示例代码（AppConfig）：</p>\r\r<pre class="brush:java;">\r// Web容器的配置\r@EnableWebMvc\r// 禁用默认的过滤规则；只扫描Controller注解的\r@ComponentScan(\r        value=&quot;ren.oliver.spring.mvc&quot;,\r        includeFilters={\r                @ComponentScan.Filter(type=FilterType.ANNOTATION,classes={Controller.class})\r        },\r        useDefaultFilters=false\r)\rpublic class AppConfig extends WebMvcConfigurerAdapter {\r\r    // 定制视图解析器\r    @Override\r    public void configureViewResolvers(ViewResolverRegistry registry) {\r        // 比如我们想用JSP解析器，默认所有的页面都从/WEB-INF/ok.jsp\r        registry.jsp(&quot;/WEB-INF/pages/&quot;,&quot;.jsp&quot;);\r    }\r\r    // 静态资源访问,静态资源交给Tomcat来处理\r    @Override\r    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\r        configurer.enable();\r    }\r\r    // 拦截器\r    @Override\r    public void addInterceptors(InterceptorRegistry registry) {\r        // 拦截器配置拦截所有请求\r        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);\r    }\r\r}</pre>\r\r<p>示例代码（MyInterceptor）：</p>\r\r<pre class="brush:java;">\rpublic class MyInterceptor implements HandlerInterceptor {\r\r    // 在目标方法运行之间执行\r    @Override\r    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r        System.out.println(&quot;MyInterceptor.preHandle&quot;);\r        return true;\r    }\r\r    // 在目标方法执行之后执行\r    @Override\r    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\r        System.out.println(&quot;MyInterceptor.postHandle&quot;);\r    }\r\r    // 页面响应之后执行\r    @Override\r    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r        System.out.println(&quot;MyInterceptor.afterCompletion&quot;);\r    }\r\r}</pre>\r\r<p>示例代码（OrderController）：</p>\r\r<pre class="brush:java;">\r@Controller\rpublic class OrderController {\r\r    @Autowired\r    OrderService orderService;\r\r    @ResponseBody\r    @RequestMapping(&quot;/buy&quot;)\r    public String buy(){\r        return orderService.buy(&quot;12345678&quot;);\r    }\r\r    // 相当于会找 /WEB-INF/pages/ok.jsp\r    @RequestMapping(&quot;/ok&quot;)\r    public String ok(){\r        return &quot;ok&quot;;\r    }\r}</pre>\r\r<p>示例代码（OrderService）：</p>\r\r<pre class="brush:java;">\r@Service\rpublic class OrderService {\r    public String buy(String orderId){\r        return &quot;OrderId: &quot; + orderId;\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 5),
(1835, '同步处理原理.png', '同步处理原理-png', 1569120850, 1569120850, 'a:5:{s:4:"name";s:22:"同步处理原理.png";s:4:"path";s:34:"/usr/uploads/2019/09/532974579.png";s:4:"size";i:56153;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1836, 0),
(1836, 'Servlet同步处理', '1836', 1569120840, 1570183948, '<p>本文记录Java学习过程中遇到的Servlet同步处理～</p>\r<!--more-->\r\r<p>同步处理：请求发出后，等待服务端响应。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/09/3460403435.png" style="width: 800px; height: 706px;" /></p>\r\r<p>同步处理的原理：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/09/532974579.png" style="width: 800px; height: 544px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@WebServlet(&quot;/sync&quot;)\rpublic class SyncServlet extends HttpServlet {\r\r    @Override\r    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\r        System.out.println(Thread.currentThread() + &quot;开始执行&quot;);\r        try {\r            sync();\r        } catch (InterruptedException e) {\r            e.printStackTrace();\r        }\r\r        resp.getWriter().write(&quot;处理成功&quot;);\r        System.out.println(Thread.currentThread() + &quot;结束执行&quot;);\r    }\r\r    public void sync() throws InterruptedException{\r        System.out.println(Thread.currentThread() + &quot;业务开始&quot;);\r        // 模拟业务操作\r        Thread.sleep(100 * 1000);\r        System.out.println(Thread.currentThread() + &quot;业务结束&quot;);\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1838, '异步处理原理.png', '异步处理原理-png', 1569122870, 1569122870, 'a:5:{s:4:"name";s:22:"异步处理原理.png";s:4:"path";s:35:"/usr/uploads/2019/09/2799207055.png";s:4:"size";i:107749;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1839, 0),
(1839, 'Servlet异步处理', '1839', 1569122880, 1570183936, '<p>本文记录Java学习过程中遇到的Servlet异步处理～</p>\r<!--more-->\r\r<p>异步处理：请求发出后，主线程不一直等待，转交给子线程处理。</p>\r\r<p>异步处理的原理：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/09/2799207055.png" style="width: 800px; height: 394px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 支持异步处理: asyncSupported = true\r@WebServlet(value = &quot;/async&quot;, asyncSupported = true)\rpublic class AsyncServlet extends HttpServlet {\r\r    @Override\r    protected void doGet(final HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r        System.out.println(&quot;主线程&quot; + Thread.currentThread() + &quot;开始，时间：&quot; + System.currentTimeMillis());\r        final AsyncContext startAsync = req.startAsync();\r        startAsync.start(new Runnable() {\r            @Override\r            public void run() {\r                try {\r                    System.out.println(&quot;副线程&quot; + Thread.currentThread() + &quot;开始，时间：&quot; + System.currentTimeMillis());\r                    // 业务处理\r                    async();\r                    AsyncContext asyncContext = req.getAsyncContext();\r                    ServletResponse response = asyncContext.getResponse();\r                    response.getWriter().write(&quot;处理成功&quot;);\r                    // 通知Servlet处理结束\r                    startAsync.complete();\r                    System.out.println(&quot;副线程&quot; + Thread.currentThread() + &quot;结束，时间：&quot; + System.currentTimeMillis());\r                } catch (InterruptedException e) {\r                    e.printStackTrace();\r                } catch (IOException e) {\r                    e.printStackTrace();\r                }\r            }\r        });\r        System.out.println(&quot;主线程&quot; + Thread.currentThread()+&quot;结束，时间：&quot; + System.currentTimeMillis());\r    }\r\r    public void async() throws InterruptedException{\r        System.out.println(Thread.currentThread() + &quot;业务开始&quot;);\r        // 模拟业务操作\r        Thread.sleep(5 * 1000);\r        System.out.println(Thread.currentThread() + &quot;业务结束&quot;);\r    }\r    \r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1834, '同步处理.png', '同步处理-png', 1569120849, 1569120849, 'a:5:{s:4:"name";s:16:"同步处理.png";s:4:"path";s:35:"/usr/uploads/2019/09/3460403435.png";s:4:"size";i:41921;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1836, 0),
(1840, 'SpingMVC异步处理——Callable', '1840', 1569163680, 1570183923, '<p>本文记录Java学习过程中遇到的SpingMVC异步处理&mdash;&mdash;Callable～</p>\r<!--more-->\r\r<p>官方文档：<a href="https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/web.html#mvc-servlet-context-hierarchy" target="_blank">docs</a></p>\r\r<p>示例代码（AsyncController）：</p>\r\r<pre class="brush:java;">\r@Controller\r@RequestMapping(&quot;/async&quot;)\rpublic class AsyncController {\r\r    @ResponseBody\r    @RequestMapping(&quot;/callable&quot;)\r    public Callable&lt;String&gt; callable() {\r        System.out.println(&quot;主线程&quot; + Thread.currentThread() + &quot;开始，时间：&quot; + System.currentTimeMillis());\r        Callable&lt;String&gt; callable = new Callable&lt;String&gt;() {\r            @Override\r            public String call() throws Exception {\r                System.out.println(&quot;副线程&quot; + Thread.currentThread() + &quot;开始，时间：&quot; + System.currentTimeMillis());\r                // 模拟业务处理\r                Thread.sleep(5 * 1000);\r                System.out.println(&quot;副线程&quot; + Thread.currentThread() + &quot;结束，时间：&quot; + System.currentTimeMillis());\r                return &quot;处理成功&quot;;\r            }\r        };\r        System.out.println(&quot;主线程&quot; + Thread.currentThread() + &quot;结束，时间：&quot; + System.currentTimeMillis());\r        return callable;\r    }\r\r}</pre>\r\r<p>可以从拦截器的执行结果看到，请求进入时拦截了一次，将Callable返回结果时，将请求重新派发给容器时又拦截了一次，一共进行了两次拦截，验证代码如下。</p>\r\r<p>示例代码（MyInterceptor）：</p>\r\r<pre class="brush:java;">\rpublic class MyInterceptor implements HandlerInterceptor {\r\r    // 在目标方法运行之间执行\r    @Override\r    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r        System.out.println(&quot;MyInterceptor.preHandle, URI:&quot; + request.getRequestURI());\r        return true;\r    }\r\r    // 在目标方法执行之后执行\r    @Override\r    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\r        System.out.println(&quot;MyInterceptor.postHandle, URI:&quot; + request.getRequestURI());\r    }\r\r    // 页面响应之后执行\r    @Override\r    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r        System.out.println(&quot;MyInterceptor.afterCompletion, URI:&quot; + request.getRequestURI());\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1841, 'DeferredResult原理.png', 'DeferredResult原理-png', 1569166084, 1569166084, 'a:5:{s:4:"name";s:24:"DeferredResult原理.png";s:4:"path";s:35:"/usr/uploads/2019/09/3890176583.png";s:4:"size";i:55126;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1842, 0),
(1842, 'SpingMVC异步处理——DeferredResult', '1842', 1569166140, 1570183890, '<p>本文记录Java学习过程中遇到的SpingMVC异步处理&mdash;&mdash;DeferredResult～</p>\r<!--more-->\r\r<p>DeferredResult原理为：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/09/3890176583.png" style="width: 716px; height: 320px;" /></p>\r\r<p>示例代码（MyDeferredQueue）：</p>\r\r<pre class="brush:java;">\rpublic class MyDeferredQueue {\r\r    // 用一个队列来保存结果\r    private static Queue&lt;DeferredResult&lt;String&gt;&gt; queue = new ConcurrentLinkedQueue&lt;&gt;();\r\r    // 将元素加到队列尾部\r    public static void put(DeferredResult&lt;String&gt; deferredResult){\r        queue.add(deferredResult);\r    }\r\r    // 获取队列的第一个元素\r    public static DeferredResult&lt;String&gt; get(){\r        return queue.poll();\r    }\r\r}</pre>\r\r<p>示例代码（AsyncController）：</p>\r\r<pre class="brush:java;">\r@Controller\r@RequestMapping(&quot;/async&quot;)\rpublic class AsyncController {\r\r    @ResponseBody\r    @RequestMapping(&quot;/callable&quot;)\r    public Callable&lt;String&gt; callable() {\r        System.out.println(&quot;主线程&quot; + Thread.currentThread() + &quot;开始，时间：&quot; + System.currentTimeMillis());\r        Callable&lt;String&gt; callable = new Callable&lt;String&gt;() {\r            @Override\r            public String call() throws Exception {\r                System.out.println(&quot;副线程&quot; + Thread.currentThread() + &quot;开始，时间：&quot; + System.currentTimeMillis());\r                // 模拟业务处理\r                Thread.sleep(5 * 1000);\r                System.out.println(&quot;副线程&quot; + Thread.currentThread() + &quot;结束，时间：&quot; + System.currentTimeMillis());\r                return &quot;处理成功&quot;;\r            }\r        };\r        System.out.println(&quot;主线程&quot; + Thread.currentThread() + &quot;结束，时间：&quot; + System.currentTimeMillis());\r        return callable;\r    }\r\r    // 相当于Tomcat的线程1，来处理用户请求，并将请求的操作放到Queue队列里\r    @ResponseBody\r    @RequestMapping(&quot;/deferredResultPut&quot;)\r    public DeferredResult&lt;String&gt; deferredResultPut() {\r        // 设置等待超时时间和超时错误\r        DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;(5 * 1000L, &quot;failed&quot;);\r        // 将请求保存到队列\r        MyDeferredQueue.put(deferredResult);\r        return deferredResult;\r    }\r\r    // 相当于Tomcat的线程N，来处理用户请求，并将请求的操作放到Queue队列里\r    @ResponseBody\r    @RequestMapping(&quot;/deferredResultGet&quot;)\r    public String deferredResultGet() {\r        // 创建订单（按真实操作应该是从订单服务取，这里直接返回）\r        // 模拟从订单服务获取的订单信息（免调接口）\r        String id = UUID.randomUUID().toString();\r        DeferredResult&lt;String&gt; deferredResult = MyDeferredQueue.get();\r        deferredResult.setResult(id);\r        return id;\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1850, '为什么需要ORM框架', '1850', 1570191900, 1570191966, '<p>本文记录Java学习过程中遇到的为什么需要ORM框架～</p>\r<!--more-->\r\r<p>先来看一段JDBC的代码来感受一下～</p>\r\r<p>示例代码（QueryStatement）：</p>\r\r<pre class="brush:java;">\rpublic void queryStatement() {\r\r    Connection connection = null;\r    Statement statement = null;\r\r    List&lt;User&gt; users = new ArrayList&lt;&gt;();\r    try {\r\r        // 注册MySQL驱动\r        System.out.println(&quot;注册MySQL驱动&quot;);\r        Class.forName(JDBC_DRIVER);\r\r        // 获得一个连接\r        System.out.println(&quot;获得一个连接&quot;);\r        connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);\r\r        // 创建一个查询\r        System.out.println(&quot;创建一个查询&quot;);\r        statement = connection.createStatement();\r\r        // 创建SQL\r        String userName = &quot;oliver&quot;;\r        String sql = &quot;SELECT * FROM t_user where user_name=&#39;&quot; + userName + &quot;&#39;&quot;;\r        // 打印SQL\r        System.out.println(&quot;SQL语句：&quot; + sql);\r\r        // 执行SQL语句\r        ResultSet resultSet = statement.executeQuery(sql);\r\r        // 从resultSet中获取数据并转化成pojo对象\r        while (resultSet.next()) {\r            User user = new User();\r			user.setId(resultSet.getInt(&quot;id&quot;));\r			user.setUserName(resultSet.getString(&quot;user_name&quot;));\r            user.setRealName(resultSet.getString(&quot;real_name&quot;));\r            user.setSex(resultSet.getByte(&quot;sex&quot;));\r            user.setMobile(resultSet.getString(&quot;mobile&quot;));\r            user.setEmail(resultSet.getString(&quot;email&quot;));\r            user.setNote(resultSet.getString(&quot;note&quot;));\r            System.out.println(user.toString());\r            users.add(user);\r        }\r\r        // 关闭连接，释放资源\r        resultSet.close();\r        statement.close();\r        connection.close();\r    } catch (SQLException e) {\r        e.printStackTrace();\r    } catch (Exception e) {\r        e.printStackTrace();\r    } finally {\r        // 确保资源一定被释放\r        try {\r            if (statement != null) {\r                statement.close();\r            }\r        } catch (SQLException e) {\r            e.printStackTrace();\r        }\r        try {\r            if (connection != null) {\r                connection.close();\r\r            }\r        } catch (SQLException e) {\r            e.printStackTrace();\r        }\r    }\r}</pre>\r\r<p>示例代码（QueryPreparedStatement）：</p>\r\r<pre class="brush:java;">\rpublic void queryPreparedStatement() {\r\r    Connection conn = null;\r    PreparedStatement stmt = null;\r\r    List&lt;User&gt; users = new ArrayList&lt;&gt;();\r    try {\r\r        // 注册MySQL驱动\r        System.out.println(&quot;注册MySQL驱动&quot;);\r        Class.forName(JDBC_DRIVER);\r\r        // 获得一个连接\r        System.out.println(&quot;获得一个连接&quot;);\r        conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);\r\r        // 创建一个查询\r        System.out.println(&quot;创建一个查询&quot;);\r        // 创建SQL\r        String sql = &quot;SELECT * FROM t_user where user_name= ? &quot;;\r        stmt = conn.prepareStatement(sql);\r        stmt.setString(1, &quot;oliver&quot;);\r        // 打印SQL\r        System.out.println(&quot;SQL: &quot; + stmt.toString());\r        ResultSet rs = stmt.executeQuery();\r\r        // 从resultSet中获取数据并转化成pojo对象\r        while (rs.next()) {\r            User user = new User();\r			user.setId(rs.getInt(&quot;id&quot;));\r			user.setUserName(rs.getString(&quot;user_name&quot;));\r            user.setRealName(rs.getString(&quot;real_name&quot;));\r            user.setSex(rs.getByte(&quot;sex&quot;));\r            user.setMobile(rs.getString(&quot;mobile&quot;));\r            user.setEmail(rs.getString(&quot;email&quot;));\r            user.setNote(rs.getString(&quot;note&quot;));\r            System.out.println(user.toString());\r            users.add(user);\r        }\r\r        // 关闭连接，释放资源\r        rs.close();\r        stmt.close();\r        conn.close();\r    } catch (SQLException e) {\r        e.printStackTrace();\r    } catch (Exception e) {\r        e.printStackTrace();\r    } finally {\r        // 确保资源一定被释放\r        try {\r            if (stmt != null)\r                stmt.close();\r        } catch (SQLException e) {\r            e.printStackTrace();\r        }\r        try {\r            if (conn != null)\r                conn.close();\r        } catch (SQLException e) {\r            e.printStackTrace();\r        }\r    }\r\r    // 打印查询结果数量\r    System.out.println(&quot;查询到的总用户数：&quot; + users.size());\r}</pre>\r\r<p>示例代码（UpdateStatement）：</p>\r\r<pre class="brush:java;">\rpublic void updateStatement() {\r\r    Connection conn = null;\r    PreparedStatement stmt = null;\r\r    try {\r\r        // 注册MySQL的驱动\r        System.out.println(&quot;注册MySQL的驱动&quot;);\r        Class.forName(JDBC_DRIVER);\r\r        // 获得一个连接\r        System.out.println(&quot;获得一个连接&quot;);\r        conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);\r\r        // 启动手动提交\r        conn.setAutoCommit(false);\r\r        // 创建一个更新\r        System.out.println(&quot;创建一个更新&quot;);\r        String sql = &quot;update t_user  set mobile= ? where user_name= ? &quot;;\r        stmt = conn.prepareStatement(sql);\r        stmt.setString(1, &quot;18999999999&quot;);\r        stmt.setString(2, &quot;oliver&quot;);\r        // 打印SQL\r        System.out.println(stmt.toString());\r        // 执行SQL\r        int ret = stmt.executeUpdate();\r        System.out.println(&quot;此次修改影响数据库的行数为：&quot; + ret);\r\r        // 手动提交数据\r        conn.commit();\r\r        // 关闭连接，释放资源\r        stmt.close();\r        conn.close();\r    } catch (SQLException se) {\r        try {\r            conn.rollback();\r        } catch (SQLException e) {\r            e.printStackTrace();\r        }\r        se.printStackTrace();\r    } catch (Exception e) {\r        try {\r            conn.rollback();\r        } catch (SQLException se) {\r            se.printStackTrace();\r        }\r        e.printStackTrace();\r    } finally {\r        // 确保资源一定被释放\r        try {\r            if (stmt != null)\r                stmt.close();\r        } catch (SQLException e) {\r            e.printStackTrace();\r        }\r        try {\r            if (conn != null)\r                conn.close();\r        } catch (SQLException e) {\r            e.printStackTrace();\r        }\r    }\r}</pre>\r\r<p>传统的JDBC编程存在的弊端：</p>\r\r<ul>\r	<li>工作量大，操作数据库至少要5步；</li>\r	<li>业务代码和技术代码耦合；</li>\r	<li>连接资源手动关闭，存在隐患。</li>\r</ul>\r\r<p>所以就诞生了各种ORM框架～</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1854, 'h-vs-m.png', 'h-vs-m-png', 1570199866, 1570199866, 'a:5:{s:4:"name";s:10:"h-vs-m.png";s:4:"path";s:35:"/usr/uploads/2019/10/1818681821.png";s:4:"size";i:84270;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1855, 0),
(1855, 'Hibernate与MyBatis', '1855', 1570199880, 1570200117, '<p>本文记录Java学习过程中遇到的Hibernate与MyBatis～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/10/1818681821.png" style="width: 800px; height: 160px;" /></p>\r\r<p>Hibernate：</p>\r\r<ul>\r	<li>全表映射带来不便；</li>\r	<li>无法自定义组装SQL；</li>\r	<li>复杂关联关系以及复杂SQL语句支持弱；</li>\r	<li>不支持存储过程；</li>\r	<li>HQL黑盒封装，调优复杂；</li>\r	<li>性能较差，不适合大型互联网高性能要求。</li>\r</ul>\r\r<p>MyBatis：</p>\r\r<ul>\r	<li>几乎可以替换JDBC；</li>\r	<li>高度灵活；</li>\r	<li>基于底层SQL的优化能力；</li>\r	<li>学习门槛低，易于维护；</li>\r	<li>开发工作量相对较大。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1856, 'MyBatis简介.png', 'MyBatis简介-png', 1570200049, 1570200049, 'a:5:{s:4:"name";s:17:"MyBatis简介.png";s:4:"path";s:35:"/usr/uploads/2019/10/4271709288.png";s:4:"size";i:85118;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1857, 0),
(1857, 'MyBatis简介', '1857', 1570200060, 1570200132, '<p>本文记录Java学习过程中遇到的MyBatis简介～</p>\r<!--more-->\r\r<p>MyBatis前身是iBatis,其源于&ldquo;Internet&rdquo;和&ldquo;ibatis&rdquo;的组合，本质是一种半自动的ORM框架，除了POJO和映射关系之外，还需要编写SQL语句。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/10/4271709288.png" style="width: 800px; height: 182px;" /></p>\r\r<p>Mybatis映射文件三要素：</p>\r\r<ul>\r	<li>SQL；</li>\r	<li>POJO；</li>\r	<li>映射规则。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1861, 'MyBatis快速入门.png', 'MyBatis快速入门-png', 1570203950, 1570203950, 'a:5:{s:4:"name";s:23:"MyBatis快速入门.png";s:4:"path";s:35:"/usr/uploads/2019/10/1197629439.png";s:4:"size";i:66880;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1862, 0),
(1862, 'MyBatis快速入门', '1862', 1570203960, 1570203989, '<p>本文记录Java学习过程中遇到的MyBatis快速入门～</p>\r<!--more-->\r\r<p>示例代码（加入MyBatis的依赖-pom.xml）：</p>\r\r<pre class="brush:java;">\r&lt;!-- MyBatis相关依赖 --&gt;\r&lt;dependency&gt;\r    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\r    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\r    &lt;version&gt;3.4.1&lt;/version&gt;\r&lt;/dependency&gt;</pre>\r\r<p>示例代码（添加MyBatis的配置文件-jdbc-mysql.properties）：</p>\r\r<pre class="brush:bash;">\rjdbc.driver=com.mysql.jdbc.Driver\rjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;allowMultiQueries=true\rjdbc.username=root\rjdbc.password=123456</pre>\r\r<p>示例代码（添加MyBatis的配置文件-mybatis-config.xml）：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\r&lt;configuration&gt;\r\r    &lt;properties resource=&quot;jdbc-mysql.properties&quot; /&gt;\r\r    &lt;settings&gt;\r        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;\r    &lt;/settings&gt;\r\r    &lt;!--配置environment环境 --&gt;\r    &lt;environments default=&quot;development&quot;&gt;\r\r        &lt;!-- 环境配置，每个SqlSessionFactory对应一个环境 --&gt;\r        &lt;environment id=&quot;development&quot;&gt;\r            &lt;transactionManager type=&quot;JDBC&quot; /&gt;\r            &lt;dataSource type=&quot;UNPOOLED&quot;&gt;\r                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;\r                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;\r                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;\r                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;\r            &lt;/dataSource&gt;\r        &lt;/environment&gt;\r\r    &lt;/environments&gt;\r\r    &lt;!-- 映射文件，mapper的配置文件 --&gt;\r    &lt;mappers&gt;\r        &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot; /&gt;\r    &lt;/mappers&gt;\r\r&lt;/configuration&gt;</pre>\r\r<p>示例代码（实体类）：</p>\r\r<pre class="brush:java;">\rpublic class User {\r\r    private Integer id;\r\r    private String userName;\r\r    private String realName;\r\r    private Byte sex;\r\r    private String mobile;\r\r    private String email;\r\r    private String note;\r\r    private Integer positionId;\r\r    public Integer getId() {\r        return id;\r    }\r\r    public void setId(Integer id) {\r        this.id = id;\r    }\r\r    public String getUserName() {\r        return userName;\r    }\r\r    public void setUserName(String userName) {\r        this.userName = userName;\r    }\r\r    public String getRealName() {\r        return realName;\r    }\r\r    public void setRealName(String realName) {\r        this.realName = realName;\r    }\r\r    public Byte getSex() {\r        return sex;\r    }\r\r    public void setSex(Byte sex) {\r        this.sex = sex;\r    }\r\r    public String getMobile() {\r        return mobile;\r    }\r\r    public void setMobile(String mobile) {\r        this.mobile = mobile;\r    }\r\r    public String getEmail() {\r        return email;\r    }\r\r    public void setEmail(String email) {\r        this.email = email;\r    }\r\r    public String getNote() {\r        return note;\r    }\r\r    public void setNote(String note) {\r        this.note = note;\r    }\r\r    public Integer getPositionId() {\r        return positionId;\r    }\r\r    public void setPositionId(Integer positionId) {\r        this.positionId = positionId;\r    }\r\r    @Override\r    public String toString() {\r        return &quot;TUser [id=&quot; + id + &quot;, userName=&quot; + userName + &quot;, realName=&quot;\r                + realName + &quot;, sex=&quot; + sex + &quot;, mobile=&quot; + mobile + &quot;, email=&quot;\r                + email + &quot;, note=&quot; + note + &quot;, positionId=&quot; + positionId + &quot;]&quot;;\r    }\r\r}</pre>\r\r<p>示例代码（mapper接口）：</p>\r\r<pre class="brush:java;">\rpublic interface UserMapper {\r\r    User selectByPrimaryKey(Integer id);\r\r}</pre>\r\r<p>示例代码（mapper的xml文件）：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;\r&lt;mapper namespace=&quot;ren.oliver.mybatis.quick.start.mapper.UserMapper&quot;&gt;\r\r    &lt;select id=&quot;selectByPrimaryKey&quot; resultType=&quot;ren.oliver.mybatis.quick.start.pojo.User&quot; parameterType=&quot;java.lang.Integer&quot;&gt;\r		select\r			id,\r			user_name userName,\r			real_name realName,\r			sex,\r			mobile,\r			email,\r			note,\r			position_id positionId\r		from\r		    t_user\r		where\r		    id = #{id, jdbcType=INTEGER}\r	&lt;/select&gt;\r\r&lt;/mapper&gt;</pre>\r\r<p>示例代码（测试）：</p>\r\r<pre class="brush:java;">\rpublic class UserMapperTest {\r\r    @Test\r    public void selectByPrimaryKeyTest() throws Exception {\r        String resource = &quot;mybatis-config.xml&quot;;\r        InputStream inputStream = Resources.getResourceAsStream(resource);\r        // 读取MyBatis配置文件创建SqlSessionFactory\r        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r        inputStream.close();\r        // 获取SqlSession\r        SqlSession sqlSession = sqlSessionFactory.openSession();\r        // 获取对应mapper\r        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r        // 执行查询语句并返回结果\r        User user = mapper.selectByPrimaryKey(1);\r        System.out.println(user.toString());\r    }\r\r}</pre>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/10/1197629439.png" style="width: 800px; height: 494px;" />​</p>\r\r<ul>\r	<li>SqlSessionFactoryBuilder：读取配置信息创建SqlSessionFactory，建造者模式（方法级别生命周期）；</li>\r	<li>SqlSessionFactory：创建SqlSession，工厂单例模式（程序级别生命周期）；</li>\r	<li>SqlSession：代表一次数据库连接，可以直接发送SQL执行，也可以通过调用Mapper访问数据库；线程不安全，要保证线程独享（方法级别生命周期）；</li>\r	<li>SQLMapper：由一个Java接口和XML文件组成，包含了要执行的SQL语句和结果集映射规则（方法级别生命周期）。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1852, 'ORM简介.png', 'ORM简介-png', 1570194875, 1570194875, 'a:5:{s:4:"name";s:13:"ORM简介.png";s:4:"path";s:34:"/usr/uploads/2019/10/772363723.png";s:4:"size";i:91682;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1853, 0),
(1853, 'ORM简介', '1853', 1570194900, 1570200091, '<p>本文记录Java学习过程中遇到的ORM简介～</p>\r<!--more-->\r\r<p>对象关系映射（ORM Obeject Relational Mapping）：ORM模型就是数据库的表与简单Java对象（POJO）的映射模型，它主要解决数据库数据和POJO对象的相互映射问题。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/10/772363723.png" style="width: 800px; height: 192px;" />​</p>\r\r<p>ORM带来的好处：</p>\r\r<ul>\r	<li>更加贴合面向对象的编程语意，Java程序员喜欢的姿势；</li>\r	<li>技术和业务解耦，Java程序员无需对数据库相关的知识深入了解；</li>\r	<li>不需要手工释放数据库连接资源了。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1863, 'MyBatis配置文件——概览', '1863', 1570241940, 1570259390, '<p>本文记录Java学习过程中遇到的MyBatis配置文件&mdash;&mdash;概览～</p>\r<!--more-->\r\r<p><strong>properties</strong></p>\r\r<ul>\r	<li>定义配置，配置的属性可以在整个配置文件中其他位置进行引用；</li>\r	<li>重要，优先使用property配置文件解耦。</li>\r</ul>\r\r<p><strong>settings</strong></p>\r\r<ul>\r	<li>设置，用于指定MyBatis的一些全局配置属性，这些属性非常重要，它们会改变MyBatis的运行时行为；</li>\r	<li>重要，后面专门说明。</li>\r</ul>\r\r<p><strong>typeAliases</strong></p>\r\r<ul>\r	<li>别名，为Java类型设置一个短的名字，映射时方便使用；</li>\r	<li>分为系统定义别名和自定义别名；</li>\r	<li>可以通过XML和注解配置。</li>\r</ul>\r\r<p><strong>typeHandlers</strong></p>\r\r<ul>\r	<li>用于jdbcType与javaType之间的转换；</li>\r	<li>无特殊需求不需要调整。</li>\r</ul>\r\r<p><strong>ObjectFactory</strong></p>\r\r<ul>\r	<li>MyBatis每次创建结果对象的新实例时，它都会使用对象工厂（ObjectFactory）去构建POJO；</li>\r	<li>大部分场景下无需修改。</li>\r</ul>\r\r<p><strong>plugins</strong></p>\r\r<ul>\r	<li>插件，MyBatis允许你在已映射的语句执行过程中的某一点进行拦截调用。</li>\r</ul>\r\r<p><strong>environments</strong></p>\r\r<ul>\r	<li>用于配置多个数据源，每个数据源分为数据库源和事务的配置；</li>\r	<li>在多数据源环境使用。</li>\r</ul>\r\r<p><strong>databaseIdProvider</strong></p>\r\r<ul>\r	<li>MyBatis可以根据不同的数据库厂商执行不同的语句，用于一个系统内多厂商数据源支持；</li>\r	<li>大部分场景下无需修改。</li>\r</ul>\r\r<p><strong>mappers</strong></p>\r\r<ul>\r	<li>配置引入映射器的方法；</li>\r	<li>可以使用相对于类路径的资源引用、或完全限定资源定位符（包括file:///的URL），或类名和包名等。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\r&lt;configuration&gt;\r\r    &lt;properties resource=&quot;jdbc-mysql.properties&quot;/&gt;\r\r    &lt;settings&gt;\r        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;\r    &lt;/settings&gt;\r\r    &lt;!-- 别名定义 --&gt;\r    &lt;typeAliases&gt;\r        &lt;package name=&quot;ren.oliver.mybatis.learning.pojo&quot;/&gt;\r    &lt;/typeAliases&gt;\r\r    &lt;!--配置environment环境 --&gt;\r    &lt;environments default=&quot;development&quot;&gt;\r\r        &lt;!-- 环境配置，每个SqlSessionFactory对应一个环境 --&gt;\r        &lt;environment id=&quot;development&quot;&gt;\r            &lt;transactionManager type=&quot;JDBC&quot; /&gt;\r            &lt;dataSource type=&quot;UNPOOLED&quot;&gt;\r                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;\r                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;\r                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;\r                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;\r            &lt;/dataSource&gt;\r        &lt;/environment&gt;\r\r    &lt;/environments&gt;\r\r    &lt;!-- 映射文件，mapper的配置文件 --&gt;\r    &lt;mappers&gt;\r        &lt;mapper resource=&quot;mybatis/*.xml&quot; /&gt;\r    &lt;/mappers&gt;\r\r&lt;/configuration&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1864, 'MyBatis配置文件——settings', '1864', 1570261207, 1570261207, '<p>本文记录Java学习过程中遇到的MyBatis配置文件&mdash;&mdash;settings～</p>\r<!--more-->\r\r<p><strong>cacheEnabled</strong></p>\r\r<ul>\r	<li>该配置影响的所有映射器中配置的缓存的全局开关；</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：true。</li>\r</ul>\r\r<p><strong>lazyLoadingEnabled</strong></p>\r\r<ul>\r	<li>延迟加载的全局开关；</li>\r	<li>当开启时，所有关联对象都会延迟加载；</li>\r	<li>特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：false。</li>\r</ul>\r\r<p><strong>aggressiveLazyLoading</strong></p>\r\r<ul>\r	<li>当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；</li>\r	<li>反之，每种属性将会按需加载；</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：true。</li>\r</ul>\r\r<p><strong>multipleResultSetsEnabled</strong></p>\r\r<ul>\r	<li>是否允许单一语句返回多结果集（需要兼容驱动）；</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：true。</li>\r</ul>\r\r<p><strong>useColumnLabel</strong></p>\r\r<ul>\r	<li>使用列标签代替列名；</li>\r	<li>不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果；</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：true。</li>\r</ul>\r\r<p><strong>useGeneratedKeys</strong></p>\r\r<ul>\r	<li>允许JDBC支持自动生成主键，需要驱动兼容；</li>\r	<li>如果设置为true则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如Derby）；</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：false。</li>\r</ul>\r\r<p><strong>autoMappingBehavior</strong></p>\r\r<ul>\r	<li>指定MyBatis应如何自动映射列到字段或属性；</li>\r	<li>NONE表示取消自动映射；</li>\r	<li>PARTIAL只会自动映射没有定义嵌套结果集映射的结果集；</li>\r	<li>FULL会自动映射任意复杂的结果集（无论是否嵌套）；</li>\r	<li>取值范围：NONE | PARTIAL | FULL；</li>\r	<li>默认值：PARTIAL。</li>\r</ul>\r\r<p><strong>defaultExecutorType</strong></p>\r\r<ul>\r	<li>配置默认的执行器；</li>\r	<li>SIMPLE就是普通的执行器；</li>\r	<li>REUSE执行器会重用预处理语句（prepared statements）；</li>\r	<li>BATCH执行器将重用语句并执行批量更新；</li>\r	<li>取值范围：SIMPLE | REUSE | BATCH；</li>\r	<li>默认值：SIMPLE。</li>\r</ul>\r\r<p><strong>defaultStatementTimeout</strong></p>\r\r<ul>\r	<li>设置超时时间，它决定驱动等待数据库响应的秒数；</li>\r	<li>取值范围：正整数；</li>\r	<li>默认值：无。</li>\r</ul>\r\r<p><strong>safeRowBoundsEnabled</strong></p>\r\r<ul>\r	<li>允许在嵌套语句中使用分页（RowBounds）；</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：false。</li>\r</ul>\r\r<p><strong>mapUnderscoreToCamelCase</strong></p>\r\r<ul>\r	<li>是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名A_COLUMN到经典Java属性名aColumn的类似映射；</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：false。</li>\r</ul>\r\r<p><strong>localCacheScope</strong></p>\r\r<ul>\r	<li>MyBatis利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询；</li>\r	<li>SESSION会缓存一个会话中执行的所有查询；</li>\r	<li>STATEMENT本地会话仅用在语句执行上，对相同SqlSession的不同调用将不会共享数据；</li>\r	<li>取值范围：SESSION | STATEMENT；</li>\r	<li>默认值：SESSION。</li>\r</ul>\r\r<p><strong>jdbcTypeForNull</strong></p>\r\r<ul>\r	<li>当没有为参数提供特定的JDBC类型时，为空值指定JDBC类型；</li>\r	<li>某些驱动需要指定列的JDBC类型，多数情况直接用一般类型即可，比如NULL、VARCHAR或OTHER；</li>\r	<li>取值范围：JdbcType枚举，最常见的是: NULL, VARCHAR和OTHER；</li>\r	<li>默认值：OTHER。</li>\r</ul>\r\r<p><strong>lazyLoadTriggerMethods</strong></p>\r\r<ul>\r	<li>指定哪个对象的方法触发一次延迟加载；</li>\r	<li>取值范围：如果是方法列表用逗号隔开；</li>\r	<li>默认值：equals,clone,hashCode,toString。</li>\r</ul>\r\r<p><strong>callSettersOnNulls</strong></p>\r\r<ul>\r	<li>指定当结果集中值为null的时候是否调用映射对象的setter（map对象时为put）方法，这对于有Map.keySet()依赖或null值初始化的时候是有用的；</li>\r	<li>注意基本类型（int、boolean等）是不能设置成null的；</li>\r	<li>取值范围：true | false；</li>\r	<li>默认值：false。</li>\r</ul>\r\r<p><strong>logPrefix</strong></p>\r\r<ul>\r	<li>指定MyBatis增加到日志名称的前缀；</li>\r	<li>取值范围：任何字符串；</li>\r	<li>默认值：无。</li>\r</ul>\r\r<p><strong>logImpl</strong></p>\r\r<ul>\r	<li>指定MyBatis所用日志的具体实现，未指定时将取值范围的顺序自动查找；</li>\r	<li>取值范围：SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING；</li>\r	<li>默认值：无。</li>\r</ul>\r\r<p><strong>proxyFactory</strong></p>\r\r<ul>\r	<li>指定Mybatis创建具有延迟加载能力的对象所用到的代理工具；</li>\r	<li>取值范围：CGLIB | JAVASSIST；</li>\r	<li>默认值：版本3.3.0以上为JAVASSIST。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!-- 参数设置 --&gt;\r&lt;settings&gt;\r	&lt;!-- \r		这个配置使全局的映射器启用或禁用缓存 \r	--&gt;\r	&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;\r	&lt;!-- \r		全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载 \r	--&gt;\r	&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;\r	&lt;!-- \r		当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载 \r	--&gt;\r	&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot; /&gt;\r	&lt;!-- \r		允许或不允许多种结果集从一个单独的语句中返回（需要适合的驱动） \r	--&gt;\r	&lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot; /&gt;\r	&lt;!-- \r		使用列标签代替列名。不同的驱动在这方便表现不同。参考驱动文档或充分测试两种方法来决定所使用的驱动 \r	--&gt;\r	&lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt;\r	&lt;!-- \r		允许JDBC支持生成的键。需要适合的驱动。如果设置为true则这个设置强制生成的键被使用，尽管一些驱动拒绝兼容但仍然有效（比如Derby） \r	--&gt;\r	&lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot; /&gt;\r	&lt;!-- \r		指定MyBatis如何自动映射列到字段/属性。PARTIAL只会自动映射简单，没有嵌套的结果。FULL会自动映射任意复杂的结果（嵌套的或其他情况） \r	--&gt;\r	&lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot; /&gt;\r	&lt;!--\r		当检测出未知列（或未知属性）时，如何处理，默认情况下没有任何提示，这在测试的时候很不方便，不容易找到错误。 \r		NONE : 不做任何处理 (默认值) \r		WARNING : 警告日志形式的详细信息 \r		FAILING : 映射失败，抛出异常和详细信息 \r	--&gt;\r	&lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot; /&gt;\r	&lt;!-- \r		配置默认的执行器。SIMPLE执行器没有什么特别之处。REUSE执行器重用预处理语句。BATCH执行器重用语句和批量更新 \r	--&gt;\r	&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot; /&gt;\r	&lt;!-- \r		设置超时时间，它决定驱动等待一个数据库响应的时间 \r	--&gt;\r	&lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25000&quot; /&gt;\r	&lt;!--\r		设置查询返回值数量，可以被查询数值覆盖 \r	--&gt;\r	&lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot; /&gt;\r	&lt;!-- \r		允许在嵌套语句中使用分页 \r	--&gt;\r	&lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot; /&gt;\r	&lt;!--\r		是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn \r		的类似映射。 \r	--&gt;\r	&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot; /&gt;\r	&lt;!--\r		MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 \r		默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession \r		的不同调用将不会共享数据。 \r	--&gt;\r	&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot; /&gt;\r	&lt;!-- \r		当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 \r		NULL、VARCHAR OTHER。 \r	--&gt;\r	&lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot; /&gt;\r	&lt;!-- \r		指定哪个对象的方法触发一次延迟加载。 \r	--&gt;\r	&lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot; /&gt;\r&lt;/settings&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1865, 'MyBatis配置文件——environments', '1865', 1570261687, 1570261687, '<p>本文记录Java学习过程中遇到的MyBatis配置文件&mdash;&mdash;environments～</p>\r<!--more-->\r\r<p>environment元素是配置一个数据源的开始，属性id是它的唯一标识。</p>\r\r<p>transactionManager元素配置数据库事务，其中type属性有三种配置方式：</p>\r\r<ul>\r	<li>jdbc，采用jdbc的方式管理事务；</li>\r	<li>managed，采用容器的方式管理事务，在JNDI数据源中使用；</li>\r	<li>自定义，自定义数据库事务管理办法。</li>\r</ul>\r\r<p>dataSource 元素配置数据源连接信息，type属性是连接数据库的方式配置，有四种配置方式：</p>\r\r<ul>\r	<li>UNPOOLED：非连接池方式连接；</li>\r	<li>POOLED：使用连接池连接；</li>\r	<li>JNDI：使用JNDI数据源；</li>\r	<li>自定义数据源。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--配置environment环境 --&gt;\r&lt;environments default=&quot;development&quot;&gt;\r    &lt;!-- 环境配置1，每个SqlSessionFactory对应一个环境 --&gt;\r    &lt;environment id=&quot;development1&quot;&gt;\r        &lt;!--\r            事务配置 type= JDBC、MANAGED\r            1.JDBC:这个配置直接简单使用了JDBC的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。\r            2.MANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期（比如Spring或JEE应用服务器的上下文）。\r            默认情况下它会关闭连接。然而一些容器并不希望这样，因此如果你需要从连接中停止它，将closeConnection属性设置为false\r        --&gt;\r        &lt;transactionManager type=&quot;JDBC&quot; /&gt;\r        &lt;!-- &lt;transactionManager type=&quot;MANAGED&quot;&gt; &lt;property name=&quot;closeConnection&quot;\r            value=&quot;false&quot;/&gt; &lt;/transactionManager&gt; --&gt;\r        &lt;!-- 数据源类型：type = UNPOOLED、POOLED、JNDI 1.UNPOOLED：这个数据源的实现是每次被请求时简单打开和关闭连接。它有一点慢，这是对简单应用程序的一个很好的选择，因为它不需要及时的可用连接。\r            不同的数据库对这个的表现也是不一样的，所以对某些数据库来说配置数据源并不重要，这个配置也是闲置的 2.POOLED：这是JDBC连接对象的数据源连接池的实现，用来避免创建新的连接实例时必要的初始连接和认证时间。\r            这是一种当前Web应用程序用来快速响应请求很流行的方法。 3.JNDI：这个数据源的实现是为了使用如Spring或应用服务器这类的容器，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文的引用 --&gt;\r        &lt;dataSource type=&quot;UNPOOLED&quot;&gt;\r            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;\r            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/xhm&quot; /&gt;\r            &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;\r            &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;\r            &lt;!-- 默认连接事务隔离级别 &lt;property name=&quot;defaultTransactionIsolationLevel&quot; value=&quot;&quot;\r                /&gt; --&gt;\r        &lt;/dataSource&gt;\r    &lt;/environment&gt;\r\r    &lt;!-- 环境配置2 --&gt;\r    &lt;environment id=&quot;development2&quot;&gt;\r        &lt;transactionManager type=&quot;JDBC&quot; /&gt;\r        &lt;dataSource type=&quot;POOLED&quot;&gt;\r            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;\r            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/xhm&quot; /&gt;\r            &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;\r            &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;\r            &lt;!--\r                在任意时间存在的活动（也就是正在使用）连接的数量\r            --&gt;\r            &lt;property name=&quot;poolMaximumActiveConnections&quot; value=&quot;10&quot; /&gt;\r            &lt;!--\r                任意时间存在的空闲连接数\r            --&gt;\r            &lt;property name=&quot;poolMaximumIdleConnections&quot; value=&quot;5&quot; /&gt;\r            &lt;!--\r                在被强制返回之前，池中连接被检查的时间\r            --&gt;\r            &lt;property name=&quot;poolMaximumCheckoutTime&quot; value=&quot;20000&quot; /&gt;\r            &lt;!--\r                这是给连接池一个打印日志状态机会的低层次设置，还有重新尝试获得连接，这些情况下往往需要很长时间（为了避免连接池没有配置时静默失败）\r            --&gt;\r            &lt;property name=&quot;poolTimeToWait&quot; value=&quot;20000&quot; /&gt;\r            &lt;!--\r                发送到数据的侦测查询，用来验证连接是否正常工作，并且准备接受请求。\r            --&gt;\r            &lt;property name=&quot;poolPingQuery&quot; value=&quot;NO PING QUERY SET&quot; /&gt;\r            &lt;!--\r                这是开启或禁用侦测查询。如果开启，你必须用一个合法的SQL语句（最好是很快速的）设置poolPingQuery属性\r            --&gt;\r            &lt;property name=&quot;poolPingEnabled&quot; value=&quot;false&quot; /&gt;\r            &lt;!--\r                这是用来配置poolPingQuery多次时间被用一次。这可以被设置匹配标准的数据库连接超时时间，来避免不必要的侦测\r            --&gt;\r            &lt;property name=&quot;poolPingConnectionsNotUsedFor&quot; value=&quot;0&quot; /&gt;\r        &lt;/dataSource&gt;\r    &lt;/environment&gt;\r\r    &lt;!-- 环境配置 --&gt;\r    &lt;environment id=&quot;development3&quot;&gt;\r        &lt;transactionManager type=&quot;JDBC&quot; /&gt;\r        &lt;dataSource type=&quot;JNDI&quot;&gt;\r            &lt;property name=&quot;data_source&quot; value=&quot;java:comp/env/jndi/mybatis&quot; /&gt;\r            &lt;property name=&quot;env.encoding&quot; value=&quot;UTF8&quot; /&gt;\r            &lt;!--\r                &lt;property name=&quot;initial_context&quot; value=&quot;&quot;/&gt; &lt;property name=&quot;env.encoding&quot;\r                value=&quot;UTF8&quot;/&gt;\r            --&gt;\r        &lt;/dataSource&gt;\r    &lt;/environment&gt;\r&lt;/environments&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1866, 'MyBatis配置文件——mapper', '1866', 1570262160, 1570266102, '<p>本文记录Java学习过程中遇到的MyBatis配置文件&mdash;&mdash;mapper～</p>\r<!--more-->\r\r<p>一共有四种方式：</p>\r\r<ul>\r	<li>用classPath下资源引用。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;mappers&gt;\r	&lt;!--直接映射到相应的mapper文件 --&gt;\r	&lt;mapper resource=&quot;sqlmapper/UserMapper.xml&quot; /&gt;\r&lt;/mappers&gt;</pre>\r\r<ul>\r	<li>用类注册方式引用。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;mappers&gt;\r	&lt;!&mdash;通过类扫描mapper文件 --&gt;\r	&lt;mapper class=&quot;ren.oliver.mybatis.mapper.TUserMapper&quot; /&gt;\r&lt;/mappers&gt;</pre>\r\r<ul>\r	<li>使用包名引入引射器名。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;mappers&gt;\r	&lt;!&mdash;扫描包下所有的mapper文件 --&gt;\r	&lt;package name=&quot;ren.oliver.mybatis.mapper&quot;/&gt;\r&lt;/mappers&gt;</pre>\r\r<ul>\r	<li>用文件的全路径引用。</li>\r</ul>\r\r<p>注意：第一种方式用的推荐使用，类文件和mapper文件可以不需要放在一个文件夹中，xml文件也不会和Java文件混合在一起。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1870, 'MyBatis中mapper的配置——select自动映射', '1870', 1570540920, 1570541117, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;select自动映射～</p>\r<!--more-->\r\r<ul>\r	<li>前提：SQL列名和JavaBean的属性是一致的。</li>\r	<li>自动映射等级autoMappingBehavior设置为PARTIAL，需要谨慎使用FULL。</li>\r	<li>使用resultType。</li>\r	<li>如果列名和JavaBean不一致，但列名符合单词下划线分割，Java是驼峰命名法，则mapUnderscoreToCamelCase可设置为true。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;!--\r    指定MyBatis如何自动映射列到字段/属性：\r        PARTIAL只会自动映射简单，没有嵌套的结果。\r        FULL会自动映射任意复杂的结果（嵌套的或其他情况）。\r--&gt;\r&lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot; /&gt;\r&lt;!--\r    是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。\r --&gt;\r&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot; /&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1868, 'MyBatis中mapper的配置概览', '1868', 1570538223, 1570538223, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置概览～</p>\r<!--more-->\r\r<p>MyBatis常用的xml配置的映射器有：</p>\r\r<ul>\r	<li>cache：给定命名空间的缓存配置；</li>\r	<li>cache-ref：其他命名空间缓存配置的引用；</li>\r	<li>resultMap：是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象；</li>\r	<li>sql：可被其他语句引用的可重用语句块；</li>\r	<li>insert：映射插入语句；</li>\r	<li>update：映射更新语句；</li>\r	<li>delete：映射删除语句；</li>\r	<li>select：映射查询语句。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1869, 'MyBatis中mapper的配置——select概览', '1869', 1570540800, 1570540836, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;select概览～</p>\r<!--more-->\r\r<p><strong>id</strong></p>\r\r<ul>\r	<li>它和Mapper的命名空间组合起来是唯一的，提供给MyBatis调用；</li>\r	<li>如果命名空间和id组合起来不唯一，会抛出异常。</li>\r</ul>\r\r<p><strong>parameterType</strong></p>\r\r<ul>\r	<li>传入参数的类型；</li>\r	<li>可以给出类全名，也可以给出类别名，使用别名必须是MyBatis内部定义或自定义的；&nbsp;</li>\r	<li>基本数据类型：int, String, long, date(不知是sql.date还是util.date)；</li>\r	<li>复杂数据类型：类和Map；</li>\r	<li>可以选择JavaBean，Map等复杂的参数类型传递给SQL。</li>\r</ul>\r\r<p><strong>resultType</strong></p>\r\r<ul>\r	<li>从这条语句中返回的期望类型的类的完全限定名或别名；</li>\r	<li>注意：如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身；</li>\r	<li>可以使用resultType或resultMap，但不能同时使用；</li>\r	<li>定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射；</li>\r	<li>或者定义为int,double,float等参数...；</li>\r	<li>也可以使用别名，但是要符合别名规范，不能和resultMap同时使用；</li>\r	<li>它是我们常用的参数之一，比如我们总计总条数就可以把它的值设为int。</li>\r</ul>\r\r<p><strong>resultMap</strong></p>\r\r<ul>\r	<li>外部resultMap的命名引用；</li>\r	<li>可以使用resultMap或resultType，但不能同时使用；&nbsp;</li>\r	<li>它是映射集的引用，将执行强大的映射功能，可以使用resultType或者resultMap其中的一个，resultMap可以给予我们自定义映射规则的机会；</li>\r	<li>它是MyBatis最复杂的元素，可以配置映射规则，级联，typeHandler等。</li>\r</ul>\r\r<p><strong>flushCache</strong></p>\r\r<ul>\r	<li>它的作用是在调用SQL后，是否要求MyBatis清空之前查询的本地缓存和二级缓存；</li>\r	<li>取值为true/false，默认为false。</li>\r</ul>\r\r<p><strong>useCache</strong></p>\r\r<ul>\r	<li>启动二级缓存开关，是否要求MyBatis将此次结果缓存；</li>\r	<li>取值为true/false，默认为true。</li>\r</ul>\r\r<p><strong>timeout</strong></p>\r\r<ul>\r	<li>设置超时时间，超时之后抛出异常，单位是秒；</li>\r	<li>默认值为数据库厂商提供的JDBC驱动所设置的秒数。</li>\r</ul>\r\r<p><strong>fetchSize</strong></p>\r\r<ul>\r	<li>获取记录的总条数设定；</li>\r	<li>默认值是数据库厂商提供的JDBC驱动所设的条数。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1871, 'MyBatis中mapper的配置——select传递多个查询入参', '1871', 1570541531, 1570541531, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;select传递多个查询入参～</p>\r<!--more-->\r\r<p>1.使用map传递参数；可读性差，导致可维护性和可扩展性差，杜绝使用。</p>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectByEmailAndSex1(Map&lt;String, Object&gt; param);</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;select id=&quot;selectByEmailAndSex1&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;map&quot;&gt;\r    select\r      &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user a\r    where\r      a.email like CONCAT(&#39;%&#39;, #{email}, &#39;%&#39;) and a.sex = #{sex}\r&lt;/select&gt;</pre>\r\r<p>2.使用注解传递参数：直观明了，当参数较少一般小于5个的时候，建议使用。</p>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectByEmailAndSex2(\r        @Param(&quot;email&quot;) String email,\r        @Param(&quot;sex&quot;) Byte sex\r);</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;select id=&quot;selectByEmailAndSex2&quot; resultMap=&quot;BaseResultMap&quot;&gt;\r    select\r      &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user a\r    where\r      a.email like CONCAT(&#39;%&#39;, #{email}, &#39;%&#39;) and a.sex = #{sex}\r&lt;/select&gt;</pre>\r\r<p>3.使用JavaBean的方式传递参数：当参数大于5个的时候，建议使用。</p>\r\r<p>示例代码（实体）：</p>\r\r<pre class="brush:java;">\rpublic class EmailSexBean {\r\r    private Byte sex;\r    private String email;\r\r    public Byte getSex() {\r        return sex;\r    }\r\r    public void setSex(Byte sex) {\r        this.sex = sex;\r    }\r\r    public String getEmail() {\r        return email;\r    }\r\r    public void setEmail(String email) {\r        this.email = email;\r    }\r\r}</pre>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectByEmailAndSex3(EmailSexBean esb);</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;select id=&quot;selectByEmailAndSex3&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;EmailSexBean&quot;&gt;\r    select\r      &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user a\r    where\r      a.email like CONCAT(&#39;%&#39;, #{email}, &#39;%&#39;) and a.sex = #{sex}\r&lt;/select&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1872, 'MyBatis中mapper的配置——resultMap概览', '1872', 1570541700, 1570541728, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;resultMap概览～</p>\r<!--more-->\r\r<p>ResultMap元素是MyBatis中最重要最强大的元素，它可以让你从90%的JDBC的ResultSets数据提取代码中解放出来，在对复杂语句进行联合映射的时候，它很可能可以代替数千行的同等功能的代码。</p>\r\r<p>ResultMap的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1873, 'MyBatis中mapper的配置——resultMap属性', '1873', 1570541895, 1570541895, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;resultMap属性～</p>\r<!--more-->\r\r<p><strong>id</strong></p>\r\r<ul>\r	<li>当前命名空间中的一个唯一标识，用于标识一个resultMap。</li>\r</ul>\r\r<p><strong>type</strong></p>\r\r<ul>\r	<li>类的完全限定名, 或者一个类型别名 (内置的别名可以参考上面的表格)。</li>\r</ul>\r\r<p><strong>autoMapping</strong></p>\r\r<ul>\r	<li>如果设置这个属性，MyBatis将会为这个ResultMap开启或者关闭自动映射；</li>\r	<li>这个属性会覆盖全局的属性autoMappingBehavior；</li>\r	<li>默认值为：unset。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1874, 'MyBatis中mapper的配置——resultMap子元素', '1874', 1570542180, 1570542297, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;resultMap子元素～</p>\r<!--more-->\r\r<p>constructor - 用于在实例化类时，注入结果到构造方法中</p>\r\r<ul>\r	<li>idArg - ID 参数;标记出作为 ID 的结果可以帮助提高整体性能</li>\r	<li>arg - 将被注入到构造方法的一个普通结果</li>\r</ul>\r\r<p>id &ndash; 一个ID结果，标记出作为ID的结果可以帮助提高整体性能</p>\r\r<p>result &ndash; 注入到字段或 JavaBean 属性的普通结果</p>\r\r<p>association &ndash; 一个复杂类型的关联，许多结果将包装成这种类型</p>\r\r<ul>\r	<li>嵌套结果映射 &ndash; 关联可以指定为一个resultMap元素，或者引用一个</li>\r</ul>\r\r<p>collection &ndash; 一个复杂类型的集合</p>\r\r<ul>\r	<li>嵌套结果映射 &ndash; 集合可以指定为一个resultMap元素，或者引用一个</li>\r</ul>\r\r<p>discriminator &ndash; 使用结果值来决定使用哪个resultMap</p>\r\r<ul>\r	<li>case &ndash; 基于某些值的结果映射\r	<ul>\r		<li>嵌套结果映射 &ndash; 一个case也是一个映射它本身的结果，因此可以包含很多相同的元素，或者它可以参照一个外部的resultMap</li>\r	</ul>\r	</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;User&quot;&gt;\r    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;\r    &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\r    &lt;result column=&quot;real_name&quot; property=&quot;realName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\r    &lt;result column=&quot;sex&quot; property=&quot;sex&quot; jdbcType=&quot;TINYINT&quot; /&gt;\r    &lt;result column=&quot;mobile&quot; property=&quot;mobile&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\r    &lt;result column=&quot;email&quot; property=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\r    &lt;result column=&quot;note&quot; property=&quot;note&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\r    &lt;result column=&quot;position_id&quot; property=&quot;positionId&quot; jdbcType=&quot;INTEGER&quot; /&gt;\r&lt;/resultMap&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1875, 'MyBatis中mapper的配置——resultMap的id&amp;result', '1875', 1570542561, 1570542561, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;resultMap的id&amp;result～</p>\r<!--more-->\r\r<p>id和result都将一个列的值映射到一个简单数据类型(字符串,整型,双精度浮点数,日期等)的属性或字段。</p>\r\r<p>两者之间的唯一不同是，id表示的结果将是对象的标识属性，这会在比较对象实例时用到。 这样可以提高整体的性能，尤其是缓存和嵌套结果映射(也就是联合映射)的时候。</p>\r\r<p>常用属性：</p>\r\r<p><strong>property</strong></p>\r\r<ul>\r	<li>POJO中映射到列结果的字段或者属性。如果POJO的属性匹配的是存在的，并且和给定SQL列名（column元素）是相同的，那么MyBatis就会自动映射。</li>\r</ul>\r\r<p><strong>column</strong></p>\r\r<ul>\r	<li>SQL中的列名或者是列的别名。一般情况下，这和传递给resultSet.getString(columnName)方法的参数一样。</li>\r</ul>\r\r<p><strong>javaType</strong></p>\r\r<ul>\r	<li>配置的Java的类。</li>\r</ul>\r\r<p><strong>jdbcType</strong></p>\r\r<ul>\r	<li>配置的数据库的类型。</li>\r</ul>\r\r<p><strong>typeHandler</strong></p>\r\r<ul>\r	<li>类型处理器，使用这个属性可以覆盖默认的类型处理器。这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1876, 'MyBatis中mapper的配置——resultMap的constructor', '1876', 1570542807, 1570542807, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;resultMap的constructor～</p>\r<!--more-->\r\r<p>一个pojo不存在没有参数的构造方法，就需要使用constructor。</p>\r\r<p>为了通过名称来引用构造方法参数，你可以添加@Param注解指定参数名称的前提下，以任意顺序编写arg元素。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:xml;">\r&lt;constructor&gt;\r	&lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; /&gt;\r	&lt;arg column=&quot;user_name&quot; javaType=&quot;String&quot; /&gt;\r&lt;/constructor&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1877, 'MyBatis中mapper的配置——insert,update和delete概览', '1877', 1570630800, 1570631399, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;insert,update和delete概览～</p>\r<!--more-->\r\r<p><strong>id</strong></p>\r\r<ul>\r	<li>命名空间中的唯一标识符，可被用来代表这条语句。</li>\r</ul>\r\r<p><strong>parameterType</strong></p>\r\r<ul>\r	<li>将要传入语句的参数的完全限定类名或别名；</li>\r	<li>这个属性是可选的，因为MyBatis可以通过TypeHandler推断出具体传入语句的参数，默认值为unset。</li>\r</ul>\r\r<p><strong>flushCache</strong></p>\r\r<ul>\r	<li>将其设置为true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。</li>\r</ul>\r\r<p><strong>timeout</strong></p>\r\r<ul>\r	<li>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数；</li>\r	<li>默认值为unset（依赖驱动）。</li>\r</ul>\r\r<p><strong>statementType</strong></p>\r\r<ul>\r	<li>STATEMENT，PREPARED或CALLABLE的一个；</li>\r	<li>这会让MyBatis分别使用Statement，PreparedStatement或CallableStatement，默认值：PREPARED。</li>\r</ul>\r\r<p><strong>useGeneratedKeys</strong></p>\r\r<ul>\r	<li>仅对insert和update有用；</li>\r	<li>这会令MyBatis使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键（比如：像MySQL和SQLServer这样的关系数据库管理系统的自动递增字段），默认值：false。</li>\r</ul>\r\r<p><strong>keyProperty</strong></p>\r\r<ul>\r	<li>仅对insert和update有用；</li>\r	<li>唯一标记一个属性，MyBatis会通过getGeneratedKeys的返回值或者通过insert语句的selectKey子元素设置它的键值，默认：unset。</li>\r	<li>如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</li>\r</ul>\r\r<p><strong>keyColumn</strong></p>\r\r<ul>\r	<li>仅对insert和update有用；</li>\r	<li>通过生成的键值设置表中的列名，这个设置仅在某些数据库（像PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。</li>\r	<li>如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</li>\r</ul>\r\r<p><strong>databaseId</strong></p>\r\r<ul>\r	<li>如果配置了databaseIdProvider，MyBatis会加载所有的不带databaseId或匹配当前databaseId的语句；如果带或者不带的语句都有，则不带的会被忽略。</li>\r</ul>\r\r<p>示例代码（insert）：</p>\r\r<pre class="brush:xml;">\r&lt;insert id=&quot;insert1&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;\r	insert into\r	  t_user (id, user_name, real_name, sex, mobile, email, note, position_id)\r	values\r	  (\r	    #{id,jdbcType=INTEGER},\r	    #{userName,jdbcType=VARCHAR},\r	    #{realName,jdbcType=VARCHAR},\r	    #{sex,jdbcType=TINYINT}, #{mobile,jdbcType=VARCHAR},\r	    #{email,jdbcType=VARCHAR},\r	    #{note,jdbcType=VARCHAR},\r	    #{positionId,jdbcType=INTEGER}\r	  )\r&lt;/insert&gt;</pre>\r\r<p>示例代码（update）：</p>\r\r<pre class="brush:xml;">\r&lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;TUser&quot;&gt;\r	update\r	  t_user\r	set\r	  user_name = #{userName, jdbcType=VARCHAR},\r	  real_name = #{realName, jdbcType=VARCHAR},\r	  sex = #{sex, jdbcType=TINYINT},\r	  mobile = #{mobile, jdbcType=VARCHAR},\r	  email = #{email, jdbcType=VARCHAR},\r	  note = #{note, jdbcType=VARCHAR},\r	  position_id = #{positionId, jdbcType=INTEGER}\r	where\r	  id = #{id, jdbcType=INTEGER}\r&lt;/update&gt;</pre>\r\r<p>示例代码（delete）：</p>\r\r<pre class="brush:xml;">\r&lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt;\r	delete from\r	  t_user\r	where\r	  id = #{id,jdbcType=INTEGER}\r&lt;/delete&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1878, 'MyBatis中mapper的配置——insert,update和delete的selectKey元素', '1878', 1570631040, 1570631427, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;insert,update和delete的selectKey元素～</p>\r<!--more-->\r\r<p><strong>keyProperty</strong></p>\r\r<ul>\r	<li>selectKey语句结果应该被设置的目标属性；</li>\r	<li>如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</li>\r</ul>\r\r<p><strong>keyColumn</strong></p>\r\r<ul>\r	<li>匹配属性的返回结果集中的列名称；</li>\r	<li>如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</li>\r</ul>\r\r<p><strong>resultType</strong></p>\r\r<ul>\r	<li>结果的类型；</li>\r	<li>MyBatis通常可以推算出来，但是为了更加确定写上也不会有什么问题；</li>\r	<li>MyBatis允许任何简单类型用作主键的类型，包括字符串；</li>\r	<li>如果希望作用于多个生成的列，则可以使用一个包含期望属性的Object或一个Map。</li>\r</ul>\r\r<p><strong>order</strong></p>\r\r<ul>\r	<li>这可以被设置为BEFORE或AFTER；</li>\r	<li>如果设置为BEFORE，那么它会首先选择主键，设置keyProperty然后执行插入语句；</li>\r	<li>如果设置为AFTER，那么先执行插入语句，然后是selectKey元素（这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用）。</li>\r</ul>\r\r<p><strong>statementType</strong></p>\r\r<ul>\r	<li>与前面相同，MyBatis支持STATEMENT，PREPARED和CALLABLE语句的映射类型，分别代表PreparedStatement和CallableStatement类型。</li>\r</ul>\r\r<p>使用格式：</p>\r\r<pre class="brush:xml;">\r&lt;selectKey  keyProperty=&ldquo;id&rdquo; order= &quot;Before&quot; resultType=&quot;int&quot;&gt;\r	select SEQ_ID.nextval from dual\r&lt;/selectKey&gt;</pre>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;insert id=&quot;insert2&quot; parameterType=&quot;TUser&quot;&gt;\r    &lt;selectKey  keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;\r        select LAST_INSERT_ID()\r    &lt;/selectKey&gt;\r    insert into\r      t_user (id, user_name, real_name, sex, mobile, email, note, position_id)\r    values\r      (\r        #{id,jdbcType=INTEGER},\r        #{userName,jdbcType=VARCHAR},\r        #{realName,jdbcType=VARCHAR},\r        #{sex,jdbcType=TINYINT}, #{mobile,jdbcType=VARCHAR},\r        #{email,jdbcType=VARCHAR},\r        #{note,jdbcType=VARCHAR},\r        #{positionId,jdbcType=INTEGER}\r      )\r&lt;/insert&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1879, 'MyBatis中mapper的配置——sql元素和参数', '1879', 1570631640, 1570632260, '<p>本文记录Java学习过程中遇到的MyBatis中mapper的配置&mdash;&mdash;sql元素和参数～</p>\r<!--more-->\r\r<p>sql元素：用来定义可重用的 SQL 代码段，可以包含在其他语句中；</p>\r\r<p>参数：向sql语句中传递的可变参数。</p>\r\r<ul>\r	<li>预编译#{}：将传入的数据都当成一个字符串，会对自动传入的数据加一个单引号，能够很大程度防止sql注入；</li>\r	<li>传值${}：传入的数据直接显示生成在sql中，无法防止sql注入；</li>\r	<li>表名、选取的列是动态的，order by和in操作， 可以考虑使用$。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;sql id=&quot;Base_Column_List&quot;&gt;\r	id, user_name, real_name, sex, mobile, email, note, position_id\r&lt;/sql&gt;\r\r&lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Integer&quot;&gt;\r    select\r      &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user\r    where\r      id = #{id,jdbcType=INTEGER}\r&lt;/select&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1880, 'MyBatis注解方式配置——概览', '1880', 1570633980, 1570637260, '<p>本文记录Java学习过程中遇到的MyBatis注解方式配置&mdash;&mdash;概览～</p>\r<!--more-->\r\r<p>注解方式就是将SQL语句直接写在接口上，对于需求比较简单的系统，效率较高。</p>\r\r<p>缺点在于，每次修改sql语句都要编译代码，对于复杂的sql语句可编辑性和可读性都差，一般不建议使用这种配置方式。</p>\r\r<p>常用注解有：</p>\r\r<ul>\r	<li>@Select</li>\r	<li>@Results</li>\r	<li>@Insert</li>\r	<li>@Update</li>\r	<li>@Delete</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic interface JobHistoryAnnotationMapper {\r\r    @Results(\r            id=&quot;jobInfo&quot;,\r            value={\r                    @Result(property=&quot;id&quot;, column=&quot;id&quot;, id = true),\r                    @Result(property=&quot;userId&quot;, column=&quot;user_id&quot;),\r                    @Result(property=&quot;compName&quot;, column=&quot;comp_name&quot;),\r                    @Result(property=&quot;years&quot;, column=&quot;years&quot;),\r                    @Result(property=&quot;title&quot;, column=&quot;title&quot;)\r            }\r    )\r    @Select(\r            &quot;select &quot; +\r                &quot;id, user_id, comp_name, years, title &quot; +\r            &quot;from &quot; +\r                &quot;t_job_history &quot; +\r            &quot; where &quot; +\r                &quot;user_id = #{userId} &quot;\r    )\r    List&lt;JobHistory&gt; selectByUserId(int userId);\r\r    @ResultMap(&quot;jobInfo&quot;)\r    @Select(\r            &quot;select &quot; +\r                &quot;id, user_id, comp_name, years, title &quot; +\r            &quot;from &quot; +\r                &quot;t_job_history&quot;\r    )\r    List&lt;JobHistory&gt; selectAll();\r\r    @Insert(\r            &quot;insert into &quot; +\r                &quot;t_job_history(id, user_id, comp_name, years, title) &quot; +\r            &quot;values(&quot; +\r                &quot;#{id, jdbcType=INTEGER}, &quot; +\r                &quot;#{userId, jdbcType=INTEGER}, &quot; +\r                &quot;#{compName, jdbcType=VARCHAR}, &quot; +\r                &quot;#{years, jdbcType=INTEGER}, &quot; +\r                &quot;#{title, jdbcType=VARCHAR}&quot; +\r            &quot;)&quot;\r    )\r    @Options(useGeneratedKeys=true, keyProperty=&quot;id&quot;)\r    int insert(JobHistory record);\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1882, 'MyBatis动态SQL元素', '1882', 1570688040, 1571465159, '<p>本文记录Java学习过程中遇到的MyBatis动态SQL元素～</p>\r<!--more-->\r\r<p><strong>if</strong></p>\r\r<ul>\r	<li>判断语句；</li>\r	<li>单条件分支判断。</li>\r</ul>\r\r<p>示例代码（接口selectIfOper1）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectIfOper1(\r        @Param(&quot;email&quot;) String email,\r        @Param(&quot;sex&quot;) Byte sex\r);</pre>\r\r<p>示例代码（配置selectIfOper1）：</p>\r\r<pre class="brush:xml;">\r&lt;select id=&quot;selectIfOper1&quot; resultMap=&quot;BaseResultMap&quot;&gt;\r    select\r      &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user a\r    where\r      &lt;if test=&quot;email != null and email != &#39;&#39;&quot;&gt;\r        a.email like CONCAT(&#39;%&#39;, #{email}, &#39;%&#39;)\r      &lt;/if&gt;\r      &lt;if test=&quot;sex != null &quot;&gt;\r        and a.sex = #{sex}\r      &lt;/if&gt;\r&lt;/select&gt;</pre>\r\r<p>示例代码（接口selectIfOper2）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectIfOper2(\r        @Param(&quot;email&quot;) String email,\r        @Param(&quot;sex&quot;) Byte sex\r);</pre>\r\r<p>示例代码（配置selectIfOper2）：</p>\r\r<pre class="brush:xml;">\r&lt;select id=&quot;selectIfOper2&quot; resultMap=&quot;BaseResultMap&quot;&gt;\r    select\r    &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r    t_user a\r    where\r    	1 = 1\r    &lt;if test=&quot;email != null and email != &#39;&#39;&quot;&gt;\r        and a.email like CONCAT(&#39;%&#39;, #{email}, &#39;%&#39;)\r    &lt;/if&gt;\r    &lt;if test=&quot;sex != null &quot;&gt;\r        and a.sex = #{sex}\r    &lt;/if&gt;\r&lt;/select&gt;</pre>\r\r<p><strong>choose、when、otherwise</strong></p>\r\r<ul>\r	<li>相当于Java的case when；</li>\r	<li>多条件分支判断。</li>\r</ul>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectChooseOper(\r        @Param(&quot;email&quot;)String email,\r        @Param(&quot;sex&quot;)Byte sex\r);</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;select id=&quot;selectChooseOper&quot; resultMap=&quot;BaseResultMap&quot;&gt;\r    select\r    &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user a\r    &lt;where&gt;\r        &lt;choose&gt;\r            &lt;when test=&quot;email != null and email != &#39;&#39;&quot;&gt;\r                and a.email like CONCAT(&#39;%&#39;, #{email}, &#39;%&#39;)\r            &lt;/when&gt;\r            &lt;when test=&quot;sex != null&quot;&gt;\r                and a.sex = #{sex}\r            &lt;/when&gt;\r            &lt;otherwise&gt;\r                and 1=1\r            &lt;/otherwise&gt;\r        &lt;/choose&gt;\r    &lt;/where&gt;\r&lt;/select&gt;</pre>\r\r<p><strong>trim、where、set</strong></p>\r\r<ul>\r	<li>辅助元素；</li>\r	<li>用于处理sql拼装问题。</li>\r</ul>\r\r<p>示例代码（where接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectIfandWhereOper(\r        @Param(&quot;email&quot;) String email,\r        @Param(&quot;sex&quot;) Byte sex\r);</pre>\r\r<p>示例代码（where配置）：</p>\r\r<pre class="brush:xml;">\r&lt;select id=&quot;selectIfandWhereOper&quot; resultMap=&quot;BaseResultMap&quot;&gt;\r    select\r      &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user a\r    &lt;where&gt;\r        &lt;if test=&quot;email != null and email != &#39;&#39;&quot;&gt;\r          and a.email like CONCAT(&#39;%&#39;, #{email}, &#39;%&#39;)\r        &lt;/if&gt;\r        &lt;if test=&quot;sex != null &quot;&gt;\r          and a.sex = #{sex}\r        &lt;/if&gt;\r    &lt;/where&gt;\r&lt;/select&gt;</pre>\r\r<p>示例代码（set接口）：</p>\r\r<pre class="brush:java;">\rint updateIfAndSetOper(User record);</pre>\r\r<p>示例代码（set配置）：</p>\r\r<pre class="brush:xml;">\r&lt;update id=&quot;updateIfAndSetOper&quot; parameterType=&quot;User&quot;&gt;\r    update\r      t_user\r    &lt;set&gt;\r        &lt;if test=&quot;userName != null&quot;&gt;\r          user_name = #{userName, jdbcType=VARCHAR},\r        &lt;/if&gt;\r        &lt;if test=&quot;realName != null&quot;&gt;\r          real_name = #{realName, jdbcType=VARCHAR},\r        &lt;/if&gt;\r        &lt;if test=&quot;sex != null&quot;&gt;\r          sex = #{sex, jdbcType=TINYINT},\r        &lt;/if&gt;\r        &lt;if test=&quot;mobile != null&quot;&gt;\r          mobile = #{mobile, jdbcType=VARCHAR},\r        &lt;/if&gt;\r        &lt;if test=&quot;email != null&quot;&gt;\r          email = #{email, jdbcType=VARCHAR},\r        &lt;/if&gt;\r        &lt;if test=&quot;note != null&quot;&gt;\r          note = #{note, jdbcType=VARCHAR},\r        &lt;/if&gt;\r        &lt;if test=&quot;positionId != null&quot;&gt;\r          position_id = #{positionId, jdbcType=INTEGER},\r        &lt;/if&gt;\r    &lt;/set&gt;\r    where\r      id = #{id, jdbcType=INTEGER}\r&lt;/update&gt;</pre>\r\r<p>示例代码（trim接口）：</p>\r\r<pre class="brush:java;">\rint insertSelective(User record);</pre>\r\r<p>示例代码（trim配置）：</p>\r\r<pre class="brush:xml;">\r&lt;insert id=&quot;insertSelective&quot; parameterType=&quot;ren.oliver.mybatis.learning.pojo.UserRoleKey&quot; &gt;\r    insert into\r      t_user_role\r    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;\r        &lt;if test=&quot;roleId != null&quot; &gt;\r            role_id,\r        &lt;/if&gt;\r        &lt;if test=&quot;userId != null&quot; &gt;\r            user_id,\r        &lt;/if&gt;\r    &lt;/trim&gt;\r    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;\r        &lt;if test=&quot;roleId != null&quot; &gt;\r            #{roleId,jdbcType=INTEGER},\r        &lt;/if&gt;\r        &lt;if test=&quot;userId != null&quot; &gt;\r            #{userId,jdbcType=INTEGER},\r        &lt;/if&gt;\r    &lt;/trim&gt;\r&lt;/insert&gt;</pre>\r\r<p><strong>foreach</strong></p>\r\r<ul>\r	<li>循环语句；</li>\r	<li>在in语句等列举条件常用，常用于实现批量操作。</li>\r</ul>\r\r<p>示例代码（接口selectForeach4In）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectForeach4In(String[] names);</pre>\r\r<p>示例代码（配置selectForeach4In）：</p>\r\r<pre class="brush:xml;">\r&lt;select id=&quot;selectForeach4In&quot; resultMap=&quot;BaseResultMap&quot;&gt;\r    select\r      &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user a\r    where\r      a.user_name in\r      &lt;foreach collection=&quot;array&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;userName&quot; index=&quot;i&quot; separator=&quot;,&quot;&gt;\r        #{userName}\r      &lt;/foreach&gt;\r&lt;/select&gt;</pre>\r\r<p>示例代码（接口insertForeach4Batch）：</p>\r\r<pre class="brush:java;">\rint insertForeach4Batch(List&lt;User&gt; users);</pre>\r\r<p>示例代码（配置insertForeach4Batch）：</p>\r\r<pre class="brush:xml;">\r&lt;insert id=&quot;insertForeach4Batch&quot;&gt;\r    insert into\r      t_user (user_name, real_name, sex, mobile,email,note, position_id)\r    values\r      &lt;foreach collection=&quot;list&quot; separator=&quot;,&quot; item=&quot;user&quot;&gt;\r        (\r          #{user.userName,jdbcType=VARCHAR},\r          #{user.realName,jdbcType=VARCHAR},\r          #{user.sex,jdbcType=TINYINT},\r          #{user.mobile,jdbcType=VARCHAR},\r          #{user.email,jdbcType=VARCHAR},\r          #{user.note,jdbcType=VARCHAR},\r          #{user.positionId,jdbcType=INTEGER}\r        )\r      &lt;/foreach&gt;\r&lt;/insert&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1883, '批量操作——JDBC', '1883', 1570781534, 1570781534, '<p>本文记录Java学习过程中遇到的批量操作&mdash;&mdash;JDBC～</p>\r<!--more-->\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rConnection conn = null;\rStatement stmt = null;\r\rtry {\r\r    // 注册MySQL的驱动\r    System.out.println(&quot;注册MySQL的驱动&quot;);\r    Class.forName(JDBC_DRIVER);\r\r    // 获得一个连接\r    System.out.println(&quot;获得一个连接&quot;);\r    conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);\r\r    // 启动手动提交\r    conn.setAutoCommit(false);\r\r    // 创建一个更新\r    System.out.println(&quot;创建一个更新&quot;);\r    stmt = conn.createStatement();\r    String sq11 = &quot;update t_user set mobile= &#39;110&#39; where user_name= &#39;lison&#39;&quot;;\r    String sq12 = &quot;update t_user set mobile= &#39;120&#39; where user_name= &#39;james&#39;&quot;;\r    stmt.addBatch(sq11);\r    stmt.addBatch(sq12);\r    // 打印SQL\r    System.out.println(stmt.toString());\r    // 执行SQL\r    int[] ret = stmt.executeBatch();\r    System.out.println(&quot;此次修改影响数据库的行数为：&quot; + Arrays.toString(ret));\r\r    // 手动提交数据\r    conn.commit();\r\r    // 关闭连接，释放资源\r    stmt.close();\r    conn.close();\r} catch (SQLException se) {\r    try {\r        conn.rollback();\r    } catch (SQLException e) {\r        e.printStackTrace();\r    }\r    se.printStackTrace();\r} catch (Exception e) {\r    try {\r        conn.rollback();\r    } catch (SQLException se) {\r        se.printStackTrace();\r    }\r    e.printStackTrace();\r} finally {\r    // 确保资源一定被释放\r    try {\r        if (stmt != null)\r            stmt.close();\r    } catch (SQLException e) {\r        e.printStackTrace();\r    }\r    try {\r        if (conn != null)\r            conn.close();\r    } catch (SQLException e) {\r        e.printStackTrace();\r    }\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1884, '批量操作——MyBatis', '1884', 1570782000, 1570782048, '<p>本文记录Java学习过程中遇到的批量操作&mdash;&mdash;MyBatis～</p>\r<!--more-->\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 获取sqlSession\rSqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH, false);\r// 获取对应mapper\rUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\rUser user1 = new User();\ruser1.setUserName(&quot;mark&quot;);\ruser1.setRealName(&quot;毛毛&quot;);\ruser1.setEmail(&quot;xxoo@163.com&quot;);\ruser1.setMobile(&quot;18695988747&quot;);\ruser1.setNote(&quot;mark&#39;s note&quot;);\ruser1.setSex((byte) 1);\ruser1.setPositionId(1);\rSystem.out.println(userMapper.insertSelective(user1));\r\rUser user2 = new User();\ruser2.setId(3);\ruser2.setUserName(&quot;cindy&quot;);\ruser2.setRealName(&quot;王美丽&quot;);\ruser2.setEmail(&quot;xxoo@163.com&quot;);\ruser2.setMobile(&quot;18695988747&quot;);\ruser2.setNote(&quot;cindy&#39;s note&quot;);\ruser2.setSex((byte) 2);\ruser2.setPositionId(1);\rSystem.out.println(userMapper.updateIfOper1(user2));\r\rsqlSession.commit();</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1886, 'Mybatis代码生成器（MBG）', '1886', 1570950600, 1570952269, '<p>本文记录Java学习过程中遇到的Mybatis代码生成器（MBG）～</p>\r<!--more-->\r\r<p>MyBatis Generator：MyBatis的开发团队提供的一个很强大的代码生成器，代码包含了数据库表对应的实体类 、Mapper 接口类、 Mapper XML 文件和 Example 对象等，这些代码文件中几乎包含了全部的单表操作方法，使用MBG可以极大程度上方便我们使用MyBatis，还可以减少很多重复操作。</p>\r\r<p>MBG配置文件主要结构：</p>\r\r<p>generatorConfiguration &ndash; 根节点</p>\r\r<p style="margin-left: 40px;">properties &ndash; 用于指定一个需要在配置中解析使用的外部属性文件；</p>\r\r<p style="margin-left: 40px;">classPathEntry - 在MBG工作的时候，需要额外加载的依赖包；</p>\r\r<p style="margin-left: 40px;">context -用于指定生成一组对象的环境</p>\r\r<p style="margin-left: 80px;">property (0 个或多个） - 设置一些固定属性</p>\r\r<p style="margin-left: 80px;">plugin (0 个或多个）- 定义一个插件，用于扩展或修改通过 MBG 生成的代码</p>\r\r<p style="margin-left: 80px;">commentGenerator (0 个或 1 个） - 该标签用来配置如何生成注释信息</p>\r\r<p style="margin-left: 80px;">jdbcConnection ( 1 个）- 必须要有的，使用这个配置链接数据库</p>\r\r<p style="margin-left: 80px;">javaTypeResolver ( 0 个或 1 个） - 指定 JDBC 类型和 Java 类型如何转换</p>\r\r<p style="margin-left: 80px;">javaModelGenerator ( 1 个） - java模型创建器</p>\r\r<p style="margin-left: 80px;">sqlMapGenerator (0 个或 1 个）- 生成SQL map的XML文件生成器</p>\r\r<p style="margin-left: 80px;">javaClientGenerator (0 个或 1 个）- 生成Mapper接口</p>\r\r<p style="margin-left: 80px;">table ( 1个或多个） -选择一个table来生成相关文件，可以有一个或多个table</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\r&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r&lt;!DOCTYPE generatorConfiguration PUBLIC\r        &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;\r        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;\r&lt;generatorConfiguration&gt;\r\r    &lt;properties resource=&quot;jdbc-mysql.properties&quot;/&gt;\r\r    &lt;!--\r        context: 生成一组对象的环境\r            id:必选，上下文id，用于在生成错误时提示\r            defaultModelType:指定生成对象的样式\r                 1.conditional：类似hierarchical；\r                 2.flat：所有内容（主键，blob）等全部生成在一个对象中，推荐使用；\r                 3.hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)\r            targetRuntime:\r                 1.MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；\r                 2.MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；\r     --&gt;\r    &lt;context id=&quot;context&quot; defaultModelType=&quot;flat&quot; targetRuntime=&quot;MyBatis3&quot;&gt;\r\r        &lt;!-- 生成的Java文件的编码 --&gt;\r        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;\r\r        &lt;commentGenerator&gt;\r\r            &lt;!--\r                是否去除自动生成的注释\r                    true：是\r                    false:否\r            --&gt;\r            &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;/&gt;\r\r            &lt;!--\r                阻止注释中包含时间戳\r                    true：是\r                    false:否\r            --&gt;\r            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;\r\r            &lt;!--\r                注释是否包含数据库表的注释信息\r                    true：是\r                    false:否\r            --&gt;\r            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;\r\r        &lt;/commentGenerator&gt;\r\r        &lt;!-- 数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;\r        &lt;jdbcConnection driverClass=&quot;${jdbc.driver}&quot; connectionURL=&quot;${jdbc.url}&quot; userId=&quot;${jdbc.username}&quot; password=&quot;${jdbc.password}&quot;/&gt;\r\r        &lt;!--\r            Java模型创建器，是必须要的元素\r            负责：\r                1.key类（见context的defaultModelType）；\r                2.Java类；\r                3.查询类\r        	targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；\r        	targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录\r     	--&gt;\r        &lt;javaModelGenerator targetPackage=&quot;ren.oliver.mybatis.generator.entity&quot; targetProject=&quot;src/main/java&quot;&gt;\r            &lt;!--\r                设置一个根对象，如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；\r                在Table的rootClass属性中可以覆盖该选项\r                注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：\r                    1.属性名相同;\r                    2.类型相同;\r                    3.有相同的getter/setter方法.\r            &lt;property name=&quot;rootClass&quot; value=&quot;ren.oliver.mybatis.generator.entity.BaseEntity&quot;/&gt;\r            --&gt;\r        &lt;/javaModelGenerator&gt;\r\r\r        &lt;!--\r            生成SQLMAP的XML文件生成器：\r                targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；\r                targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录\r         --&gt;\r        &lt;sqlMapGenerator targetPackage=&quot;.&quot; targetProject=&quot;src/main/resources/mybatis&quot;&gt;\r        &lt;/sqlMapGenerator&gt;\r\r        &lt;!--\r            对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口\r               type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：\r                   1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；\r                   2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；\r                   3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；\r               注意，如果context是MyBatis3Simple，只支持ANNOTATEDMAPPER和XMLMAPPER\r        --&gt;\r        &lt;javaClientGenerator targetPackage=&quot;ren.oliver.mybatis.generator.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;ANNOTATEDMAPPER&quot;/&gt;\r\r        &lt;!-- shema 数据库 tableName表明 --&gt;\r        &lt;table schema=&quot;mybatis&quot; tableName=&quot;t_user&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;\r               enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;\r            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot;/&gt;\r        &lt;/table&gt;\r\r    &lt;/context&gt;\r\r&lt;/generatorConfiguration&gt;</pre>\r\r<p><strong>怎么运行MGB</strong></p>\r\r<ul>\r	<li>从命令提示符使用XML配置文件</li>\r</ul>\r\r<pre class="brush:bash;">\rjava -jar mybatis-generator-core-x.x.x.jar -configfile generatorConfig.xml</pre>\r\r<p>使用场景：对逆向工程定制较少，项目工程结构比较复杂的情况</p>\r\r<ul>\r	<li>作为MavenPlugin运行</li>\r</ul>\r\r<pre class="brush:java;">\rmvn mybatis-generator:generate</pre>\r\r<p>使用场景：对逆向工程定制较多，项目工程结构比较单一的情况</p>\r\r<ul>\r	<li>一个Java程序使用XML配置文件</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rList&lt;String&gt; warnings = new ArrayList&lt;&gt;();\rboolean overwrite = true;\rString genCfg = &quot;generatorConfig.xml&quot;;\rFile configFile = new File(getClass().getClassLoader().getResource(genCfg).getFile());\rConfigurationParser cp = new ConfigurationParser(warnings);\rConfiguration config = null;\rtry {\r    config = cp.parseConfiguration(configFile);\r} catch (IOException e) {\r    e.printStackTrace();\r} catch (XMLParserException e) {\r    e.printStackTrace();\r}\rDefaultShellCallback callback = new DefaultShellCallback(overwrite);\rMyBatisGenerator myBatisGenerator = null;\rtry {\r    myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\r} catch (InvalidConfigurationException e) {\r    e.printStackTrace();\r}\rtry {\r    myBatisGenerator.generate(null);\r} catch (SQLException e) {\r    e.printStackTrace();\r} catch (IOException e) {\r    e.printStackTrace();\r} catch (InterruptedException e) {\r    e.printStackTrace();\r}</pre>\r\r<p>使用场景：对逆向工程定制较多，项目工程结构比较单一的情况</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1888, 'MyBatis关联查询——概述', '1888', 1571709697, 1571709697, '<p>本文记录Java学习过程中遇到的MyBatis关联查询&mdash;&mdash;概述～</p>\r<!--more-->\r\r<p>在关系型数据库中，我们经常要处理一对一、一对多的关系。例如：一辆汽车需要有一个引擎，这是一对一的关系；一辆汽车有4个或更多个轮子，这是一对多的关系。关联元素就是专门用来处理关联关系的。</p>\r\r<p>关联方式：</p>\r\r<ul>\r	<li>嵌套结果：使用嵌套结果映射来处理重复的联合结果的子集；</li>\r	<li>嵌套查询：通过执行另外一个 SQL 映射语句来返回预期的复杂类型。</li>\r</ul>\r\r<p>关联元素：</p>\r\r<ul>\r	<li>association：一对一关系；</li>\r	<li>collection：一对多关系；</li>\r	<li>discriminator：鉴别器映射。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1889, 'MyBatis一对一关联查询——嵌套结果', '1889', 1571713020, 1572631201, '<p>本文记录Java学习过程中遇到的MyBatis一对一关联查询&mdash;&mdash;嵌套结果～</p>\r<!--more-->\r\r<p>association标签嵌套结果方式常用属性：</p>\r\r<ul>\r	<li>property：对应实体类中的属性名，必填项；</li>\r	<li>javaType：属性对应的Java类型；</li>\r	<li>resultMap：可以直接使用现有的resultMap，而不需要在这里配置映射关系；</li>\r	<li>columnPrefix：查询列的前缀，配置前缀后，在子标签配置result的column时可以省略前缀。</li>\r</ul>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectUserPosition1();</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap id=&quot;userAndPosition1&quot; extends=&quot;BaseResultMap&quot; type=&quot;User&quot;&gt;\r    &lt;association property=&quot;position&quot; javaType=&quot;ren.oliver.mybatis.learning.pojo.Position&quot; columnPrefix=&quot;post_&quot; &gt;\r        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;\r        &lt;result column=&quot;name&quot; property=&quot;postName&quot;/&gt;\r        &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;\r    &lt;/association&gt;\r&lt;/resultMap&gt;\r\r&lt;select id=&quot;selectUserPosition1&quot; resultMap=&quot;userAndPosition1&quot;&gt;\r	select user_name,\r		real_name,\r		sex,\r		mobile,\r		email,\r		a.note,\r		b.id  post_id,\r		b.post_name,\r		b.note post_note\r	from t_user a,\r		t_position b\r	where a.position_id = b.id\r&lt;/select&gt;</pre>\r\r<p>注意：</p>\r\r<ul>\r	<li>resultMap可以通过使用extends实现继承关系，简化很多配置工作量；</li>\r	<li>关联的表查询的类添加前缀是编程的好习惯；</li>\r	<li>通过添加完整的命名空间，可以引用其他xml文件的resultMap。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 5),
(1890, 'MyBatis一对一关联查询——嵌套查询', '1890', 1571729460, 1571729564, '<p>本文记录Java学习过程中遇到的MyBatis一对一关联查询&mdash;&mdash;嵌套查询～</p>\r<!--more-->\r\r<p>association标签嵌套查询方式常用属性：&nbsp;</p>\r\r<ul>\r	<li>select：另一个映射查询的id，MyBatis会额外执行这个查询获取嵌套对象的结果；</li>\r	<li>column：列名（或别名），将主查询中列的结果作为嵌套查询的参数；</li>\r	<li>fetchType：数据加载方式，可选值为lazy和eager，分别为延迟加载和积极加载，这个配置会覆盖全局的lazyLoadingEnabled配置。</li>\r</ul>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectUserPosition2();</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap id=&quot;userAndPosition2&quot; extends=&quot;BaseResultMap&quot; type=&quot;User&quot;&gt;\r    &lt;association property=&quot;position&quot;  column=&quot;position_id&quot; select=&quot;ren.oliver.mybatis.learning.mapper.PositionMapper.selectByPrimaryKey&quot; /&gt;\r&lt;/resultMap&gt;\r\r&lt;select id=&quot;selectUserPosition2&quot; resultMap=&quot;userAndPosition2&quot;&gt;\r	select\r	a.id,\r	a.user_name,\r	a.real_name,\r	a.sex,\r	a.mobile,\r	a.position_id\r	from t_user a\r&lt;/select&gt;</pre>\r\r<p>注意（N+1查询问题，概括地讲，N+1查询问题可以是这样引起的）：</p>\r\r<ul>\r	<li>你执行了一个单独的SQL语句来获取结果列表(就是&ldquo;+1&rdquo;)；</li>\r	<li>对返回的每条记录，你执行了一个查询语句来为每个加载细节(就是&ldquo;N&rdquo;)；</li>\r	<li>这个问题会导致成百上千的SQL语句被执行，这通常不是期望的。</li>\r</ul>\r\r<p>解决办法：使用&ldquo;fetchType=lazy&rdquo;并且全局setting进行改善：</p>\r\r<pre class="brush:xml;">\r&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 5),
(1891, 'MyBatis一对多关联查询——嵌套结果', '1891', 1572632372, 1572632372, '<p>本文记录Java学习过程中遇到的MyBatis一对多关联查询&mdash;&mdash;嵌套结果～</p>\r<!--more-->\r\r<p>collection支持的属性以及属性的作用和association完全相同。</p>\r\r<p>collection标签嵌套结果方式常用属性：</p>\r\r<ul>\r	<li>property：对应实体类中的属性名，必填项；</li>\r	<li>javaType：属性对应的Java类型；</li>\r	<li>resultMap：可以直接使用现有的resultMap，而不需要在这里配置映射关系；</li>\r	<li>columnPrefix：查询列的前缀，配置前缀后，在子标签配置result的column时可以省略前缀。</li>\r</ul>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectUserJobs1();</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap id=&quot;userAndJobs1&quot; extends=&quot;BaseResultMap&quot; type=&quot;User&quot;&gt;\r    &lt;collection property=&quot;jobs&quot; ofType=&quot;JobHistory&quot; &gt;\r        &lt;result column=&quot;comp_name&quot; property=&quot;compName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\r        &lt;result column=&quot;years&quot; property=&quot;years&quot; jdbcType=&quot;INTEGER&quot; /&gt;\r        &lt;result column=&quot;title&quot; property=&quot;title&quot; jdbcType=&quot;VARCHAR&quot; /&gt;\r    &lt;/collection&gt;\r&lt;/resultMap&gt;\r\r&lt;select id=&quot;selectUserJobs1&quot; resultMap=&quot;userAndJobs1&quot;&gt;\r	select\r	  a.id,\r	  a.user_name,\r	  a.real_name,\r	  a.sex,\r	  a.mobile,\r	  b.comp_name,\r	  b.years,\r	  b.title\r	from\r	  t_user a, t_job_history b\r	where\r	  a.id = b.user_id\r&lt;/select&gt;</pre>\r\r<p>注意：MyBatis会根据id标签，进行字段的合并，合理配置好ID标签可以提高处理的效率。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1892, 'MyBatis一对多关联查询——嵌套查询', '1892', 1572634126, 1572634126, '<p>本文记录Java学习过程中遇到的MyBatis一对多关联查询&mdash;&mdash;嵌套查询～</p>\r<!--more-->\r\r<p>collection支持的属性以及属性的作用和association完全相同。</p>\r\r<p>collection标签嵌套结果方式常用属性：</p>\r\r<ul>\r	<li>property：对应实体类中的属性名，必填项；</li>\r	<li>javaType：属性对应的Java类型；</li>\r	<li>resultMap：可以直接使用现有的resultMap，而不需要在这里配置映射关系；</li>\r	<li>columnPrefix：查询列的前缀，配置前缀后，在子标签配置result的column时可以省略前缀。</li>\r</ul>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectUserJobs2();</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap id=&quot;userAndJobs2&quot; extends=&quot;BaseResultMap&quot; type=&quot;User&quot;&gt;\r    &lt;collection property=&quot;jobs&quot; fetchType=&quot;lazy&quot; column=&quot;id&quot; select=&quot;ren.oliver.mybatis.learning.mapper.JobHistoryMapper.selectByUserId&quot; /&gt;\r&lt;/resultMap&gt;\r\r&lt;select id=&quot;selectUserJobs2&quot; resultMap=&quot;userAndJobs2&quot;&gt;\r	select\r	  a.id,\r	  a.user_name,\r	  a.real_name,\r	  a.sex,\r	  a.mobile\r	from\r	  t_user a\r&lt;/select&gt;</pre>\r\r<p><strong>注意：</strong></p>\r\r<p>如果要配置一个相当复杂的映射，一定要从基础映射开始配置，每增加一些配置就进行对应的测试，在循序渐进的过程中更容易发现和解决问题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1893, 'MyBatis鉴别器——discriminator', '1893', 1572637349, 1572637349, '<p>本文记录Java学习过程中遇到的MyBatis鉴别器&mdash;&mdash;discriminator～</p>\r<!--more-->\r\r<p>在特定的情况下使用不同的pojo进行关联，鉴别器元素就是被设计来处理这个情况的。</p>\r\r<p>鉴别器非常容易理解，因为它的表现很像Java语言中的switch语句。</p>\r\r<p>discriminator标签常用的两个属性如下：</p>\r\r<ul>\r	<li>column：该属性用于设置要进行鉴别比较值的列；</li>\r	<li>javaType：该属性用于指定列的类型，保证使用相同的Java类型来比较值。</li>\r</ul>\r\r<p>discriminator标签可以有1个或多个case标签，case标签包含以下三个属性：</p>\r\r<ul>\r	<li>value：该值为discriminator指定column用来匹配的值；</li>\r	<li>resultMap：当column的值和value的值匹配时，可以配置使用resultMap指定的映射，resultMap优先级高于resultType；</li>\r	<li>resultType：当column的值和value的值匹配时，用于配置使用resultType指定的映射。</li>\r</ul>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectUserHealthReport();</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap id=&quot;userAndHealthReport&quot; extends=&quot;BaseResultMap&quot; type=&quot;User&quot;&gt;\r    &lt;discriminator column=&quot;sex&quot;  javaType=&quot;int&quot;&gt;\r        &lt;case value=&quot;1&quot; resultMap=&quot;userAndHealthReportMale&quot; /&gt;\r        &lt;case value=&quot;2&quot; resultMap=&quot;userAndHealthReportFemale&quot; /&gt;\r    &lt;/discriminator&gt;\r&lt;/resultMap&gt;\r\r&lt;resultMap id=&quot;userAndHealthReportMale&quot; extends=&quot;userAndHealthReport&quot; type=&quot;User&quot;&gt;\r    &lt;collection property=&quot;healthReports&quot; column=&quot;id&quot; select= &quot;ren.oliver.mybatis.learning.mapper.HealthReportMaleMapper.selectByUserId&quot;&gt;\r\r    &lt;/collection&gt;\r&lt;/resultMap&gt;\r\r&lt;resultMap id=&quot;userAndHealthReportFemale&quot; extends=&quot;userAndHealthReport&quot; type=&quot;User&quot;&gt;\r    &lt;collection property=&quot;healthReports&quot; column=&quot;id&quot; select= &quot;ren.oliver.mybatis.learning.mapper.HealthReportFemaleMapper.selectByUserId&quot;&gt;\r\r    &lt;/collection&gt;\r&lt;/resultMap&gt;\r\r&lt;select id=&quot;selectUserHealthReport&quot; resultMap=&quot;userAndHealthReport&quot;&gt;\r    select\r      &lt;include refid=&quot;Base_Column_List&quot; /&gt;\r    from\r      t_user a\r&lt;/select&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1894, 'MyBatis多对多查询——嵌套结果', '1894', 1572651475, 1572651475, '<p>本文记录Java学习过程中遇到的MyBatis多对多查询&mdash;&mdash;嵌套结果～</p>\r<!--more-->\r\r<p>多对多查询有两个先决条件：</p>\r\r<ul>\r	<li>多对多需要一种中间表建立连接关系；</li>\r	<li>多对多关系是由两个一对多关系组成的，一对多可以也可以用两种方式实现。</li>\r</ul>\r\r<p>多对多查询都是可以通过两个一对多实现的。</p>\r\r<p>示例代码（接口）：</p>\r\r<pre class="brush:java;">\rList&lt;User&gt; selectUserRole();</pre>\r\r<p>示例代码（配置）：</p>\r\r<pre class="brush:xml;">\r&lt;resultMap id=&quot;userRoleInfo&quot; type=&quot;User&quot;  extends=&quot;BaseResultMap&quot;&gt;\r    &lt;collection property=&quot;roles&quot; ofType=&quot;Role&quot; columnPrefix=&quot;role_&quot;&gt;\r        &lt;result column=&quot;id&quot; property=&quot;id&quot; /&gt;\r        &lt;result column=&quot;Name&quot; property=&quot;roleName&quot; /&gt;\r        &lt;result column=&quot;note&quot; property=&quot;note&quot; /&gt;\r    &lt;/collection&gt;\r&lt;/resultMap&gt;\r\r&lt;select id=&quot;selectUserRole&quot; resultMap=&quot;userRoleInfo&quot;&gt;\r	select\r	  a.id,\r	  a.user_name,\r	  a.real_name,\r	  a.sex,\r	  a.mobile,\r	  a.note,\r	  b.role_id,\r	  c.role_name,\r	  c.note role_note\r	from\r	  t_user a, t_user_role b, t_role c\r	where\r	  a.id = b.user_id AND b.role_id = c.id\r &lt;/select&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1895, 'MyBatis缓存.png', 'MyBatis缓存-png', 1572712457, 1572712457, 'a:5:{s:4:"name";s:17:"MyBatis缓存.png";s:4:"path";s:35:"/usr/uploads/2019/11/1819129095.png";s:4:"size";i:114923;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1896, 0),
(1896, 'MyBatis缓存——一级缓存和二级缓存', '1896', 1572712556, 1572712556, '<p>本文记录Java学习过程中遇到的MyBatis缓存&mdash;&mdash;一级缓存和二级缓存～</p>\r<!--more-->\r\r<p>MyBatis包含一个非常强大的查询缓存特性，使用缓存可以使应用更快地获取数据，避免频繁的数据库交互。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/1819129095.png" style="width: 800px; height: 574px;" />​</p>\r\r<p>一级缓存（也叫应用缓存）：</p>\r\r<ul>\r	<li>一级缓存默认会启用，想要关闭一级缓存可以在select标签上配置flushCache=&ldquo;true&rdquo;；</li>\r	<li>一级缓存存在于SqlSession的生命周期中，在同一个SqlSession中查询时，MyBatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中。如果同一个SqlSession中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当Map缓存对象中己经存在该键值时，则会返回缓存中的对象；</li>\r	<li>任何的INSERT、UPDATE、DELETE操作都会清空一级缓存。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 获取sqlSession\rSqlSession sqlSession1 = sqlSessionFactory.openSession();\r// 获取对应mapper\rUserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);\r// 执行查询语句并返回结果\rString email = &quot;qq.com&quot;;\rByte sex = 1;\rList&lt;User&gt; list1 = userMapper1.selectByEmailAndSex2(email, sex);\rSystem.out.println(list1.size());\r\r// 增删改操作会清空一级缓存和二级缓存\rUser userInsert = new User();\ruserInsert.setUserName(&quot;test1&quot;);\ruserInsert.setRealName(&quot;realname1&quot;);\ruserInsert.setEmail(&quot;myemail1&quot;);\ruserMapper1.insert1(userInsert);\rList&lt;User&gt; list2 = userMapper1.selectByEmailAndSex2(email, sex);\rSystem.out.println(list2.toString());\rHashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\rmap.put(&quot;email&quot;, email);\rmap.put(&quot;sex&quot;, sex);\rList&lt;User&gt; list3 = userMapper1.selectByEmailAndSex1(map);\rSystem.out.println(list3.toString());\r\r// 一级缓存是SQLSession维度的，关闭SQLSession将失效\rsqlSession1.close();\r\rSqlSession sqlSession2 = sqlSessionFactory.openSession();\rUserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);\rList&lt;User&gt; list4 = userMapper2.selectByEmailAndSex2(email, sex);\rSystem.out.println(list4.toString());\rsqlSession2.close();</pre>\r\r<p>二级缓存（也叫应用缓存）：</p>\r\r<p>二级缓存存在于SqlSessionFactory的生命周期中，可以理解为跨sqlSession；缓存是以namespace为单位的，不同namespace下的操作互不影响。</p>\r\r<p>setting参数cacheEnabled，这个参数是二级缓存的全局开关，默认值是true，如果把这个参数设置为false，即使有后面的二级缓存配置，也不会生效。</p>\r\r<p>要开启二级缓存，需要在SQL映射文件中添加配置：</p>\r\r<pre class="brush:xml;">\r&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot; /&gt;</pre>\r\r<p>字面上看就是这样，这个简单语句的效果如下：</p>\r\r<ul>\r	<li>映射语句文件中的所有select语句将会被缓存；</li>\r	<li>映射语句文件中的所有insert，update和delete语句会刷新缓存；</li>\r	<li>缓存会使用Least-Recently-Used(LRU，最近最少使用的)算法来收回；</li>\r	<li>根据时间表(比如：no-Flush-Interval，没有刷新间隔), 缓存不会以任何时间顺序来刷新；</li>\r	<li>缓存会存储列表集合或对象（无论查询方法返回什么）的512个引用；</li>\r	<li>缓存会被视为是read/write(可读/可写)的缓存。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:xml;">\rSqlSession sqlSession1 = sqlSessionFactory.openSession();\r\rUserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);\rString email = &quot;qq.com&quot;;\rByte sex = 1;\rList&lt;User&gt; list1 = userMapper1.selectByEmailAndSex2(email, sex);\rSystem.out.println(list1.size());\r\rList&lt;User&gt; list2 = userMapper1.selectByEmailAndSex2(email, sex);\rSystem.out.println(list2.size());\r\rUser userInsert = new User();\ruserInsert.setUserName(&quot;test1&quot;);\ruserInsert.setRealName(&quot;realname1&quot;);\ruserInsert.setEmail(&quot;myemail1&quot;);\ruserMapper1.insert1(userInsert);\r\rList&lt;User&gt; list3 = userMapper1.selectByEmailAndSex2(email, sex);\rSystem.out.println(list3.size());\rsqlSession1.close();\r\r\rSqlSession sqlSession2 = sqlSessionFactory.openSession();\rUserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);\rList&lt;User&gt; list4 = userMapper2.selectByEmailAndSex2(email, sex);\rSystem.out.println(list4.size());\rsqlSession2.close();\r\rSqlSession sqlSession3 = sqlSessionFactory.openSession();\rJobHistoryMapper userMapper3 = sqlSession3.getMapper(JobHistoryMapper.class);\rList&lt;User&gt; list5 = userMapper3.selectByEmailAndSex2(email, sex);\rSystem.out.println(list5.size());\rsqlSession3.close();</pre>\r\r<p>注意：</p>\r\r<p>使用二级缓存容易出现脏读，建议避免使用二级缓存，在业务层使用可控制的缓存代替更好。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1897, 'MyBatis-Spring.png', 'MyBatis-Spring-png', 1572713151, 1572713151, 'a:5:{s:4:"name";s:18:"MyBatis-Spring.png";s:4:"path";s:35:"/usr/uploads/2019/11/1730904071.png";s:4:"size";i:39770;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1898, 0),
(1898, 'MyBatis-Spring简介', '1898', 1572713164, 1572713164, '<p>本文记录Java学习过程中遇到的MyBatis-Spring简介～</p>\r<!--more-->\r\r<p>Mybatis-Spring用于帮助你将MyBatis代码无缝地整合到Spring中：</p>\r\r<ul>\r	<li>Spring将会加载必要的MyBatis工厂类和session类；</li>\r	<li>提供一个简单的方式来注入MyBatis数据映射器和SqlSession到业务层的bean中；&nbsp;</li>\r	<li>方便集成Spring事务；</li>\r	<li>翻译MyBatis的异常到Spring的DataAccessException异常(数据访问异常)中。</li>\r</ul>\r\r<p>MyBatis-Spring兼容性：</p>\r\r<p>MyBatis-Spring要求Java5及以上版本还有下面列出的MyBatis和Spring版本：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/1730904071.png" style="width: 800px; height: 175px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1899, 'MyBatis-Spring实战', '1899', 1572719271, 1572719271, '<p>本文记录Java学习过程中遇到的MyBatis-Spring实战～</p>\r<!--more-->\r\r<p>1.准备Spring项目；</p>\r\r<p>2.在pom文件中添加mybatis-spring的依赖：</p>\r\r<pre class="brush:xml;">\r&lt;dependency&gt;\r	&lt;groupId&gt;org.mybatis&lt;/groupId&gt;\r	&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\r	&lt;version&gt;1.3.0&lt;/version&gt;\r&lt;/dependency&gt;</pre>\r\r<p>3.配置SqlSessionFactoryBean：</p>\r\r<p>在MyBatis-Spring中，SqlSessionFactoryBean是用于创建SqlSessionFactory的。</p>\r\r<ul>\r	<li>dataSource：用于配置数据源，该属性为必选项，必须通过这个属性配置数据源，这里使用了上一节中配置好的dataSource数据库连接池；</li>\r	<li>mapper Locations：配置SqlSessionFactoryBean扫描XML映射文件的路径，可以使用Ant风格的路径进行配置；</li>\r	<li>configLocation：用于配置mybatis config XML的路径，除了数据源外，对MyBatis的各种配直仍然可以通过这种方式进行，并且配置MyBatis settings时只能使用这种方式。但配置文件中任意环境，数据源和MyBatis的事务管理器都会被忽略；</li>\r	<li>typeAliasesPackage：配置包中类的别名，配置后，包中的类在XML映射文件中使用时可以省略包名部分，直接使用类名。这个配置不支持 Ant风格的路径，当需要配置多个包路径时可以使用分号或逗号进行分隔。</li>\r</ul>\r\r<p>4.配置MapperScannerConfigurer：</p>\r\r<p>通过MapperScannerConfigurer类自动扫描所有的Mapper接口，使用时可以直接注入接口。</p>\r\r<p>MapperScannerConfigurer中常配置以下两个属性：</p>\r\r<ul>\r	<li>basePackage：用于配置基本的包路径。可以使用分号或逗号作为分隔符设置多于一个的包路径，每个映射器将会在指定的包路径中递归地被搜索到；</li>\r	<li>annotationClass：用于过滤被扫描的接口，如果设置了该属性，那么MyBatis的接口只有包含该注解才会被扫描进去。</li>\r</ul>\r\r<p>5.配置事务</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1900, 'MyBatis源码导入流程', '1900', 1572752608, 1572752608, '<p>本文记录Java学习过程中遇到的MyBatis源码导入流程～</p>\r<!--more-->\r\r<ol>\r	<li>下载MyBatis的源码；</li>\r	<li>检查maven的版本，必须是3.25以上，建议使用maven的最新版本；</li>\r	<li>mybatis的工程是maven工程，在开发工具中导入，工程必须使用jdk1.8以上版本；</li>\r	<li>把mybatis源码的pom文件中&lt;optional&gt;true&lt;/optional&gt;，全部改为false；</li>\r	<li>在工程目录下执行 mvn clean install -Dmaven.test.skip=true,将当前工程安装到本地仓库（pdf插件报错的话，需要将这个插件屏蔽）；</li>\r	<li>其他工程依赖此工程。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1901, 'MyBatis源码结构.png', 'MyBatis源码结构-png', 1572752756, 1572752756, 'a:5:{s:4:"name";s:23:"MyBatis源码结构.png";s:4:"path";s:35:"/usr/uploads/2019/11/1359168245.png";s:4:"size";i:102510;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1902, 0),
(1902, 'MyBatis源码结构', '1902', 1572753267, 1572753267, '<p>本文记录Java学习过程中遇到的MyBatis源码结构～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/1359168245.png" style="width: 800px; height: 459px;" /></p>\r\r<p>annotations</p>\r\r<ul>\r	<li>包含所有mapper接口中用到的注解</li>\r	<li>例如：常用的@Param，@Select等等</li>\r</ul>\r\r<p>binding</p>\r\r<ul>\r	<li>生成mapper接口的动态代理并进行管理</li>\r</ul>\r\r<p>builder</p>\r\r<ul>\r	<li>包含Configuration对象所有构建器，包括XML和注解两种方式配置解析</li>\r	<li>BaseBuilder构建器基类</li>\r	<li>XMLConfigBuilder解析configuration.xml配置文件</li>\r	<li>XMLMapperBuilder解析Mapper.xml配置文件</li>\r	<li>XMLStatementBuilder解析select、insert、update和delete标签</li>\r	<li>MapperAnnotationBuilder解析Mapper</li>\r</ul>\r\r<p>cache</p>\r\r<ul>\r	<li>缓存功能实现，包含各种缓存装饰器</li>\r	<li>TransactionalCache，二级缓存功能实现</li>\r</ul>\r\r<p>cursor</p>\r\r<ul>\r	<li>实现游标的方式查询数据</li>\r	<li>游标非常适合处理百万级别的数据查询，通常情况下不适合一次性加载到内存中</li>\r	<li>这种方式类似使用SAX解析XML文件</li>\r</ul>\r\r<p>datasource</p>\r\r<ul>\r	<li>数据源，包括jndi数据源和连接池功能</li>\r</ul>\r\r<p>executor</p>\r\r<p>包含SQL语句执行器，核心功能包<br />\r主要功能</p>\r\r<ul>\r	<li>主键生成功能</li>\r	<li>执行参数解析功能</li>\r	<li>执行结果解析功能</li>\r	<li>SQL执行器</li>\r	<li>缓存执行器</li>\r</ul>\r\r<p>ErrorContext，错误上下文对象，跟踪所有执行流程</p>\r\r<p>exceptions</p>\r\r<ul>\r	<li>框架异常</li>\r	<li>常见异常：TooManyResultsException</li>\r</ul>\r\r<p>io</p>\r\r<ul>\r	<li>资源文件读取</li>\r</ul>\r\r<p>jdbc</p>\r\r<ul>\r	<li>JDBC一些操作</li>\r	<li>SQLRuner SQL执行</li>\r	<li>ScriptRunner脚本执行，可以执行建库语句，在执行测试用例时候用的非常多</li>\r</ul>\r\r<p>lang</p>\r\r<ul>\r	<li>这个包只有2个注解</li>\r	<li>@UsersJava7标示哪些可以使用Java7</li>\r	<li>@UsersJava8标示哪些可以使用Java8</li>\r</ul>\r\r<p>logging</p>\r\r<ul>\r	<li>日志功能，实现多种日志框架的对接</li>\r	<li>org.apache.ibatis.logging.jdbc代理所有功能JDBC操作，实现了在debug模式下能够输出SQL</li>\r</ul>\r\r<p>mapping</p>\r\r<ul>\r	<li>配置文件与实体对象的映射功能</li>\r	<li>Mapper映射</li>\r	<li>参数映射</li>\r	<li>结果映射</li>\r</ul>\r\r<p>parsing</p>\r\r<ul>\r	<li>解析工具包</li>\r	<li>Generic TokenParser：解析#{}和${}这种占位符</li>\r	<li>XPathParser：XPath形式解析XML</li>\r	<li>PropertyParser：properties解析器</li>\r	<li>org.apache.ibatis.plugin</li>\r</ul>\r\r<p>plugin</p>\r\r<ul>\r	<li>拦截器功能实现，使用代理模式实现拦截</li>\r</ul>\r\r<p>reflection</p>\r\r<ul>\r	<li>反射器功能，这个包下实现元数据编程</li>\r	<li>通过把Java对象转换成 元数据对象 MetaObject，然后就可以对元数据对象进行赋值操作，数据库查询结果到Java对象映射就是通过元对象实现</li>\r</ul>\r\r<p>scripting</p>\r\r<ul>\r	<li>动态SQL语言实现，配置文件中if、where、set、foreach、choose和when功能就是在这个包实现的，借助OGNL表达式也可以扩展自己的语言实现功能</li>\r</ul>\r\r<p>session</p>\r\r<ul>\r	<li>主要实现SqlSession功能，非常核心包</li>\r	<li>官方注释：SqlSession包含了MyBatis工作的所有的Java接口，通过这些接口可以执行SQL命令（insert，delete、update、select），获取Mapper，管理事务</li>\r</ul>\r\r<p>transaction</p>\r\r<ul>\r	<li>事务功能实现，包装了数据库连接，处理数据库连接生命周期</li>\r	<li>连接创建</li>\r	<li>预编译</li>\r	<li>提交、回滚和关闭</li>\r</ul>\r\r<p>type</p>\r\r<ul>\r	<li>类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1903, '设计模式的几个原则', '1903', 1572764357, 1572764357, '<p>本文记录Java学习过程中遇到的设计模式的几个原则～</p>\r<!--more-->\r\r<ul>\r	<li>单一职责原则：一个类或者一个接口只负责唯一项职责，尽量设计出功能单一的接口；</li>\r	<li>依赖倒转原则：高层模块不应该依赖低层模块具体实现，解耦高层与低层。既面向接口编程，当实现发生变化时，只需提供新的实现类，不需要修改高层模块代码;</li>\r	<li>开放-封闭原则：程序对外扩展开放，对修改关闭；换句话说，当需求发生变化时，我们可以通过添加新模块来满足新需求，而不是通过修改原来的实现代码来满足新需求。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1904, '适配器模式.png', '适配器模式-png', 1572851754, 1572851754, 'a:5:{s:4:"name";s:19:"适配器模式.png";s:4:"path";s:35:"/usr/uploads/2019/11/3195397226.png";s:4:"size";i:45610;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1905, 0),
(1905, '适配器模式', '1905', 1572851769, 1572851769, '<p>本文记录Java学习过程中遇到的适配器模式～</p>\r<!--more-->\r\r<p>适配器模式（Adapter-Pattern）是作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/3195397226.png" style="width: 800px; height: 462px;" />​</p>\r\r<ul>\r	<li>Target：目标角色，期待得到的接口；</li>\r	<li>Adaptee：适配者角色，被适配的接口；</li>\r	<li>Adapter：适配器角色，将源接口转换成目标接口。</li>\r</ul>\r\r<p><strong>适用场景：</strong></p>\r\r<p>当调用双方都不太容易修改的时候，为了复用现有组件可以使用适配器模式，在系统中接入第三方组件的时候经常被使用到。</p>\r\r<p><strong>注意：</strong></p>\r\r<p>如果系统中存在过多的适配器，会增加系统的复杂性，设计人员应考虑对系统进行重构。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1906, '日志模块类图.png', '日志模块类图-png', 1572852167, 1572852167, 'a:5:{s:4:"name";s:22:"日志模块类图.png";s:4:"path";s:35:"/usr/uploads/2019/11/2552351608.png";s:4:"size";i:98182;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1907, 0),
(1907, 'MyBatis日志模块代码分析——打日志', '1907', 1572852120, 1573486319, '<p>本文记录Java学习过程中遇到的MyBatis日志模块代码分析&mdash;&mdash;打日志～</p>\r<!--more-->\r\r<p>MyBatis没有提供日志的实现类，需要接入第三方的日志组件，但第三方日志组件都有各自的Log级别，且各不相同，MyBatis统一提供了trace、debug、warn、error四个级别。</p>\r\r<p>自动扫描日志实现，并且第三方日志插件加载优先级如下：slf4J &rarr; commonsLoging &rarr; Log4J2 &rarr; Log4J &rarr; JdkLog。</p>\r\r<p>日志的使用要优雅的嵌入到主体功能中。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/2552351608.png" style="width: 800px; height: 380px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1908, '代理模式', '1908', 1573480980, 1573481168, '<p>本文记录Java学习过程中遇到的代理模式～</p>\r<!--more-->\r\r<p>定义：给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。</p>\r\r<p>目的：</p>\r\r<ol>\r	<li>通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性；</li>\r	<li>通过代理对象对原有的业务增强。</li>\r</ol>\r\r<p>好处：</p>\r\r<ol>\r	<li>作为中介解耦客户端和真实对象，保护真实对象安全；</li>\r	<li>防止直接访问目标对象给系统带来的不必要复杂性；</li>\r	<li>对业务进行增强，增强点多样化如：前入、后入、异常。</li>\r</ol>\r\r<p>类图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/2217339508.png" style="width: 800px; height: 340px;" /></p>\r\r<p>动态代理：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/3559281879.png" style="width: 800px; height: 495px;" /></p>\r\r<p>&nbsp;</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1909, '代理模式.png', '代理模式-png', 1573481072, 1573481072, 'a:5:{s:4:"name";s:16:"代理模式.png";s:4:"path";s:35:"/usr/uploads/2019/11/2217339508.png";s:4:"size";i:191345;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1908, 0),
(1910, '动态代理.png', '动态代理-png', 1573481155, 1573481155, 'a:5:{s:4:"name";s:16:"动态代理.png";s:4:"path";s:35:"/usr/uploads/2019/11/3559281879.png";s:4:"size";i:185710;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1908, 0),
(1912, '日志模块JDBC包类图.png', '日志模块JDBC包类图-png', 1573486413, 1573486413, 'a:5:{s:4:"name";s:29:"日志模块JDBC包类图.png";s:4:"path";s:35:"/usr/uploads/2019/11/2602396762.png";s:4:"size";i:73184;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1913, 0),
(1913, 'MyBatis日志模块代码分析——动态代理', '1913', 1573486440, 1573486476, '<p>本文记录Java学习过程中遇到的MyBatis日志模块代码分析&mdash;&mdash;动态代理～</p>\r<!--more-->\r\r<p>日志模块JDBC包类图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/2602396762.png" style="width: 800px; height: 385px;" /></p>\r\r<ul>\r	<li>ConnectionLogger：负责打印连接信息和SQL语句，并创建PreparedStatementLogger；</li>\r	<li>PreparedStatementLogger：负责打印参数信息，并创建ResultSetLogger；</li>\r	<li>ResultSetLogge：负责打印数据结果信息。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1914, '工厂模式.png', '工厂模式-png', 1573561461, 1573561461, 'a:5:{s:4:"name";s:16:"工厂模式.png";s:4:"path";s:35:"/usr/uploads/2019/11/2808720128.png";s:4:"size";i:60774;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1915, 0),
(1915, '工厂模式', '1915', 1573561440, 1573561511, '<p>本文记录Java学习过程中遇到的工厂模式～</p>\r<!--more-->\r\r<p>工厂模式（Factory Pattern）属于创建型模式，它提供了一种创建对象的最佳方式。定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/2808720128.png" style="width: 800px; height: 239px;" /></p>\r\r<ul>\r	<li>工厂接口（Factory）：工厂接口是工厂方法模式的核心接口，调用者会直接和工厂接口交互用于获取具体的产品实现类；</li>\r	<li>具体工厂类（ConcreteFactory）:是工厂接口的实现类，用于实例化产品对象，不同的具体工厂类会根据需求实例化不同的产品实现类；</li>\r	<li>产品接口（Product）：产品接口用于定义产品类的功能，具体工厂类产生的所有产品都必须实现这个接口。调用者与产品接口直接交互，这是调用者最关心的接口；</li>\r	<li>具体产品类（ConcreteProduct）：实现产品接口的实现类，具体产品类中定义了具体的业务逻辑。</li>\r</ul>\r\r<p>创建对象的方式：</p>\r\r<ul>\r	<li>使用new关键字直接创建对象；</li>\r	<li>通过反射机制创建对象；</li>\r	<li>通过工厂类创建对象。</li>\r</ul>\r\r<p>前两种的缺点：</p>\r\r<ul>\r	<li>对象创建和对象使用使用的职责耦合在一起，违反单一原则；</li>\r	<li>当业务扩展时，必须修改代业务代码，违反了开闭原则。</li>\r</ul>\r\r<p>后一种的优点：</p>\r\r<ul>\r	<li>把对象的创建和使用的过程分开，对象创建和对象使用使用的职责解耦；</li>\r	<li>如果创建对象的过程很复杂，创建过程统一到工厂里管理，既减少了重复代码，也方便以后对创建过程的修改维护；</li>\r	<li>当业务扩展时，只需要增加工厂子类，符合开闭原则。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1916, '数据源模块类图.png', '数据源模块类图-png', 1573958511, 1573958511, 'a:5:{s:4:"name";s:25:"数据源模块类图.png";s:4:"path";s:35:"/usr/uploads/2019/11/3615373678.png";s:4:"size";i:110111;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1920, 0),
(1918, 'PooledDataSource获取连接过程.png', 'PooledDataSource获取连接过程-png', 1573958724, 1573958724, 'a:5:{s:4:"name";s:38:"PooledDataSource获取连接过程.png";s:4:"path";s:34:"/usr/uploads/2019/11/812564061.png";s:4:"size";i:44576;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1920, 0),
(1919, 'PooledDataSource归还连接过程.png', 'PooledDataSource归还连接过程-png', 1573958778, 1573958778, 'a:5:{s:4:"name";s:38:"PooledDataSource归还连接过程.png";s:4:"path";s:35:"/usr/uploads/2019/11/4071850811.png";s:4:"size";i:89822;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1920, 0),
(1920, 'MyBatis数据源模块代码分析', '1920', 1573958791, 1573958791, '<p>本文记录Java学习过程中遇到的MyBatis数据源模块代码分析～</p>\r<!--more-->\r\r<p>数据源模块需求：</p>\r\r<ul>\r	<li>常见的数据源组件都实现了javax.sql.DataSource接口；</li>\r	<li>MyBatis不但要能集成第三方的数据源组件，自身也提供了数据源的实现；</li>\r	<li>一般情况下，数据源的初始化过程参数较多，比较复杂。</li>\r</ul>\r\r<p>数据源模块类图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/3615373678.png" style="width: 800px; height: 258px;" /></p>\r\r<ul>\r	<li>PooledConnection：使用动态代理封装了真正的数据库连接对象；</li>\r	<li>PoolState：用于管理PooledConnection对象状态的组件，通过两个list分别管理空闲状态的连接资源和活跃状态的连接资源；</li>\r	<li>PooledDataSource：一个简单的、同步的和线程安全的数据库连接池。</li>\r</ul>\r\r<p>PooledDataSource获取连接过程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/812564061.png" style="width: 510px; height: 739px;" /></p>\r\r<p>PooledDataSource归还连接过程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/4071850811.png" style="width: 585px; height: 802px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1921, '装饰器模式类图.png', '装饰器模式类图-png', 1573988549, 1573988549, 'a:5:{s:4:"name";s:25:"装饰器模式类图.png";s:4:"path";s:35:"/usr/uploads/2019/11/2132010496.png";s:4:"size";i:65073;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1923, 0),
(1922, 'MyBatis的缓存组件.png', 'MyBatis的缓存组件-png', 1573988590, 1573988590, 'a:5:{s:4:"name";s:26:"MyBatis的缓存组件.png";s:4:"path";s:35:"/usr/uploads/2019/11/2700455579.png";s:4:"size";i:31568;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1923, 0),
(1923, '装饰器模式', '1923', 1573988602, 1573988602, '<p>本文记录Java学习过程中遇到的装饰器模式～</p>\r<!--more-->\r\r<p>装饰器模式（Decorator-Pattern）允许向一个现有的对象添加新的功能，是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能，使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>\r\r<p>装饰器模式类图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/2132010496.png" style="width: 800px; height: 471px;" /></p>\r\r<ul>\r	<li>组件（Component）：组件接口定义了全部组件类和装饰器实现的行为；</li>\r	<li>组件实现类（ConcreteComponent）:实现Component接口，组件实现类就是被装饰器装饰的原始对象，新功能或者附加功能都是通过装饰器添加到该类的对象上的；</li>\r	<li>装饰器抽象类（Decorator）：实现Component接口的抽象类，在其中封装了一个Component 对象，也就是被装饰的对象；</li>\r	<li>具体装饰器类（ConcreteDecorator）：该实现类要向被装饰的对象添加某些功能。</li>\r</ul>\r\r<p>优点（相对于继承，装饰器模式灵活性更强，扩展性更强）：</p>\r\r<ul>\r	<li>灵活性：装饰器模式将功能切分成一个个独立的装饰器，在运行期可以根据需要动态的添加功能，甚至对添加的新功能进行自由的组合；</li>\r	<li>扩展性：当有新功能要添加的时候，只需要添加新的装饰器实现类，然后通过组合方式添加这个新装饰器，无需修改已有代码，符合开闭原则。</li>\r</ul>\r\r<p>装饰器模式使用举例：</p>\r\r<p>1.IO中输入流和输出流的设计：</p>\r\r<pre class="brush:java;">\rBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;file.txt&quot;)));</pre>\r\r<p>2.Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper类增强了request对象的功能；</p>\r\r<p>3.MyBatis的缓存组件：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/2700455579.png" style="width: 800px; height: 396px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1924, '缓存模块类图.png', '缓存模块类图-png', 1574176869, 1574176869, 'a:5:{s:4:"name";s:22:"缓存模块类图.png";s:4:"path";s:35:"/usr/uploads/2019/11/3461078897.png";s:4:"size";i:32516;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1925, 0),
(1925, 'MyBatis缓存模块代码分析——主要设计', '1925', 1574176886, 1574176886, '<p>本文记录Java学习过程中遇到的MyBatis缓存模块代码分析&mdash;&mdash;主要设计～</p>\r<!--more-->\r\r<p>缓存模块需求：</p>\r\r<ul>\r	<li>Mybatis缓存的实现是基于Map的，从缓存里面读写数据是缓存模块的核心基础功能；</li>\r	<li>除核心功能之外，有很多额外的附加功能，如：防止缓存击穿，添加缓存清空策略（fifo、lru）、序列化功能、日志能力、定时清空能力等；</li>\r	<li>附加功能可以以任意的组合附加到核心基础功能之上。</li>\r</ul>\r\r<p>怎么样优雅的为核心功能添加附加能力？</p>\r\r<p>使用继承的办法扩展附加功能？</p>\r\r<p>继承的方式是静态的，用户不能控制增加行为的方式和时机。另外，新功能的存在多种组合，使用继承可能导致大量子类存在。</p>\r\r<p>缓存模块类图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/3461078897.png" style="width: 800px; height: 399px;" />​</p>\r\r<ul>\r	<li>Cache：Cache接口是缓存模块的核心接口，定义了缓存的基本操作；</li>\r	<li>PerpetualCache：在缓存模块中扮演ConcreteComponent角色，使用HashMap来实现cache的相关操作；</li>\r	<li>BlockingCache：阻塞版本的缓存装饰器，保证只有一个线程到数据库去查找指定的key对应的数据。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1926, '粗锁粒度.png', '粗锁粒度-png', 1574177246, 1574177246, 'a:5:{s:4:"name";s:16:"粗锁粒度.png";s:4:"path";s:35:"/usr/uploads/2019/11/3643001306.png";s:4:"size";i:46676;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1928, 0),
(1927, '细锁粒度.png', '细锁粒度-png', 1574177271, 1574177271, 'a:5:{s:4:"name";s:16:"细锁粒度.png";s:4:"path";s:35:"/usr/uploads/2019/11/3734801653.png";s:4:"size";i:48108;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1928, 0),
(1928, 'MyBatis缓存模块代码分析——锁粒度的问题 ', '1928', 1574177288, 1574177288, '<p>本文记录Java学习过程中遇到的MyBatis缓存模块代码分析&mdash;&mdash;锁粒度的问题 ～</p>\r<!--more-->\r\r<p>粗粒度锁：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/3643001306.png" style="width: 800px; height: 373px;" /></p>\r\r<p>细粒度锁：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/3734801653.png" style="width: 800px; height: 476px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1930, 'BlockingCache.png', 'BlockingCache-png', 1574177496, 1574177496, 'a:5:{s:4:"name";s:17:"BlockingCache.png";s:4:"path";s:35:"/usr/uploads/2019/11/3792202968.png";s:4:"size";i:141376;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1931, 0),
(1931, 'MyBatis缓存模块代码分析——缓存装饰器', '1931', 1574177509, 1574177509, '<p>本文记录Java学习过程中遇到的MyBatis缓存模块代码分析&mdash;&mdash;缓存装饰器～</p>\r<!--more-->\r\r<p>FifoCache</p>\r\r<p>LoggingCache</p>\r\r<p>ScheduledCache</p>\r\r<p>BlockingCache</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/11/3792202968.png" style="width: 800px; height: 387px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1932, 'MyBatis缓存模块代码分析——CacheKey', '1932', 1574177614, 1574177614, '<p>本文记录Java学习过程中遇到的MyBatis缓存模块代码分析&mdash;&mdash;CacheKey～</p>\r<!--more-->\r\r<p>Mybatis中涉及到动态SQL的原因，缓存项的key不能仅仅通过一个String来表示，所以通过CacheKey来封装缓存的Key值，CacheKey可以封装多个影响缓存项的因素；判断两个CacheKey是否相同关键是比较两个对象的hash值是否一致。</p>\r\r<p>构成CacheKey的对象：</p>\r\r<ul>\r	<li>mappedStatment的id；</li>\r	<li>指定查询结果集的范围（分页信息）；</li>\r	<li>查询所使用的SQL语句；</li>\r	<li>用户传递给SQL语句的实际参数值。</li>\r</ul>\r\r<p>重点解读方法：</p>\r\r<ul>\r	<li>update(Object obj)；</li>\r	<li>equals(Object obj)。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1933, '反射的核心类.png', '反射的核心类-png', 1575819230, 1575819230, 'a:5:{s:4:"name";s:22:"反射的核心类.png";s:4:"path";s:34:"/usr/uploads/2019/12/534940534.png";s:4:"size";i:51519;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1935, 0),
(1934, 'ORM框架查询数据过程.png', 'ORM框架查询数据过程-png', 1575819251, 1575819251, 'a:5:{s:4:"name";s:31:"ORM框架查询数据过程.png";s:4:"path";s:34:"/usr/uploads/2019/12/896753182.png";s:4:"size";i:108871;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1935, 0),
(1935, 'MyBatis反射模块代码分析', '1935', 1575819276, 1575819276, '<p>本文记录Java学习过程中遇到的MyBatis反射模块代码分析～</p>\r<!--more-->\r\r<p>ORM框架查询数据过程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/896753182.png" style="width: 800px; height: 315px;" /></p>\r\r<p>反射的核心类：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/534940534.png" style="width: 800px; height: 190px;" /></p>\r\r<ul>\r	<li>MetaObject：封装了对象元信息，包装了MyBatis中五个核心的反射类，也是提供给外部使用的反射工具类，可以利用它可以读取或者修改对象的属性信息；</li>\r	<li>ObjectFactory：MyBatis每次创建结果对象的新实例时，它都会使用对象工厂（ObjectFactory）去构建POJO；</li>\r	<li>ReflectorFactory：创建Reflector的工厂类，Reflector是mybatis反射模块的基础，每个Reflector对象都对应一个类，在其中缓存了反射操作所需要的类元信息；</li>\r	<li>ObjectWrapper：对对象的包装，抽象了对象的属性信息，他定义了一系列查询对象属性信息的方法，以及更新属性的方法；</li>\r	<li>ObjectWrapperFactory： ObjectWrapper 的工厂类，用于创建ObjectWrapper。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1936, 'MyBatis核心流程三大阶段', '1936', 1575992400, 1575992400, '<p>本文记录Java学习过程中遇到的MyBatis核心流程三大阶段～</p>\r<!--more-->\r\r<p>MyBatis核心流程三大阶段为：</p>\r\r<ul>\r	<li>初始化阶段：读取XML配置文件和注解中的配置信息，创建配置对象，并完成各个模块的初始化的工作；</li>\r	<li>代理阶段：封装iBatis的编程模型，使用mapper接口开发的初始化工作；</li>\r	<li>数据读写阶段：通过SqlSession完成SQL的解析，参数的映射、SQL的执行、结果的解析过程。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1937, '建造者模式.png', '建造者模式-png', 1576032592, 1576032592, 'a:5:{s:4:"name";s:19:"建造者模式.png";s:4:"path";s:35:"/usr/uploads/2019/12/2164152208.png";s:4:"size";i:53141;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1938, 0),
(1938, '建造者模式', '1938', 1576032600, 1576032832, '<p>本文记录Java学习过程中遇到的建造者模式～</p>\r<!--more-->\r\r<p>建造者模式（Builder-Pattern）：使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/2164152208.png" style="width: 800px; height: 364px;" /></p>\r\r<ul>\r	<li>Builder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建；</li>\r	<li>ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例；</li>\r	<li>Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建；</li>\r	<li>Product：要创建的复杂对象。</li>\r</ul>\r\r<p>建造者模式使用场景：</p>\r\r<ul>\r	<li>需要生成的对象具有复杂的内部结构，实例化对象时要屏蔽掉对象内部的细节，让上层代码与复杂对象的实例化过程解耦，可以使用建造者模式；简而言之，如果&ldquo;遇到多个构造器参数时要考虑用构建器&rdquo;；</li>\r	<li>一个对象的实例化是依赖各个组件的产生以及装配顺序，关注的是一步一步地组装出目标对象，可以使用建造器模式。</li>\r</ul>\r\r<p>与工厂模式的区别：</p>\r\r<p>1.对象复杂度：</p>\r\r<ul>\r	<li>建造者建造的对象更加复杂，是一个复合产品，它由各个部件复合而成，部件不同产品对象不同，生成的产品粒度细；</li>\r	<li>在工厂方法模式里，我们关注的是一个产品整体，无须关心产品的各部分是如何创建出来的。</li>\r</ul>\r\r<p>2.客户端参与程度：</p>\r\r<ul>\r	<li>建造者模式，导演对象参与了产品的创建，决定了产品的类型和内容，参与度高；适合实例化对象时属性变化频繁的场景；</li>\r	<li>工厂模式，客户端对产品的创建过程参与度低，对象实例化时属性值相对比较固定。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1939, 'MyBatis建造者类图.png', 'MyBatis建造者类图-png', 1576982433, 1576982433, 'a:5:{s:4:"name";s:26:"MyBatis建造者类图.png";s:4:"path";s:35:"/usr/uploads/2019/12/4277657317.png";s:4:"size";i:67770;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1945, 0),
(1940, 'MyBatis的初始化.png', 'MyBatis的初始化-png', 1576982459, 1576982459, 'a:5:{s:4:"name";s:23:"MyBatis的初始化.png";s:4:"path";s:35:"/usr/uploads/2019/12/1087324028.png";s:4:"size";i:93936;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1945, 0),
(1941, 'Configuration类图解.png', 'Configuration类图解-png', 1576982485, 1576982485, 'a:5:{s:4:"name";s:26:"Configuration类图解.png";s:4:"path";s:35:"/usr/uploads/2019/12/3282445054.png";s:4:"size";i:200208;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1945, 0),
(1942, 'ResultMap图解.png', 'ResultMap图解-png', 1576982543, 1576982543, 'a:5:{s:4:"name";s:19:"ResultMap图解.png";s:4:"path";s:35:"/usr/uploads/2019/12/4241051775.png";s:4:"size";i:230256;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1945, 0),
(1943, 'mappedStatment图解.png', 'mappedStatment图解-png', 1576982596, 1576982596, 'a:5:{s:4:"name";s:24:"mappedStatment图解.png";s:4:"path";s:35:"/usr/uploads/2019/12/2322161594.png";s:4:"size";i:231229;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1945, 0),
(1944, 'MyBatis初始化过程.png', 'MyBatis初始化过程-png', 1576982616, 1576982616, 'a:5:{s:4:"name";s:26:"MyBatis初始化过程.png";s:4:"path";s:34:"/usr/uploads/2019/12/235783649.png";s:4:"size";i:112612;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1945, 0),
(1945, 'MyBatis初始化过程代码分析', '1945', 1576982629, 1576982629, '<p>本文记录Java学习过程中遇到的MyBatis初始化过程代码分析～</p>\r<!--more-->\r\r<p>MyBatis建造者类图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/4277657317.png" style="width: 800px; height: 234px;" /></p>\r\r<ul>\r	<li>XMLConfigBuilder：主要负责解析mybatis-config.xml；</li>\r	<li>XMLMapperBuilder：主要负责解析映射配置文件；</li>\r	<li>XMLStatementBuilder：主要负责解析映射配置文件中的SQL节点。</li>\r</ul>\r\r<p>MyBatis的初始化：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/1087324028.png" style="width: 800px; height: 257px;" /></p>\r\r<p>映射器的关键类：</p>\r\r<ul>\r	<li>Configuration：MyBatis启动初始化的核心就是将所有xml配置文件信息加载到Configuration对象中，Configuration是单例的，生命周期是应用级的；</li>\r	<li>MapperRegistry：mapper接口动态代理工厂类的注册中心。在MyBatis中，通过mapperProxy实现InvocationHandler接口，MapperProxyFactory用于生成动态代理的实例对象；</li>\r	<li>ResultMap：用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；</li>\r	<li>MappedStatement：用于存储mapper.xml文件中的select、insert、update和delete节点，同时还包含了这些节点的很多重要属性；</li>\r	<li>SqlSource：mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含?占位符，可以直接提交给数据库执行。</li>\r</ul>\r\r<p>Configuration类图解：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/3282445054.png" style="width: 800px; height: 352px;" /></p>\r\r<p>ResultMap图解：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/4241051775.png" style="width: 800px; height: 360px;" /></p>\r\r<p>mappedStatment图解：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/2322161594.png" style="width: 800px; height: 214px;" /></p>\r\r<p>MyBatis初始化过程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/235783649.png" style="width: 800px; height: 550px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(1946, '代理阶段.png', '代理阶段-png', 1577114182, 1577114182, 'a:5:{s:4:"name";s:16:"代理阶段.png";s:4:"path";s:35:"/usr/uploads/2019/12/3110014457.png";s:4:"size";i:423987;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1948, 0),
(1947, 'binding模块分析.png', 'binding模块分析-png', 1577114202, 1577114202, 'a:5:{s:4:"name";s:23:"binding模块分析.png";s:4:"path";s:35:"/usr/uploads/2019/12/2663638662.png";s:4:"size";i:45083;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1948, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1948, 'MyBatis的binding模块代码分析', '1948', 1577114303, 1577114303, '<p>本文记录Java学习过程中遇到的MyBatis的binding模块代码分析～</p>\r<!--more-->\r\r<p>代理阶段：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/3110014457.png" style="width: 800px; height: 341px;" /></p>\r\r<p>binding模块分析：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2019/12/2663638662.png" style="width: 800px; height: 472px;" />​</p>\r\r<ul>\r	<li>MapperRegistry：mapper接口和对应的代理对象工厂的注册中心；</li>\r	<li>MapperProxyFactory：用于生成mapper接口动态代理的实例对象；</li>\r	<li>MapperProxy：实现了InvocationHandler接口，它是增强mapper接口的实现；</li>\r	<li>MapperMethod：封装了Mapper接口中对应方法的信息，以及对应的sql语句的信息，它是mapper接口与映射配置文件中sql语句的桥梁。</li>\r</ul>\r\r<p>MapperMethod：封装了Mapper接口中对应方法的信息，以及对应的sql语句的信息；它是mapper接口与映射配置文件中sql语句的桥梁； MapperMethod对象不记录任何状态信息，所以它可以在多个代理对象之间共享。</p>\r\r<ul>\r	<li>SqlCommand：从configuration中获取方法的命名空间.方法名以及SQL语句的类型；</li>\r	<li>MethodSignature：封装mapper接口方法的相关信息（入参，返回类型）；</li>\r	<li>ParamNameResolver：解析mapper接口方法中的入参。</li>\r</ul>\r\r<p>翻译过程：</p>\r\r<ul>\r	<li>找到session中对应的方法执行：MapperMethod.SqlCommand.type +MapperMethod.MethodSignature.returnType；</li>\r	<li>找到命名空间和方法名：MapperMethod.SqlCommand.name；</li>\r	<li>传递参数：MapperMethod.MethodSignature.paramNameResolver。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 5),
(1949, 'Gradle概述', '1949', 1577848859, 1577848859, '<p>本文记录Java学习过程中遇到的Gradle概述～</p>\r<!--more-->\r\r<p>Gradle的作用如下：</p>\r\r<ul>\r	<li>一款最新的功能强大的构建工具；</li>\r	<li>使用程序代替传统的XML配置，项目构建更灵活；</li>\r	<li>丰富的第三方插件，有更多的选择；</li>\r	<li>完善Android开发技术体系；</li>\r	<li>提升自动化构建技术的深度；</li>\r	<li>进阶为高级工程师，获得薪资更高的Offer。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1950, 'DSL介绍', '1950', 1577849117, 1577849117, '<p>本文记录Java学习过程中遇到的DSL介绍～</p>\r<!--more-->\r\r<p>DSL语言全称为Domain Specific Language。</p>\r\r<p>常见的DSL语言：</p>\r\r<ul>\r	<li>XML；</li>\r	<li>Matlab；</li>\r	<li>groovy。</li>\r</ul>\r\r<p>特点：解决某一特定领域的问题，通用语言是要解决所有的问题。</p>\r\r<p>核心思想：求专不求全，解决特定问题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1951, 'Groovy介绍', '1951', 1577849826, 1577849826, '<p>本文记录Java学习过程中遇到的Groovy介绍～</p>\r<!--more-->\r\r<p>Groovy是一种基于JVM的敏捷开发语言，可以将Groovy编译为class字节码来让JVM执行，也支持解释执行；它结合了Python、Ruby和Smalltalk的许多强大的特性；它可以与Java完美结合，而且可以使用Java所有的库。</p>\r\r<p>Groovy特性：</p>\r\r<ul>\r	<li>语法上支持动态类型和闭包等新特性；</li>\r	<li>无缝集成所有已经存在的Java类库；</li>\r	<li>支持面向对象，也支持面向过程。</li>\r</ul>\r\r<p>Groovy优势：</p>\r\r<ul>\r	<li>一种更加敏捷的编程语言；</li>\r	<li>入门非常容易，但功能非常强大；</li>\r	<li>可以作为编程语言，也可以作为脚本语言；</li>\r	<li>掌握Java的基础很容易掌握Groovy。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1952, 'Groovy基础语法-变量', '1952', 1577889822, 1577889822, '<p>本文记录Java学习过程中遇到的Groovy基础语法-变量～</p>\r<!--more-->\r\r<p>变量的类型：</p>\r\r<ul>\r	<li>基本类型；</li>\r	<li>对象类型。</li>\r</ul>\r\r<p>注意：无论是定义基本类型，还是定义对象类型，最后都会被准换为对象类型。</p>\r\r<p>变量的定义：</p>\r\r<ul>\r	<li>强类型定义方式；</li>\r	<li>弱类型定义方式。</li>\r</ul>\r\r<p>注意：</p>\r\r<ol>\r	<li>如果变量只是自己当前类用，建议使用弱类型；</li>\r	<li>如果变量是给其他类使用的，建议使用强类型。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1953, 'Groovy基础语法-字符串', '1953', 1577894404, 1577894404, '<p>本文记录Java学习过程中遇到的Groovy基础语法-字符串～</p>\r<!--more-->\r\r<p>单引号、双引号与三引号的区别：</p>\r\r<ol>\r	<li>单引号需要自己定义转译类型，不能做到直接输出，与Java的String完全相同，不可更改；</li>\r	<li>双引号支持变量填充，也支持表达式运算；</li>\r	<li>三引号不需要自己定义转译类型，直接输入即可；</li>\r</ol>\r\r<p>字符串的方法：</p>\r\r<ul>\r	<li>java.lang.String；</li>\r	<li>DefaultGroovyMethods；</li>\r	<li>StringGroovyMethods（普通类型参数和闭包类型参数）。</li>\r</ul>\r\r<p>GString：</p>\r\r<ul>\r	<li>三种定义方式；</li>\r	<li>新增的操作符；</li>\r	<li>新增的API。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1954, 'Groovy基础语法-逻辑控制Switch', '1954', 1579586566, 1579586566, '<p>本文记录Java学习过程中遇到的Groovy基础语法-逻辑控制Switch～</p>\r<!--more-->\r\r<p>Groovy中的Switch与Java中的不同，它支持任意类型的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\rdef result=&#39;none&#39;\rdef x=&#39;string&#39;\rswitch (x.class) {\r    case &#39;foo&#39;:\r        result = &#39;found foo&#39;\r        break\r    case &#39;bar&#39;:\r        result = &#39;bar&#39;\r        break\r    case [1.23, 4, 5, 6, &#39;inlist&#39;]:\r        result = &#39;list&#39;\r        break\r    case 12..30:\r        result = &#39;range&#39;\r        break\r    case Integer:\r        result = &#39;integer&#39;\r        break\r    case BigDecimal:\r        result = &#39;big decimal&#39;\r        break\r    default:\r        result = &#39;default&#39;\r}\rprintln result</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1955, 'Groovy基础语法-逻辑控制For', '1955', 1579586918, 1579586918, '<p>本文记录Java学习过程中遇到的Groovy基础语法-逻辑控制For～</p>\r<!--more-->\r\r<p>Groovy中的for循环支持对范围、List和Map进行循环。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// 范围\rdef sum = 0\rfor (i in 0..9) {\r    sum += i\r}\rprintln sum\r\r// List\rsum = 0\rfor (i in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) {\r    sum += i\r}\rprintln sum\r\r// Map\rsum = 0\rfor (i in [&#39;lili&#39;: 1, &#39;luck&#39;: 2, &#39;xiaoming&#39;: 3]) {\r    sum += i.value\r}\rprintln sum</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1956, 'Groovy基础语法-闭包基础', '1956', 1579589220, 1579589296, '<p>本文记录Java学习过程中遇到的Groovy基础语法-闭包基础～</p>\r<!--more-->\r\r<p>Groovy中的闭包与Java中的方法很像，但也有很多不同。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\rdef clouser\r// 无参数\rclouser = {\r    println &quot;Hello Groovy!&quot;\r}\r// 通过call调用\rclouser.call()\r// 直接调用\rclouser()\r\r// 一个参数\rclouser = {\r    String name -&gt; println &quot;Hello ${name}!&quot;\r}\r// 通过call调用\rclouser.call(&quot;Groovy&quot;)\r// 直接调用\rclouser(&quot;Groovy&quot;)\r\r// 多个参数\rclouser = {\r    String name,int age -&gt; println &quot;Hello ${name}, my age is ${age}!&quot;\r}\r// 通过call调用\rclouser.call(&quot;Groovy&quot;, 18)\r// 直接调用\rclouser(&quot;Groovy&quot;, 18)\r\r// 默认参数\rclouser = {\r    println &quot;Hello ${it}!&quot;\r}\r// 通过call调用\rclouser.call(&quot;Groovy&quot;)\r// 直接调用\rclouser(&quot;Groovy&quot;)\r\r// 返回值为字符串\rclouser = {\r    return  &quot;Hello Groovy!&quot;\r}\r// 通过call调用\rprintln clouser.call()\r// 直接调用\rprintln clouser()\r\r// 返回值为null\rclouser = {\r    println  &quot;Hello Groovy!&quot;\r}\r// 通过call调用\rprintln clouser.call()\r// 直接调用\rprintln clouser()</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1957, 'Groovy基础语法-闭包使用', '1957', 1579590143, 1579590143, '<p>本文记录Java学习过程中遇到的Groovy基础语法-闭包使用～</p>\r<!--more-->\r\r<p>Groovy中的闭包与Java中的方法很像，但也有很多不同。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\rint x=5\r\r// 求阶乘-upto()方法\rint fab1(int number) {\r    int result = 1\r    result.upto(number, {num -&gt; result *= num})\r    return result\r}\rprintln fab1(x)\r\r// 求阶乘-downto()方法\rint fab2(int number) {\r    int result = 1\r    number.downto(1) {\r        num -&gt; result *= num\r    }\r    return result\r}\rprintln fab2(x)\r\rint cal(int number) {\r    int result = 0\r    number.times {\r        num -&gt; result += num\r    }\r    return result\r}\rprintln cal(x)</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1958, 'Groovy基础语法-闭包与String结合使用', '1958', 1579593766, 1579593766, '<p>本文记录Java学习过程中遇到的Groovy基础语法-闭包与String结合使用～</p>\r<!--more-->\r\r<p>Groovy中的闭包与Java中的方法很像，但也有很多不同。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// 字符串与闭包结合使用\rString str = &#39;the 2 and 3 is 5&#39;\r\r// each\rprintln str.each {\r    String temp -&gt; println temp.multiply(2)\r}\r\r// find\rprintln str.find {\r    String s -&gt; s.isNumber()\r}\r\r// findAll\rprintln str.findAll {\r    String s -&gt; s.isNumber()\r}\r\r// any\rprintln str.any {\r    String s -&gt; s.isNumber()\r}\r\r// every\rprintln str.every {\r    String s -&gt; s.isNumber()\r}\r\r// collect\rprintln str.collect {\r    it.toUpperCase()\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1959, 'Groovy基础语法-闭包的委托策略', '1959', 1579598997, 1579598997, '<p>本文记录Java学习过程中遇到的Groovy基础语法-闭包的委托策略～</p>\r<!--more-->\r\r<p>闭包有三个重要变量：this，owner和delegate：</p>\r\r<ul>\r	<li>this：代表闭包定义处的类；</li>\r	<li>owner：代表闭包定义处的类或者对象；</li>\r	<li>delegate：代表任意对象，默认与owner一致。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\rclouser = {\r    println this\r    println owner\r    println delegate\r}\r// 都是当前脚本的对象\rclouser()\r\r// 类内部静态闭包\rclass Boy {\r\r    def static clouser = {\r        println this\r        println owner\r        println delegate\r    }\r\r    def static say() {\r        def clouser = {\r            println this\r            println owner\r            println delegate\r        }\r        clouser.call()\r    }\r\r}\rBoy.clouser()\rBoy.say()\r\r// 类内部动态闭包\rclass Girl {\r\r    def clouser = {\r        println this\r        println owner\r        println delegate\r    }\r\r    def say() {\r        def clouser = {\r            println this\r            println owner\r            println delegate\r        }\r        clouser.call()\r    }\r\r}\rGirl girl = new Girl();\rgirl.clouser()\rgirl.say()\r\r// 在闭包中定义闭包\rdef outerClouser = {\r    def innerClouser = {\r        println this\r        println owner\r        println delegate\r    }\r    innerClouser.delegate = girl\r    innerClouser()\r}\routerClouser()</pre>\r\r<p>闭包委托策略。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\rclass Student {\r    String name\r    def pretty = {\r        &quot;My name is ${name}&quot;\r    }\r    String toString() {\r        pretty.call()\r    }\r}\r\rclass Teacher {\r    String name;\r}\r\rdef student = new Student(name: &#39;Oliver&#39;)\rdef teacher = new Teacher(name: &#39;Cathy&#39;)\rprintln student.toString()\rstudent.pretty.delegate = teacher\r// 修改委托策略\r// DELEGATE_FIRST：先从delegate的对象中寻找\r// DELEGATE_ONLY：只从delegate的对象中寻找\rstudent.pretty.resolveStrategy = groovy.lang.Closure.DELEGATE_FIRST\rprintln student.toString()</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1960, 'Groovy基础语法-列表', '1960', 1579604936, 1579604936, '<p>本文记录Java学习过程中遇到的Groovy基础语法-列表～</p>\r<!--more-->\r\r<p>Groovy中的List与Java中数组的定义方式相同，底层实现默认是ArrarList。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// 数组的定义\rdef array1 = [1, 2, 3, 4, 5] as int[]\rint[] array2 = [1, 2, 3, 4, 5]\r\r// List的定义\rdef list1 = []\rprintln list1.class\rdef list2 = [1, 2, 3, 4, 5]\rprintln list2.size()\r\r// List的排序\rdef list3 = [6, -3, 9, 2, -7, 1, 5]\r\r// 默认规则\rCollections.sort(list3)\rlist3.sort()\rprintln list3\r\r// 自定义规则\rComparator comparator = {\r    a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : 1\r}\rCollections.sort(list3, comparator)\rlist3.sort(comparator)\rprintln list3\r\r// 通过闭包传递排序规则\rlist3.sort {\r    a, b -&gt; a == b ? 0 : Math.abs(a) &gt; Math.abs(b) ? -1 : 1\r}\rprintln list3\r\rdef list4 = [&#39;abc&#39;, &#39;z&#39;, &#39;Hello&#39;, &#39;groovy&#39;, &#39;java&#39;]\rlist4.sort {\r    it -&gt; return it.size()\r}\rprintln list4\r\r// List的查找\rdef list5 = [-3, 9, 6, 2, -7, 1, 5]\r\r// find\rprintln list5.find { return it % 2 == 0 }\r\r// findAll\rprintln list5.findAll { return it % 2 != 0 }\r\r// any\rprintln list5.any { return it % 2 != 0 }\r\r// every\rprintln list5.every { return it % 2 == 0 }\r\r// min\rprintln list5.min { return Math.abs(it) }\r\r// max\rprintln list5.max { return Math.abs(it) }\r\r// count\rprintln list5.count { return it % 2 == 0 }\r\r// List的添加\rlist5.add(6)\rprintln list5\rlist5.leftShift(7)\rprintln list5\rlist5 = list5 + 9\rprintln list5\r\r// list的删除\rlist5.remove(7)\rprintln list5\rlist5.remove((Object) 7)\rprintln list5\rlist5.removeAt(7)\rprintln list5\rlist5.removeElement(7)\rprintln list5\rlist5.removeAll { return it % 2 == 0 }\rprintln list5\rlist5 = list5 - [1, 3]\rprintln list5</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1961, 'Groovy基础语法-映射', '1961', 1579607454, 1579607454, '<p>本文记录Java学习过程中遇到的Groovy基础语法-映射～</p>\r<!--more-->\r\r<p>Groovy中的List与Java中Map的定义方式类似，底层实现默认是LinkedHashMap。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// Map的定义\rdef colors = [red  : &#39;ff0000&#39;, green: &#39;00ff00&#39;, blue : &#39;0000ff&#39;]\rprintln colors\rprintln colors.getClass()\r\r// Map的获取\rprintln colors[&#39;red&#39;]\rprintln colors.green\r\r// Map的添加\rcolors.yellow = &#39;ffff00&#39;\rprintln colors\rcolors.complex = [a: 1, b: 2]\rprintln colors\r\r// Map的操作\rdef students = [\r        1: [\r                number: &#39;0001&#39;,\r                name: &#39;Bob&#39;,\r                score : 55,\r                sex: &#39;male&#39;\r        ],\r        2: [\r                number: &#39;0002&#39;,\r                name: &#39;Johnny&#39;,\r                score : 62,\r                sex: &#39;female&#39;\r        ],\r        3: [\r                number: &#39;0003&#39;,\r                name: &#39;Claire&#39;,\r                score : 73,\r                sex: &#39;female&#39;\r        ],\r        4: [\r                number: &#39;0004&#39;,\r                name: &#39;Amy&#39;,\r                score : 66,\r                sex: &#39;male&#39;\r        ]\r]\r\r// each\rstudents.each {\r    def student -&gt; println &quot;the key is ${student.key}, the value is ${student.value}&quot;\r}\r\r// eachWithIndex\rstudents.eachWithIndex {\r    def student, int index -&gt; println &quot;the index is ${index}, the key is ${student.key}, the value is ${student.value}&quot;\r}\r\r// each\rstudents.each {\r    key, value -&gt; println &quot;the key is ${key}, the value is ${value}&quot;\r}\r\r// eachWithIndex\rstudents.eachWithIndex {\r    key, value, index -&gt; println &quot;the index is ${index}, the key is ${key}, the value is ${value}&quot;\r}\r\r// Map的查找\r\r// find\rprintln students.find { def student -&gt; student.value.score &gt;= 60 }\r\r// findAll\rprintln students.findAll { def student -&gt; student.value.score &gt;= 60 }\r\r// count\rprintln students.count { def student -&gt; student.value.score &gt;= 60 &amp;&amp; student.value.sex == &#39;male&#39; }\r\r// collect\rprintln students.findAll { def student -&gt; student.value.score &gt;= 60 }.collect { return it.value.name }\r\r// groupBy\rprintln students.groupBy { def student -&gt; return student.value.score &gt;= 60 ? &#39;及格&#39; : &#39;不及格&#39; }\r\r// Map的排序\r\r// sort\rprintln students.sort {\r    def student1, def student2 -&gt;\r        Number score1 = student1.value.score\r        Number score2 = student2.value.score\r        return score1 == score2 ? 0 : score1 &lt; score2 ? -1 : 1\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1962, 'Groovy基础语法-范围', '1962', 1579608352, 1579608352, '<p>本文记录Java学习过程中遇到的Groovy基础语法-范围～</p>\r<!--more-->\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// Range的定义\rdef range = 1..10\rprintln range\rprintln range.class\r\r// Range的获取\rprintln range[0]\rprintln range.contains(10)\r// 起始值\rprintln range.from\rprintln range.to\r\r// Range的操作与List一样\r\r// Range的遍历\r\r// each\rrange.each {\r    println it\r}\r\r// for\rfor (i in range) {\r    println i\r}\r\r// switch\rdef getGrade(Number number) {\r    def result\r    switch (number) {\r        case 0..&lt;60:\r            result = &#39;不及格&#39;\r            break\r        case 60..&lt;70:\r            result = &#39;及格&#39;\r            break\r        case 70..&lt;80:\r            result = &#39;良好&#39;\r            break\r        case 80..100:\r            result = &#39;优秀&#39;\r            break\r    }\r    return result\r}\rprintln getGrade(60)</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1963, 'Groovy面向对象-基础定义', '1963', 1580047462, 1580047462, '<p>本文记录Java学习过程中遇到的Groovy面向对象-基础定义～</p>\r<!--more-->\r\r<p>Groovy与Java类似，也是支持面向对象的。</p>\r\r<p>Groovy与Java不同的是：所有值和方法都是public的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// Groovy中默认都是public的\rclass Person implements Serializable {\r\r    String name\r\r    Integer age\r\r    def increaseAge(Integer years) {\r        this.age += years\r    }\r\r    // 方法丢失的时候先调用\r    def methodMissing(String name, Object args) {\r        return &quot;the method is missing&quot;\r    }\r\r    // 方法找不到的时候用它替代\r    def invokeMethod(String name, Object args) {\r        return &quot;the method is ${name}, the params is ${args}&quot;\r    }\r\r}\r\rdef person = new Person(name: &quot;oliver&quot;, age: 18)\r// 无论是直接.还是调用set/get方法，最终都是调用set/get\rprintln &quot;the name is ${person.name}, the age is ${person.age}&quot;\rperson.increaseAge(2)\rprintln &quot;the name is ${person.name}, the age is ${person.age}&quot;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1964, 'Groovy面向对象-接口', '1964', 1580047777, 1580047777, '<p>本文记录Java学习过程中遇到的Groovy面向对象-接口～</p>\r<!--more-->\r\r<p>Groovy与Java类似，也是支持面向对象的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// 接口中不允许定义非public的方法\rinterface Action {\r    void eat()\r\r    void drink()\r\r    void play()\r}\r\r// Groovy中默认都是public的\rclass Person implements Action {\r\r    String name\r\r    Integer age\r\r    def increaseAge(Integer years) {\r        this.age += years\r    }\r\r    // 方法丢失的时候先调用\r    def methodMissing(String name, Object args) {\r        return &quot;the method is missing&quot;\r    }\r\r    // 方法找不到的时候用它替代\r    def invokeMethod(String name, Object args) {\r        return &quot;the method is ${name}, the params is ${args}&quot;\r    }\r\r    @Override\r    void eat() {\r\r    }\r\r    @Override\r    void drink() {\r\r    }\r\r    @Override\r    void play() {\r\r    }\r    \r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1965, 'Groovy面向对象-Trait', '1965', 1580047915, 1580047915, '<p>本文记录Java学习过程中遇到的Groovy面向对象-Trait～</p>\r<!--more-->\r\r<p>Groovy与Java类似，也是支持面向对象的。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// 可以给某些方法提供些默认的实现\rtrait DefaultAction {\r\r    abstract void eat()\r\r    void play() {\r        println &#39;I can play&#39;\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1966, 'Groovy面向对象-方法调用', '1966', 1580048520, 1580048619, '<p>本文记录Java学习过程中遇到的Groovy面向对象-方法调用～</p>\r<!--more-->\r\r<p>Groovy的类的方法调用流程图如下：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/01/155022033.png" style="width: 800px; height: 453px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\rclass Person implements Serializable {\r\r    String name\r\r    Integer age\r\r    def increaseAge(Integer years) {\r        this.age += years\r    }\r\r    // 方法丢失的时候先调用\r    def methodMissing(String name, Object args) {\r        return &quot;the method is missing&quot;\r    }\r\r    // 方法找不到的时候用它替代\r    def invokeMethod(String name, Object args) {\r        return &quot;the method is ${name}, the params is ${args}&quot;\r    }\r\r}\r\rdef person = new Person(name: &quot;oliver&quot;, age: 18)\rprintln person.cry()</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1967, 'Groovy的方法调用流程图.png', 'Groovy的方法调用流程图-png', 1580048594, 1580048594, 'a:5:{s:4:"name";s:34:"Groovy的方法调用流程图.png";s:4:"path";s:34:"/usr/uploads/2020/01/155022033.png";s:4:"size";i:130070;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1966, 0),
(1968, 'Groovy面向对象-metaClass', '1968', 1580048997, 1580048997, '<p>本文记录Java学习过程中遇到的Groovy面向对象-metaClass～</p>\r<!--more-->\r\r<p>Groovy支持通过metaClass向类中动态的添加属性和方法。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\rclass Person implements Serializable {\r\r    String name\r\r    Integer age\r\r    def increaseAge(Integer years) {\r        this.age += years\r    }\r\r    // 方法丢失的时候先调用\r    def methodMissing(String name, Object args) {\r        return &quot;the method is missing&quot;\r    }\r\r    // 方法找不到的时候用它替代\r    def invokeMethod(String name, Object args) {\r        return &quot;the method is ${name}, the params is ${args}&quot;\r    }\r\r}\r\rdef person = new Person(name: &quot;oliver&quot;, age: 18)\r\r// 为类动态的添加一个属性\rPerson.metaClass.sex = &#39;male&#39;\rperson = new Person(name: &quot;oliver&quot;, age: 18)\rprintln person.sex\rperson.sex = &#39;female&#39;\rprintln person.sex\r\r// 为类动态的添加一个动态方法\rPerson.metaClass.sexUpperCase = {\r    -&gt; sex.toUpperCase()\r}\rperson = new Person(name: &quot;oliver&quot;, age: 18)\rprintln person.sexUpperCase()\r\r// 为类动态的添加一个静态方法\rPerson.metaClass.static.createPerson = {\r    String name, Integer age -&gt;\r        new Person(name: name, age: age)\r}\rperson = Person.createPerson(&#39;cathy&#39;, 18)\rprintln &quot;the name is ${person.name}, the age is ${person.age}&quot;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1969, 'Groovy面向对象-metaClass扩展', '1969', 1580050324, 1580050324, '<p>本文记录Java学习过程中遇到的Groovy面向对象-metaClass扩展～</p>\r<!--more-->\r\r<p>Groovy支持通过metaClass向类中动态的添加属性和方法，这里演示如何将添加的属性和方法设置为全局生效。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\r// Groovy中默认都是public的\rclass Person implements Serializable {\r\r    String name\r\r    Integer age\r\r    def increaseAge(Integer years) {\r        this.age += years\r    }\r\r    // 方法丢失的时候先调用\r    def methodMissing(String name, Object args) {\r        return &quot;the method is missing&quot;\r    }\r\r    // 方法找不到的时候用它替代\r    def invokeMethod(String name, Object args) {\r        return &quot;the method is ${name}, the params is ${args}&quot;\r    }\r\r}\r\r// Person的管理器\rclass PersonManager {\r\r    static Person createPerson(String name, Integer age) {\r        return Person.createPerson(name, age)\r    }\r\r}\r\r// 应用的管理器\rclass ApplicationManager {\r\r    static void init() {\r        ExpandoMetaClass.enableGlobally()\r        // 为Person类添加方法\r        Person.metaClass.static.createPerson = {\r            String name, Integer age -&gt;\r                new Person(name: name, age: age)\r        }\r    }\r\r}\r\r// 应用的入口类\rclass Entry {\r\r    static void main(def args) {\r        // 应用启动\r        println &#39;正在启动...&#39;\r\r        // 应用初始化\r        println &#39;初始化开始...&#39;\r        ApplicationManager.init()\r        println &#39;初始化完成...&#39;\r\r        // 创建Person\r        def person = PersonManager.createPerson(&#39;oliver&#39;, 18)\r        println &quot;the name is ${person.name}, the age is ${person.age}&quot;\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1970, 'Groovy高级语法-JSON操作', '1970', 1580188285, 1580188285, '<p>本文记录Java学习过程中遇到的Groovy高级语法-JSON操作～</p>\r<!--more-->\r\r<p>一共包含两部分：</p>\r\r<ol>\r	<li>将json字符串转化为实体对象；</li>\r	<li>将实体对象转化为json字符串。</li>\r</ol>\r\r<p>示例代码（将实体对象转化为json字符串）：</p>\r\r<pre class="brush:groovy;">\rdef list = [\r        new Person(name: &#39;oliver&#39;, age: 18),\r        new Person(name: &#39;cathy&#39;, age: 18)\r]\rdef json\r\r// 输出json字符串\rprintln json=JsonOutput.toJson(list)\r// 优化输出格式\rprintln JsonOutput.prettyPrint(json)</pre>\r\r<p>示例代码（将json字符串转化为实体对象）：</p>\r\r<pre class="brush:groovy;">\rdef slurper = new JsonSlurper()\r// 将json字符串转化为对象\rlist = slurper.parseText(json)\rprintln list\r// 将其他类型的数据转化为对象\rlist = slurper.parse(json.getBytes())\rprintln list\r\r// 从网络上获取数据\rdef getNetworkData(String url) {\r    // 发送http请求\r    def connection = new URL(url).openConnection()\r    connection.setRequestMethod(&#39;GET&#39;)\r    connection.connect()\r    def response = connection.content.text\r    // 将json转化为实体对象\r    def jsonSluper = new JsonSlurper()\r    return jsonSluper.parseText(response)\r}\r\r// 输出获取到的数据\rprintln getNetworkData(&#39;https://www.baidu.com/home/xman/data/tipspluslist&#39;).data</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1971, 'Groovy高级语法-XML操作', '1971', 1580189400, 1580189400, '<p>本文记录Java学习过程中遇到的Groovy高级语法-XML操作～</p>\r<!--more-->\r\r<p>一共包含两部分：</p>\r\r<ol>\r	<li>将xml字符串转化为实体对象；</li>\r	<li>将实体对象转化为xml字符串。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;">\rimport groovy.xml.MarkupBuilder\r\rfinal String xml = &#39;&#39;&#39;\r&lt;response version-api=&quot;2.0&quot;&gt;\r    &lt;value&gt;\r        &lt;books id=&quot;1&quot; classification=&quot;android&quot;&gt;\r            &lt;book available=&quot;20&quot; id=&quot;1&quot;&gt;\r                &lt;title&gt;疯狂Android讲义&lt;/title&gt;\r                &lt;author id=&quot;1&quot;&gt;李刚&lt;/author&gt;\r            &lt;/book&gt;\r            &lt;book available=&quot;14&quot; id=&quot;2&quot;&gt;\r               &lt;title&gt;第一行代码&lt;/title&gt;\r               &lt;author id=&quot;2&quot;&gt;郭林&lt;/author&gt;\r           &lt;/book&gt;\r           &lt;book available=&quot;13&quot; id=&quot;3&quot;&gt;\r               &lt;title&gt;Android开发艺术探索&lt;/title&gt;\r               &lt;author id=&quot;3&quot;&gt;任玉刚&lt;/author&gt;\r           &lt;/book&gt;\r           &lt;book available=&quot;5&quot; id=&quot;4&quot;&gt;\r               &lt;title&gt;Android源码设计模式&lt;/title&gt;\r               &lt;author id=&quot;4&quot;&gt;何红辉&lt;/author&gt;\r           &lt;/book&gt;\r       &lt;/books&gt;\r       &lt;books id=&quot;2&quot; classification=&quot;web&quot;&gt;\r           &lt;book available=&quot;10&quot; id=&quot;1&quot;&gt;\r               &lt;title&gt;Vue从入门到精通&lt;/title&gt;\r               &lt;author id=&quot;4&quot;&gt;李刚&lt;/author&gt;\r           &lt;/book&gt;\r       &lt;/books&gt;\r   &lt;/value&gt;\r&lt;/response&gt;\r&#39;&#39;&#39;\rprintln xml\r\r// 解析XML文档\rdef xmlSluper = new XmlSlurper()\rdef response = xmlSluper.parseText(xml)\r\r// 输出解析后的结果\rprintln response.value.books[0].book[0].title.text()\r// 数据节点的属性值\rprintln response.value.books[1].book[0].@available\r\r// 遍历查找想要的数据-常规遍历\rdef list = []\rresponse.value.books.each { books -&gt;\r    //下面开始对书结点进行遍历\r    books.book.each { book -&gt;\r        def author = book.author.text()\r        if (author.equals(&#39;李刚&#39;)) {\r            list.add(book.title.text())\r        }\r    }\r}\rprintln list\r\r// 遍历查找想要的数据-深度遍历\rlist = response.depthFirst().findAll { book -&gt;\r    return book.author.text() == &#39;李刚&#39; ? true : false\r}\rprintln list\r\r// 遍历查找想要的数据-广度遍历\rdef name = response.value.books.children().findAll { node -&gt;\r    node.name() == &#39;book&#39; &amp;&amp; node.@id == &#39;2&#39;\r}.collect { node -&gt;\r    return node.title.text()\r}\rprintln name\r\r// 生成XML格式数据的两种方式\r/*\r&lt;langs type=&#39;current&#39; count=&#39;3&#39; mainstream=&#39;true&#39;&gt;\r &lt;language flavor=&#39;static&#39; version=&#39;1.5&#39;&gt;Java&lt;/language&gt;\r &lt;language flavor=&#39;dynamic&#39; version=&#39;1.6&#39;&gt;Groovy&lt;/language&gt;\r &lt;language flavor=&#39;dynamic&#39; version=&#39;1.9&#39;&gt;JavaScript&lt;/language&gt;\r&lt;/langs&gt;\r*/\rdef sw = new StringWriter()\rdef xmlBuilder = new MarkupBuilder(sw)\rxmlBuilder.langs(type: &#39;current&#39;, count: &#39;3&#39;, mainstream: &#39;true&#39;) {\r    language(flavor: &#39;static&#39;, version: &#39;1.5&#39;, &#39;Java&#39;)\r    language(flavor: &#39;dynamic&#39;, version: &#39;1.6&#39;, &#39;Groovy&#39;)\r    language(flavor: &#39;dynamic&#39;, version: &#39;1.9&#39;, &#39;JavaScript&#39;)\r}\rprintln sw\r\rclass Language {\r    String flavor\r    String version\r    String value\r}\r\rclass Langs {\r    String type = &#39;current&#39;\r    int count = 3\r    boolean mainstream = true\r    def languages = [\r            new Language(flavor: &#39;static&#39;, version: &#39;1.5&#39;, value: &#39;Java&#39;),\r            new Language(flavor: &#39;dynamic&#39;, version: &#39;1.6&#39;, value: &#39;Groovy&#39;),\r            new Language(flavor: &#39;dynamic&#39;, version: &#39;1.9&#39;, value: &#39;JavaScript&#39;)\r    ]\r}\r\rsw = new StringWriter()\rxmlBuilder = new MarkupBuilder(sw)\rdef langs = new Langs()\rxmlBuilder.langs(type: langs.type, count: langs.count, mainstream: langs.mainstream) {\r    langs.languages.each { lang -&gt;\r        language(flavor: lang.flavor, version: lang.version, lang.value)\r    }\r}\rprintln sw</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1972, 'Groovy高级语法-文件操作', '1972', 1580210123, 1580210123, '<p>本文记录Java学习过程中遇到的Groovy高级语法-文件操作～</p>\r<!--more-->\r\r<p>示例代码：</p>\r\r<pre class="brush:groovy;ruler:true;">\rimport objectorention.Person\r\rdef file = new File(&#39;../../.idea/Groovy.iml&#39;)\r\r// 逐行读取文件\rfile.eachLine { line -&gt;\r    println line\r}\r\r// 读取全部内容-要换行\rdef text = file.getText()\rprintln text\r\r// 读取全部内容-不换行\rdef result = file.readLines()\rprintln result\r\r// 读取部分内容\rdef reader = file.withReader { reader -&gt;\r    char[] buffer = new char[100]\r    reader.read(buffer)\r    return buffer\r}\rprintln reader\r\r// 拷贝文件\rdef copy(String sourcePath, String destationPath) {\r    try {\r        def desFile = new File(destationPath)\r        if (!desFile.exists()) {\r            desFile.createNewFile()\r        }\r        new File(sourcePath).withReader { reader -&gt;\r            def lines = reader.readLines()\r            desFile.withWriter { writer -&gt;\r                lines.each { line -&gt;\r                    writer.append(line + &quot;\\r\\n&quot;)\r                }\r            }\r        }\r        return true\r    } catch (Exception e) {\r        e.printStackTrace()\r    }\r    return false\r}\rprintln copy(&#39;../../.idea/Groovy.iml&#39;, &#39;/tmp/Groovy.iml&#39;)\r\r// 序列化\rdef saveObject(Object object, String path) {\r    try {\r        def desFile = new File(path)\r        if (!desFile.exists()) {\r            desFile.createNewFile()\r        }\r        desFile.withObjectOutputStream { out -&gt;\r            out.writeObject(object)\r        }\r        return true\r    } catch (Exception e) {\r    }\r    return false\r}\r\r// 反序列化\rdef readObject(String path) {\r    def obj = null\r    try {\r        def file = new File(path)\r        if (file == null || !file.exists()) return null\r        file.withObjectInputStream { input -&gt;\r            obj = input.readObject()\r        }\r    } catch (Exception e) {\r\r    }\r    return obj\r}\r\r// 序列化测试\rdef person = new Person(name: &#39;Oliver King&#39;, age: 18)\rsaveObject(person, &#39;/tmp/person.bin&#39;)\rperson = (Person) readObject(&#39;/tmp/person.bin&#39;)\rprintln &quot;the name is ${person.name} and the age is ${person.age}&quot;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1973, 'Gradle基本概念', '1973', 1580221106, 1580221106, '<p>本文记录Java学习过程中遇到的Gradle基本概念～</p>\r<!--more-->\r\r<p>Gradle是用来做项目构建的，与Maven和Ant类似，但他不仅仅是一个构建工具，可以将Gradle看做一种编程框架。</p>\r\r<p>Gradle主要包括：</p>\r\r<ul>\r	<li>Groovy核心语法；</li>\r	<li>build script block；</li>\r	<li>Gradle API。</li>\r</ul>\r\r<p>Gradle的优势：</p>\r\r<ul>\r	<li>更加灵活，可以自定义构建过程；</li>\r	<li>粒度性上，资源与代码独立，无耦合；</li>\r	<li>扩展性好，支持插件机制，复用灵活；</li>\r	<li>兼用型好，兼用所有Ant与Mave的功能。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1975, 'Gradle的Java执行流程图.png', 'Gradle的Java执行流程图-png', 1580968933, 1580968933, 'a:5:{s:4:"name";s:32:"Gradle的Java执行流程图.png";s:4:"path";s:34:"/usr/uploads/2020/02/562039290.png";s:4:"size";i:150282;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1976, 0),
(1976, 'Gradle生命周期监听', '1976', 1580968948, 1580968948, '<p>本文记录Java学习过程中遇到的Gradle生命周期监听～</p>\r<!--more-->\r\r<p>Gradle生命周期监听的主要方法有：</p>\r\r<ul>\r	<li>this.beforeEvalute {}：配置阶段开始以前的监听回调；</li>\r	<li>this.afterEvalute {}：配置阶段完成以后的监听回调；</li>\r	<li>this.gradle.buildFinished {}：Gradle执行完毕以后的监听回调；</li>\r	<li>this.gradle.beforeProject {}：等同于this.beforeEvalute {}；</li>\r	<li>this.gradle.afterProject {}：等同于this.afterEvalute {}。</li>\r</ul>\r\r<p>注意：初始化阶段执行的是settings.gradle文件。</p>\r\r<p>Gradle的Java执行流程图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/02/562039290.png" style="width: 800px; height: 187px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1977, 'Gradle的Project概述', '1977', 1580969660, 1580969660, '<p>本文记录Java学习过程中遇到的Gradle的Project概述～</p>\r<!--more-->\r\r<p>任何一个有build.gradle文件的目录都是一个Project，包括IDEA中的每个Module。</p>\r\r<p>Gradle是以树的结构管理Project的，有父子关系。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1978, 'Gradle中Project相关API', '1978', 1581083704, 1581083704, '<p>本文记录Java学习过程中遇到的Gradle中Project相关API～</p>\r<!--more-->\r\r<p>Project常用的API有：</p>\r\r<ul>\r	<li>this.getAllprojects()：获取所有的Project；</li>\r	<li>this.getSubprojects()：获取当前Project的所有子Project；</li>\r	<li>this.getParentProject()：获取当前Project的父Project；</li>\r	<li>this.getRootProject()：获取当前Project的根Project。</li>\r</ul>\r\r<p>Project其他的API有：</p>\r\r<p>1.操作单个project</p>\r\r<pre class="brush:java;">\rproject(&#39;project-name&#39;) { Project project -&gt;\r	// 这里是对project要进行的操作\r	apply plugin: &#39;com.android.application&#39;\r	group &#39;ren.oliver.gradle&#39;\r	version &#39;1.0.0&#39;\r\r	dependencies {\r\r	}\r\r	android {\r\r	}\r}</pre>\r\r<p>2.操作所有Project</p>\r\r<pre class="brush:java;">\rallprojects {\r	// 对所有的Project进行配置\r	group &#39;ren.oliver.gradle&#39;\r	version &#39;1.0.0&#39;\r}</pre>\r\r<p>3.操作所有子Project</p>\r\r<pre class="brush:java;">\rsubprojects {\r	// 对所有子Project进行配置\r	group &#39;ren.oliver.gradle&#39;\r	version &#39;1.0.0&#39;\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1979, 'Gradle中属性相关API', '1979', 1582369767, 1582369767, '<p>本文记录Java学习过程中遇到的Gradle中属性相关API～</p>\r<!--more-->\r\r<p>常用的默认属性有：</p>\r\r<ul>\r	<li>DEFAULT_BUILD_FILE：默认构建配置文件；</li>\r	<li>PATH_SEPARATOR：路径分隔符；</li>\r	<li>DEFAULT_BUILD_DIR_NAME：默认输出文件夹。</li>\r</ul>\r\r<p>定义扩展类型属性-代码区块：</p>\r\r<pre class="brush:java;">\rext {\r	key = value\r}</pre>\r\r<pre class="brush:java;">\r// 使用扩展属性\rthis.key\rthis.rootProject.key</pre>\r\r<p>注意：所有父工程定义的属性都会被子工程继承。</p>\r\r<p>定义扩展类型属性-配置文件（gradle.properties）：</p>\r\r<pre class="brush:java;">\rkey=value</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1980, 'Gradle中文件相关API', '1980', 1582371840, 1582371868, '<p>本文记录Java学习过程中遇到的Gradle中文件相关API～</p>\r<!--more-->\r\r<p>路径获取相关API：</p>\r\r<ul>\r	<li>getRootDir()：获取根工程文件路径；</li>\r	<li>getBuildDir()：获取产出文件路径；</li>\r	<li>getProjectDir()：获取当前工程文件路径；</li>\r	<li>file(&quot;filename&quot;)：获取当前工程相对路径的文件（能找到则返回文件对象，否则报文件找不到的异常）；</li>\r	<li>files(&quot;filename&quot;...)：一个或多个文件。</li>\r</ul>\r\r<p>文件操作相关API：</p>\r\r<p>1.拷贝：</p>\r\r<pre class="brush:java;">\rcopy {\r	from file(&quot;form&quot;)\r	into getBuildDir()\r	exclude {\r		// 排除不需要拷贝的\r	}\r	rename {\r		// 重命名\r	}\r}</pre>\r\r<p>2.文件树：</p>\r\r<pre class="brush:java;">\rfileTree(&quot;dirname&quot;) { FileTree fileTree -&gt;\r	fileTree.visit { FileTreeElement fileTreeElement -&gt;\r		println fileTreeElement.file.name\r	}\r}</pre>\r\r<p>3.删除文件：</p>\r\r<pre class="brush:java;">\rdelete(&quot;filename&quot;)</pre>\r\r<p>4.创建文件夹：</p>\r\r<pre class="brush:java;">\rmkdir(&quot;dirname&quot;)</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1981, 'Gradle中依赖相关API', '1981', 1582373880, 1583666080, '<p>本文记录Java学习过程中遇到的Gradle中依赖相关API～</p>\r<!--more-->\r\r<p>依赖配置：</p>\r\r<pre class="brush:java;">\rbuildScript { ScriptHandler scriptHandler -&gt;\r	// 配置工程的仓库地址\r	scriptHandler.repositories { RepositoryHandler repositoryHandler -&gt;\r		repositoryHandler.jcenter()\r		repositoryHandler.mavenCenter()\r		repositoryHandler.mavenLocal()\r		repositoryHandler.maven {\r			name &#39;oliver-repository&#39;\r			url &#39;http://maven.olive.ren/&#39;\r			credentials {\r				username = &#39;oliver&#39;\r				password = &#39;password&#39;\r			}\r		}\r	}\r	// 配置工程的插件依赖地址\r	scriptHandler.dependencies {\r		// 引入方式 插件名称\r	}\r}\r\rdependencies {\r	// 依赖方式 依赖名称\r	compile(&quot;依赖&quot;) {\r		exclude 要排除的依赖\r		// 传递依赖，默认false\r		transitive true/false\r		// 每次都从服务端拉取\r		changing = true\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1982, 'Gradle中外部命令API', '1982', 1582374486, 1582374486, '<p>本文记录Java学习过程中遇到的Gradle中外部命令API～</p>\r<!--more-->\r\r<p>外部命令的使用：</p>\r\r<pre class="brush:java;">\rtask(&#39;taskname&#39;) {\r	doLast {\r		def sourcePath = &#39;sourcePath&#39;\r		def targetPath = &#39;targetPath&#39;\r		def command = &quot;mv -f ${sourcePath} ${targetPath}&quot;\r		exec {\r			try {\r				executable &#39;bash&#39;\r				args &#39;-c&#39;, command\r				println &#39;success&#39;\r			} catch (Exception e) {\r				println &#39;fale&#39;\r			}\r		}\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1983, 'Gradle中Task执行', '1983', 1582382239, 1582382239, '<p>本文记录Java学习过程中遇到的Gradle中Task执行～</p>\r<!--more-->\r\r<p>Task执行相关配置：</p>\r\r<pre class="brush:java;">\rtask taskname {\r	doFirst {\r		// 在挂接的任务之前执行，可以多次调用\r	}\r	doLast {\r		// 在挂接的任务之后执行，可以多次调用\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1984, 'Gradle中Task执行顺序', '1984', 1582429610, 1582429610, '<p>本文记录Java学习过程中遇到的Gradle中Task执行顺序～</p>\r<!--more-->\r\r<p>Task执行顺序配置方式有：</p>\r\r<p>1.dependsOn强依赖：</p>\r\r<pre class="brush:java;">\rtask A {\r	\r}\r\rtask B(dependsOn: [A]) {\r	\r}\r\rB.dependsOn(A)</pre>\r\r<p>2.输入输出：</p>\r\r<pre class="brush:java;">\rtask A {\r	output.files this.destfiles\r}\r\rtask B {\r	input.files this.destfiles\r}</pre>\r\r<p>3.mustRunAfter/shouldRunAfter</p>\r\r<pre class="brush:java;">\rtask A {\r}\r\rtask B {\r	mustRunAfter A\r	shouldRunAfter A\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(1985, 'Gradle中Task类型', '1985', 1582430872, 1582430872, '<p>本文记录Java学习过程中遇到的Gradle中Task类型～</p>\r<!--more-->\r\r<p>常见的Task类型有：</p>\r\r<ul>\r	<li>DefaultTask：默认task类型；</li>\r	<li>Delete：删除类型；</li>\r	<li>Copy：复制类型；</li>\r	<li>Zip：压缩类型。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1986, 'Gradle中Settings类', '1986', 1582431390, 1582431390, '<p>本文记录Java学习过程中遇到的Gradle中Settings类～</p>\r<!--more-->\r\r<p>Settings类对应的就是settings.gradle文件，Gradle在配置阶段就是执行的这个类的代码。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1987, 'Gradle中SourceSet类', '1987', 1582432382, 1582432382, '<p>本文记录Java学习过程中遇到的Gradle中SourceSet类～</p>\r<!--more-->\r\r<p>Gradle通过SourceSet类指定源码和依赖包的地址。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rsourceSet {\r	main {\r		jniLibs.srcDirs = [&#39;libs&#39;]\r	}\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1988, '策略模式.png', '策略模式-png', 1582462460, 1582462460, 'a:5:{s:4:"name";s:16:"策略模式.png";s:4:"path";s:35:"/usr/uploads/2020/02/1210986646.png";s:4:"size";i:39790;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1989, 0),
(1989, '策略模式', '1989', 1582462485, 1582462485, '<p>本文记录Java学习过程中遇到的策略模式～</p>\r<!--more-->\r\r<p>策略模式（Strategy-Pattern）策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/02/1210986646.png" style="width: 800px; height: 315px;" /></p>\r\r<ul>\r	<li>Context：算法调用者，使用setStrategy方法灵活的选择策略（strategy）；</li>\r	<li>Strategy：算法的统一接口；</li>\r	<li>ConcreteStrategy：算法的具体实现。</li>\r</ul>\r\r<p>使用场景：</p>\r\r<p>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时；&nbsp;<br />\r出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(1990, 'SqlSession.png', 'SqlSession-png', 1582463707, 1582463707, 'a:5:{s:4:"name";s:14:"SqlSession.png";s:4:"path";s:35:"/usr/uploads/2020/02/2642994055.png";s:4:"size";i:51768;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1992, 0),
(1991, 'SqlSession查询嵌套关系.png', 'SqlSession查询嵌套关系-png', 1582463727, 1582463727, 'a:5:{s:4:"name";s:32:"SqlSession查询嵌套关系.png";s:4:"path";s:35:"/usr/uploads/2020/02/3499451372.png";s:4:"size";i:159504;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1992, 0),
(1992, 'MyBatis的SqlSession源码分析', '1992', 1582463700, 1582463771, '<p>本文记录Java学习过程中遇到的MyBatis的SqlSession源码分析～</p>\r<!--more-->\r\r<p>SqlSession是MyBaits对外提供的最关键的核心接口，通过它可以执行数据库读写命令、获取映射器、管理事务等。</p>\r\r<p>URL类图：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/02/2642994055.png" style="width: 800px; height: 252px;" /></p>\r\r<p>SqlSession查询接口嵌套关系：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/02/3499451372.png" style="width: 800px; height: 315px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(1995, '模版模式', '1995', 1582986660, 1583055311, '<p>本文记录Java学习过程中遇到的模版模式～</p>\r<!--more-->\r\r<p>模板模式（Template Pattern）：一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定实现。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3317679109.png" style="width: 800px; height: 312px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(1997, '模版模式.png', '模版模式-png', 1583055298, 1583055298, 'a:5:{s:4:"name";s:16:"模版模式.png";s:4:"path";s:35:"/usr/uploads/2020/03/3317679109.png";s:4:"size";i:92590;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1995, 0),
(1998, 'Executor.png', 'Executor-png', 1583055327, 1583055327, 'a:5:{s:4:"name";s:12:"Executor.png";s:4:"path";s:35:"/usr/uploads/2020/03/4289922218.png";s:4:"size";i:53580;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1999, 0);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(1999, 'MyBatis的Executor模块代码分析', '1999', 1583055300, 1583055689, '<p>本文记录Java学习过程中遇到的MyBatis的Executor模块代码分析～</p>\r<!--more-->\r\r<p>Executor是MyBaits核心接口之一，定义了数据库操作最基本的方法，SqlSession的功能都是基于它来实现的。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/4289922218.png" style="width: 800px; height: 256px;" />​</p>\r\r<p>BaseExecutor：抽象类，实现了executor接口的大部分方法，主要提供了缓存管理和事务管理的能力，其他子类需要实现的抽象方法为：doUpdate,doQuery等方法。</p>\r\r<p>BaseExecutor代码分析：</p>\r\r<p>遇到由一系列步骤构成的过程需要执行，这个过程从高层次上看是相同的，但是有些步骤的实现可能不同，这个时候就需要考虑用模板模式了。比如：Executor查询操作流程。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3823296280.png" style="width: 645px; height: 797px;" /></p>\r\r<p>Executor的三个实现类：</p>\r\r<ul>\r	<li>SimpleExecutor：默认配置，使用PrepareStatement对象访问数据库，每次访问都要创建新的PrepareStatement对象；</li>\r	<li>ReuseExecutor：使用预编译PrepareStatement对象访问数据库，访问时，会重用缓存中的statement对象；</li>\r	<li>BatchExecutor：实现批量执行多条SQL语句的能力。</li>\r</ul>\r\r<p>通过对SimpleExecutor的doQuery()方法的解读发现，Executor是个指挥官，它在调度三个小弟工作。</p>\r\r<p>Executor的三个重要处理器：</p>\r\r<ul>\r	<li>StatementHandler：它的作用是使用数据库的Statement或PrepareStatement执行操作，启承上启下作用；</li>\r	<li>ParameterHandler：对预编译的SQL语句进行参数设置，SQL语句中的的占位符&ldquo;?&rdquo;都对应BoundSql.parameterMappings集合中的一个元素，在该对象中记录了对应的参数名称以及该参数的相关属性；</li>\r	<li>ResultSetHandler：对数据库返回的结果集（ResultSet）进行封装，返回用户指定的实体类型。</li>\r</ul>\r\r<p>Executor内部运作过程：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3066759137.png" style="width: 800px; height: 458px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(2000, 'BaseExecutor.png', 'BaseExecutor-png', 1583055365, 1583055365, 'a:5:{s:4:"name";s:16:"BaseExecutor.png";s:4:"path";s:35:"/usr/uploads/2020/03/3823296280.png";s:4:"size";i:62012;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1999, 0),
(2001, 'Executor内部运作过程.png', 'Executor内部运作过程-png', 1583055384, 1583055384, 'a:5:{s:4:"name";s:30:"Executor内部运作过程.png";s:4:"path";s:35:"/usr/uploads/2020/03/3066759137.png";s:4:"size";i:96550;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 1999, 0),
(2002, 'StatementHandler.png', 'StatementHandler-png', 1583055615, 1583055615, 'a:5:{s:4:"name";s:20:"StatementHandler.png";s:4:"path";s:34:"/usr/uploads/2020/03/150375730.png";s:4:"size";i:53570;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2004, 0),
(2003, 'ResultSetHandler.png', 'ResultSetHandler-png-1', 1583055638, 1583055638, 'a:5:{s:4:"name";s:20:"ResultSetHandler.png";s:4:"path";s:35:"/usr/uploads/2020/03/4226351270.png";s:4:"size";i:196672;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2004, 0),
(2004, 'MyBatis的StatementHandler模块代码分析', '2004', 1583055651, 1583055651, '<p>本文记录Java学习过程中遇到的MyBatis的StatementHandler模块代码分析～</p>\r<!--more-->\r\r<p>StatementHandler完成Mybatis最核心的工作，也是Executor实现的基础；功能包括：创建statement对象，为sql语句绑定参数，执行增删改查等SQL语句、将结果映射集进行转化。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/150375730.png" style="width: 800px; height: 392px;" /></p>\r\r<ul>\r	<li>BaseStatementHandler：所有子类的抽象父类，定义了初始化statement的操作顺序，由子类实现具体的实例化不同的statement（模板模式）；</li>\r	<li>RoutingStatementHandler：Excutor组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类；</li>\r	<li>SimpleStatmentHandler ：使用statement对象访问数据库，无须参数化；</li>\r	<li>PreparedStatmentHandler ：使用预编译PrepareStatement对象访问数据库；</li>\r	<li>CallableStatmentHandler ：调用存储过程。</li>\r</ul>\r\r<p>ResultSetHandler：ResultSetHandler将从数据库查询得到的结果按照映射配置文件的映射规则，映射成相应的结果集对象。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/4226351270.png" style="width: 800px; height: 195px;" />​</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2005, 'MyBatis插件概述', '2005', 1583666070, 1583666070, '<p>本文记录Java学习过程中遇到的MyBatis插件概述～</p>\r<!--more-->\r\r<p>插件是用来改变或者扩展MyBatis的原有的功能，MyBaits的插件就是通过继承Interceptor拦截器实现的；在没有完全理解插件之前禁止使用插件对mybaits进行扩展，又可能会导致严重的问题。</p>\r\r<p>MyBatis中能使用插件进行拦截的接口和方法如下：</p>\r\r<ul>\r	<li>Executor（update、query、flushStatment、commit、rollback、getTransaction、close、isClose）；</li>\r	<li>StatementHandler（prepare、paramterize、batch、update、query）；</li>\r	<li>ParameterHandler（getParameterObject、setParameters）；</li>\r	<li>ResultSetHandler（handleResultSets、handleCursorResultSets、handleOutputParameters）。</li>\r</ul>\r\r<p>定义一个阈值，当查询操作运行时间超过这个阈值记录日志供运维人员定位慢查询，插件实现步骤：</p>\r\r<ol>\r	<li>实现Interceptor接口方法；</li>\r	<li>确定拦截的签名；</li>\r	<li>在配置文件中配置插件；</li>\r	<li>运行测试用例。</li>\r</ol>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r@Intercepts({\r        @Signature(type=StatementHandler.class,method=&quot;query&quot;,args={Statement.class, ResultHandler.class})//,\r	    // @Signature(type=StatementHandler.class,method=&quot;query&quot;,args={MappedStatement.class,Object.class, RowBounds\r        //.class, ResultHandler.class})\r})\rpublic class ThresholdInterceptor implements Interceptor {\r\r    private long threshold;\r\r    @Override\r    public Object intercept(Invocation invocation) throws Throwable {\r        long begin = System.currentTimeMillis();\r        Object ret = invocation.proceed();\r        long end=System.currentTimeMillis();\r        long runTime = end - begin;\r        if(runTime&gt;=threshold){\r            Object[] args = invocation.getArgs();\r            Statement stat = (Statement) args[0];\r            MetaObject metaObjectStat = SystemMetaObject.forObject(stat);\r            PreparedStatementLogger statementLogger = (PreparedStatementLogger)metaObjectStat.getValue(&quot;h&quot;);\r            Statement statement = statementLogger.getPreparedStatement();\r            System.out.println(&quot;SQL：&ldquo;&quot; + statement.toString() + &quot;&rdquo;执行时间为：&quot; + runTime+ &quot;毫秒，已超过阈值。&quot;);\r        }\r        return ret;\r    }\r\r    @Override\r    public Object plugin(Object target) {\r        return Plugin.wrap(target, this);\r    }\r\r    @Override\r    public void setProperties(Properties properties) {\r        this.threshold = Long.valueOf(properties.getProperty(&quot;threshold&quot;));\r    }\r\r}</pre>\r\r<pre class="brush:xml;">\r&lt;!-- 插件配置 --&gt;\r&lt;plugins&gt;\r        &lt;plugin interceptor=&quot;ren.oliver.mybatis.learning.interceptor.ThresholdInterceptor&quot;&gt;\r            &lt;property name=&quot;threshold&quot; value=&quot;10&quot;/&gt;\r        &lt;/plugin&gt;\r&lt;/plugins&gt;</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2006, '责任链模式.png', '责任链模式-png', 1583670716, 1583670716, 'a:5:{s:4:"name";s:19:"责任链模式.png";s:4:"path";s:35:"/usr/uploads/2020/03/2875589123.png";s:4:"size";i:56570;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2007, 0),
(2007, '责任链模式', '2007', 1583670735, 1583670735, '<p>本文记录Java学习过程中遇到的责任链模式～</p>\r<!--more-->\r\r<p>责任链模式：就是把一件工作分别经过链上的各个节点，让这些节点依次处理这个工作；和装饰器模式不同，每个节点都知道后继者是谁；适合为完成同一个请求需要多个处理类的场景。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/2875589123.png" style="width: 800px; height: 354px;" />​</p>\r\r<p>要素分析：</p>\r\r<ul>\r	<li>Handler：定义了一个处理请求的标准接口；</li>\r	<li>ConcreteHandler：具体的处理者，处理它负责的部分，根据业务可以结束处理流程，也可以将请求转发给它的后继者；</li>\r	<li>client：发送者，发起请求的客户端。</li>\r</ul>\r\r<p>责任链模式优点：</p>\r\r<ul>\r	<li>降低耦合度：它将请求的发送者和接收者解耦；</li>\r	<li>简化对象：使得对象不需要知道链的结构；</li>\r	<li>增强给对象指派职责的灵活性：通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任；</li>\r	<li>增加新的请求处理类方便。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2008, '为什么要了解Java虚拟机', '2008', 1584372700, 1584372700, '<p>本文记录Java学习过程中遇到的为什么要了解JVM～</p>\r<!--more-->\r\r<p>了解Java虚拟机有如下好处：</p>\r\r<ul>\r	<li>写出更好、更健壮的Java程序；</li>\r	<li>提高Java应用的性能，排除问题；</li>\r	<li>面试必备知识。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2009, '常见的Java虚拟机', '2009', 1584374351, 1584374351, '<p>本文记录Java学习过程中遇到的常见的Java虚拟机～</p>\r<!--more-->\r\r<p>Sun/Oracle系列的虚拟机：</p>\r\r<ul>\r	<li>Sun Classic：在Java1.0里面发布的，是第一款商用Java虚拟机，纯解释执行的，问题很多；</li>\r	<li>Exact VM：在Java1.2发布的，在Sun专有的平台Solories中发布的，具有两级即时编译器和解释器与编译器混合工作的模式，使用了准确式的内存管理，在Java1.4的时候推出舞台；</li>\r	<li>HotSpot VM：在Java1.4中发布的，是目前使用范围最广的Java虚拟机，使用的是热点代码探测技术，它会找出最有价值的代码，然后通知即时编译器，将其编译为本地代码；</li>\r	<li>Mobile系列：面对移动和嵌入式市场。</li>\r</ul>\r\r<p>其他公司的虚拟机：</p>\r\r<ul>\r	<li>BEA JRockit：号称是世界上运行最快的，为Server端应用做过特别的优化，把所有的代码进行即时编译再执行，不考虑应用的启动速度；</li>\r	<li>IBM J9 VM：与HostSpot类似，覆盖各个平台，主要的市场是IBM的大小型机；</li>\r	<li>BEA Liquid VM：特别的硬件平台使用的虚拟机，本身就是一个操作系统，直接在硬件上运行JVM；</li>\r	<li>Google Android Dalvik VM：安卓内部使用的虚拟机；</li>\r	<li>Apache Harmony：因为与Sun公司有矛盾，但后来Sun将JDK开源，所以不再维护了。</li>\r	<li>Microsoft JVM：因为版权问题出现的。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2010, '未来的Java技术', '2010', 1584375103, 1584375103, '<p>本文记录Java学习过程中遇到的未来的Java技术～</p>\r<!--more-->\r\r<p>未来的Java技术有：</p>\r\r<ul>\r	<li>模块化：以后系统会越来越大，越来越复杂，没有人会为了一个小模块下载整个大模块，所以近几年维服务越来越火；</li>\r	<li>混合语言：支持更多语言在JVM上运行；</li>\r	<li>多核并行：并发编程，提高运行速度；</li>\r	<li>丰富语法：比如自动装箱，注解，switch支持字符串和lambda等等；</li>\r	<li>64位：目前很多都是X86架构的；</li>\r	<li>更强的垃圾回收：ZJC，号称可以在秒级别回收T级别内存。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2011, 'JVM运行时数据区域 .png', 'JVM运行时数据区域-png', 1584629350, 1584629350, 'a:5:{s:4:"name";s:29:"JVM运行时数据区域 .png";s:4:"path";s:35:"/usr/uploads/2020/03/4126036639.png";s:4:"size";i:275252;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2012, 0),
(2012, 'JVM运行时数据区域', '2012', 1584629340, 1584631274, '<p>本文记录Java学习过程中遇到的JVM运行时数据区域～</p>\r<!--more-->\r\r<p>定义：Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p>\r\r<p>类型：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区（运行时常量池）、直接内存。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/4126036639.png" style="width: 800px; height: 601px;" />​</p>\r\r<p>各个区域的作用：</p>\r\r<p>1.程序计数器：较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响；</p>\r\r<p>2.Java栈：线程私有，生命周期和线程，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程；栈里面存放着各种基本数据类型和对象的引用（即-Xss）；</p>\r\r<p>3.本地方法栈：本地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单地动态链接并直接调用native方法；</p>\r\r<p>4.堆：Java堆是Javaer需要重点关注的一块区域，因为涉及到内存的分配(new关键字，反射等)与回收(回收算法，收集器等) ；</p>\r\r<p>几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：</p>\r\r<ul>\r	<li>-Xms：堆的最小值；</li>\r	<li>-Xmx：堆的最大值；</li>\r	<li>-Xmn：新生代的大小；</li>\r	<li>-XX:NewSize；新生代最小值；</li>\r	<li>-XX:MaxNewSize：新生代最大值；</li>\r</ul>\r\r<p>5.方法区：也叫永久区，用于存储已经被虚拟机加载的类信息，常量(&quot;zdy&quot;,&quot;123&quot;等)，静态变量(static变量)等数据；</p>\r\r<p>可用以下参数调整：</p>\r\r<ul>\r	<li>jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；</li>\r	<li>jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize；</li>\r	<li>jdk1.8以后大小就只受本机总内存的限制</li>\r</ul>\r\r<p>6.运行时常量池：运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量(&quot;zdy&quot;,&quot;123&quot;等)和符号引用；</p>\r\r<p>7.直接内存：不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在Java堆内可以用directByteBuffer对象直接引用并操作；这块内存不受Java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/849466593.png" style="width: 411px; height: 300px;" />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/2029618481.png" style="width: 183px; height: 300px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3315855243.png" style="width: 800px; height: 533px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 12),
(2013, '01.png', '01-png', 1584629812, 1584629812, 'a:5:{s:4:"name";s:6:"01.png";s:4:"path";s:34:"/usr/uploads/2020/03/849466593.png";s:4:"size";i:128921;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2012, 0),
(2014, '02.png', '02-png', 1584629833, 1584629833, 'a:5:{s:4:"name";s:6:"02.png";s:4:"path";s:35:"/usr/uploads/2020/03/2029618481.png";s:4:"size";i:51011;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2012, 0),
(2015, '03.png', '03-png-1', 1584629912, 1584629912, 'a:5:{s:4:"name";s:6:"03.png";s:4:"path";s:35:"/usr/uploads/2020/03/3315855243.png";s:4:"size";i:76996;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2012, 0),
(2021, '6.png', '6-png', 1584630872, 1584630872, 'a:5:{s:4:"name";s:5:"6.png";s:4:"path";s:35:"/usr/uploads/2020/03/1723780896.png";s:4:"size";i:232528;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2019, 0),
(2024, '从线程角度来看JVM内存区域.png', '从线程角度来看JVM内存区域-png', 1584633906, 1584633906, 'a:5:{s:4:"name";s:40:"从线程角度来看JVM内存区域.png";s:4:"path";s:35:"/usr/uploads/2020/03/4109253697.png";s:4:"size";i:432731;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2025, 0),
(2019, 'JVM各个版本内存区域的变化', '2019', 1584630720, 1584631096, '<p>本文记录Java学习过程中遇到的JVM各个版本内存区域的变化～</p>\r<!--more-->\r\r<p>Java6：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/1723780896.png" style="width: 800px; height: 657px;" /></p>\r\r<p>Java7:</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3523224591.png" style="width: 800px; height: 654px;" /></p>\r\r<p>Java8：</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3404988756.png" style="width: 800px; height: 499px;" /></p>\r\r<p>永久代来存储类信息、常量、静态变量等数据不是个好主意, 很容易遇到内存溢出的问题。</p>\r\r<p>对永久代进行调优是很困难的，同时将元空间与堆的垃圾回收进行了隔离，避免永久代引发的Full GC和OOM等问题。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 5),
(2022, '7.png', '7-png', 1584630938, 1584630938, 'a:5:{s:4:"name";s:5:"7.png";s:4:"path";s:35:"/usr/uploads/2020/03/3523224591.png";s:4:"size";i:247814;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2019, 0),
(2023, '8.png', '8-png-1', 1584631081, 1584631081, 'a:5:{s:4:"name";s:5:"8.png";s:4:"path";s:35:"/usr/uploads/2020/03/3404988756.png";s:4:"size";i:260087;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2019, 0),
(2025, '从线程角度来看JVM内存区域', '2025', 1584633935, 1584633935, '<p>本文记录Java学习过程中遇到的从线程角度来看JVM内存区域～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/4109253697.png" style="width: 800px; height: 472px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(2026, '深入辨析堆和栈', '2026', 1584634680, 1584635196, '<p>本文记录Java学习过程中遇到的深入辨析堆和栈～</p>\r<!--more-->\r\r<p>功能上：</p>\r\r<ul>\r	<li>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；</li>\r	<li>堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</li>\r</ul>\r\r<p>线程独享还是共享</p>\r\r<ul>\r	<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；</li>\r	<li>堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>\r</ul>\r\r<p>空间大小</p>\r\r<ul>\r	<li>栈的内存要远远小于堆内存，栈的深度是有限制的，可能发生StackOverFlowError问题。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/2577444483.png" style="width: 800px; height: 579px;" /></p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class SimpleHeap {\r\r    private int id;\r\r    public SimpleHeap(int id) {\r        this.id = id;\r    }\r\r    public void print() {\r        System.out.println(id);\r    }\r\r    public static void main(String[] args) {\r        SimpleHeap s1 = new SimpleHeap(1);\r        SimpleHeap s2 = new SimpleHeap(2);\r        s1.print();\r        s2.print();\r    }\r\r}</pre>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3201528426.png" style="width: 800px; height: 474px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(2027, '堆和栈.png', '堆和栈-png', 1584634782, 1584634782, 'a:5:{s:4:"name";s:13:"堆和栈.png";s:4:"path";s:35:"/usr/uploads/2020/03/2577444483.png";s:4:"size";i:227105;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2026, 0),
(2028, '堆与栈的区别.png', '堆与栈的区别-png', 1584635183, 1584635183, 'a:5:{s:4:"name";s:22:"堆与栈的区别.png";s:4:"path";s:35:"/usr/uploads/2020/03/3201528426.png";s:4:"size";i:170568;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2026, 0),
(2029, '方法的出入栈.png', '方法的出入栈-png', 1584843081, 1584843081, 'a:5:{s:4:"name";s:22:"方法的出入栈.png";s:4:"path";s:35:"/usr/uploads/2020/03/1853776646.png";s:4:"size";i:143234;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2030, 0),
(2030, '方法的出入栈', '2030', 1584843060, 1584844539, '<p>本文记录Java学习过程中遇到的方法的出入栈～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/1853776646.png" style="width: 800px; height: 446px;" /></p>\r\r<p>方法在运行的时候会打包成栈桢，一个栈桢至少要包含局部变量表，操作数栈和帧数据区。</p>\r\r<p>栈上分配：虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。</p>\r\r<p>逃逸分析：是栈上分配需要的技术基础，它的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 栈上分配\rpublic class StackAlloc {\r\r    public static class User {\r        public int id = 0;\r        public String name = &quot;&quot;;\r    }\r\r    public static void alloc() {\r        User user = new User();\r        user.id = 1;\r        user.name = &quot;oliver&quot;;\r    }\r\r    // JVM参数：-server -Xms10m -Xmx10m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations -XX:-UseTLAB\r    public static void main(String[] args) {\r        long b = System.currentTimeMillis();\r        for (int i = 0; i &lt; 100000000; i++) {\r            alloc();\r        }\r        long e = System.currentTimeMillis();\r        System.out.println((e-b) + &quot;ms&quot;);\r    }\r\r}</pre>\r\r<p>JVM参数分析：</p>\r\r<ul>\r	<li>-server：JVM运行的模式之一，只有server模式下才能进行逃逸分析，JVM运行的模式还有mix/client，Linux一般默认为server模式；</li>\r	<li>-Xmx10m和-Xms10m：堆的大小，最大最小值都是10m；</li>\r	<li>-XX:+DoEscapeAnalysis：是否启用逃逸分析(默认打开)；</li>\r	<li>-XX:+PrintGC：打印GC日志；</li>\r	<li>-XX:+EliminateAllocations：标量替换(默认打开)，是不是允许将对象打散分配在栈上；</li>\r	<li>-XX:+UseTLAB：是否开启本地线程分配缓冲（ThreadLocalAllocBuffer），即是否每个线程都有自己的缓存区（堆的一部分），在分配内存的时候，线程会先在自己的缓存区申请。注意：只有在申请的时候每个线程有自己的缓存区，其他的时候还是每个线程都可以使用的。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(2031, '虚拟机中的对象创建.png', '虚拟机中的对象创建-png', 1584846555, 1584846555, 'a:5:{s:4:"name";s:31:"虚拟机中的对象创建.png";s:4:"path";s:35:"/usr/uploads/2020/03/3825507857.png";s:4:"size";i:98555;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2032, 0),
(2032, '虚拟机中的对象创建', '2032', 1584846540, 1584846957, '<p>本文记录Java学习过程中遇到的虚拟机中的对象创建～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3825507857.png" style="width: 800px; height: 541px;" /></p>\r\r<p>虚拟机遇到一条new指令时会对象的分配，具体的步骤如下：</p>\r\r<p>1）检查加载：</p>\r\r<ul>\r	<li>先执行相应的类加载过程，如果类的class没有加载则进行加载。</li>\r</ul>\r\r<p>2）分配内存：</p>\r\r<p>接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>\r\r<ul>\r	<li>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为&ldquo;指针碰撞&rdquo;。</li>\r	<li>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为&ldquo;空闲列表&rdquo;。</li>\r</ul>\r\r<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>\r\r<p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>\r\r<p>解决这个问题有两种方案：</p>\r\r<ul>\r	<li>一种是对分配内存空间的动作进行同步处理&mdash;&mdash;实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；</li>\r	<li>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:+UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。</li>\r</ul>\r\r<p>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</p>\r\r<p>3）内存空间初始化：</p>\r\r<ul>\r	<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>\r</ul>\r\r<p>4）设置：</p>\r\r<ul>\r	<li>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</li>\r</ul>\r\r<p>5）对象初始化：</p>\r\r<ul>\r	<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(2033, '对象的内存布局', '2033', 1584847440, 1584847546, '<p>本文记录Java学习过程中遇到的对象的内存布局～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/815001030.png" style="width: 800px; height: 288px;" />​</p>\r\r<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>\r\r<ul>\r	<li>对象头（Header）：包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；</li>\r	<li>实例数据（Instance Data）：程序代码中所定义的各种类型的字段内容；</li>\r	<li>对齐填充（Padding）：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot-VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 4),
(2034, '对象的内存布局.png', '对象的内存布局-png', 1584847534, 1584847534, 'a:5:{s:4:"name";s:25:"对象的内存布局.png";s:4:"path";s:34:"/usr/uploads/2020/03/815001030.png";s:4:"size";i:93332;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2033, 0),
(2035, '使用句柄.png', '使用句柄-png', 1584847936, 1584847936, 'a:5:{s:4:"name";s:16:"使用句柄.png";s:4:"path";s:35:"/usr/uploads/2020/03/4028981527.png";s:4:"size";i:239260;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2037, 0),
(2036, '直接指针.png', '直接指针-png', 1584847956, 1584847956, 'a:5:{s:4:"name";s:16:"直接指针.png";s:4:"path";s:35:"/usr/uploads/2020/03/1880559942.png";s:4:"size";i:236759;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2037, 0),
(2037, '对象的访问定位', '2037', 1584847981, 1584847981, '<p>本文记录Java学习过程中遇到的对象的访问定位～</p>\r<!--more-->\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/4028981527.png" style="width: 800px; height: 580px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/1880559942.png" style="width: 800px; height: 555px;" /></p>\r\r<p>建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象，目前主流的访问方式有使用句柄和直接指针两种：</p>\r\r<ul>\r	<li>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>\r	<li>如果使用直接指针访问， reference中存储的直接就是对象地址。</li>\r</ul>\r\r<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改；使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>\r\r<p>注意：对HotSpot而言，它是使用直接指针访问方式进行对象访问的。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2038, 'JVM参数设置和内存溢出实战', '2038', 1584862680, 1584890102, '<p>本文记录Java学习过程中遇到的JVM参数设置和内存溢出实战～</p>\r<!--more-->\r\r<p>堆溢出：</p>\r\r<pre class="brush:java;">\r// 堆内存溢出\rpublic class HeapOOM {\r\r    public static void heapOOM1() {\r        List&lt;Object&gt; list = new LinkedList&lt;&gt;();\r        int i=0;\r        while(true) {\r            i++;\r            if(i%10000==0) {\r                System.out.println(&quot;i=&quot;+i);\r            }\r            list.add(new Object());\r        }\r    }\r\r    public static void heapOOM2() {\r        String[] strings = new String[100000000];\r        System.out.println(strings);\r    }\r\r    // JVM启动参数：-Xms5m -Xmx5m -XX:+PrintGC\r    public static void main(String[] args) {\r        // heapOOM1();\r        heapOOM2();\r    }\r\r}</pre>\r\r<ul>\r	<li>出现java.lang.OutOfMemoryError: GC overhead limit exceeded：一般是某个循环里在不停的分配对象，但是分配的太多，最后把堆撑爆了；</li>\r	<li>出现java.lang.OutOfMemoryError: Java heap space：一般是分配了巨型对象，直接返回了装不下。</li>\r</ul>\r\r<p>方法区溢出：</p>\r\r<pre class="brush:java;">\r// 方法区溢出\rpublic class MetaSpaceOOM {\r\r    // JVM参数：-XX:MaxMetaspaceSize=5m\r    public static void main(String[] args) {\r        List&lt;Object&gt; list = new LinkedList&lt;&gt;();\r        int i=0;\r        while(true) {\r            i++;\r            if(i%10000==0) {\r                System.out.println(&quot;i=&quot;+i);\r            }\r            list.add(new Object());\r        }\r    }\r\r}</pre>\r\r<ul>\r	<li>出现java.lang.OutOfMemoryError: throw from the UncaughtExceptionHandler in thread &quot;main&quot;：一般是方法区设置的太小或者Java代码太多了。</li>\r</ul>\r\r<p>栈溢出：</p>\r\r<pre class="brush:java;">\r// 栈溢出\rpublic class StackOOM {\r\r    private int stackLength = 1;\r\r    public void recursion() {\r        stackLength++;\r        recursion();\r    }\r\r    public void recursion(Integer x, String y) {\r        stackLength++;\r        recursion(x, y);\r    }\r\r    // JVM参数：-Xss256k\r    public static void main(String[] args) {\r        StackOOM stackOOM = new StackOOM();\r        try {\r            // stackOOM.recursion();\r            stackOOM.recursion(1, &quot;s&quot;);\r        } catch (Throwable e) {\r            System.out.println(&quot;stack length = &quot; + stackOOM.stackLength);\r            e.printStackTrace();\r        }\r    }\r\r}</pre>\r\r<ul>\r	<li>出现java.lang.StackOverflowError：一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。</li>\r</ul>\r\r<p>虚拟机栈带给的启示：方法的执行因为要打包成栈桢，所以天生要比实现同样功能的循环慢，所以树的遍历算法中：递归和非递归(循环来实现)都有存在的意义。递归代码简洁，非递归代码复杂但是速度较快。</p>\r\r<p>直接内存溢出：</p>\r\r<pre class="brush:java;">\r// 直接内存溢出\rpublic class DirectMemOOM {\r\r    // JVM参数：-Xmx10m -XX:MaxDirectMemorySize=10m\r    public static void main(String[] args) {\r        ByteBuffer b = ByteBuffer.allocateDirect(1024*1024*14);\r    }\r\r}</pre>\r\r<ul>\r	<li>出现java.lang.OutOfMemoryError: Direct buffer memory：一般常见于网络通信的时候。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 7),
(2039, '为什么要了解垃圾收集器和内存分配策略', '2039', 1585146561, 1585146561, '<p>本文记录Java学习过程中遇到的为什么要了解垃圾收集器和内存分配策略～</p>\r<!--more-->\r\r<p>要了解垃圾收集器和内存分配策略的原因：</p>\r\r<ol>\r	<li>面试需要，如今的必备知识；</li>\r	<li>GC对应用的性能是有影响的；</li>\r	<li>写代码有好处。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2040, '可达性分析.png', '可达性分析-png', 1585146953, 1585146953, 'a:5:{s:4:"name";s:19:"可达性分析.png";s:4:"path";s:35:"/usr/uploads/2020/03/3998008788.png";s:4:"size";i:96374;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2041, 0),
(2041, 'GC判断对象的存活', '2041', 1585146960, 1585146997, '<p>本文记录Java学习过程中遇到的GC判断对象的存活～</p>\r\r<!--more-->\r\r<p>主要有两种方法：</p>\r\r<ol>\r	<li>引用计数算法：主要是记录每个对象的引用次数，使用很方便，但对于互相引用的对象没办法正确的回收；</li>\r	<li>可达性分析：通过一系列的称为&ldquo;GC Roots&rdquo;的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</li>\r</ol>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3998008788.png" style="width: 800px; height: 446px;" /></p>\r\r<p>在Java, 可作为GC Roots的对象包括:</p>\r\r<ul>\r	<li>方法区: 类静态属性引用的对象;</li>\r	<li>方法区: 常量引用的对象;</li>\r	<li>虚拟机栈(本地变量表)中引用的对象.</li>\r	<li>本地方法栈JNI(Native方法)中引用的对象。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2042, 'JVM中的各种引用', '2042', 1585148940, 1585149788, '<p>本文记录Java学习过程中遇到的JVM中的各种引用～</p>\r<!--more-->\r\r<p>1.强引用（Reference）：一般的对象都是强引用，例如：Object obj = new Object() 。</p>\r\r<p>2.软引用（SoftReference）：一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 软引用测试\rpublic class SoftRefTest {\r\r    public static class User {\r\r        public int id;\r        public String name;\r\r        public User(int id, String name) {\r            this.id = id;\r            this.name = name;\r        }\r\r        @Override\r        public String toString() {\r            return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;\r        }\r\r    }\r\r    // JVM参数：-Xms10m -Xmx10m -XX:+PrintGC\r    public static void main(String[] args) {\r\r        User u = new User(1,&quot;Oliver King&quot;);\r        SoftReference&lt;User&gt; userSoft = new SoftReference&lt;&gt;(u);\r\r        // 保证刚刚创建的对应只有userSoft引用\r        u = null;\r\r        System.out.println(&quot;BeforeGc: &quot; + userSoft.get());\r        System.gc();\r        System.out.println(&quot;AfterGc:&quot; + userSoft.get());\r\r        List&lt;byte[]&gt; list = new LinkedList&lt;&gt;();\r        try {\r            for(int i=0; i &lt; 100; i++) {\r                System.out.println(&quot;BeforeOOM: &quot; + userSoft.get());\r                list.add(new byte[1024*1024*1]);\r            }\r        } catch (Throwable e) {\r            System.out.println(&quot;AfterOOM: &quot; + userSoft.get());\r        }\r    }\r\r}</pre>\r\r<p>3.弱引用（WeakReference）：一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\r// 弱引用测试\rpublic class WeakRefTest {\r\r    public static class User {\r\r        public int id;\r        public String name;\r\r        public User(int id, String name) {\r            this.id = id;\r            this.name = name;\r        }\r\r        @Override\r        public String toString() {\r            return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;\r        }\r\r    }\r\r    // JVM参数：-XX:+PrintGC\r    public static void main(String[] args) {\r\r        User u = new User(1,&quot;Oliver King&quot;);\r        WeakReference&lt;User&gt; userWeak = new WeakReference&lt;&gt;(u);\r\r        // 保证刚刚创建的对应只有userSoft引用\r        u = null;\r\r        System.out.println(&quot;BeforeGc: &quot; + userWeak.get());\r        System.gc();\r        System.out.println(&quot;AfterGc:&quot; + userWeak.get());\r    }\r\r}</pre>\r\r<p>4.虚引用（PhantomReference）:幽灵引用，最弱，被垃圾回收的时候会收到一个通知。</p>\r\r<p>注意：软引用SoftReference和弱引用WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。</p>\r\r<p>例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(2043, '数据结构与算法的关系.png', '数据结构与算法的关系-png', 1585222125, 1585222125, 'a:5:{s:4:"name";s:34:"数据结构与算法的关系.png";s:4:"path";s:35:"/usr/uploads/2020/03/2812616831.png";s:4:"size";i:312464;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2044, 0),
(2044, '数据结构与算法的关系', '2044', 1585222138, 1585222138, '<p>本文记录Java学习过程中遇到的数据结构与算法的关系～</p>\r<!--more-->\r\r<p>相互之间存在关系的数据元素的集合就是数据结构，算法是解决特定问题的有限求解步骤。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/2812616831.png" style="width: 800px; height: 579px;" />​</p>\r\r<p>学习数据结构与算法有什么用呢？拿一个厨师的厨艺来比较的话，真正的大厨一般不是那种能做各种花样的菜式的人，而是能把普通的菜炒出不平凡的效果的人。就像&ldquo;酸辣土豆丝&rdquo;，不同的人炒出来的效果就不一样，从一道简单的菜就可以看出厨师的功底，而数据结构与算法就是程序员的功底。</p>\r\r<p>回到图上，由图中可以看出，数据结构操组的对象是数据元素，即他们有相同的属性（属性也取决于观察者的角度），它们之间的存在的关系会产生不同的结构，数据元素之间的关系+操作构成了数据类型，对已有的数据类型进行抽象就构成了抽象数据类型（ADT），就是封装了值和操作的模型。</p>\r\r<p>在看算法这一块，就是根据输入，设计可行的计算方法并用有限的可执行步骤描述出来（程序），最终得到确定的输出。（从中也可以看出算法的5大特性：输入，输出，有穷性，确定性，可行性）。</p>\r\r<p>评估一个算法的好坏常用时间复杂度，时间复杂度的计算方法也可以分为3步，具体步骤图上已经给出，举个例子来说（不考虑输入输出的时间以及每个步骤之间的时间差异）：如果程序需要执行3n&sup2; + 10n + 20的次，那么第一步将化简为3n&sup2; + 10n + 1，第二步将化简为3n&sup2;，第三步化简为n&sup2;，最终时间复杂度为O(n&sup2;)。</p>\r\r<p>线性表，堆栈，串，树，图是常见的用抽象数据类型定义的结构，查找和排序是常见的算法。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2045, '数据的逻辑结构', '2045', 1585225320, 1585225527, '<p>本文记录Java学习过程中遇到的数据的逻辑结构～</p>\r<!--more-->\r\r<p>逻辑结构是从思想的角度上对系统分类，把系统分成若干个逻辑单元，不同逻辑单元分别实现自己的功能。数据的逻辑结构是对数据之间关系的描述，有时就把逻辑结构简称为数据结构，数据的逻辑结构分为以下四种：</p>\r\r<ul>\r	<li>集合结构：集合结构的集合中任何两个数据元素之间都没有逻辑关系，组织形式松散；</li>\r	<li>线性结构：数据结构中线性结构指的是数据元素之间存在着&ldquo;一对一&rdquo;的线性关系的数据结构；</li>\r	<li>树状结构：树状结构是一个或多个节点的有限集合；</li>\r	<li>网络结构：网络结构是指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。</li>\r</ul>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/2782775789.png" style="width: 200px; height: 180px;" /><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/1316578635.png" style="width: 200px; height: 182px;" /><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/4232154594.png" style="width: 200px; height: 141px;" /><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3305663266.png" style="width: 200px; height: 145px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2046, '集合结构.png', '集合结构-png', 1585225458, 1585225458, 'a:5:{s:4:"name";s:16:"集合结构.png";s:4:"path";s:35:"/usr/uploads/2020/03/2782775789.png";s:4:"size";i:51381;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2045, 0),
(2047, '线性结构.png', '线性结构-png', 1585225476, 1585225476, 'a:5:{s:4:"name";s:16:"线性结构.png";s:4:"path";s:35:"/usr/uploads/2020/03/1316578635.png";s:4:"size";i:40674;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2045, 0),
(2048, '树形结构.png', '树形结构-png', 1585225490, 1585225490, 'a:5:{s:4:"name";s:16:"树形结构.png";s:4:"path";s:35:"/usr/uploads/2020/03/4232154594.png";s:4:"size";i:56122;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2045, 0),
(2049, '图形结构.png', '图形结构-png', 1585225508, 1585225508, 'a:5:{s:4:"name";s:16:"图形结构.png";s:4:"path";s:35:"/usr/uploads/2020/03/3305663266.png";s:4:"size";i:54439;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2045, 0),
(2050, '数据的存储结构', '2050', 1585225714, 1585225714, '<p>本文记录Java学习过程中遇到的数据的存储结构～</p>\r<!--more-->\r\r<p>数据的存储结构是指数据的逻辑结构在计算机中的表示。</p>\r\r<p>数据的存储结构分为顺序存储结构和链接存储结构两种：</p>\r\r<ol>\r	<li>顺序存储结构：顺序存储方法它是把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现，由此得到的存储表示称为顺序存储结构；</li>\r	<li>链接存储结构：链接存储方法它不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的。由此得到的存储表示称为链式存储结构，链式存储结构通常借助于程序设计语言中的指针类型来实现。</li>\r</ol>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1);
INSERT INTO `typecho_contents` (`cid`, `title`, `slug`, `created`, `modified`, `text`, `order`, `authorId`, `template`, `type`, `status`, `password`, `commentsNum`, `allowComment`, `allowPing`, `allowFeed`, `parent`, `views`) VALUES
(2051, '数据类型与抽象数据类型', '2051', 1585227553, 1585227553, '<p>本文记录Java学习过程中遇到的数据类型与抽象数据类型～</p>\r<!--more-->\r\r<p>数据类型：一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>\r\r<p>抽象数据类型：一个数字模型及定义在该模型上的一组操作。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2052, '标记-清除算法.png', '标记-清除算法-png', 1585493073, 1585493073, 'a:5:{s:4:"name";s:23:"标记-清除算法.png";s:4:"path";s:35:"/usr/uploads/2020/03/4008115125.png";s:4:"size";i:203285;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2053, 0),
(2053, '垃圾回收算法——标记-清除算法', '2053', 1585493096, 1585493096, '<p>本文记录Java学习过程中遇到的垃圾回收算法&mdash;&mdash;标记-清除算法～</p>\r<!--more-->\r\r<p>标记-清除算法（Mark-Sweep）分为&ldquo;标记&rdquo;和&ldquo;清除&rdquo;两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/4008115125.png" style="width: 800px; height: 529px;" /></p>\r\r<p>它的主要不足是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2054, '复制算法.png', '复制算法-png', 1585493391, 1585493391, 'a:5:{s:4:"name";s:16:"复制算法.png";s:4:"path";s:35:"/usr/uploads/2020/03/3123023065.png";s:4:"size";i:111900;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2055, 0),
(2055, '垃圾回收算法——复制算法', '2055', 1585493400, 1585493418, '<p>本文记录Java学习过程中遇到的垃圾回收算法&mdash;&mdash;复制算法～</p>\r<!--more-->\r\r<p>复制算法（Copying）：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/3123023065.png" style="width: 800px; height: 541px;" />​</p>\r\r<p>注意：这种算法的代价是将内存缩小为了原来的一半。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2056, '标记-整理算法.png', '标记-整理算法-png', 1585493533, 1585493533, 'a:5:{s:4:"name";s:23:"标记-整理算法.png";s:4:"path";s:35:"/usr/uploads/2020/03/1524862214.png";s:4:"size";i:414567;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2057, 0),
(2057, '垃圾回收算法——标记-整理算法', '2057', 1585493564, 1585493564, '<p>本文记录Java学习过程中遇到的垃圾回收算法&mdash;&mdash;标记-整理算法～</p>\r<!--more-->\r\r<p>标记-整理算法（Mark-Compact）：首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/1524862214.png" style="width: 800px; height: 555px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2058, '分代收集.png', '分代收集-png', 1585534864, 1585534864, 'a:5:{s:4:"name";s:16:"分代收集.png";s:4:"path";s:33:"/usr/uploads/2020/03/56034650.png";s:4:"size";i:394578;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2059, 0),
(2059, '垃圾回收算法——分代收集', '2059', 1585534887, 1585534887, '<p>本文记录Java学习过程中遇到的垃圾回收算法&mdash;&mdash;分代收集～</p>\r<!--more-->\r\r<p>当前商业虚拟机的垃圾收集都采用&ldquo;分代收集&rdquo;（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>\r\r<p>研究表明，新生代中的对象98%是&ldquo;朝生夕死&rdquo;的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>\r\r<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被&ldquo;浪费&rdquo;。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>\r\r<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用&ldquo;标记&mdash;清理&rdquo;或者&ldquo;标记&mdash;整理&rdquo;算法来进行回收。</p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/03/56034650.png" style="width: 800px; height: 562px;" /></p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(2060, '常见的垃圾回收算法实现', '2060', 1585729500, 1585731928, '<p>本文记录Java学习过程中遇到的常见的垃圾回收算法实现～</p>\r<!--more-->\r\r<p>新生代相关：</p>\r\r<table border="1" cellpadding="1" cellspacing="1" style="width: 800px;">\r	<thead>\r		<tr>\r			<th scope="col">收集器</th>\r			<th scope="col">收集对象和算法</th>\r			<th scope="col">收集器类型</th>\r			<th scope="col">说明</th>\r			<th scope="col">适用场景</th>\r		</tr>\r	</thead>\r	<tbody>\r		<tr>\r			<td>Serial</td>\r			<td>新生代，复制算法</td>\r			<td>单线程</td>\r			<td>进行垃圾收集时，必须暂停所有工作线程，直到完成</td>\r			<td>简单高效，适合内存不大的情况</td>\r		</tr>\r		<tr>\r			<td>ParNew</td>\r			<td>新生代，复制算法</td>\r			<td>并行的多线程收集器</td>\r			<td>ParNew垃圾收集器是Serial收集器的多线程版本</td>\r			<td>搭配CMS垃圾回收器的首选</td>\r		</tr>\r		<tr>\r			<td>Parallel Scavenge</td>\r			<td>吞吐量优先收集器</td>\r			<td>新生代，复制算法</td>\r			<td>并行的多线程收集器</td>\r			<td>\r			<p>类似ParNew，更加关注吞吐量，达到一个可控制的吞吐量；</p>\r\r			<p>本身是Server级别多CPU机器上的默认GC方式，主要适合后台运算不需要太多交互的任务</p>\r			</td>\r		</tr>\r	</tbody>\r</table>\r\r<p>备注：</p>\r\r<ul>\r	<li>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li>\r	<li>垃圾收集时间=垃圾回收频率*单次垃圾回收时间</li>\r</ul>\r\r<p>年老代：</p>\r\r<table border="1" cellpadding="1" cellspacing="1" style="width: 800px;">\r	<thead>\r		<tr>\r			<th scope="col">收集器</th>\r			<th scope="col">收集对象和算法</th>\r			<th scope="col">收集器类型</th>\r			<th scope="col">说明</th>\r			<th scope="col">适用场景</th>\r		</tr>\r	</thead>\r	<tbody>\r		<tr>\r			<td>Serial Old</td>\r			<td>老年代，标记整理算法</td>\r			<td>单线程</td>\r			<td>JDK7/8默认的老生代垃圾回收器</td>\r			<td>Client模式下虚拟机使用</td>\r		</tr>\r		<tr>\r			<td>Parallel Old</td>\r			<td>老年代，标记整理算法</td>\r			<td>并行的多线程收集器</td>\r			<td>Parallel Scavenge收集器的老年代版本，为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合</td>\r			<td>在注重吞吐量以及CPU资源敏感的场合采用</td>\r		</tr>\r		<tr>\r			<td>CMS</td>\r			<td>老年代，标记清除算法</td>\r			<td>并行与并发收集器</td>\r			<td>尽可能的缩短垃圾收集时用户线程停止时间，但缺点在于：\r			<ul>\r				<li>内存碎片；</li>\r				<li>需要更多cpu资源；</li>\r				<li>浮动垃圾问题，需要更大的堆空间。</li>\r			</ul>\r			</td>\r			<td>重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统，目前是互联网后端主流的垃圾回收器</td>\r		</tr>\r		<tr>\r			<td>G1</td>\r			<td>跨新生代和老年代，标记整理+化整为零</td>\r			<td>并行与并发收集器</td>\r			<td>JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收，可预测的停顿是其最大的优势</td>\r			<td>面向服务端应用的垃圾回收器，目标为取代CMS</td>\r		</tr>\r	</tbody>\r</table>\r\r<p>注意，这里的并行和并发与前面学的不一样，分别如下：</p>\r\r<ul>\r	<li>并行：垃圾收集的多线程的同时进行；</li>\r	<li>并发：垃圾收集的多线程和应用的多线程同时进行。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2061, 'Serial:Serial Old.png', 'Serial-Serial-Old-png', 1585754894, 1585754894, 'a:5:{s:4:"name";s:21:"Serial:Serial Old.png";s:4:"path";s:35:"/usr/uploads/2020/04/3232811020.png";s:4:"size";i:152655;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 1, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2066, 0),
(2062, 'ParNew:Serial Old.png', 'ParNew-Serial-Old-png', 1585755078, 1585755078, 'a:5:{s:4:"name";s:21:"ParNew:Serial Old.png";s:4:"path";s:35:"/usr/uploads/2020/04/2465470433.png";s:4:"size";i:167595;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 2, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2066, 0),
(2063, 'Parallel Scavenge:Parallel Old.png', 'Parallel-Scavenge-Parallel-Old-png', 1585755172, 1585755172, 'a:5:{s:4:"name";s:34:"Parallel Scavenge:Parallel Old.png";s:4:"path";s:34:"/usr/uploads/2020/04/299303261.png";s:4:"size";i:164672;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 3, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2066, 0),
(2064, 'Concurrent Mark Sweep（CMS）.png', 'Concurrent-Mark-Sweep-CMS-png', 1585755375, 1585755375, 'a:5:{s:4:"name";s:34:"Concurrent Mark Sweep（CMS）.png";s:4:"path";s:35:"/usr/uploads/2020/04/3128592584.png";s:4:"size";i:205546;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 4, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2066, 0),
(2065, 'G1.png', 'G1-png', 1585755523, 1585755523, 'a:5:{s:4:"name";s:6:"G1.png";s:4:"path";s:34:"/usr/uploads/2020/04/920098707.png";s:4:"size";i:306004;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 5, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2066, 0),
(2066, '垃圾回收器工作示意图', '2066', 1585755540, 1586159926, '<p>本文记录Java学习过程中遇到的垃圾回收器工作示意图～</p>\r<!--more-->\r\r<p><strong>Serial/Serial Old</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/04/3232811020.png" style="width: 800px; height: 170px;" /></p>\r\r<p>最古老的，单线程，独占式，成熟，适合单CPU服务器。</p>\r\r<p>参数配置：</p>\r\r<pre class="brush:java;">\r-XX:+UseSerialGC：新生代和老年代都用串行收集器\r-XX:+UseParNewGC：新生代使用ParNew，老年代使用Serial Old\r-XX:+UseParallelGC：新生代使用ParallerGC，老年代使用Serial Old</pre>\r\r<p><strong>ParNew/Serial Old</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/04/2465470433.png" style="width: 800px; height: 165px;" /></p>\r\r<p>和Serial基本没区别，唯一的区别：多线程，多CPU的，停顿时间比Serial少。</p>\r\r<p>参数配置：</p>\r\r<pre class="brush:java;">\r-XX:+UseParNewGC：新生代使用ParNew，老年代使用Serial Old</pre>\r\r<p><strong>Parallel Scavenge/Parallel Old</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/04/299303261.png" style="width: 800px; height: 176px;" /></p>\r\r<p>关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>\r\r<p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>\r\r<p>参数设置：</p>\r\r<pre class="brush:java;">\r-XX:+UseParallerOldGC：新生代使用ParallerGC，老年代使用Parallel Old；\r-XX:MaxGCPauseMills：参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了；\r-XX:GCTimeRatio：参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1/（1+19）），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集时间；\r-XX:+UseAdaptiveSizePolicy：这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略。</pre>\r\r<p>如果对于收集器运作原来不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>\r\r<p><strong>Concurrent Mark Sweep（CMS）</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/04/3128592584.png" style="width: 800px; height: 170px;" /></p>\r\r<p>收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>\r\r<p>从名字（包含&ldquo;Mark Sweep&rdquo;）上就可以看出，CMS收集器是基于&ldquo;标记&mdash;清除&rdquo;算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p>\r\r<ul>\r	<li>初始标记-短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；</li>\r	<li>并发标记-和用户的应用程序同时进行，进行GC RootsTracing的过程；</li>\r	<li>重新标记-短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短；</li>\r	<li>并发清除。</li>\r</ul>\r\r<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>\r\r<p>参数设置：</p>\r\r<pre class="brush:java;">\r-XX:+UseConcMarkSweepGC：表示新生代使用ParNew，老年代的用CMS</pre>\r\r<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉，这一部分垃圾就称为&ldquo;浮动垃圾&rdquo;。</p>\r\r<p>同时用户的线程还在运行，需要给用户线程留下运行的内存空间。</p>\r\r<p>常用参数配置：</p>\r\r<pre class="brush:java;">\r-XX:CMSInitialOccupyFraction：因为以上两点，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK早期版本的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。在JDK1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次&ldquo;Concurrent Mode Failure&rdquo;失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高很容易导致大量&ldquo;Concurrent Mode Failure&rdquo;失败，性能反而降低；\r-XX:+UseCMSCompactAtFullCollection：为了解决内存碎片的问题，CMS收集器提供了一个这个开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长；\r-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full-GC后，跟着来一次带压缩的（默认值为0，表示每次进入FullGC时都进行碎片整理）。</pre>\r\r<p><strong>G1</strong></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/04/2540195182.png" style="width: 800px; height: 344px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/04/920098707.png" style="width: 800px; height: 779px;" /></p>\r\r<p><img alt="" src="http://www.oliver.ren/usr/uploads/2020/04/3053813421.png" style="width: 800px; height: 289px;" /></p>\r\r<p>G1收集的几个阶段</p>\r\r<ul>\r	<li>新生代GC；</li>\r	<li>并发标记周期；</li>\r	<li>混合收集；</li>\r	<li>可能的FullGC。</li>\r</ul>\r\r<p>参数设置：</p>\r\r<pre class="brush:java;">\r-XX:+UseG1GC</pre>\r\r<p>G1的特点：</p>\r\r<ul>\r	<li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行；</li>\r	<li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果；</li>\r	<li>空间整合：与CMS的&ldquo;标记&mdash;清理&rdquo;算法不同，G1从整体来看是基于&ldquo;标记&mdash;整理&rdquo;算法实现的收集器，从局部（两个Region之间）上来看是基于&ldquo;复制&rdquo;算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，可预测的停顿，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC；</li>\r	<li>内存布局：在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</li>\r</ul>\r\r<p>新生代GC：eden区和survivor区回收后，所有eden区被清空，存在一个survivor区保存了部分数据。部分新生代的对象会晋升到老年代，老年代区域会增多。</p>\r\r<p>并发标记周期：</p>\r\r<ul>\r	<li>初始标记：短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，产生一个全局停顿，都伴随有一次新生代的GC；</li>\r	<li>根区域扫描：扫描survivor区可以直接到达的老年代区域；</li>\r	<li>并发标记：扫描和查找整个堆的存活对象，并标记；</li>\r	<li>重新标记：会产生全局停顿，对并发标记阶段的结果进行修正；</li>\r	<li>独占清理：会产生全局停顿，对GC回收比例进行排序，供混合收集阶段使用；</li>\r	<li>并发清理：识别并清理完全空闲的区域，并发进行。</li>\r</ul>\r\r<p>混合收集：对含有垃圾比例较高的Region进行回收。</p>\r\r<p>注意：G1当出现内存不足的的情况，也可能进行的FullGC回收。</p>\r\r<p>G1重要的参数：</p>\r\r<pre class="brush:java;">\r-XX:MaxGCPauseMillis：指定目标的最大停顿时间，G1尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间；\r-XX:ParallerGCThreads：设置GC的工作线程数量。</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 10),
(2067, '未来的垃圾回收技术', '2067', 1585817423, 1585817423, '<p>本文记录Java学习过程中遇到的未来的垃圾回收技术～</p>\r<!--more-->\r\r<p>关键技术：</p>\r\r<ul>\r	<li>有色指针（Colored Pointers）；</li>\r	<li>加载屏障（Load Barrier）。</li>\r</ul>\r\r<p>ZGC通过技术手段把stw的情况控制在仅有一次，就是第一次的初始标记才会发生，这样也就不难理解为什么GC停顿时间不随着堆增大而上升了，再大也是通过并发的时间去回收。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2069, 'G1-new.png', 'G1-new-png', 1586158711, 1586158711, 'a:5:{s:4:"name";s:10:"G1-new.png";s:4:"path";s:35:"/usr/uploads/2020/04/2540195182.png";s:4:"size";i:207411;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 6, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2066, 0),
(2070, 'G1-old.png', 'G1-old-png', 1586158757, 1586158757, 'a:5:{s:4:"name";s:10:"G1-old.png";s:4:"path";s:35:"/usr/uploads/2020/04/3053813421.png";s:4:"size";i:176437;s:4:"type";s:3:"png";s:4:"mime";s:9:"image/png";}', 7, 1, NULL, 'attachment', 'publish', NULL, 0, '1', '0', '1', 2066, 0),
(2071, 'Stop The World现象', '2071', 1586163108, 1586163108, '<p>本文记录Java学习过程中遇到的Stop The World现象～</p>\r<!--more-->\r\r<p>Stop The World现象：指的是GC的过程中停止用户线程的现象，GC收集器和GC使用调优的目标就是尽可能的减少STW的时间和次数。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class StopTheWorld {\r\r    // 不停地往list中填充数据\r    public static class FillListThread extends Thread{\r        List&lt;byte[]&gt; list = new LinkedList&lt;&gt;();\r        @Override\r        public void run() {\r            try {\r                while(true){\r                    if(list.size() * 512 / 1024 / 1024 &gt;= 990){\r                        list.clear();\r                        System.out.println(&quot;list is clear&quot;);\r                    }\r                    byte[] ba;\r                    for(int i=0; i &lt; 100; i++){\r                        ba = new byte[2*1024];\r                        list.add(ba);\r                    }\r                    Thread.sleep(1);\r                }\r\r            } catch (Exception e) {\r\r            }\r        }\r    }\r\r    // 每100ms打印当前耗时\r    public static class TimerThread extends Thread{\r        public final static long startTime = System.currentTimeMillis();\r        @Override\r        public void run() {\r            try {\r                while(true){\r                    long t =  System.currentTimeMillis()-startTime;\r                    System.out.println(t/1000 + &quot;.&quot; + t%1000);\r                    Thread.sleep(100);\r                }\r\r            } catch (Exception e) {\r            }\r        }\r    }\r\r    // JVM参数：-Xmx300M -Xms300M -XX:+UseSerialGC -XX:+PrintGCDetails\r    public static void main(String[] args) {\r        FillListThread myThread = new FillListThread();\r        TimerThread timerThread = new TimerThread();\r        myThread.start();\r        timerThread.start();\r    }\r\r}</pre>\r\r<p>示例结果：</p>\r\r<pre class="brush:bash;">\r7.559\r[Full GC (Allocation Failure) [Tenured: 204799K-&gt;204799K(204800K), 0.1936324 secs] 296959K-&gt;294141K(296960K), [Metaspace: 3321K-&gt;3321K(1056768K)], 0.1937117 secs] [Times: user=0.17 sys=0.00, real=0.20 secs] \r7.818\r[Full GC (Allocation Failure) [Tenured: 204799K-&gt;204799K(204800K), 0.2130953 secs] 296959K-&gt;296959K(296960K), [Metaspace: 3321K-&gt;3321K(1056768K)], 0.2131267 secs] [Times: user=0.16 sys=0.01, real=0.21 secs] \r[Full GC (Allocation Failure) [Tenured: 204799K-&gt;204799K(204800K), 0.1962960 secs] 296959K-&gt;296928K(296960K), [Metaspace: 3321K-&gt;3321K(1056768K)], 0.1963161 secs] [Times: user=0.18 sys=0.00, real=0.20 secs] \r8.300\r[Full GC (Allocation Failure) [Tenured: 204799K-&gt;204799K(204800K), 0.1613856 secs] 296959K-&gt;296958K(296960K), [Metaspace: 3321K-&gt;3321K(1056768K)], 0.1614146 secs] [Times: user=0.14 sys=0.00, real=0.16 secs] \r[Full GC (Allocation Failure) [Tenured: 204799K-&gt;204799K(204800K), 0.1432040 secs] 296958K-&gt;296958K(296960K), [Metaspace: 3321K-&gt;3321K(1056768K)], 0.1432276 secs] [Times: user=0.13 sys=0.00, real=0.15 secs] \r8.606</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2072, '内存分配与回收策略', '2072', 1586164429, 1586164429, '<p>本文记录Java学习过程中遇到的内存分配与回收策略～</p>\r<!--more-->\r\r<p>内存分配与回收策略包括：</p>\r\r<ul>\r	<li>对象优先在Eden分配：如果说Eden内存空间不足，就会发生Minor GC。</li>\r	<li>大对象直接进入老年代：大对象指的是需要大量连续内存空间的Java对象，比如很长的字符串和大型数组。导致的现象有：1、虽然内存有空间，但还需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。相关参数：-XX:PretenureSizeThreshold参数：大于这个数量直接在老年代分配（缺省为0，表示绝不会直接分配在老年代）；</li>\r	<li>长期存活的对象将进入老年代：相关参数：-XX:MaxTenuringThreshold默认15岁；</li>\r	<li>动态对象年龄判定：为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄；</li>\r	<li>空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把survivor无法容纳的对象直接进入老年代。只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则Full GC。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2073, '新生代配置', '2073', 1586167320, 1586167383, '<p>本文记录Java学习过程中遇到的新生代配置~</p>\r<!--more-->\r\r<p>新生代大小配置参数的优先级：</p>\r\r<ul>\r	<li>高：-XX:NewSize/MaxNewSize;</li>\r	<li>中: -Xmn（NewSize=MaxNewSize）</li>\r	<li>低：-XX:NewRatio表示比例，例如，2表示新生代:老年代=1:2</li>\r</ul>\r\r<p>-XX:SurvivorRatio表示Eden和Survivor的比值，缺省为8。表示Eden:FromSurvivor:ToSurvivor=8:1:1。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class NewSize {\r\r    /**\r     * 4组JVM参数：\r     * 1.-Xms20M -Xmx20M -XX:+PrintGCDetails &ndash;Xmn2m -XX:SurvivorRatio=2\r     * 2.-Xms20M -Xmx20M -XX:+PrintGCDetails -Xmn7m -XX:SurvivorRatio=2\r     * 3.-Xms20M -Xmx20M -XX:+PrintGCDetails -Xmn15m -XX:SurvivorRatio=8\r     * 4.-Xms20M -Xmx20M -XX:+PrintGCDetails -XX:NewRatio=2\r     */\r    public static void main(String[] args) {\r        // 1M大小\r        int cap = 1 * 1024 * 1024;\r\r        List byteList = new LinkedList&lt;byte[]&gt;();\r        // 慢慢地创建10个1M的对象\r        for (int i = 0; i &lt; 10; i++) {\r            byteList.add(new byte[cap]);\r        }\r    }\r\r}</pre>\r\r<p>示例参数：</p>\r\r<pre class="brush:java;">\r-Xms20M -Xmx20M -XX:+PrintGCDetails &ndash;Xmn2m -XX:SurvivorRatio=2\rHeap\r PSYoungGen      total 1536K, used 1173K [0x00000007bfe00000, 0x00000007c0000000, 0x00000007c0000000)\r  eden space 1024K, 69% used [0x00000007bfe00000,0x00000007bfeb1660,0x00000007bff00000)\r  from space 512K, 90% used [0x00000007bff00000,0x00000007bff74010,0x00000007bff80000)\r  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)\r ParOldGen       total 18432K, used 10240K [0x00000007bec00000, 0x00000007bfe00000, 0x00000007bfe00000)\r  object space 18432K, 55% used [0x00000007bec00000,0x00000007bf6000a0,0x00000007bfe00000)\r Metaspace       used 3306K, capacity 4496K, committed 4864K, reserved 1056768K\r  class space    used 365K, capacity 388K, committed 512K, reserved 1048576K</pre>\r\r<p>发生了一次垃圾回收，数组都在老年代。</p>\r\r<pre class="brush:java;">\r-Xms20M -Xmx20M -XX:+PrintGCDetails -Xmn7m -XX:SurvivorRatio=2\r[GC (Allocation Failure) [PSYoungGen: 3802K-&gt;1520K(5632K)] 3802K-&gt;2552K(18944K), 0.0015986 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] \r[GC (Allocation Failure) [PSYoungGen: 4713K-&gt;1504K(5632K)] 5745K-&gt;5616K(18944K), 0.0029725 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r[GC (Allocation Failure) [PSYoungGen: 4727K-&gt;1520K(5632K)] 8839K-&gt;8704K(18944K), 0.0022459 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] \rHeap\r PSYoungGen      total 5632K, used 3710K [0x00000007bf900000, 0x00000007c0000000, 0x00000007c0000000)\r  eden space 4096K, 53% used [0x00000007bf900000,0x00000007bfb23820,0x00000007bfd00000)\r  from space 1536K, 98% used [0x00000007bfd00000,0x00000007bfe7c020,0x00000007bfe80000)\r  to   space 1536K, 0% used [0x00000007bfe80000,0x00000007bfe80000,0x00000007c0000000)\r ParOldGen       total 13312K, used 7184K [0x00000007bec00000, 0x00000007bf900000, 0x00000007bf900000)\r  object space 13312K, 53% used [0x00000007bec00000,0x00000007bf304070,0x00000007bf900000)\r Metaspace       used 3292K, capacity 4496K, committed 4864K, reserved 1056768K\r  class space    used 363K, capacity 388K, committed 512K, reserved 1048576K</pre>\r\r<p>发生了垃圾回收，新生代存了部分数组，老年代也保存了部分数组，发生了晋升现象。</p>\r\r<pre class="brush:java;">\r-Xms20M -Xmx20M -XX:+PrintGCDetails -Xmn15m -XX:SurvivorRatio=2\r[GC (Allocation Failure) [PSYoungGen: 8027K-&gt;3568K(11776K)] 8027K-&gt;6664K(16896K), 0.0038696 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] \r[Full GC (Ergonomics) [PSYoungGen: 3568K-&gt;2363K(11776K)] [ParOldGen: 3096K-&gt;4185K(5120K)] 6664K-&gt;6549K(16896K), [Metaspace: 3283K-&gt;3283K(1056768K)], 0.0073336 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] \rHeap\r PSYoungGen      total 11776K, used 6700K [0x00000007bf100000, 0x00000007c0000000, 0x00000007c0000000)\r  eden space 8192K, 52% used [0x00000007bf100000,0x00000007bf53c308,0x00000007bf900000)\r  from space 3584K, 65% used [0x00000007bf900000,0x00000007bfb4ef40,0x00000007bfc80000)\r  to   space 3584K, 0% used [0x00000007bfc80000,0x00000007bfc80000,0x00000007c0000000)\r ParOldGen       total 5120K, used 4185K [0x00000007bec00000, 0x00000007bf100000, 0x00000007bf100000)\r  object space 5120K, 81% used [0x00000007bec00000,0x00000007bf016500,0x00000007bf100000)\r Metaspace       used 3290K, capacity 4496K, committed 4864K, reserved 1056768K\r  class space    used 363K, capacity 388K, committed 512K, reserved 1048576K</pre>\r\r<p>新生代可以放下所有的数组，老年代没放。</p>\r\r<pre class="brush:java;">\r-Xms20M -Xmx20M -XX:+PrintGCDetails -XX:NewRatio=2\r[GC (Allocation Failure) [PSYoungGen: 4945K-&gt;496K(6144K)] 4945K-&gt;3592K(19968K), 0.0070063 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] \r[GC (Allocation Failure) [PSYoungGen: 5781K-&gt;480K(6144K)] 8877K-&gt;8696K(19968K), 0.0035369 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r[Full GC (Ergonomics) [PSYoungGen: 480K-&gt;0K(6144K)] [ParOldGen: 8216K-&gt;8585K(13824K)] 8696K-&gt;8585K(19968K), [Metaspace: 3287K-&gt;3287K(1056768K)], 0.0067643 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] \rHeap\r PSYoungGen      total 6144K, used 2204K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000)\r  eden space 5632K, 39% used [0x00000007bf980000,0x00000007bfba73e8,0x00000007bff00000)\r  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)\r  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)\r ParOldGen       total 13824K, used 8585K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000)\r  object space 13824K, 62% used [0x00000007bec00000,0x00000007bf4624d0,0x00000007bf980000)\r Metaspace       used 3293K, capacity 4496K, committed 4864K, reserved 1056768K\r  class space    used 363K, capacity 388K, committed 512K, reserved 1048576K</pre>\r\r<p>发生了垃圾回收，出现了空间分配担保，而且发生了FullGC。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0),
(2074, '内存泄漏和内存溢出辨析', '2074', 1586185500, 1586185814, '<p>本文记录Java学习过程中遇到的内存泄漏和内存溢出辨析～</p>\r<!--more-->\r\r<p>内存泄漏和内存溢出的区别如下：</p>\r\r<ul>\r	<li>内存溢出：实实在在的内存空间不足导致。例如，将6L的水放到5L的水里；</li>\r	<li>内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况。例如，5L的桶里面有1L的沙子导致只有4L的容量。</li>\r</ul>\r\r<p>示例代码（内存泄露）：</p>\r\r<pre class="brush:java;">\rpublic class Stack {\r\r    public  Object[] elements;\r    // 指示器，指示当前栈顶的位置\r    private int size = 0;\r\r    private static final int Cap = 16;\r\r    public Stack() {\r        elements = new Object[Cap];\r    }\r\r    // 入栈\r    public void push(Object e){\r        elements[size] = e;\r        size++;\r    }\r\r    // 出栈\r    public Object pop(){\r        size = size-1;\r        Object o = elements[size];\r        // 防止内存泄露\r        elements[size] = null;\r        return o;\r    }\r\r    public static void main(String[] args) {\r        Stack stack = new Stack();\r        Object o = new Object();\r        System.out.println(&quot;o=&quot;+o);\r        stack.push(o);\r        Object o1 =  stack.pop();\r        System.out.println(&quot;o1=&quot;+o1);\r        // 看是否有内存泄露\r        System.out.println(stack.elements[0]);\r    }\r\r}\r</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2075, 'JDK常用工具——JPS', '2075', 1586187083, 1586187083, '<p>本文记录Java学习过程中遇到的JDK常用工具&mdash;&mdash;JPS～</p>\r<!--more-->\r\r<p>jps：列出当前机器上正在运行的虚拟机进程。</p>\r\r<p>常用参数：</p>\r\r<ul>\r	<li>-p: 仅仅显示VM标示，不显示jar、class和main参数等信息；</li>\r	<li>-m: 输出主函数传入的参数；</li>\r	<li>-l: 输出应用程序主类完整package名称或jar完整名称；</li>\r	<li>-v: 列出JVM参数，-Xms20m和Xmx50m是启动程序指定的JVM参数。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2076, 'JDK常用工具——JSTAT', '2076', 1586187618, 1586187618, '<p>本文记录Java学习过程中遇到的JDK常用工具&mdash;&mdash;JSTAT～</p>\r<!--more-->\r\r<p>jstat是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p>\r\r<p>示例命令（需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次）：</p>\r\r<pre class="brush:bash;">\rjstat-gc PID 250 20</pre>\r\r<p>常用参数：</p>\r\r<ul>\r	<li>-class：类加载器；</li>\r	<li>-compiler：JIT；</li>\r	<li>-gc：GC堆状态；</li>\r	<li>-gccapacity：各区大小；</li>\r	<li>-gccause：最近一次GC统计和原因；</li>\r	<li>-gcnew：新区统计；</li>\r	<li>-gcnewcapacity：新区大小；</li>\r	<li>-gcold：老区统计；</li>\r	<li>-gcoldcapacity：老区大小；</li>\r	<li>-gcpermcapacity：永久区大小；</li>\r	<li>-gcutil：GC统计汇总；</li>\r	<li>-printcompilation：HotSpot编译统计。</li>\r</ul>\r\r<p>显示参数：</p>\r\r<ul>\r	<li>S0C：年轻代中第一个survivor（幸存区）的容量 (字节)；&nbsp;</li>\r	<li>S1C：年轻代中第二个survivor（幸存区）的容量 (字节)；</li>\r	<li>S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节)；</li>\r	<li>S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节)；</li>\r	<li>EC：年轻代中Eden（伊甸园）的容量 (字节)；</li>\r	<li>EU：年轻代中Eden（伊甸园）目前已使用空间 (字节)；</li>\r	<li>OC：Old代的容量 (字节)；</li>\r	<li>OU：Old代目前已使用空间 (字节)；</li>\r	<li>PC：Perm(持久代)的容量 (字节)；</li>\r	<li>PU：Perm(持久代)目前已使用空间 (字节)；</li>\r	<li>YGC：从应用程序启动到采样时年轻代中gc次数；</li>\r	<li>YGCT：从应用程序启动到采样时年轻代中gc所用时间(s)；</li>\r	<li>FGC：从应用程序启动到采样时old代(全gc)gc次数；</li>\r	<li>FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s)；</li>\r	<li>GCT：从应用程序启动到采样时gc用的总时间(s)；</li>\r	<li>NGCMN：年轻代(young)中初始化(最小)的大小 (字节)；</li>\r	<li>NGCMX：年轻代(young)的最大容量 (字节)；</li>\r	<li>NGC：年轻代(young)中当前的容量 (字节)；</li>\r	<li>OGCMN：old代中初始化(最小)的大小 (字节)；</li>\r	<li>OGCMX：old代的最大容量 (字节)；</li>\r	<li>OGC：old代当前新生成的容量 (字节)；</li>\r	<li>PGCMN：perm代中初始化(最小)的大小 (字节)；</li>\r	<li>PGCMX：perm代的最大容量 (字节)；</li>\r	<li>PGC：perm代当前新生成的容量 (字节)；</li>\r	<li>S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比；</li>\r	<li>S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比；</li>\r	<li>E：年轻代中Eden（伊甸园）已使用的占当前容量百分比；</li>\r	<li>O：old代已使用的占当前容量百分比；</li>\r	<li>P：perm代已使用的占当前容量百分比；</li>\r	<li>S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (字节)；</li>\r	<li>S1CMX：年轻代中第二个survivor（幸存区）的最大容量 (字节)；</li>\r	<li>ECMX：年轻代中Eden（伊甸园）的最大容量 (字节)；</li>\r	<li>DSS：当前需要survivor（幸存区）的容量 (字节)（Eden区已满）；</li>\r	<li>TT：持有次数限制；</li>\r	<li>MTT：最大持有次数限制。</li>\r</ul>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 3),
(2077, 'JDK常用工具——JINFO', '2077', 1586229693, 1586229693, '<p>本文记录Java学习过程中遇到的JDK常用工具&mdash;&mdash;JINFO～</p>\r<!--more-->\r\r<p>jinfo用于查看和修改虚拟机的参数。</p>\r\r<p>常用参数：</p>\r\r<ul>\r	<li>&ndash;sysprops：可以查看由System.getProperties()取得的参数；</li>\r	<li>&ndash;flag：未被显式指定的参数的系统默认值；</li>\r	<li>&ndash;flags：显示虚拟机的参数；</li>\r	<li>&ndash;flag +/-[参数]：可以增加或者去除参数，但是仅限于由java -XX:+PrintFlagsFinal -version查询出来且为manageable的参数。</li>\r</ul>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class JInfoTest {\r\r    // JVM参数：-Xmx20M -Xms20M -Xmn2M -XX:+PrintGC\r    // jinfo -flag +PrintGCDetails PID\r    public static void main(String[] args) {\r        while (true) {\r            byte[] b = null;\r            for (int i=0; i &lt; 10; i++) {\r                b = new byte[1 * 1024 * 1024];\r            }\r            try {\r                Thread.sleep(5 * 1000);\r            } catch (InterruptedException e) {\r                e.printStackTrace();\r            }\r        }\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2078, 'JDK常用工具——JMAP与JHAT', '2078', 1586230038, 1586230038, '<p>本文记录Java学习过程中遇到的JDK常用工具&mdash;&mdash;JMAP与JHAT～</p>\r<!--more-->\r\r<p>jmap用于生成堆转储快照（一般称为heapdump或dump文件）。它作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:java;">\rjmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</pre>\r\r<p>Sun JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。</p>\r\r<p>使用格式：</p>\r\r<pre class="brush:bash;">\rjhat dumpfile</pre>\r\r<p>后屏幕显示&ldquo;Server is ready.&rdquo;的提示后，用户在浏览器中键入http://localhost:7000/就可以访问详情。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 2),
(2079, 'JDK常用工具——JSTACK', '2079', 1586233560, 1586233577, '<p>本文记录Java学习过程中遇到的JDK常用工具&mdash;&mdash;JSTACK～</p>\r<!--more-->\r\r<p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。</p>\r\r<p>在代码中可以用java.lang.Thread类的getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。</p>\r\r<p>示例代码：</p>\r\r<pre class="brush:java;">\rpublic class JStack {\r\r    public static void main(String[] args) {\r        Map&lt;Thread, StackTraceElement[]&gt; allStackTraces = Thread.getAllStackTraces();\r        for (Map.Entry&lt;Thread, StackTraceElement[]&gt; stackTrace : allStackTraces.entrySet()) {\r            Thread thread = stackTrace.getKey();\r            System.out.println(thread.getName() + &quot;_&quot; + thread.getId());\r            StackTraceElement[] stackTraceElements = stackTrace.getValue();\r            for (StackTraceElement stackTraceElement : stackTraceElements) {\r                System.out.println(stackTraceElement);\r            }\r        }\r    }\r\r}</pre>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2080, 'JDK常用工具——JConsole与VisualVM', '2080', 1586233860, 1586233943, '<p>本文记录Java学习过程中遇到的JDK常用工具&mdash;&mdash;JConsole与VisualVM～</p>\r<!--more-->\r\r<p>管理远程进程需要在远程程序的启动参数中增加：</p>\r\r<pre class="brush:java;">\r-Djava.rmi.server.hostname=xxx\r-Dcom.sun.management.jmxremote\r-Dcom.sun.management.jmxremote.port=xxx\r-Dcom.sun.management.jmxremote.authenticate=false\r-Dcom.sun.management.jmxremote.ssl=false</pre>\r\r<p>VisualVM插件中心地址：<a href="https://visualvm.github.io">https://visualvm.github.io</a></p>\r\r<p>要注意版本问题，不同的JDK所带的visualvm是不一样的，下载插件时需要下对应的版本。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 1),
(2082, '浅堆和深堆', '2082', 1586234060, 1586234060, '<p>本文记录Java学习过程中遇到的浅堆和深堆～</p>\r<!--more-->\r\r<p>浅堆：（Shallow-Heap）是指一个对象所消耗的内存。例如，在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。</p>\r\r<p>深堆：这个对象被GC回收后，可以真实释放的内存大小，也就是只能通过对象被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象所持有的对象的集合。深堆是指对象的保留集中所有的对象的浅堆大小之和。</p>\r\r<p>举例：对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p>\r', 0, 1, NULL, 'post', 'publish', NULL, 0, '0', '0', '0', 0, 0);

-- --------------------------------------------------------

--
-- 表的结构 `typecho_fields`
--

CREATE TABLE IF NOT EXISTS `typecho_fields` (
  `cid` int(10) unsigned NOT NULL,
  `name` varchar(200) NOT NULL,
  `type` varchar(8) DEFAULT 'str',
  `str_value` text,
  `int_value` int(10) DEFAULT '0',
  `float_value` float DEFAULT '0',
  PRIMARY KEY (`cid`,`name`),
  KEY `int_value` (`int_value`),
  KEY `float_value` (`float_value`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- --------------------------------------------------------

--
-- 表的结构 `typecho_metas`
--

CREATE TABLE IF NOT EXISTS `typecho_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL,
  `description` varchar(200) DEFAULT NULL,
  `count` int(10) unsigned DEFAULT '0',
  `order` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=43 ;

--
-- 转存表中的数据 `typecho_metas`
--

INSERT INTO `typecho_metas` (`mid`, `name`, `slug`, `type`, `description`, `count`, `order`, `parent`) VALUES
(1, 'IT', 'it', 'category', NULL, 51, 1, 0),
(2, 'Linux', 'linux', 'category', NULL, 104, 2, 0),
(4, 'Oracle', 'oracle', 'category', NULL, 28, 3, 0),
(6, 'PHP', 'php', 'category', NULL, 2, 4, 0),
(9, 'Java', 'java', 'category', NULL, 792, 5, 0),
(10, 'Python', 'python', 'category', NULL, 0, 6, 0),
(23, 'MySQL', 'mysql', 'category', NULL, 47, 8, 0),
(26, '软件测试', 'qa', 'category', NULL, 2, 9, 0),
(27, 'TCP/IP', 'network', 'category', NULL, 7, 10, 0),
(28, 'WEB前端', 'fe', 'category', NULL, 77, 11, 0),
(29, 'Redis', 'redis', 'category', NULL, 19, 12, 0),
(30, 'SpringMVC', 'SpringMVC', 'tag', NULL, 5, 0, 0),
(31, 'Spring', 'Spring', 'tag', NULL, 5, 0, 0),
(32, 'Servlet', 'Servlet', 'tag', NULL, 2, 0, 0),
(33, 'IOC', 'IOC', 'tag', NULL, 1, 0, 0),
(34, 'AOP', 'AOP', 'tag', NULL, 1, 0, 0),
(35, 'Ping', 'Ping', 'tag', NULL, 1, 0, 0),
(36, 'JDBC', 'JDBC', 'tag', NULL, 1, 0, 0),
(37, 'ORM', 'ORM', 'tag', NULL, 2, 0, 0),
(38, 'Hibernate', 'Hibernate', 'tag', NULL, 1, 0, 0),
(39, 'MyBatis', 'MyBatis', 'tag', NULL, 11, 0, 0),
(40, 'Gradle', 'gradle', 'category', NULL, 0, 13, 0),
(41, 'Gradle', 'Gradle', 'tag', NULL, 1, 0, 0),
(42, 'Groovy', 'Groovy', 'tag', NULL, 3, 0, 0);

-- --------------------------------------------------------

--
-- 表的结构 `typecho_options`
--

CREATE TABLE IF NOT EXISTS `typecho_options` (
  `name` varchar(32) NOT NULL,
  `user` int(10) unsigned NOT NULL DEFAULT '0',
  `value` text,
  PRIMARY KEY (`name`,`user`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `typecho_options`
--

INSERT INTO `typecho_options` (`name`, `user`, `value`) VALUES
('theme', 0, 'Bytecats2'),
('timezone', 0, '28800'),
('lang', 0, NULL),
('charset', 0, 'UTF-8'),
('contentType', 0, 'text/html'),
('gzip', 0, '0'),
('generator', 0, 'Typecho 1.2/18.1.29'),
('title', 0, 'Oliver''s Blog'),
('description', 0, '小菜鸟要努力学习哦'),
('keywords', 0, 'Oliver''s Blog,檀香学习笔记,小菜鸟要努力学习哦'),
('rewrite', 0, '1'),
('frontPage', 0, 'recent'),
('frontArchive', 0, '0'),
('commentsRequireMail', 0, '1'),
('commentsWhitelist', 0, '0'),
('commentsRequireURL', 0, '0'),
('commentsRequireModeration', 0, '1'),
('plugins', 0, 'a:2:{s:9:"activated";a:5:{s:10:"RobotsPlus";a:1:{s:7:"handles";a:1:{s:21:"Widget_Archive:header";a:1:{i:0;a:2:{i:0;s:17:"RobotsPlus_Plugin";i:1;s:5:"isbot";}}}}s:11:"BaiduSubmit";a:1:{s:7:"handles";a:2:{s:39:"Widget_Contents_Post_Edit:finishPublish";a:1:{i:0;a:2:{i:0;s:18:"BaiduSubmit_Action";i:1;s:4:"send";}}s:39:"Widget_Contents_Page_Edit:finishPublish";a:1:{i:0;a:2:{i:0;s:18:"BaiduSubmit_Action";i:1;s:4:"send";}}}}s:8:"CkEditor";a:1:{s:7:"handles";a:4:{s:31:"admin/write-post.php:richEditor";a:1:{i:0;a:2:{i:0;s:15:"CkEditor_Plugin";i:1;s:6:"render";}}s:31:"admin/write-page.php:richEditor";a:1:{i:0;a:2:{i:0;s:15:"CkEditor_Plugin";i:1;s:6:"render";}}s:31:"Widget_Contents_Post_Edit:write";a:1:{i:0;a:2:{i:0;s:15:"CkEditor_Plugin";i:1;s:6:"filter";}}s:31:"Widget_Contents_Page_Edit:write";a:1:{i:0;a:2:{i:0;s:15:"CkEditor_Plugin";i:1;s:6:"filter";}}}}s:4:"Stat";a:1:{s:7:"handles";a:2:{s:27:"Widget_Archive:singleHandle";a:1:{i:0;a:2:{i:0;s:11:"Stat_Plugin";i:1;s:12:"singleHandle";}}s:21:"Widget_Archive:select";a:1:{i:0;a:2:{i:0;s:11:"Stat_Plugin";i:1;s:12:"selectHandle";}}}}s:3:"AMP";a:1:{s:7:"handles";a:2:{s:39:"Widget_Contents_Post_Edit:finishPublish";a:1:{i:0;a:2:{i:0;s:10:"AMP_Action";i:1;s:12:"sendRealtime";}}s:21:"Widget_Archive:header";a:1:{i:0;a:2:{i:0;s:10:"AMP_Action";i:1;s:8:"headlink";}}}}}s:7:"handles";a:9:{s:21:"Widget_Archive:header";a:2:{i:0;a:2:{i:0;s:17:"RobotsPlus_Plugin";i:1;s:5:"isbot";}s:5:"0.001";a:2:{i:0;s:10:"AMP_Action";i:1;s:8:"headlink";}}s:39:"Widget_Contents_Post_Edit:finishPublish";a:2:{i:0;a:2:{i:0;s:18:"BaiduSubmit_Action";i:1;s:4:"send";}s:5:"0.001";a:2:{i:0;s:10:"AMP_Action";i:1;s:12:"sendRealtime";}}s:39:"Widget_Contents_Page_Edit:finishPublish";a:1:{i:0;a:2:{i:0;s:18:"BaiduSubmit_Action";i:1;s:4:"send";}}s:31:"admin/write-post.php:richEditor";a:1:{i:0;a:2:{i:0;s:15:"CkEditor_Plugin";i:1;s:6:"render";}}s:31:"admin/write-page.php:richEditor";a:1:{i:0;a:2:{i:0;s:15:"CkEditor_Plugin";i:1;s:6:"render";}}s:31:"Widget_Contents_Post_Edit:write";a:1:{i:0;a:2:{i:0;s:15:"CkEditor_Plugin";i:1;s:6:"filter";}}s:31:"Widget_Contents_Page_Edit:write";a:1:{i:0;a:2:{i:0;s:15:"CkEditor_Plugin";i:1;s:6:"filter";}}s:27:"Widget_Archive:singleHandle";a:1:{i:0;a:2:{i:0;s:11:"Stat_Plugin";i:1;s:12:"singleHandle";}}s:21:"Widget_Archive:select";a:1:{i:0;a:2:{i:0;s:11:"Stat_Plugin";i:1;s:12:"selectHandle";}}}}'),
('commentDateFormat', 0, 'F jS, Y \\a\\t h:i a'),
('siteUrl', 0, 'http://www.oliver.ren'),
('defaultCategory', 0, '1'),
('allowRegister', 0, '0'),
('defaultAllowComment', 0, '1'),
('defaultAllowPing', 0, '1'),
('defaultAllowFeed', 0, '1'),
('pageSize', 0, '9'),
('postsListSize', 0, '9'),
('commentsListSize', 0, '3'),
('commentsHTMLTagAllowed', 0, NULL),
('postDateFormat', 0, 'Y-m-d'),
('feedFullText', 0, '0'),
('editorSize', 0, '350'),
('autoSave', 0, '0'),
('markdown', 0, '1'),
('commentsMaxNestingLevels', 0, '5'),
('commentsPostTimeout', 0, '2592000'),
('commentsUrlNofollow', 0, '1'),
('commentsShowUrl', 0, '1'),
('commentsMarkdown', 0, '0'),
('commentsPageBreak', 0, '0'),
('commentsThreaded', 0, '1'),
('commentsPageSize', 0, '20'),
('commentsPageDisplay', 0, 'last'),
('commentsOrder', 0, 'ASC'),
('commentsCheckReferer', 0, '1'),
('commentsAutoClose', 0, '0'),
('commentsPostIntervalEnable', 0, '1'),
('commentsPostInterval', 0, '60'),
('commentsShowCommentOnly', 0, '1'),
('commentsAvatar', 0, '1'),
('commentsAvatarRating', 0, 'G'),
('commentsAntiSpam', 0, '1'),
('routingTable', 0, 'a:35:{i:0;a:34:{s:5:"index";a:6:{s:3:"url";s:1:"/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:8:"|^[/]?$|";s:6:"format";s:1:"/";s:6:"params";a:0:{}}s:7:"archive";a:6:{s:3:"url";s:6:"/blog/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:13:"|^/blog[/]?$|";s:6:"format";s:6:"/blog/";s:6:"params";a:0:{}}s:2:"do";a:6:{s:3:"url";s:22:"/action/[action:alpha]";s:6:"widget";s:9:"Widget_Do";s:6:"action";s:6:"action";s:4:"regx";s:32:"|^/action/([_0-9a-zA-Z-]+)[/]?$|";s:6:"format";s:10:"/action/%s";s:6:"params";a:1:{i:0;s:6:"action";}}s:4:"post";a:6:{s:3:"url";s:23:"/[category]/[slug].html";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:30:"|^/([^/]+)/([^/]+)\\.html[/]?$|";s:6:"format";s:11:"/%s/%s.html";s:6:"params";a:2:{i:0;s:8:"category";i:1;s:4:"slug";}}s:10:"attachment";a:6:{s:3:"url";s:26:"/attachment/[cid:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:28:"|^/attachment/([0-9]+)[/]?$|";s:6:"format";s:15:"/attachment/%s/";s:6:"params";a:1:{i:0;s:3:"cid";}}s:8:"category";a:6:{s:3:"url";s:12:"/[slug].html";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:22:"|^/([^/]+)\\.html[/]?$|";s:6:"format";s:8:"/%s.html";s:6:"params";a:1:{i:0;s:4:"slug";}}s:3:"tag";a:6:{s:3:"url";s:12:"/tag/[slug]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:20:"|^/tag/([^/]+)[/]?$|";s:6:"format";s:8:"/tag/%s/";s:6:"params";a:1:{i:0;s:4:"slug";}}s:6:"author";a:6:{s:3:"url";s:22:"/author/[uid:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:24:"|^/author/([0-9]+)[/]?$|";s:6:"format";s:11:"/author/%s/";s:6:"params";a:1:{i:0;s:3:"uid";}}s:6:"search";a:6:{s:3:"url";s:19:"/search/[keywords]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:23:"|^/search/([^/]+)[/]?$|";s:6:"format";s:11:"/search/%s/";s:6:"params";a:1:{i:0;s:8:"keywords";}}s:10:"index_page";a:6:{s:3:"url";s:21:"/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:22:"|^/page/([0-9]+)[/]?$|";s:6:"format";s:9:"/page/%s/";s:6:"params";a:1:{i:0;s:4:"page";}}s:12:"archive_page";a:6:{s:3:"url";s:26:"/blog/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:27:"|^/blog/page/([0-9]+)[/]?$|";s:6:"format";s:14:"/blog/page/%s/";s:6:"params";a:1:{i:0;s:4:"page";}}s:13:"category_page";a:6:{s:3:"url";s:28:"/[slug].html/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:31:"|^/([^/]+)\\.html/([0-9]+)[/]?$|";s:6:"format";s:12:"/%s.html/%s/";s:6:"params";a:2:{i:0;s:4:"slug";i:1;s:4:"page";}}s:8:"tag_page";a:6:{s:3:"url";s:27:"/tag/[slug]/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:29:"|^/tag/([^/]+)/([0-9]+)[/]?$|";s:6:"format";s:11:"/tag/%s/%s/";s:6:"params";a:2:{i:0;s:4:"slug";i:1;s:4:"page";}}s:11:"author_page";a:6:{s:3:"url";s:37:"/author/[uid:digital]/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:33:"|^/author/([0-9]+)/([0-9]+)[/]?$|";s:6:"format";s:14:"/author/%s/%s/";s:6:"params";a:2:{i:0;s:3:"uid";i:1;s:4:"page";}}s:11:"search_page";a:6:{s:3:"url";s:34:"/search/[keywords]/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:32:"|^/search/([^/]+)/([0-9]+)[/]?$|";s:6:"format";s:14:"/search/%s/%s/";s:6:"params";a:2:{i:0;s:8:"keywords";i:1;s:4:"page";}}s:12:"archive_year";a:6:{s:3:"url";s:18:"/[year:digital:4]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:19:"|^/([0-9]{4})[/]?$|";s:6:"format";s:4:"/%s/";s:6:"params";a:1:{i:0;s:4:"year";}}s:13:"archive_month";a:6:{s:3:"url";s:36:"/[year:digital:4]/[month:digital:2]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:30:"|^/([0-9]{4})/([0-9]{2})[/]?$|";s:6:"format";s:7:"/%s/%s/";s:6:"params";a:2:{i:0;s:4:"year";i:1;s:5:"month";}}s:11:"archive_day";a:6:{s:3:"url";s:52:"/[year:digital:4]/[month:digital:2]/[day:digital:2]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:41:"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})[/]?$|";s:6:"format";s:10:"/%s/%s/%s/";s:6:"params";a:3:{i:0;s:4:"year";i:1;s:5:"month";i:2;s:3:"day";}}s:17:"archive_year_page";a:6:{s:3:"url";s:38:"/[year:digital:4]/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:33:"|^/([0-9]{4})/page/([0-9]+)[/]?$|";s:6:"format";s:12:"/%s/page/%s/";s:6:"params";a:2:{i:0;s:4:"year";i:1;s:4:"page";}}s:18:"archive_month_page";a:6:{s:3:"url";s:56:"/[year:digital:4]/[month:digital:2]/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:44:"|^/([0-9]{4})/([0-9]{2})/page/([0-9]+)[/]?$|";s:6:"format";s:15:"/%s/%s/page/%s/";s:6:"params";a:3:{i:0;s:4:"year";i:1;s:5:"month";i:2;s:4:"page";}}s:16:"archive_day_page";a:6:{s:3:"url";s:72:"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:55:"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})/page/([0-9]+)[/]?$|";s:6:"format";s:18:"/%s/%s/%s/page/%s/";s:6:"params";a:4:{i:0;s:4:"year";i:1;s:5:"month";i:2;s:3:"day";i:3;s:4:"page";}}s:12:"comment_page";a:6:{s:3:"url";s:53:"[permalink:string]/comment-page-[commentPage:digital]";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:36:"|^(.+)/comment\\-page\\-([0-9]+)[/]?$|";s:6:"format";s:18:"%s/comment-page-%s";s:6:"params";a:2:{i:0;s:9:"permalink";i:1;s:11:"commentPage";}}s:4:"feed";a:6:{s:3:"url";s:20:"/feed[feed:string:0]";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:4:"feed";s:4:"regx";s:17:"|^/feed(.*)[/]?$|";s:6:"format";s:7:"/feed%s";s:6:"params";a:1:{i:0;s:4:"feed";}}s:8:"feedback";a:6:{s:3:"url";s:31:"[permalink:string]/[type:alpha]";s:6:"widget";s:15:"Widget_Feedback";s:6:"action";s:6:"action";s:4:"regx";s:29:"|^(.+)/([_0-9a-zA-Z-]+)[/]?$|";s:6:"format";s:5:"%s/%s";s:6:"params";a:2:{i:0;s:9:"permalink";i:1;s:4:"type";}}s:4:"page";a:6:{s:3:"url";s:12:"/[slug].html";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";s:4:"regx";s:22:"|^/([^/]+)\\.html[/]?$|";s:6:"format";s:8:"/%s.html";s:6:"params";a:1:{i:0;s:4:"slug";}}s:13:"baidu_sitemap";a:6:{s:3:"url";s:18:"/baidu_sitemap.xml";s:6:"widget";s:18:"BaiduSubmit_Action";s:6:"action";s:7:"sitemap";s:4:"regx";s:27:"|^/baidu_sitemap\\.xml[/]?$|";s:6:"format";s:18:"/baidu_sitemap.xml";s:6:"params";a:0:{}}s:22:"baidu_sitemap_advanced";a:6:{s:3:"url";s:29:"/admin/baidu_sitemap/advanced";s:6:"widget";s:18:"BaiduSubmit_Action";s:6:"action";s:8:"send_all";s:4:"regx";s:37:"|^/admin/baidu_sitemap/advanced[/]?$|";s:6:"format";s:29:"/admin/baidu_sitemap/advanced";s:6:"params";a:0:{}}s:9:"amp_index";a:6:{s:3:"url";s:10:"/ampindex/";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:8:"AMPindex";s:4:"regx";s:17:"|^/ampindex[/]?$|";s:6:"format";s:10:"/ampindex/";s:6:"params";a:0:{}}s:7:"amp_map";a:6:{s:3:"url";s:13:"/amp/[target]";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:7:"AMPpage";s:4:"regx";s:20:"|^/amp/([^/]+)[/]?$|";s:6:"format";s:7:"/amp/%s";s:6:"params";a:1:{i:0;s:6:"target";}}s:8:"amp_list";a:6:{s:3:"url";s:19:"/amp/list/[list_id]";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:7:"AMPlist";s:4:"regx";s:25:"|^/amp/list/([^/]+)[/]?$|";s:6:"format";s:12:"/amp/list/%s";s:6:"params";a:1:{i:0;s:7:"list_id";}}s:7:"mip_map";a:6:{s:3:"url";s:13:"/mip/[target]";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:7:"MIPpage";s:4:"regx";s:20:"|^/mip/([^/]+)[/]?$|";s:6:"format";s:7:"/mip/%s";s:6:"params";a:1:{i:0;s:6:"target";}}s:11:"amp_sitemap";a:6:{s:3:"url";s:16:"/amp_sitemap.xml";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:10:"ampsitemap";s:4:"regx";s:25:"|^/amp_sitemap\\.xml[/]?$|";s:6:"format";s:16:"/amp_sitemap.xml";s:6:"params";a:0:{}}s:11:"mip_sitemap";a:6:{s:3:"url";s:16:"/mip_sitemap.xml";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:10:"mipsitemap";s:4:"regx";s:25:"|^/mip_sitemap\\.xml[/]?$|";s:6:"format";s:16:"/mip_sitemap.xml";s:6:"params";a:0:{}}s:11:"clean_cache";a:6:{s:3:"url";s:12:"/clean_cache";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:10:"cleancache";s:4:"regx";s:20:"|^/clean_cache[/]?$|";s:6:"format";s:12:"/clean_cache";s:6:"params";a:0:{}}}s:5:"index";a:3:{s:3:"url";s:1:"/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:7:"archive";a:3:{s:3:"url";s:6:"/blog/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:2:"do";a:3:{s:3:"url";s:22:"/action/[action:alpha]";s:6:"widget";s:9:"Widget_Do";s:6:"action";s:6:"action";}s:4:"post";a:3:{s:3:"url";s:23:"/[category]/[slug].html";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:10:"attachment";a:3:{s:3:"url";s:26:"/attachment/[cid:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:8:"category";a:3:{s:3:"url";s:12:"/[slug].html";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:3:"tag";a:3:{s:3:"url";s:12:"/tag/[slug]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:6:"author";a:3:{s:3:"url";s:22:"/author/[uid:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:6:"search";a:3:{s:3:"url";s:19:"/search/[keywords]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:10:"index_page";a:3:{s:3:"url";s:21:"/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:12:"archive_page";a:3:{s:3:"url";s:26:"/blog/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:13:"category_page";a:3:{s:3:"url";s:28:"/[slug].html/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:8:"tag_page";a:3:{s:3:"url";s:27:"/tag/[slug]/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:11:"author_page";a:3:{s:3:"url";s:37:"/author/[uid:digital]/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:11:"search_page";a:3:{s:3:"url";s:34:"/search/[keywords]/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:12:"archive_year";a:3:{s:3:"url";s:18:"/[year:digital:4]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:13:"archive_month";a:3:{s:3:"url";s:36:"/[year:digital:4]/[month:digital:2]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:11:"archive_day";a:3:{s:3:"url";s:52:"/[year:digital:4]/[month:digital:2]/[day:digital:2]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:17:"archive_year_page";a:3:{s:3:"url";s:38:"/[year:digital:4]/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:18:"archive_month_page";a:3:{s:3:"url";s:56:"/[year:digital:4]/[month:digital:2]/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:16:"archive_day_page";a:3:{s:3:"url";s:72:"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:12:"comment_page";a:3:{s:3:"url";s:53:"[permalink:string]/comment-page-[commentPage:digital]";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:4:"feed";a:3:{s:3:"url";s:20:"/feed[feed:string:0]";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:4:"feed";}s:8:"feedback";a:3:{s:3:"url";s:31:"[permalink:string]/[type:alpha]";s:6:"widget";s:15:"Widget_Feedback";s:6:"action";s:6:"action";}s:4:"page";a:3:{s:3:"url";s:12:"/[slug].html";s:6:"widget";s:14:"Widget_Archive";s:6:"action";s:6:"render";}s:13:"baidu_sitemap";a:3:{s:3:"url";s:18:"/baidu_sitemap.xml";s:6:"widget";s:18:"BaiduSubmit_Action";s:6:"action";s:7:"sitemap";}s:22:"baidu_sitemap_advanced";a:3:{s:3:"url";s:29:"/admin/baidu_sitemap/advanced";s:6:"widget";s:18:"BaiduSubmit_Action";s:6:"action";s:8:"send_all";}s:9:"amp_index";a:3:{s:3:"url";s:10:"/ampindex/";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:8:"AMPindex";}s:7:"amp_map";a:3:{s:3:"url";s:13:"/amp/[target]";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:7:"AMPpage";}s:8:"amp_list";a:3:{s:3:"url";s:19:"/amp/list/[list_id]";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:7:"AMPlist";}s:7:"mip_map";a:3:{s:3:"url";s:13:"/mip/[target]";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:7:"MIPpage";}s:11:"amp_sitemap";a:3:{s:3:"url";s:16:"/amp_sitemap.xml";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:10:"ampsitemap";}s:11:"mip_sitemap";a:3:{s:3:"url";s:16:"/mip_sitemap.xml";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:10:"mipsitemap";}s:11:"clean_cache";a:3:{s:3:"url";s:12:"/clean_cache";s:6:"widget";s:10:"AMP_Action";s:6:"action";s:10:"cleancache";}}'),
('plugin:AMP', 0, 'a:12:{s:9:"cacheTime";s:2:"24";s:8:"baiduAPI";s:72:"http://data.zz.baidu.com/urls?site=www.oliver.ren&token=sSMtTkZPt86zWCT0";s:10:"baiduAPPID";s:16:"1602767415797591";s:10:"baiduTOKEN";s:16:"bNiWczi1sv6QseH3";s:10:"ampSiteMap";s:1:"1";s:10:"mipSiteMap";s:1:"1";s:8:"ampIndex";s:1:"1";s:13:"mipAutoSubmit";s:1:"1";s:14:"OnlyForSpiders";s:1:"0";s:10:"defaultPIC";s:63:"https://holmesian.org/usr/themes/Holmesian/images/holmesian.png";s:4:"LOGO";s:63:"https://holmesian.org/usr/themes/Holmesian/images/holmesian.png";s:7:"PostURL";s:21:"http://www.oliver.ren";}'),
('actionTable', 0, 'a:0:{}'),
('panelTable', 0, 'a:2:{s:5:"child";a:1:{i:1;a:3:{i:0;a:6:{i:0;s:12:"蜘蛛日志";i:1;s:18:"查看蜘蛛日志";i:2;s:41:"extending.php?panel=RobotsPlus%2FLogs.php";i:3;s:13:"administrator";i:4;b:0;i:5;s:0:"";}i:1;a:6:{i:0;s:21:"百度结构化日志";i:1;s:21:"百度结构化日志";i:2;s:42:"extending.php?panel=BaiduSubmit%2FLogs.php";i:3;s:13:"administrator";i:4;b:0;i:5;s:0:"";}i:2;a:6:{i:0;s:19:"AMP/MIP自动提交";i:1;s:12:"自动提交";i:2;s:35:"extending.php?panel=AMP%2FLinks.php";i:3;s:13:"administrator";i:4;b:0;i:5;s:0:"";}}}s:4:"file";a:3:{i:0;s:21:"RobotsPlus%2FLogs.php";i:1;s:22:"BaiduSubmit%2FLogs.php";i:2;s:15:"AMP%2FLinks.php";}}'),
('attachmentTypes', 0, '@image@,@media@,@doc@'),
('secret', 0, 'g4nkDu)12bwamFuWECZo*lPS5FEa^Wac'),
('plugin:BaiduSubmit', 0, 'a:3:{s:3:"api";s:72:"http://data.zz.baidu.com/urls?site=www.oliver.ren&token=sSMtTkZPt86zWCT0";s:5:"group";s:2:"10";s:6:"delete";s:1:"0";}'),
('markdown', 1, '0'),
('defaultAllowComment', 1, '0'),
('defaultAllowPing', 1, '0'),
('defaultAllowFeed', 1, '0'),
('autoSave', 1, '1'),
('plugin:RobotsPlus', 0, 'a:3:{s:7:"botlist";a:8:{i:0;s:5:"baidu";i:1;s:6:"google";i:2;s:5:"sogou";i:3;s:6:"youdao";i:4;s:4:"soso";i:5;s:4:"bing";i:6;s:5:"yahoo";i:7;s:3:"360";}s:9:"pagecount";s:2:"10";s:9:"droptable";s:1:"1";}'),
('xmlrpcMarkdown', 0, '0'),
('installed', 0, '1'),
('allowXmlRpc', 0, '2'),
('theme:Bytecats2', 0, 'a:3:{s:7:"logoUrl";s:0:"";s:12:"sidebarBlock";a:4:{i:0;s:10:"ShowSearch";i:1;s:12:"ShowCategory";i:2;s:11:"ShowArchive";i:3;s:8:"ShowTags";}s:3:"css";s:6:"purple";}');

-- --------------------------------------------------------

--
-- 表的结构 `typecho_pagecache`
--

CREATE TABLE IF NOT EXISTS `typecho_pagecache` (
  `hash` varchar(200) NOT NULL,
  `cache` longtext NOT NULL,
  `dateline` int(10) NOT NULL DEFAULT '0',
  `expire` int(8) NOT NULL DEFAULT '0',
  UNIQUE KEY `hash` (`hash`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- --------------------------------------------------------

--
-- 表的结构 `typecho_relationships`
--

CREATE TABLE IF NOT EXISTS `typecho_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `typecho_relationships`
--

INSERT INTO `typecho_relationships` (`cid`, `mid`) VALUES
(4, 2),
(15, 2),
(16, 2),
(16, 4),
(19, 6),
(20, 1),
(21, 1),
(21, 2),
(28, 2),
(28, 35),
(30, 2),
(75, 2),
(76, 6),
(90, 2),
(92, 2),
(93, 2),
(94, 2),
(95, 2),
(96, 2),
(106, 2),
(107, 2),
(108, 2),
(109, 2),
(110, 2),
(111, 2),
(112, 2),
(113, 2),
(114, 2),
(115, 2),
(116, 2),
(117, 2),
(118, 2),
(119, 2),
(121, 2),
(122, 2),
(124, 2),
(125, 2),
(128, 2),
(129, 2),
(130, 2),
(131, 2),
(132, 2),
(133, 2),
(134, 2),
(135, 2),
(136, 2),
(141, 2),
(142, 2),
(143, 2),
(144, 2),
(145, 2),
(146, 2),
(167, 2),
(172, 2),
(182, 2),
(189, 2),
(190, 2),
(191, 2),
(192, 2),
(193, 2),
(194, 2),
(195, 1),
(196, 2),
(198, 2),
(288, 1),
(308, 2),
(309, 2),
(310, 2),
(329, 2),
(330, 1),
(331, 1),
(332, 1),
(333, 1),
(334, 1),
(335, 1),
(337, 1),
(340, 1),
(342, 1),
(343, 1),
(344, 1),
(345, 23),
(346, 23),
(347, 23),
(348, 23),
(353, 23),
(354, 23),
(356, 23),
(357, 2),
(358, 2),
(359, 2),
(360, 23),
(361, 23),
(362, 23),
(364, 23),
(365, 23),
(366, 23),
(367, 23),
(368, 23),
(369, 1),
(371, 1),
(372, 23),
(373, 23),
(374, 23),
(375, 23),
(376, 2),
(379, 2),
(380, 2),
(383, 2),
(384, 9),
(385, 2),
(386, 2),
(387, 2),
(388, 1),
(389, 2),
(394, 23),
(395, 23),
(402, 23),
(405, 2),
(406, 1),
(407, 1),
(408, 1),
(410, 1),
(411, 1),
(412, 2),
(413, 2),
(414, 2),
(415, 2),
(416, 2),
(417, 2),
(418, 2),
(420, 1),
(421, 1),
(423, 2),
(425, 2),
(426, 2),
(427, 2),
(429, 2),
(431, 2),
(432, 2),
(433, 2),
(435, 2),
(436, 2),
(437, 2),
(438, 2),
(439, 2),
(440, 2),
(442, 2),
(443, 2),
(444, 2),
(445, 2),
(446, 2),
(447, 2),
(448, 2),
(449, 2),
(451, 2),
(452, 2),
(453, 2),
(455, 9),
(461, 1),
(466, 9),
(467, 9),
(468, 26),
(469, 26),
(471, 9),
(472, 1),
(473, 9),
(475, 9),
(476, 9),
(497, 9),
(498, 9),
(500, 9),
(501, 9),
(502, 9),
(503, 9),
(509, 9),
(510, 9),
(511, 1),
(513, 9),
(514, 9),
(515, 9),
(516, 9),
(517, 9),
(519, 9),
(521, 9),
(523, 9),
(525, 9),
(526, 9),
(527, 9),
(528, 9),
(529, 9),
(530, 9),
(531, 9),
(532, 9),
(538, 9),
(539, 9),
(542, 9),
(543, 9),
(546, 9),
(547, 9),
(548, 9),
(549, 9),
(550, 9),
(551, 9),
(552, 9),
(559, 9),
(560, 9),
(561, 9),
(566, 9),
(567, 9),
(570, 9),
(571, 9),
(575, 9),
(577, 9),
(580, 9),
(587, 9),
(590, 9),
(593, 9),
(596, 9),
(599, 9),
(602, 9),
(605, 9),
(606, 9),
(609, 9),
(612, 9),
(613, 9),
(617, 9),
(618, 9),
(619, 9),
(622, 9),
(625, 9),
(626, 9),
(627, 9),
(628, 9),
(629, 9),
(630, 9),
(631, 9),
(632, 9),
(633, 9),
(634, 9),
(635, 9),
(636, 9),
(637, 9),
(638, 9),
(639, 9),
(640, 9),
(641, 9),
(642, 9),
(643, 9),
(644, 9),
(645, 9),
(646, 9),
(647, 9),
(648, 9),
(649, 9),
(650, 9),
(651, 9),
(654, 9),
(655, 9),
(656, 9),
(657, 9),
(660, 9),
(661, 9),
(662, 9),
(663, 9),
(664, 9),
(665, 9),
(666, 9),
(667, 9),
(668, 9),
(669, 9),
(670, 9),
(671, 9),
(672, 9),
(673, 9),
(674, 9),
(675, 9),
(676, 9),
(677, 9),
(678, 9),
(679, 9),
(682, 9),
(683, 9),
(684, 9),
(685, 9),
(686, 9),
(687, 9),
(688, 9),
(691, 9),
(702, 9),
(705, 9),
(718, 1),
(726, 1),
(727, 9),
(728, 9),
(729, 9),
(731, 9),
(732, 9),
(734, 9),
(737, 9),
(739, 9),
(742, 9),
(744, 9),
(746, 9),
(748, 9),
(749, 9),
(754, 9),
(758, 9),
(759, 9),
(760, 9),
(764, 9),
(765, 9),
(767, 9),
(768, 9),
(770, 9),
(772, 9),
(776, 9),
(777, 9),
(778, 9),
(780, 9),
(781, 9),
(783, 9),
(786, 9),
(788, 9),
(789, 9),
(790, 9),
(791, 9),
(793, 9),
(794, 9),
(796, 9),
(797, 9),
(798, 9),
(800, 9),
(801, 9),
(806, 9),
(807, 9),
(809, 9),
(813, 9),
(814, 9),
(815, 9),
(817, 9),
(818, 9),
(819, 9),
(820, 9),
(823, 9),
(826, 9),
(827, 9),
(829, 9),
(833, 9),
(839, 9),
(843, 9),
(844, 9),
(845, 9),
(846, 9),
(848, 9),
(849, 9),
(851, 9),
(852, 9),
(857, 9),
(858, 9),
(860, 9),
(862, 9),
(863, 9),
(864, 9),
(865, 9),
(866, 9),
(868, 9),
(869, 9),
(870, 9),
(871, 9),
(876, 9),
(880, 9),
(882, 9),
(884, 9),
(887, 9),
(889, 9),
(890, 9),
(892, 9),
(897, 9),
(898, 9),
(900, 9),
(902, 9),
(904, 9),
(906, 9),
(908, 9),
(910, 9),
(912, 9),
(913, 9),
(914, 9),
(915, 9),
(916, 9),
(917, 9),
(918, 9),
(920, 9),
(922, 9),
(924, 9),
(925, 9),
(926, 9),
(927, 9),
(928, 9),
(929, 9),
(930, 9),
(931, 9),
(934, 9),
(935, 9),
(939, 9),
(940, 9),
(941, 9),
(943, 9),
(946, 9),
(950, 9),
(951, 9),
(952, 9),
(954, 9),
(955, 9),
(956, 9),
(958, 9),
(959, 9),
(960, 9),
(962, 9),
(965, 23),
(967, 23),
(968, 23),
(971, 23),
(981, 23),
(995, 23),
(997, 23),
(1001, 23),
(1002, 23),
(1005, 23),
(1006, 23),
(1007, 23),
(1009, 23),
(1010, 23),
(1012, 9),
(1013, 9),
(1015, 9),
(1017, 9),
(1018, 9),
(1019, 9),
(1020, 9),
(1021, 9),
(1022, 9),
(1024, 9),
(1027, 9),
(1029, 9),
(1032, 27),
(1034, 27),
(1036, 9),
(1038, 27),
(1040, 27),
(1042, 9),
(1046, 9),
(1051, 9),
(1053, 9),
(1056, 9),
(1061, 9),
(1062, 9),
(1063, 9),
(1064, 9),
(1065, 9),
(1066, 9),
(1067, 9),
(1068, 9),
(1069, 9),
(1070, 28),
(1072, 28),
(1073, 28),
(1074, 28),
(1075, 28),
(1076, 28),
(1077, 28),
(1078, 28),
(1079, 28),
(1080, 28),
(1081, 28),
(1082, 28),
(1083, 28),
(1084, 28),
(1085, 28),
(1086, 28),
(1087, 28),
(1088, 28),
(1089, 28),
(1090, 28),
(1091, 28),
(1092, 28),
(1093, 28),
(1094, 28),
(1095, 28),
(1098, 28),
(1099, 28),
(1100, 28),
(1101, 28),
(1102, 28),
(1103, 28),
(1108, 28),
(1109, 28),
(1110, 28),
(1111, 28),
(1112, 28),
(1113, 28),
(1114, 28),
(1115, 28),
(1118, 28),
(1119, 28),
(1121, 28),
(1123, 28),
(1124, 28),
(1125, 28),
(1129, 28),
(1130, 28),
(1131, 28),
(1133, 28),
(1134, 28),
(1135, 28),
(1136, 28),
(1137, 28),
(1138, 28),
(1139, 28),
(1140, 28),
(1141, 28),
(1142, 28),
(1143, 28),
(1144, 28),
(1145, 28),
(1146, 28),
(1147, 28),
(1149, 28),
(1150, 28),
(1151, 28),
(1153, 28),
(1154, 28),
(1155, 28),
(1157, 9),
(1158, 23),
(1159, 23),
(1160, 23),
(1161, 23),
(1162, 9),
(1163, 9),
(1166, 9),
(1167, 9),
(1168, 9),
(1170, 9),
(1171, 9),
(1172, 9),
(1174, 9),
(1175, 9),
(1176, 9),
(1178, 9),
(1179, 9),
(1184, 9),
(1185, 9),
(1186, 27),
(1187, 27),
(1188, 27),
(1193, 9),
(1194, 9),
(1195, 9),
(1197, 9),
(1198, 9),
(1200, 9),
(1202, 9),
(1203, 9),
(1206, 9),
(1207, 9),
(1217, 9),
(1218, 9),
(1219, 9),
(1220, 9),
(1221, 9),
(1222, 9),
(1223, 9),
(1224, 9),
(1225, 9),
(1231, 9),
(1234, 9),
(1235, 9),
(1236, 9),
(1238, 9),
(1241, 9),
(1243, 9),
(1246, 9),
(1247, 9),
(1248, 9),
(1249, 9),
(1250, 9),
(1251, 9),
(1252, 9),
(1253, 9),
(1255, 9),
(1257, 9),
(1258, 9),
(1265, 9),
(1267, 9),
(1268, 9),
(1269, 9),
(1270, 9),
(1271, 9),
(1272, 9),
(1277, 9),
(1278, 9),
(1280, 9),
(1281, 9),
(1286, 9),
(1287, 9),
(1288, 23),
(1289, 9),
(1290, 9),
(1292, 9),
(1293, 23),
(1294, 23),
(1295, 23),
(1296, 23),
(1297, 28),
(1299, 28),
(1301, 28),
(1302, 28),
(1303, 28),
(1305, 28),
(1306, 28),
(1307, 9),
(1308, 9),
(1309, 9),
(1310, 9),
(1311, 9),
(1312, 1),
(1313, 1),
(1314, 9),
(1315, 9),
(1316, 9),
(1319, 9),
(1320, 9),
(1321, 9),
(1322, 9),
(1323, 1),
(1324, 9),
(1325, 29),
(1328, 29),
(1329, 29),
(1330, 29),
(1331, 29),
(1332, 29),
(1333, 29),
(1334, 29),
(1335, 29),
(1336, 29),
(1337, 29),
(1338, 29),
(1339, 29),
(1341, 29),
(1342, 29),
(1343, 29),
(1344, 29),
(1346, 9),
(1348, 9),
(1349, 9),
(1350, 9),
(1351, 9),
(1352, 9),
(1353, 9),
(1354, 9),
(1356, 9),
(1357, 9),
(1358, 9),
(1359, 9),
(1360, 9),
(1361, 9),
(1362, 9),
(1363, 9),
(1364, 23),
(1365, 9),
(1366, 9),
(1367, 9),
(1368, 9),
(1369, 9),
(1371, 9),
(1375, 9),
(1376, 9),
(1377, 9),
(1378, 9),
(1379, 9),
(1380, 9),
(1381, 9),
(1382, 9),
(1383, 9),
(1384, 9),
(1385, 9),
(1386, 9),
(1387, 9),
(1388, 9),
(1389, 9),
(1390, 9),
(1392, 9),
(1393, 9),
(1394, 9),
(1395, 9),
(1398, 9),
(1399, 9),
(1400, 9),
(1402, 9),
(1403, 9),
(1405, 9),
(1407, 9),
(1408, 9),
(1409, 9),
(1410, 9),
(1411, 9),
(1412, 9),
(1413, 9),
(1414, 9),
(1415, 9),
(1416, 9),
(1417, 9),
(1418, 9),
(1419, 9),
(1420, 9),
(1421, 9),
(1422, 9),
(1423, 9),
(1425, 9),
(1426, 9),
(1427, 9),
(1429, 1),
(1432, 1),
(1433, 1),
(1434, 1),
(1435, 9),
(1437, 9),
(1438, 9),
(1440, 9),
(1441, 9),
(1442, 9),
(1445, 9),
(1447, 9),
(1448, 9),
(1449, 9),
(1450, 9),
(1451, 9),
(1453, 9),
(1454, 9),
(1455, 9),
(1456, 9),
(1458, 9),
(1459, 9),
(1460, 9),
(1461, 9),
(1462, 9),
(1463, 9),
(1464, 9),
(1465, 9),
(1466, 9),
(1467, 9),
(1468, 9),
(1469, 9),
(1470, 9),
(1471, 9),
(1472, 9),
(1473, 9),
(1474, 9),
(1475, 9),
(1476, 9),
(1477, 9),
(1480, 9),
(1482, 9),
(1483, 9),
(1484, 9),
(1485, 9),
(1486, 9),
(1487, 9),
(1488, 9),
(1489, 9),
(1490, 9),
(1491, 9),
(1492, 9),
(1493, 9),
(1494, 9),
(1495, 9),
(1496, 9),
(1497, 9),
(1500, 9),
(1501, 9),
(1502, 9),
(1503, 9),
(1504, 9),
(1521, 4),
(1523, 4),
(1524, 4),
(1525, 4),
(1526, 4),
(1527, 4),
(1528, 4),
(1529, 4),
(1530, 4),
(1531, 4),
(1532, 4),
(1533, 4),
(1534, 4),
(1536, 4),
(1537, 4),
(1538, 4),
(1539, 4),
(1540, 4),
(1541, 4),
(1542, 4),
(1543, 4),
(1544, 4),
(1545, 4),
(1546, 4),
(1547, 4),
(1548, 4),
(1549, 4),
(1550, 9),
(1552, 1),
(1553, 1),
(1554, 1),
(1555, 9),
(1556, 1),
(1559, 1),
(1563, 9),
(1564, 9),
(1565, 1),
(1566, 1),
(1568, 9),
(1570, 9),
(1571, 9),
(1572, 9),
(1574, 9),
(1575, 9),
(1580, 9),
(1583, 9),
(1584, 9),
(1585, 9),
(1586, 9),
(1588, 9),
(1589, 9),
(1590, 9),
(1591, 9),
(1593, 9),
(1597, 9),
(1598, 9),
(1600, 9),
(1602, 9),
(1603, 9),
(1606, 9),
(1607, 9),
(1610, 9),
(1611, 9),
(1612, 1),
(1615, 1),
(1617, 1),
(1619, 1),
(1621, 1),
(1624, 29),
(1625, 29),
(1626, 9),
(1628, 9),
(1629, 9),
(1630, 9),
(1631, 9),
(1633, 9),
(1634, 9),
(1637, 9),
(1639, 28),
(1642, 23),
(1645, 9),
(1646, 9),
(1647, 9),
(1648, 9),
(1649, 9),
(1650, 9),
(1651, 9),
(1652, 9),
(1653, 9),
(1654, 9),
(1655, 9),
(1657, 9),
(1658, 9),
(1659, 9),
(1660, 9),
(1661, 9),
(1662, 9),
(1663, 9),
(1667, 9),
(1668, 9),
(1669, 9),
(1670, 9),
(1671, 9),
(1672, 9),
(1674, 9),
(1675, 9),
(1676, 9),
(1677, 9),
(1678, 9),
(1679, 9),
(1680, 9),
(1681, 9),
(1682, 9),
(1684, 9),
(1687, 9),
(1689, 9),
(1693, 9),
(1694, 9),
(1699, 9),
(1700, 9),
(1701, 9),
(1703, 9),
(1704, 9),
(1708, 9),
(1710, 9),
(1711, 9),
(1712, 9),
(1713, 9),
(1714, 9),
(1716, 9),
(1717, 9),
(1718, 9),
(1719, 9),
(1721, 9),
(1723, 9),
(1726, 9),
(1727, 9),
(1728, 9),
(1729, 9),
(1730, 9),
(1732, 9),
(1733, 9),
(1734, 9),
(1739, 9),
(1742, 9),
(1746, 9),
(1749, 9),
(1752, 9),
(1756, 9),
(1759, 9),
(1761, 9),
(1762, 1),
(1768, 9),
(1771, 9),
(1772, 9),
(1773, 9),
(1777, 9),
(1779, 9),
(1780, 9),
(1781, 9),
(1783, 9),
(1784, 9),
(1785, 9),
(1786, 9),
(1787, 9),
(1788, 9),
(1789, 9),
(1790, 9),
(1791, 9),
(1792, 9),
(1792, 31),
(1793, 9),
(1794, 9),
(1795, 9),
(1796, 9),
(1797, 9),
(1798, 9),
(1799, 9),
(1800, 9),
(1801, 9),
(1801, 31),
(1801, 34),
(1802, 9),
(1804, 9),
(1805, 9),
(1806, 9),
(1807, 9),
(1808, 9),
(1810, 9),
(1811, 9),
(1812, 9),
(1813, 9),
(1814, 9),
(1814, 31),
(1814, 33),
(1815, 9),
(1816, 9),
(1817, 9),
(1818, 9),
(1819, 9),
(1820, 9),
(1821, 9),
(1822, 9),
(1823, 9),
(1825, 9),
(1826, 9),
(1827, 9),
(1828, 9),
(1828, 30),
(1830, 9),
(1830, 30),
(1831, 9),
(1831, 30),
(1836, 9),
(1836, 32),
(1839, 9),
(1839, 32),
(1840, 9),
(1840, 30),
(1840, 31),
(1842, 9),
(1842, 30),
(1842, 31),
(1850, 9),
(1850, 36),
(1850, 37),
(1853, 9),
(1853, 37),
(1855, 9),
(1855, 38),
(1855, 39),
(1857, 9),
(1857, 39),
(1862, 9),
(1862, 39),
(1863, 9),
(1863, 39),
(1864, 9),
(1865, 9),
(1866, 9),
(1866, 39),
(1868, 9),
(1869, 9),
(1870, 9),
(1871, 9),
(1872, 9),
(1873, 9),
(1874, 9),
(1874, 39),
(1875, 9),
(1876, 9),
(1877, 9),
(1878, 9),
(1879, 9),
(1880, 9),
(1880, 39),
(1882, 9),
(1883, 9),
(1884, 9),
(1884, 39),
(1886, 9),
(1886, 39),
(1888, 9),
(1888, 39),
(1889, 9),
(1890, 9),
(1890, 39),
(1891, 9),
(1892, 9),
(1893, 9),
(1894, 9),
(1896, 9),
(1898, 9),
(1899, 9),
(1900, 9),
(1902, 9),
(1903, 9),
(1905, 9),
(1907, 9),
(1908, 9),
(1913, 9),
(1915, 9),
(1920, 9),
(1923, 9),
(1925, 9),
(1928, 9),
(1931, 9),
(1932, 9),
(1935, 9),
(1936, 9),
(1938, 9),
(1945, 9),
(1948, 9),
(1949, 9),
(1949, 41),
(1950, 9),
(1951, 9),
(1951, 42),
(1952, 9),
(1952, 42),
(1953, 9),
(1954, 9),
(1954, 42),
(1955, 9),
(1956, 9),
(1957, 9),
(1958, 9),
(1959, 9),
(1960, 9),
(1961, 9),
(1962, 9),
(1963, 9),
(1964, 9),
(1965, 9),
(1966, 9),
(1968, 9),
(1969, 9),
(1970, 9),
(1971, 9),
(1972, 9),
(1973, 9),
(1974, 9),
(1976, 9),
(1977, 9),
(1978, 9),
(1979, 9),
(1980, 9),
(1981, 9),
(1982, 9),
(1983, 9),
(1984, 9),
(1985, 9),
(1986, 9),
(1987, 9),
(1989, 9),
(1992, 9),
(1995, 9),
(1999, 9),
(2004, 9),
(2005, 9),
(2007, 9),
(2008, 9),
(2009, 9),
(2010, 9),
(2012, 9),
(2019, 9),
(2025, 9),
(2026, 9),
(2030, 9),
(2032, 9),
(2033, 9),
(2037, 9),
(2038, 9),
(2039, 9),
(2041, 9),
(2042, 9),
(2044, 9),
(2045, 9),
(2050, 9),
(2051, 9),
(2053, 9),
(2055, 9),
(2057, 9),
(2059, 9),
(2060, 9),
(2066, 9),
(2067, 9),
(2071, 9),
(2072, 9),
(2073, 9),
(2074, 9),
(2075, 9),
(2076, 9),
(2077, 9),
(2078, 9),
(2079, 9),
(2080, 9),
(2082, 9);

-- --------------------------------------------------------

--
-- 表的结构 `typecho_robots_logs`
--

CREATE TABLE IF NOT EXISTS `typecho_robots_logs` (
  `lid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `bot` varchar(16) DEFAULT NULL,
  `url` varchar(64) DEFAULT NULL,
  `ip` varchar(16) DEFAULT NULL,
  `ltime` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`lid`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=13 ;

-- --------------------------------------------------------

--
-- 表的结构 `typecho_users`
--

CREATE TABLE IF NOT EXISTS `typecho_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `screenName` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group` varchar(16) DEFAULT 'visitor',
  `authCode` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `mail` (`mail`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

--
-- 转存表中的数据 `typecho_users`
--

INSERT INTO `typecho_users` (`uid`, `name`, `password`, `mail`, `url`, `screenName`, `created`, `activated`, `logged`, `group`, `authCode`) VALUES
(1, 'oliver', '$P$BieLp56K9plJEicWUdcGtf9axAYQ9M/', 'oliver.csu@gmail.com', 'http://www.oliver.ren', '檀香', 1484443946, 1586507251, 1584891365, 'administrator', '4f9fbdb91b598cc497c70bdfe2af5f93e07c6948');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
